{"version":3,"sources":["webpack:////git/codesandbox-client/node_modules/vue-hot-reload-api/dist/index.js","webpack:///./src/sandbox/eval/transpilers/vue/v2/component-normalizer.js","webpack:///./src/sandbox/eval/transpilers/vue/v2/utils/gen-id.js","webpack:///./src/sandbox/eval/transpilers/vue/v2/loader.ts","webpack:///./src/sandbox/eval/transpilers/vue/v2/parser.js"],"names":["module","exports","cache","Object","create","sepRE","RegExp","path","sep","replace","genId","file","context","key","contextPath","split","length","relative","hash","getRawRequest","loaderContext","loaderUtils","getRemainingRequest","hotReloadAPIPath","defaultLang","template","styles","script","postcssExtensions","rewriterInjectRE","_x","_x2","_ref","apply","arguments","_asyncToGenerator","content","dependencyPromises","addDependency","p","push","options","emitModule","vueHotReloadAPIRaw","query","filePath","_module","_objectSpread","esModule","this","vue","rawRequest","fileName","basename","sourceRoot","dirname","moduleId","hashKey","output","parts","parse","hasScoped","some","_ref2","scoped","templateAttrs","attrs","hasComment","comments","functionalTemplate","functional","bubleTemplateOptions","buble","transforms","stripWithFunctional","defaultLoaders","html","JSON","stringify","id","transformToRequire","video","source","img","image","preserveWhitespace","compilerModules","undefined","css","styleLoaderPath","js","loaders","less","scss","sass","styl","stylus","ts","typescript","pug","coffee","preLoaders","postLoaders","needsHotReload","cssModules","styleInjectionCode","forEach","style","i","requireString","src","getRequireForImport","getRequire","hasStyleLoader","indexOf","invokeStyle","c","concat","moduleName","emitError","Error","requirePath","getRequireForImportString","getRequireString","componentNormalizerRaw","inject","Promise","all","type","part","index","rawPath","getLoaderString","selectorPath","getSelectorString","depPath","stringifyRequest","impt","addCssModulesToLoader","loader","option","DEFAULT_OPTIONS","modules","OPTIONS","localIdentName","importLoaders","m","$1","$2","q","parseQuery","assign","stringifyLoaders","_loaders","map","obj","join","lang","styleCompiler","styleCompilerPath","hasInlineConfig","postcss","injectString","Array","isArray","test","ensureBang","ensureLoader","noSrcAttrs","qs","querystring","buildCustomBlockLoaderString","getRawLoaderString","_ref3","getLangString","_","name","charAt","compiler","require","SourceMapGenerator","splitRE","emptyRE","generateSourceMap","filename","generated","setSourceContent","line","addMapping","original","column","toJSON","needMap","cacheKey","filenameWithHash","get","parseComponent","pad","set"],"mappings":"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","file":"static/js/vue-loader.36a4d8407.chunk.js","sourcesContent":["module.exports = \"var Vue // late bind\\nvar version\\nvar map = Object.create(null)\\nif (typeof window !== 'undefined') {\\n  window.__VUE_HOT_MAP__ = map\\n}\\nvar installed = false\\nvar isBrowserify = false\\nvar initHookName = 'beforeCreate'\\n\\nexports.install = function (vue, browserify) {\\n  if (installed) { return }\\n  installed = true\\n\\n  Vue = vue.__esModule ? vue.default : vue\\n  version = Vue.version.split('.').map(Number)\\n  isBrowserify = browserify\\n\\n  // compat with < 2.0.0-alpha.7\\n  if (Vue.config._lifecycleHooks.indexOf('init') > -1) {\\n    initHookName = 'init'\\n  }\\n\\n  exports.compatible = version[0] >= 2\\n  if (!exports.compatible) {\\n    console.warn(\\n      '[HMR] You are using a version of vue-hot-reload-api that is ' +\\n        'only compatible with Vue.js core ^2.0.0.'\\n    )\\n    return\\n  }\\n}\\n\\n/**\\n * Create a record for a hot module, which keeps track of its constructor\\n * and instances\\n *\\n * @param {String} id\\n * @param {Object} options\\n */\\n\\nexports.createRecord = function (id, options) {\\n  if(map[id]) { return }\\n\\n  var Ctor = null\\n  if (typeof options === 'function') {\\n    Ctor = options\\n    options = Ctor.options\\n  }\\n  makeOptionsHot(id, options)\\n  map[id] = {\\n    Ctor: Ctor,\\n    options: options,\\n    instances: []\\n  }\\n}\\n\\n/**\\n * Check if module is recorded\\n *\\n * @param {String} id\\n */\\n\\nexports.isRecorded = function (id) {\\n  return typeof map[id] !== 'undefined'\\n}\\n\\n/**\\n * Make a Component options object hot.\\n *\\n * @param {String} id\\n * @param {Object} options\\n */\\n\\nfunction makeOptionsHot(id, options) {\\n  if (options.functional) {\\n    var render = options.render\\n    options.render = function (h, ctx) {\\n      var instances = map[id].instances\\n      if (ctx && instances.indexOf(ctx.parent) < 0) {\\n        instances.push(ctx.parent)\\n      }\\n      return render(h, ctx)\\n    }\\n  } else {\\n    injectHook(options, initHookName, function() {\\n      var record = map[id]\\n      if (!record.Ctor) {\\n        record.Ctor = this.constructor\\n      }\\n      record.instances.push(this)\\n    })\\n    injectHook(options, 'beforeDestroy', function() {\\n      var instances = map[id].instances\\n      instances.splice(instances.indexOf(this), 1)\\n    })\\n  }\\n}\\n\\n/**\\n * Inject a hook to a hot reloadable component so that\\n * we can keep track of it.\\n *\\n * @param {Object} options\\n * @param {String} name\\n * @param {Function} hook\\n */\\n\\nfunction injectHook(options, name, hook) {\\n  var existing = options[name]\\n  options[name] = existing\\n    ? Array.isArray(existing) ? existing.concat(hook) : [existing, hook]\\n    : [hook]\\n}\\n\\nfunction tryWrap(fn) {\\n  return function (id, arg) {\\n    try {\\n      fn(id, arg)\\n    } catch (e) {\\n      console.error(e)\\n      console.warn(\\n        'Something went wrong during Vue component hot-reload. Full reload required.'\\n      )\\n    }\\n  }\\n}\\n\\nfunction updateOptions (oldOptions, newOptions) {\\n  for (var key in oldOptions) {\\n    if (!(key in newOptions)) {\\n      delete oldOptions[key]\\n    }\\n  }\\n  for (var key$1 in newOptions) {\\n    oldOptions[key$1] = newOptions[key$1]\\n  }\\n}\\n\\nexports.rerender = tryWrap(function (id, options) {\\n  var record = map[id]\\n  if (!options) {\\n    record.instances.slice().forEach(function (instance) {\\n      instance.$forceUpdate()\\n    })\\n    return\\n  }\\n  if (typeof options === 'function') {\\n    options = options.options\\n  }\\n  if (record.Ctor) {\\n    record.Ctor.options.render = options.render\\n    record.Ctor.options.staticRenderFns = options.staticRenderFns\\n    record.instances.slice().forEach(function (instance) {\\n      instance.$options.render = options.render\\n      instance.$options.staticRenderFns = options.staticRenderFns\\n      // reset static trees\\n      // pre 2.5, all static trees are cached together on the instance\\n      if (instance._staticTrees) {\\n        instance._staticTrees = []\\n      }\\n      // 2.5.0\\n      if (Array.isArray(record.Ctor.options.cached)) {\\n        record.Ctor.options.cached = []\\n      }\\n      // 2.5.3\\n      if (Array.isArray(instance.$options.cached)) {\\n        instance.$options.cached = []\\n      }\\n\\n      // post 2.5.4: v-once trees are cached on instance._staticTrees.\\n      // Pure static trees are cached on the staticRenderFns array\\n      // (both already reset above)\\n\\n      // 2.6: temporarily mark rendered scoped slots as unstable so that\\n      // child components can be forced to update\\n      var restore = patchScopedSlots(instance)\\n      instance.$forceUpdate()\\n      instance.$nextTick(restore)\\n    })\\n  } else {\\n    // functional or no instance created yet\\n    record.options.render = options.render\\n    record.options.staticRenderFns = options.staticRenderFns\\n\\n    // handle functional component re-render\\n    if (record.options.functional) {\\n      // rerender with full options\\n      if (Object.keys(options).length > 2) {\\n        updateOptions(record.options, options)\\n      } else {\\n        // template-only rerender.\\n        // need to inject the style injection code for CSS modules\\n        // to work properly.\\n        var injectStyles = record.options._injectStyles\\n        if (injectStyles) {\\n          var render = options.render\\n          record.options.render = function (h, ctx) {\\n            injectStyles.call(ctx)\\n            return render(h, ctx)\\n          }\\n        }\\n      }\\n      record.options._Ctor = null\\n      // 2.5.3\\n      if (Array.isArray(record.options.cached)) {\\n        record.options.cached = []\\n      }\\n      record.instances.slice().forEach(function (instance) {\\n        instance.$forceUpdate()\\n      })\\n    }\\n  }\\n})\\n\\nexports.reload = tryWrap(function (id, options) {\\n  var record = map[id]\\n  if (options) {\\n    if (typeof options === 'function') {\\n      options = options.options\\n    }\\n    makeOptionsHot(id, options)\\n    if (record.Ctor) {\\n      if (version[1] < 2) {\\n        // preserve pre 2.2 behavior for global mixin handling\\n        record.Ctor.extendOptions = options\\n      }\\n      var newCtor = record.Ctor.super.extend(options)\\n      record.Ctor.options = newCtor.options\\n      record.Ctor.cid = newCtor.cid\\n      record.Ctor.prototype = newCtor.prototype\\n      if (newCtor.release) {\\n        // temporary global mixin strategy used in < 2.0.0-alpha.6\\n        newCtor.release()\\n      }\\n    } else {\\n      updateOptions(record.options, options)\\n    }\\n  }\\n  record.instances.slice().forEach(function (instance) {\\n    if (instance.$vnode && instance.$vnode.context) {\\n      instance.$vnode.context.$forceUpdate()\\n    } else {\\n      console.warn(\\n        'Root or manually mounted instance modified. Full reload required.'\\n      )\\n    }\\n  })\\n})\\n\\n// 2.6 optimizes template-compiled scoped slots and skips updates if child\\n// only uses scoped slots. We need to patch the scoped slots resolving helper\\n// to temporarily mark all scoped slots as unstable in order to force child\\n// updates.\\nfunction patchScopedSlots (instance) {\\n  if (!instance._u) { return }\\n  // https://github.com/vuejs/vue/blob/dev/src/core/instance/render-helpers/resolve-scoped-slots.js\\n  var original = instance._u\\n  instance._u = function (slots) {\\n    try {\\n      // 2.6.4 ~ 2.6.6\\n      return original(slots, true)\\n    } catch (e) {\\n      // 2.5 / >= 2.6.7\\n      return original(slots, null, true)\\n    }\\n  }\\n  return function () {\\n    instance._u = original\\n  }\\n}\\n\"","module.exports = \"/* eslint-disable */\\n/* globals __VUE_SSR_CONTEXT__ */\\n\\n// IMPORTANT: Do NOT use ES2015 features in this file.\\n// This module is a runtime utility for cleaner component module output and will\\n// be included in the final webpack user bundle.\\n\\nmodule.exports = function normalizeComponent(\\n  rawScriptExports,\\n  compiledTemplate,\\n  functionalTemplate,\\n  injectStyles,\\n  scopeId,\\n  moduleIdentifier /* server only */\\n) {\\n  let scriptExports = (rawScriptExports = rawScriptExports || {});\\n\\n  // Vue.extend constructor export interop\\n  let defaultExport = scriptExports.default || scriptExports;\\n  let options =\\n    typeof defaultExport === 'function' ? defaultExport.options : defaultExport;\\n\\n  // render functions\\n  if (compiledTemplate) {\\n    options.render = compiledTemplate.render;\\n    options.staticRenderFns = compiledTemplate.staticRenderFns;\\n    options._compiled = true;\\n  }\\n\\n  // functional template\\n  if (functionalTemplate) {\\n    options.functional = true;\\n  }\\n\\n  // scopedId\\n  if (scopeId) {\\n    options._scopeId = scopeId;\\n  }\\n\\n  let hook;\\n  if (moduleIdentifier) {\\n    // server build\\n    hook = function (context) {\\n      // 2.3 injection\\n      context =\\n        context || // cached call\\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional\\n      // 2.2 with runInNewContext: true\\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\\n        context = __VUE_SSR_CONTEXT__;\\n      }\\n      // inject component styles\\n      if (injectStyles) {\\n        injectStyles.call(this, context);\\n      }\\n      // register component module identifier for async chunk inferrence\\n      if (context && context._registeredComponents) {\\n        context._registeredComponents.add(moduleIdentifier);\\n      }\\n    };\\n    // used by ssr in case component is cached and beforeCreate\\n    // never gets called\\n    options._ssrRegister = hook;\\n  } else if (injectStyles) {\\n    hook = injectStyles;\\n  }\\n\\n  if (hook) {\\n    let functional = options.functional;\\n    let existing = functional ? options.render : options.beforeCreate;\\n\\n    if (!functional) {\\n      // inject component registration as beforeCreate hook\\n      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\\n    } else {\\n      // for template-only hot-reload because in that case the render fn doesn't\\n      // go through the normalizer\\n      options._injectStyles = hook;\\n      // register for functioal component in vue file\\n      options.render = function renderWithStyleInjection(h, context) {\\n        hook.call(context);\\n        return existing(h, context);\\n      };\\n    }\\n  }\\n\\n  return {\\n    exports: scriptExports,\\n    options: options,\\n  };\\n};\\n\"","// utility for generating a uid for each component file\n// used in scoped CSS rewriting\nimport path from 'path';\nimport hash from 'hash-sum';\n\nconst cache = Object.create(null);\nconst sepRE = new RegExp(path.sep.replace('\\\\', '\\\\\\\\'), 'g');\n\nexport default function genId(file, context, key) {\n  const contextPath = context.split(path.sep);\n  const rootId = contextPath[contextPath.length - 1];\n\n  /* eslint-disable */\n  file =\n    rootId +\n    '/' +\n    path.relative(context, file).replace(sepRE, '/') +\n    (key || '');\n  return cache[file] || (cache[file] = hash(file));\n}\n","// @flow\n/* eslint-disable import/no-webpack-loader-syntax, prefer-template, no-use-before-define, no-shadow, operator-assignment, no-else-return */\nimport querystring from 'querystring';\n\nimport { basename, dirname } from '@codesandbox/common/lib/utils/path';\n\nimport type { LoaderContext } from 'sandpack-core';\nimport loaderUtils from 'sandpack-core/lib/transpiler/utils/loader-utils';\n// @ts-ignore\nimport componentNormalizerRaw from '!raw-loader!./component-normalizer';\n// @ts-ignore\nimport vueHotReloadAPIRaw from '!raw-loader!vue-hot-reload-api';\n\nimport genId from './utils/gen-id';\nimport parse from './parser';\n\n// When extracting parts from the source vue file, we want to apply the\n// loaders chained before vue-loader, but exclude some loaders that simply\n// produces side effects such as linting.\nfunction getRawRequest(loaderContext) {\n  return loaderUtils.getRemainingRequest(loaderContext);\n}\n\nconst hotReloadAPIPath = '!noop-loader!/node_modules/vue-hot-reload-api.js';\nconst styleLoaderPath = 'vue-style-loader';\nconst templateCompilerPath = 'vue-template-compiler';\nconst styleCompilerPath = 'vue-style-compiler';\nconst selectorPath = 'vue-selector';\n\nconst defaultLang = {\n  template: 'html',\n  styles: 'css',\n  script: 'js',\n};\n\nconst postcssExtensions = ['postcss', 'pcss', 'sugarss', 'sss'];\n\nconst rewriterInjectRE = /\\b(css(?:-loader)?(?:\\?[^!]+)?)(?:!|$)/;\n\nexport default async function (content: string, loaderContext: LoaderContext) {\n  const dependencyPromises = [];\n  const addDependency = (p: string) => {\n    dependencyPromises.push(loaderContext.addDependency(p, options));\n  };\n\n  // Emit the vue-hot-reload-api so it's available in the sandbox\n  loaderContext.emitModule(\n    hotReloadAPIPath,\n    vueHotReloadAPIRaw,\n    '/',\n    false,\n    false\n  );\n\n  const path = loaderContext.path;\n  const query = loaderContext.options;\n  const filePath = loaderContext._module.module.path;\n  const options = {\n    // Always disable esModule as sandpack is CommonJS\n    esModule: false,\n    ...this.vue,\n    ...query,\n  };\n\n  const rawRequest = getRawRequest(loaderContext);\n  const fileName = basename(filePath);\n\n  const sourceRoot = dirname(path);\n  const moduleId = 'data-v-' + genId(path, options.context, options.hashKey);\n\n  const cssLoaderOptions = '?sourceMap';\n\n  let output = '';\n  const bustCache = true;\n\n  const parts = parse(content, fileName, false, sourceRoot);\n  const hasScoped = parts.styles.some(({ scoped }) => scoped);\n  const templateAttrs =\n    parts.template && parts.template.attrs && parts.template.attrs;\n  const hasComment = templateAttrs && templateAttrs.comments;\n  const functionalTemplate = templateAttrs && templateAttrs.functional;\n  const bubleTemplateOptions = { ...options.buble };\n  bubleTemplateOptions.transforms = { ...bubleTemplateOptions.transforms };\n  bubleTemplateOptions.transforms.stripWithFunctional = functionalTemplate;\n\n  const templateCompilerOptions =\n    '?' +\n    JSON.stringify({\n      id: moduleId,\n      hasScoped,\n      hasComment,\n      transformToRequire: {\n        video: 'src',\n        source: 'src',\n        img: 'src',\n        image: 'xlink:href',\n      },\n      preserveWhitespace: false,\n      buble: bubleTemplateOptions,\n      // only pass compilerModules if it's a path string\n      compilerModules:\n        typeof options.compilerModules === 'string'\n          ? options.compilerModules\n          : undefined,\n    });\n\n  const defaultLoaders = {\n    html: templateCompilerPath + templateCompilerOptions,\n    css: styleLoaderPath + '!css-loader' + cssLoaderOptions,\n    js: 'babel-loader',\n  };\n\n  const codeSandboxLoaders = {\n    less: ['vue-style-loader', 'css-loader', 'less-loader'],\n    scss: ['vue-style-loader', 'css-loader', 'sass-loader'],\n    sass: ['vue-style-loader', 'css-loader', 'sass-loader?indentedSyntax'],\n    styl: ['vue-style-loader', 'css-loader', 'stylus-loader'],\n    stylus: ['vue-style-loader', 'css-loader', 'stylus-loader'],\n    ts: ['ts-loader'],\n    typescript: ['ts-loader'],\n    pug: ['pug-loader'],\n    coffee: ['babel-loader', 'coffee-loader'],\n  };\n\n  const loaders = { ...defaultLoaders, ...codeSandboxLoaders };\n  const preLoaders = {};\n  const postLoaders = {};\n\n  const needsHotReload = parts.script || parts.template;\n  if (needsHotReload) {\n    output += 'var disposed = false\\n';\n  }\n\n  let cssModules;\n  if (parts.styles.length) {\n    let styleInjectionCode = 'function injectStyle (ssrContext) {\\n';\n    if (needsHotReload) {\n      styleInjectionCode += `  if (disposed) return\\n`;\n    }\n    parts.styles.forEach((style, i) => {\n      // require style\n      let requireString = style.src\n        ? getRequireForImport('styles', style, style.scoped)\n        : getRequire('styles', style, i, style.scoped);\n\n      const hasStyleLoader = requireString.indexOf('style-loader') > -1;\n      // const hasVueStyleLoader = requireString.indexOf('vue-style-loader') > -1;\n\n      const invokeStyle = c => `  ${c}\\n`;\n\n      const moduleName = style.module === true ? '$style' : style.module;\n      // setCssModule\n      if (moduleName) {\n        if (!cssModules) {\n          cssModules = {};\n          if (needsHotReload) {\n            output += `var cssModules = {}\\n`;\n          }\n        }\n\n        if (moduleName in cssModules) {\n          loaderContext.emitError(\n            new Error('CSS module name \"' + moduleName + '\" is not unique!')\n          );\n          styleInjectionCode += invokeStyle(requireString);\n        } else {\n          cssModules[moduleName] = true;\n\n          // `(vue-)style-loader` exposes the name-to-hash map directly\n          // `css-loader` exposes it in `.locals`\n          // add `.locals` if the user configured to not use style-loader.\n          if (!hasStyleLoader) {\n            requireString += '.locals';\n          }\n\n          if (!needsHotReload) {\n            styleInjectionCode += invokeStyle(\n              'this[\"' + moduleName + '\"] = ' + requireString\n            );\n          } else {\n            // handle hot reload for CSS modules.\n            // we store the exported locals in an object and proxy to it by\n            // defining getters inside component instances' lifecycle hook.\n            /* prettier-ignore */\n            styleInjectionCode +=\n            invokeStyle(`cssModules[\"${moduleName}\"] = ${requireString}`) +\n            `Object.defineProperty(this, \"${moduleName}\", { get: function () { return cssModules[\"${moduleName}\"] }})\\n`\n\n            const requirePath = style.src\n              ? getRequireForImportString('styles', style, style.scoped)\n              : getRequireString('styles', style, i, style.scoped);\n\n            output +=\n              `module.hot && module.hot.accept([${requirePath}], function () {\\n` +\n              // 1. check if style has been injected\n              `  var oldLocals = cssModules[\"${moduleName}\"]\\n` +\n              `  if (!oldLocals) return\\n` +\n              // 2. re-import (side effect: updates the <style>)\n              `  var newLocals = ${requireString}\\n` +\n              // 3. compare new and old locals to see if selectors changed\n              `  if (JSON.stringify(newLocals) === JSON.stringify(oldLocals)) return\\n` +\n              // 4. locals changed. Update and force re-render.\n              `  cssModules[\"${moduleName}\"] = newLocals\\n` +\n              `  require(\"${hotReloadAPIPath}\").rerender(\"${moduleId}\")\\n` +\n              `})\\n`;\n          }\n        }\n      } else {\n        styleInjectionCode += invokeStyle(requireString);\n      }\n    });\n    styleInjectionCode += '}\\n';\n    output += styleInjectionCode;\n  }\n\n  loaderContext.emitModule(\n    // No extension, so no transpilation !noop\n    '!noop-loader!/node_modules/component-normalizer.js',\n    componentNormalizerRaw,\n    '/',\n    false,\n    false\n  );\n\n  // we require the component normalizer function, and call it like so:\n  // normalizeComponent(\n  //   scriptExports,\n  //   compiledTemplate,\n  //   functionalTemplate,\n  //   injectStyles,\n  //   scopeId,\n  //   moduleIdentifier (server only)\n  // )\n  output +=\n    \"var normalizeComponent = require('!noop-loader!/node_modules/component-normalizer.js')\\n\";\n\n  // <script>\n  output += '  /* script */\\n  ';\n  const { script } = parts;\n  if (script) {\n    output +=\n      'var __vue_script__ = ' +\n      (script.src\n        ? getRequireForImport('script', script, false)\n        : getRequire('script', script, 0, false)) +\n      '\\n';\n\n    // inject loader interop\n    if (query.inject) {\n      output += '__vue_script__ = __vue_script__(injections)\\n';\n    }\n  } else {\n    output += 'var __vue_script__ = null\\n';\n  }\n\n  // <template>\n  output += '/* template */\\n';\n  const { template } = parts;\n  if (template) {\n    output +=\n      'var __vue_template__ = ' +\n      (template.src\n        ? getRequireForImport('template', template, false)\n        : getRequire('template', template, 0, false)) +\n      '\\n';\n  } else {\n    output += 'var __vue_template__ = null\\n';\n  }\n\n  // template functional\n  output += '/* template functional */\\n';\n  output +=\n    'var __vue_template_functional__ = ' +\n    (functionalTemplate ? 'true' : 'false') +\n    '\\n';\n\n  // style\n  output += '  /* styles */\\n  ';\n  output +=\n    'var __vue_styles__ = ' +\n    (parts.styles.length ? 'injectStyle' : 'null') +\n    '\\n';\n\n  // scopeId\n  output += '  /* scopeId */\\n  ';\n  output +=\n    'var __vue_scopeId__ = ' +\n    (hasScoped ? JSON.stringify(moduleId) : 'null') +\n    '\\n';\n\n  // moduleIdentifier (server only)\n  output += '/* moduleIdentifier (server only) */\\n';\n  output += 'var __vue_module_identifier__ = null\\n';\n\n  // close normalizeComponent call\n  output +=\n    'var Component = normalizeComponent(\\n' +\n    '  __vue_script__,\\n' +\n    '  __vue_template__,\\n' +\n    '  __vue_template_functional__,\\n' +\n    '  __vue_styles__,\\n' +\n    '  __vue_scopeId__,\\n' +\n    '  __vue_module_identifier__\\n' +\n    ')\\n';\n\n  // add filename in dev\n  output += 'Component.options.__file = ' + JSON.stringify(path) + '\\n';\n\n  if (!query.inject) {\n    // hot reload\n    if (needsHotReload) {\n      output +=\n        '\\n/* hot reload */\\n' +\n        'if (module.hot) {(function () {\\n' +\n        '  var hotAPI = require(\"' +\n        hotReloadAPIPath +\n        '\")\\n' +\n        '  hotAPI.install(require(\"vue\"), false)\\n' +\n        '  if (!hotAPI.compatible) return\\n' +\n        '  module.hot.accept()\\n' +\n        '  if (!module.hot.data) {\\n' +\n        // initial insert\n        '    hotAPI.createRecord(\"' +\n        moduleId +\n        '\", Component.options)\\n' +\n        '  } else {\\n';\n      // update\n      if (cssModules) {\n        output +=\n          '    if (module.hot.data.cssModules && Object.keys(module.hot.data.cssModules) !== Object.keys(cssModules)) {\\n' +\n          '      delete Component.options._Ctor\\n' +\n          '    }\\n';\n      }\n      output += `    hotAPI.${\n        functionalTemplate ? 'rerender' : 'reload'\n      }(\"${moduleId}\", Component.options)\\n  }\\n`;\n      // dispose\n      output +=\n        '  module.hot.dispose(function (data) {\\n' +\n        (cssModules ? '    data.cssModules = cssModules\\n' : '') +\n        '    disposed = true\\n' +\n        '  })\\n';\n      output += '})()}\\n';\n    }\n\n    // final export\n    output += '\\nmodule.exports = Component.exports\\n';\n  } else {\n    // inject-loader support\n    output =\n      '\\n/* dependency injection */\\n' +\n      'module.exports = function (injections) {\\n' +\n      output +\n      '\\n' +\n      '\\nreturn Component.exports\\n}';\n  }\n\n  await Promise.all(dependencyPromises);\n\n  // done\n  return output;\n\n  // --- helpers ---\n\n  function getRequire(type, part, index: number, scoped: boolean) {\n    return 'require(' + getRequireString(type, part, index, scoped) + ')';\n  }\n\n  function getRequireString(type, part, index: number, scoped: boolean) {\n    const rawPath =\n      '!!' +\n      // get loader string for pre-processors\n      getLoaderString(type, part, index, scoped) +\n      // // select the corresponding part from the vue file\n      getSelectorString(type, index || 0) +\n      // the url to the actual vue file, including remaining requests\n      // getFileName(type, part, index);\n      rawRequest;\n\n    // loaderContext.emitModule(rawPath, part.content, dirname(filePath), false, false);\n\n    const depPath = loaderUtils.stringifyRequest(loaderContext, rawPath);\n    addDependency(JSON.parse(depPath));\n\n    return depPath;\n  }\n\n  function getRequireForImport(type, impt, scoped: boolean) {\n    return 'require(' + getRequireForImportString(type, impt, scoped) + ')';\n  }\n\n  function getRequireForImportString(type, impt, scoped: boolean) {\n    const depPath = loaderUtils.stringifyRequest(\n      loaderContext,\n      '!!' + getLoaderString(type, impt, 0, scoped) + impt.src\n    );\n\n    addDependency(JSON.parse(depPath));\n\n    return depPath;\n  }\n\n  function addCssModulesToLoader(loader, part, index: number) {\n    if (!part.module) return loader;\n    const option = options.cssModules || {};\n    const DEFAULT_OPTIONS = {\n      modules: true,\n    };\n    const OPTIONS = {\n      localIdentName: '[hash:base64]',\n      importLoaders: true,\n    };\n    return loader.replace(/((?:^|!)css(?:-loader)?)(\\?[^!]*)?/, (m, $1, $2) => {\n      // $1: !css-loader\n      // $2: ?a=b\n      const q = loaderUtils.parseQuery($2 || '?');\n      Object.assign(q, OPTIONS, option, DEFAULT_OPTIONS);\n      if (index >= 0) {\n        // Note:\n        //   Class name is generated according to its filename.\n        //   Different <style> tags in the same .vue file may generate same names.\n        //   Append `_[index]` to class name to avoid this.\n        q.localIdentName += '_' + index;\n      }\n      return $1 + '?' + JSON.stringify(q);\n    });\n  }\n\n  function buildCustomBlockLoaderString(attrs) {\n    const noSrcAttrs = { ...attrs };\n    delete noSrcAttrs.src;\n    const qs = querystring.stringify(noSrcAttrs);\n    return qs ? '?' + qs : qs;\n  }\n\n  // stringify an Array of loader objects\n  function stringifyLoaders(_loaders) {\n    return _loaders\n      .map(obj =>\n        obj && typeof obj === 'object' && typeof obj.loader === 'string'\n          ? obj.loader + (obj.options ? '?' + JSON.stringify(obj.options) : '')\n          : obj\n      )\n      .join('!');\n  }\n\n  function getLoaderString(type, part, index: number, scoped: boolean) {\n    let loader = getRawLoaderString(type, part, index, scoped);\n    const lang = getLangString(type, part);\n    if (preLoaders[lang]) {\n      loader = loader + ensureBang(preLoaders[lang]);\n    }\n    if (postLoaders[lang]) {\n      loader = ensureBang(postLoaders[lang]) + loader;\n    }\n    return loader;\n  }\n\n  function getLangString(type, { lang }) {\n    if (type === 'script' || type === 'template' || type === 'styles') {\n      return lang || defaultLang[type];\n    } else {\n      return type;\n    }\n  }\n\n  function getRawLoaderString(type, part, index: number, scoped: boolean) {\n    let lang = part.lang || defaultLang[type];\n\n    let styleCompiler = '';\n    if (type === 'styles') {\n      // style compiler that needs to be applied for all styles\n      styleCompiler =\n        styleCompilerPath +\n        '?' +\n        JSON.stringify({\n          // a marker for vue-style-loader to know that this is an import from a vue file\n          vue: true,\n          id: moduleId,\n          scoped: !!scoped,\n          hasInlineConfig: !!query.postcss,\n        }) +\n        '!';\n      // normalize scss/sass/postcss if no specific loaders have been provided\n      if (!loaders[lang]) {\n        if (postcssExtensions.indexOf(lang) !== -1) {\n          lang = 'css';\n        } else if (lang === 'sass') {\n          lang = 'sass?indentedSyntax';\n        } else if (lang === 'scss') {\n          lang = 'scss';\n        }\n      }\n    }\n\n    let loader = loaders[lang];\n\n    const injectString =\n      type === 'script' && query.inject ? 'inject-loader!' : '';\n\n    if (loader != null) {\n      if (Array.isArray(loader)) {\n        loader = stringifyLoaders(loader);\n      } else if (typeof loader === 'object') {\n        loader = stringifyLoaders([loader]);\n      }\n      if (type === 'styles') {\n        // add css modules\n        loader = addCssModulesToLoader(loader, part, index);\n        // inject rewriter before css loader for extractTextPlugin use cases\n        if (rewriterInjectRE.test(loader)) {\n          loader = loader.replace(\n            rewriterInjectRE,\n            (m, $1) => ensureBang($1) + styleCompiler\n          );\n        } else {\n          loader = ensureBang(loader) + styleCompiler;\n        }\n      }\n      // if user defines custom loaders for html, add template compiler to it\n      if (type === 'template' && loader.indexOf(defaultLoaders.html) < 0) {\n        loader = defaultLoaders.html + '!' + loader;\n      }\n      return injectString + ensureBang(loader);\n    } else {\n      // unknown lang, infer the loader to be used\n      switch (type) {\n        case 'template':\n          return defaultLoaders.html + '!';\n        case 'styles':\n          loader = addCssModulesToLoader(defaultLoaders.css, part, index);\n          return loader + '!' + styleCompiler + ensureBang(ensureLoader(lang));\n        case 'script':\n          return injectString + ensureBang(ensureLoader(lang));\n        default:\n          loader = loaders[type];\n          if (Array.isArray(loader)) {\n            loader = stringifyLoaders(loader);\n          }\n          return ensureBang(loader + buildCustomBlockLoaderString(part.attrs));\n      }\n    }\n  }\n\n  // sass => sass-loader\n  // sass-loader => sass-loader\n  // sass?indentedSyntax!css => sass-loader?indentedSyntax!css-loader\n  function ensureLoader(lang) {\n    return lang\n      .split('!')\n      .map(loader =>\n        loader.replace(\n          /^([\\w-]+)(\\?.*)?/,\n          (_, name, q) =>\n            (/-loader$/.test(name) ? name : name + '-loader') + (q || '')\n        )\n      )\n      .join('!');\n  }\n\n  function getSelectorString(type: string, index: number) {\n    return (\n      selectorPath +\n      '?type=' +\n      (type === 'script' || type === 'template' || type === 'styles'\n        ? type\n        : 'customBlocks') +\n      '&index=' +\n      index +\n      (bustCache ? '&bustCache' : '') +\n      '!'\n    );\n  }\n\n  function ensureBang(loader) {\n    if (loader.charAt(loader.length - 1) !== '!') {\n      return loader + '!';\n    } else {\n      return loader;\n    }\n  }\n}\n","/* eslint-disable */\nconst compiler = require('vue-template-compiler');\nconst cache = require('lru-cache')(100);\nconst hash = require('hash-sum');\nconst SourceMapGenerator = require('source-map').SourceMapGenerator;\n\nconst splitRE = /\\r?\\n/g;\nconst emptyRE = /^(?:\\/\\/)?\\s*$/;\n\nmodule.exports = function(content, filename, needMap, sourceRoot) {\n  const cacheKey = hash(filename + content);\n  // source-map cache busting for hot-reloadded modules\n  const filenameWithHash = filename + '?' + cacheKey;\n  let output = cache.get(cacheKey);\n  if (output) return output;\n  output = compiler.parseComponent(content, { pad: 'line' });\n  if (needMap) {\n    if (output.script && !output.script.src) {\n      output.script.map = generateSourceMap(\n        filenameWithHash,\n        content,\n        output.script.content,\n        sourceRoot\n      );\n    }\n    if (output.styles) {\n      output.styles.forEach(style => {\n        if (!style.src) {\n          style.map = generateSourceMap(\n            filenameWithHash,\n            content,\n            style.content,\n            sourceRoot\n          );\n        }\n      });\n    }\n  }\n  cache.set(cacheKey, output);\n  return output;\n};\n\nfunction generateSourceMap(filename, source, generated, sourceRoot) {\n  const map = new SourceMapGenerator({ sourceRoot });\n  map.setSourceContent(filename, source);\n  generated.split(splitRE).forEach((line, index) => {\n    if (!emptyRE.test(line)) {\n      map.addMapping({\n        source: filename,\n        original: {\n          line: index + 1,\n          column: 0,\n        },\n        generated: {\n          line: index + 1,\n          column: 0,\n        },\n      });\n    }\n  });\n  return map.toJSON();\n}\n"],"sourceRoot":""}