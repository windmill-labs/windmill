//@ts-nocheck
;(() => {
	var b4 = Object.create
	var l0 = Object.defineProperty
	var T4 = Object.getOwnPropertyDescriptor
	var A4 = Object.getOwnPropertyNames
	var C4 = Object.getPrototypeOf,
		S4 = Object.prototype.hasOwnProperty
	var as = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports)
	var N4 = (e, t, n, r) => {
		if ((t && typeof t == 'object') || typeof t == 'function')
			for (let i of A4(t))
				!S4.call(e, i) &&
					i !== n &&
					l0(e, i, { get: () => t[i], enumerable: !(r = T4(t, i)) || r.enumerable })
		return e
	}
	var el = (e, t, n) => (
		(n = e != null ? b4(C4(e)) : {}),
		N4(t || !e || !e.__esModule ? l0(n, 'default', { value: e, enumerable: !0 }) : n, e)
	)
	var g2 = as((EL, jc) => {
		'use strict'
		function m2(e, t) {
			if (e != null) return e
			var n = new Error(t !== void 0 ? t : 'Got unexpected ' + e)
			throw ((n.framesToPop = 1), n)
		}
		jc.exports = m2
		jc.exports.default = m2
		Object.defineProperty(jc.exports, '__esModule', { value: !0 })
	})
	var Iu = as((gI, S2) => {
		'use strict'
		var is = '\\\\/',
			b2 = `[^${is}]`,
			hs = '\\.',
			c5 = '\\+',
			p5 = '\\?',
			Qc = '\\/',
			f5 = '(?=.)',
			T2 = '[^/]',
			qd = `(?:${Qc}|$)`,
			A2 = `(?:^|${Qc})`,
			Gd = `${hs}{1,2}${qd}`,
			d5 = `(?!${hs})`,
			h5 = `(?!${A2}${Gd})`,
			m5 = `(?!${hs}{0,1}${qd})`,
			g5 = `(?!${Gd})`,
			D5 = `[^.${Qc}]`,
			y5 = `${T2}*?`,
			E5 = '/',
			C2 = {
				DOT_LITERAL: hs,
				PLUS_LITERAL: c5,
				QMARK_LITERAL: p5,
				SLASH_LITERAL: Qc,
				ONE_CHAR: f5,
				QMARK: T2,
				END_ANCHOR: qd,
				DOTS_SLASH: Gd,
				NO_DOT: d5,
				NO_DOTS: h5,
				NO_DOT_SLASH: m5,
				NO_DOTS_SLASH: g5,
				QMARK_NO_DOT: D5,
				STAR: y5,
				START_ANCHOR: A2,
				SEP: E5
			},
			v5 = {
				...C2,
				SLASH_LITERAL: `[${is}]`,
				QMARK: b2,
				STAR: `${b2}*?`,
				DOTS_SLASH: `${hs}{1,2}(?:[${is}]|$)`,
				NO_DOT: `(?!${hs})`,
				NO_DOTS: `(?!(?:^|[${is}])${hs}{1,2}(?:[${is}]|$))`,
				NO_DOT_SLASH: `(?!${hs}{0,1}(?:[${is}]|$))`,
				NO_DOTS_SLASH: `(?!${hs}{1,2}(?:[${is}]|$))`,
				QMARK_NO_DOT: `[^.${is}]`,
				START_ANCHOR: `(?:^|[${is}])`,
				END_ANCHOR: `(?:[${is}]|$)`,
				SEP: '\\'
			},
			x5 = {
				alnum: 'a-zA-Z0-9',
				alpha: 'a-zA-Z',
				ascii: '\\x00-\\x7F',
				blank: ' \\t',
				cntrl: '\\x00-\\x1F\\x7F',
				digit: '0-9',
				graph: '\\x21-\\x7E',
				lower: 'a-z',
				print: '\\x20-\\x7E ',
				punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
				space: ' \\t\\r\\n\\v\\f',
				upper: 'A-Z',
				word: 'A-Za-z0-9_',
				xdigit: 'A-Fa-f0-9'
			}
		S2.exports = {
			MAX_LENGTH: 1024 * 64,
			POSIX_REGEX_SOURCE: x5,
			REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
			REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
			REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
			REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
			REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
			REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
			REPLACEMENTS: { '***': '*', '**/**': '**', '**/**/**': '**' },
			CHAR_0: 48,
			CHAR_9: 57,
			CHAR_UPPERCASE_A: 65,
			CHAR_LOWERCASE_A: 97,
			CHAR_UPPERCASE_Z: 90,
			CHAR_LOWERCASE_Z: 122,
			CHAR_LEFT_PARENTHESES: 40,
			CHAR_RIGHT_PARENTHESES: 41,
			CHAR_ASTERISK: 42,
			CHAR_AMPERSAND: 38,
			CHAR_AT: 64,
			CHAR_BACKWARD_SLASH: 92,
			CHAR_CARRIAGE_RETURN: 13,
			CHAR_CIRCUMFLEX_ACCENT: 94,
			CHAR_COLON: 58,
			CHAR_COMMA: 44,
			CHAR_DOT: 46,
			CHAR_DOUBLE_QUOTE: 34,
			CHAR_EQUAL: 61,
			CHAR_EXCLAMATION_MARK: 33,
			CHAR_FORM_FEED: 12,
			CHAR_FORWARD_SLASH: 47,
			CHAR_GRAVE_ACCENT: 96,
			CHAR_HASH: 35,
			CHAR_HYPHEN_MINUS: 45,
			CHAR_LEFT_ANGLE_BRACKET: 60,
			CHAR_LEFT_CURLY_BRACE: 123,
			CHAR_LEFT_SQUARE_BRACKET: 91,
			CHAR_LINE_FEED: 10,
			CHAR_NO_BREAK_SPACE: 160,
			CHAR_PERCENT: 37,
			CHAR_PLUS: 43,
			CHAR_QUESTION_MARK: 63,
			CHAR_RIGHT_ANGLE_BRACKET: 62,
			CHAR_RIGHT_CURLY_BRACE: 125,
			CHAR_RIGHT_SQUARE_BRACKET: 93,
			CHAR_SEMICOLON: 59,
			CHAR_SINGLE_QUOTE: 39,
			CHAR_SPACE: 32,
			CHAR_TAB: 9,
			CHAR_UNDERSCORE: 95,
			CHAR_VERTICAL_LINE: 124,
			CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
			extglobChars(e) {
				return {
					'!': { type: 'negate', open: '(?:(?!(?:', close: `))${e.STAR})` },
					'?': { type: 'qmark', open: '(?:', close: ')?' },
					'+': { type: 'plus', open: '(?:', close: ')+' },
					'*': { type: 'star', open: '(?:', close: ')*' },
					'@': { type: 'at', open: '(?:', close: ')' }
				}
			},
			globChars(e) {
				return e === !0 ? v5 : C2
			}
		}
	})
	var Yc = as((fi) => {
		'use strict'
		var {
			REGEX_BACKSLASH: b5,
			REGEX_REMOVE_BACKSLASH: T5,
			REGEX_SPECIAL_CHARS: A5,
			REGEX_SPECIAL_CHARS_GLOBAL: C5
		} = Iu()
		fi.isObject = (e) => e !== null && typeof e == 'object' && !Array.isArray(e)
		fi.hasRegexChars = (e) => A5.test(e)
		fi.isRegexChar = (e) => e.length === 1 && fi.hasRegexChars(e)
		fi.escapeRegex = (e) => e.replace(C5, '\\$1')
		fi.toPosixSlashes = (e) => e.replace(b5, '/')
		fi.removeBackslashes = (e) => e.replace(T5, (t) => (t === '\\' ? '' : t))
		fi.supportsLookbehinds = () => {
			let e = process.version.slice(1).split('.').map(Number)
			return (e.length === 3 && e[0] >= 9) || (e[0] === 8 && e[1] >= 10)
		}
		fi.escapeLast = (e, t, n) => {
			let r = e.lastIndexOf(t, n)
			return r === -1
				? e
				: e[r - 1] === '\\'
				? fi.escapeLast(e, t, r - 1)
				: `${e.slice(0, r)}\\${e.slice(r)}`
		}
		fi.removePrefix = (e, t = {}) => {
			let n = e
			return n.startsWith('./') && ((n = n.slice(2)), (t.prefix = './')), n
		}
		fi.wrapOutput = (e, t = {}, n = {}) => {
			let r = n.contains ? '' : '^',
				i = n.contains ? '' : '$',
				s = `${r}(?:${e})${i}`
			return t.negated === !0 && (s = `(?:^(?!${s}).*$)`), s
		}
		fi.basename = (e, { windows: t } = {}) =>
			t ? e.replace(/[\\/]$/, '').replace(/.*[\\/]/, '') : e.replace(/\/$/, '').replace(/.*\//, '')
	})
	var O2 = as((yI, R2) => {
		'use strict'
		var N2 = Yc(),
			{
				CHAR_ASTERISK: Wd,
				CHAR_AT: S5,
				CHAR_BACKWARD_SLASH: ku,
				CHAR_COMMA: N5,
				CHAR_DOT: Hd,
				CHAR_EXCLAMATION_MARK: F2,
				CHAR_FORWARD_SLASH: k2,
				CHAR_LEFT_CURLY_BRACE: Jd,
				CHAR_LEFT_PARENTHESES: zd,
				CHAR_LEFT_SQUARE_BRACKET: F5,
				CHAR_PLUS: _5,
				CHAR_QUESTION_MARK: _2,
				CHAR_RIGHT_CURLY_BRACE: w5,
				CHAR_RIGHT_PARENTHESES: w2,
				CHAR_RIGHT_SQUARE_BRACKET: L5
			} = Iu(),
			L2 = (e) => e === k2 || e === ku,
			I2 = (e) => {
				e.isPrefix !== !0 && (e.depth = e.isGlobstar ? 1 / 0 : 1)
			},
			I5 = (e, t) => {
				let n = t || {},
					r = e.length - 1,
					i = n.parts === !0 || n.scanToEnd === !0,
					s = [],
					o = [],
					a = [],
					u = e,
					h = -1,
					N = 0,
					I = 0,
					Q = !1,
					K = !1,
					ue = !1,
					de = !1,
					Pe = !1,
					Ze = !1,
					Ae = !1,
					ze = !1,
					it = !1,
					Et = 0,
					_t,
					ct,
					St = { value: '', depth: 0, isGlob: !1 },
					Je = () => h >= r,
					Ve = () => u.charCodeAt(h + 1),
					Qt = () => ((_t = ct), u.charCodeAt(++h))
				for (; h < r; ) {
					ct = Qt()
					let Lt
					if (ct === ku) {
						;(Ae = St.backslashes = !0), (ct = Qt()), ct === Jd && (Ze = !0)
						continue
					}
					if (Ze === !0 || ct === Jd) {
						for (Et++; Je() !== !0 && (ct = Qt()); ) {
							if (ct === ku) {
								;(Ae = St.backslashes = !0), Qt()
								continue
							}
							if (ct === Jd) {
								Et++
								continue
							}
							if (Ze !== !0 && ct === Hd && (ct = Qt()) === Hd) {
								if (((Q = St.isBrace = !0), (ue = St.isGlob = !0), (it = !0), i === !0)) continue
								break
							}
							if (Ze !== !0 && ct === N5) {
								if (((Q = St.isBrace = !0), (ue = St.isGlob = !0), (it = !0), i === !0)) continue
								break
							}
							if (ct === w5 && (Et--, Et === 0)) {
								;(Ze = !1), (Q = St.isBrace = !0), (it = !0)
								break
							}
						}
						if (i === !0) continue
						break
					}
					if (ct === k2) {
						if ((s.push(h), o.push(St), (St = { value: '', depth: 0, isGlob: !1 }), it === !0))
							continue
						if (_t === Hd && h === N + 1) {
							N += 2
							continue
						}
						I = h + 1
						continue
					}
					if (
						n.noext !== !0 &&
						(ct === _5 || ct === S5 || ct === Wd || ct === _2 || ct === F2) === !0 &&
						Ve() === zd
					) {
						if (((ue = St.isGlob = !0), (de = St.isExtglob = !0), (it = !0), i === !0)) {
							for (; Je() !== !0 && (ct = Qt()); ) {
								if (ct === ku) {
									;(Ae = St.backslashes = !0), (ct = Qt())
									continue
								}
								if (ct === w2) {
									;(ue = St.isGlob = !0), (it = !0)
									break
								}
							}
							continue
						}
						break
					}
					if (ct === Wd) {
						if (
							(_t === Wd && (Pe = St.isGlobstar = !0), (ue = St.isGlob = !0), (it = !0), i === !0)
						)
							continue
						break
					}
					if (ct === _2) {
						if (((ue = St.isGlob = !0), (it = !0), i === !0)) continue
						break
					}
					if (ct === F5)
						for (; Je() !== !0 && (Lt = Qt()); ) {
							if (Lt === ku) {
								;(Ae = St.backslashes = !0), Qt()
								continue
							}
							if (Lt === L5) {
								if (((K = St.isBracket = !0), (ue = St.isGlob = !0), (it = !0), i === !0)) continue
								break
							}
						}
					if (n.nonegate !== !0 && ct === F2 && h === N) {
						;(ze = St.negated = !0), N++
						continue
					}
					if (n.noparen !== !0 && ct === zd) {
						if (((ue = St.isGlob = !0), i === !0)) {
							for (; Je() !== !0 && (ct = Qt()); ) {
								if (ct === zd) {
									;(Ae = St.backslashes = !0), (ct = Qt())
									continue
								}
								if (ct === w2) {
									it = !0
									break
								}
							}
							continue
						}
						break
					}
					if (ue === !0) {
						if (((it = !0), i === !0)) continue
						break
					}
				}
				n.noext === !0 && ((de = !1), (ue = !1))
				let qt = u,
					Bt = '',
					Te = ''
				N > 0 && ((Bt = u.slice(0, N)), (u = u.slice(N)), (I -= N)),
					qt && ue === !0 && I > 0
						? ((qt = u.slice(0, I)), (Te = u.slice(I)))
						: ue === !0
						? ((qt = ''), (Te = u))
						: (qt = u),
					qt &&
						qt !== '' &&
						qt !== '/' &&
						qt !== u &&
						L2(qt.charCodeAt(qt.length - 1)) &&
						(qt = qt.slice(0, -1)),
					n.unescape === !0 &&
						(Te && (Te = N2.removeBackslashes(Te)),
						qt && Ae === !0 && (qt = N2.removeBackslashes(qt)))
				let Ne = {
					prefix: Bt,
					input: e,
					start: N,
					base: qt,
					glob: Te,
					isBrace: Q,
					isBracket: K,
					isGlob: ue,
					isExtglob: de,
					isGlobstar: Pe,
					negated: ze
				}
				if (
					(n.tokens === !0 && ((Ne.maxDepth = 0), L2(ct) || o.push(St), (Ne.tokens = o)),
					n.parts === !0 || n.tokens === !0)
				) {
					let Lt
					for (let Ct = 0; Ct < s.length; Ct++) {
						let pn = Lt ? Lt + 1 : N,
							xn = s[Ct],
							zn = e.slice(pn, xn)
						n.tokens &&
							(Ct === 0 && N !== 0
								? ((o[Ct].isPrefix = !0), (o[Ct].value = Bt))
								: (o[Ct].value = zn),
							I2(o[Ct]),
							(Ne.maxDepth += o[Ct].depth)),
							(Ct !== 0 || zn !== '') && a.push(zn),
							(Lt = xn)
					}
					if (Lt && Lt + 1 < e.length) {
						let Ct = e.slice(Lt + 1)
						a.push(Ct),
							n.tokens &&
								((o[o.length - 1].value = Ct),
								I2(o[o.length - 1]),
								(Ne.maxDepth += o[o.length - 1].depth))
					}
					;(Ne.slashes = s), (Ne.parts = a)
				}
				return Ne
			}
		R2.exports = I5
	})
	var j2 = as((EI, M2) => {
		'use strict'
		var Xc = Iu(),
			Ui = Yc(),
			{
				MAX_LENGTH: Kc,
				POSIX_REGEX_SOURCE: k5,
				REGEX_NON_SPECIAL_CHARS: R5,
				REGEX_SPECIAL_CHARS_BACKREF: O5,
				REPLACEMENTS: B2
			} = Xc,
			B5 = (e, t) => {
				if (typeof t.expandRange == 'function') return t.expandRange(...e, t)
				e.sort()
				let n = `[${e.join('-')}]`
				try {
					new RegExp(n)
				} catch {
					return e.map((i) => Ui.escapeRegex(i)).join('..')
				}
				return n
			},
			Aa = (e, t) => `Missing ${e}: "${t}" - use "\\\\${t}" to match literal characters`,
			P2 = (e, t) => {
				if (typeof e != 'string') throw new TypeError('Expected a string')
				e = B2[e] || e
				let n = { ...t },
					r = typeof n.maxLength == 'number' ? Math.min(Kc, n.maxLength) : Kc,
					i = e.length
				if (i > r) throw new SyntaxError(`Input length: ${i}, exceeds maximum allowed length: ${r}`)
				let s = { type: 'bos', value: '', output: n.prepend || '' },
					o = [s],
					a = n.capture ? '' : '?:',
					u = Xc.globChars(n.windows),
					h = Xc.extglobChars(u),
					{
						DOT_LITERAL: N,
						PLUS_LITERAL: I,
						SLASH_LITERAL: Q,
						ONE_CHAR: K,
						DOTS_SLASH: ue,
						NO_DOT: de,
						NO_DOT_SLASH: Pe,
						NO_DOTS_SLASH: Ze,
						QMARK: Ae,
						QMARK_NO_DOT: ze,
						STAR: it,
						START_ANCHOR: Et
					} = u,
					_t = (be) => `(${a}(?:(?!${Et}${be.dot ? ue : N}).)*?)`,
					ct = n.dot ? '' : de,
					St = n.dot ? Ae : ze,
					Je = n.bash === !0 ? _t(n) : it
				n.capture && (Je = `(${Je})`), typeof n.noext == 'boolean' && (n.noextglob = n.noext)
				let Ve = {
					input: e,
					index: -1,
					start: 0,
					dot: n.dot === !0,
					consumed: '',
					output: '',
					prefix: '',
					backtrack: !1,
					negated: !1,
					brackets: 0,
					braces: 0,
					parens: 0,
					quotes: 0,
					globstar: !1,
					tokens: o
				}
				;(e = Ui.removePrefix(e, Ve)), (i = e.length)
				let Qt = [],
					qt = [],
					Bt = [],
					Te = s,
					Ne,
					Lt = () => Ve.index === i - 1,
					Ct = (Ve.peek = (be = 1) => e[Ve.index + be]),
					pn = (Ve.advance = () => e[++Ve.index]),
					xn = () => e.slice(Ve.index + 1),
					zn = (be = '', tt = 0) => {
						;(Ve.consumed += be), (Ve.index += tt)
					},
					rr = (be) => {
						;(Ve.output += be.output != null ? be.output : be.value), zn(be.value)
					},
					rt = () => {
						let be = 1
						for (; Ct() === '!' && (Ct(2) !== '(' || Ct(3) === '?'); ) pn(), Ve.start++, be++
						return be % 2 === 0 ? !1 : ((Ve.negated = !0), Ve.start++, !0)
					},
					Wt = (be) => {
						Ve[be]++, Bt.push(be)
					},
					Ot = (be) => {
						Ve[be]--, Bt.pop()
					},
					vt = (be) => {
						if (Te.type === 'globstar') {
							let tt = Ve.braces > 0 && (be.type === 'comma' || be.type === 'brace'),
								Ee = be.extglob === !0 || (Qt.length && (be.type === 'pipe' || be.type === 'paren'))
							be.type !== 'slash' &&
								be.type !== 'paren' &&
								!tt &&
								!Ee &&
								((Ve.output = Ve.output.slice(0, -Te.output.length)),
								(Te.type = 'star'),
								(Te.value = '*'),
								(Te.output = Je),
								(Ve.output += Te.output))
						}
						if (
							(Qt.length &&
								be.type !== 'paren' &&
								!h[be.value] &&
								(Qt[Qt.length - 1].inner += be.value),
							(be.value || be.output) && rr(be),
							Te && Te.type === 'text' && be.type === 'text')
						) {
							;(Te.value += be.value), (Te.output = (Te.output || '') + be.value)
							return
						}
						;(be.prev = Te), o.push(be), (Te = be)
					},
					He = (be, tt) => {
						let Ee = { ...h[tt], conditions: 1, inner: '' }
						;(Ee.prev = Te), (Ee.parens = Ve.parens), (Ee.output = Ve.output)
						let xt = (n.capture ? '(' : '') + Ee.open
						Wt('parens'),
							vt({ type: be, value: tt, output: Ve.output ? '' : K }),
							vt({ type: 'paren', extglob: !0, value: pn(), output: xt }),
							Qt.push(Ee)
					},
					dt = (be) => {
						let tt = be.close + (n.capture ? ')' : '')
						if (be.type === 'negate') {
							let Ee = Je
							be.inner && be.inner.length > 1 && be.inner.includes('/') && (Ee = _t(n)),
								(Ee !== Je || Lt() || /^\)+$/.test(xn())) && (tt = be.close = `)$))${Ee}`),
								be.prev.type === 'bos' && Lt() && (Ve.negatedExtglob = !0)
						}
						vt({ type: 'paren', extglob: !0, value: Ne, output: tt }), Ot('parens')
					}
				if (n.fastpaths !== !1 && !/(^[*!]|[/()[\]{}"])/.test(e)) {
					let be = !1,
						tt = e.replace(O5, (Ee, xt, Nt, en, on, Bn) =>
							en === '\\'
								? ((be = !0), Ee)
								: en === '?'
								? xt
									? xt + en + (on ? Ae.repeat(on.length) : '')
									: Bn === 0
									? St + (on ? Ae.repeat(on.length) : '')
									: Ae.repeat(Nt.length)
								: en === '.'
								? N.repeat(Nt.length)
								: en === '*'
								? xt
									? xt + en + (on ? Je : '')
									: Je
								: xt
								? Ee
								: `\\${Ee}`
						)
					return (
						be === !0 &&
							(n.unescape === !0
								? (tt = tt.replace(/\\/g, ''))
								: (tt = tt.replace(/\\+/g, (Ee) =>
										Ee.length % 2 === 0 ? '\\\\' : Ee ? '\\' : ''
								  ))),
						tt === e && n.contains === !0
							? ((Ve.output = e), Ve)
							: ((Ve.output = Ui.wrapOutput(tt, Ve, t)), Ve)
					)
				}
				for (; !Lt(); ) {
					if (((Ne = pn()), Ne === '\0')) continue
					if (Ne === '\\') {
						let Ee = Ct()
						if ((Ee === '/' && n.bash !== !0) || Ee === '.' || Ee === ';') continue
						if (!Ee) {
							;(Ne += '\\'), vt({ type: 'text', value: Ne })
							continue
						}
						let xt = /^\\+/.exec(xn()),
							Nt = 0
						if (
							(xt &&
								xt[0].length > 2 &&
								((Nt = xt[0].length), (Ve.index += Nt), Nt % 2 !== 0 && (Ne += '\\')),
							n.unescape === !0 ? (Ne = pn() || '') : (Ne += pn() || ''),
							Ve.brackets === 0)
						) {
							vt({ type: 'text', value: Ne })
							continue
						}
					}
					if (Ve.brackets > 0 && (Ne !== ']' || Te.value === '[' || Te.value === '[^')) {
						if (n.posix !== !1 && Ne === ':') {
							let Ee = Te.value.slice(1)
							if (Ee.includes('[') && ((Te.posix = !0), Ee.includes(':'))) {
								let xt = Te.value.lastIndexOf('['),
									Nt = Te.value.slice(0, xt),
									en = Te.value.slice(xt + 2),
									on = k5[en]
								if (on) {
									;(Te.value = Nt + on),
										(Ve.backtrack = !0),
										pn(),
										!s.output && o.indexOf(Te) === 1 && (s.output = K)
									continue
								}
							}
						}
						;((Ne === '[' && Ct() !== ':') || (Ne === '-' && Ct() === ']')) && (Ne = `\\${Ne}`),
							Ne === ']' && (Te.value === '[' || Te.value === '[^') && (Ne = `\\${Ne}`),
							n.posix === !0 && Ne === '!' && Te.value === '[' && (Ne = '^'),
							(Te.value += Ne),
							rr({ value: Ne })
						continue
					}
					if (Ve.quotes === 1 && Ne !== '"') {
						;(Ne = Ui.escapeRegex(Ne)), (Te.value += Ne), rr({ value: Ne })
						continue
					}
					if (Ne === '"') {
						;(Ve.quotes = Ve.quotes === 1 ? 0 : 1),
							n.keepQuotes === !0 && vt({ type: 'text', value: Ne })
						continue
					}
					if (Ne === '(') {
						Wt('parens'), vt({ type: 'paren', value: Ne })
						continue
					}
					if (Ne === ')') {
						if (Ve.parens === 0 && n.strictBrackets === !0)
							throw new SyntaxError(Aa('opening', '('))
						let Ee = Qt[Qt.length - 1]
						if (Ee && Ve.parens === Ee.parens + 1) {
							dt(Qt.pop())
							continue
						}
						vt({ type: 'paren', value: Ne, output: Ve.parens ? ')' : '\\)' }), Ot('parens')
						continue
					}
					if (Ne === '[') {
						if (n.nobracket === !0 || !xn().includes(']')) {
							if (n.nobracket !== !0 && n.strictBrackets === !0)
								throw new SyntaxError(Aa('closing', ']'))
							Ne = `\\${Ne}`
						} else Wt('brackets')
						vt({ type: 'bracket', value: Ne })
						continue
					}
					if (Ne === ']') {
						if (n.nobracket === !0 || (Te && Te.type === 'bracket' && Te.value.length === 1)) {
							vt({ type: 'text', value: Ne, output: `\\${Ne}` })
							continue
						}
						if (Ve.brackets === 0) {
							if (n.strictBrackets === !0) throw new SyntaxError(Aa('opening', '['))
							vt({ type: 'text', value: Ne, output: `\\${Ne}` })
							continue
						}
						Ot('brackets')
						let Ee = Te.value.slice(1)
						if (
							(Te.posix !== !0 && Ee[0] === '^' && !Ee.includes('/') && (Ne = `/${Ne}`),
							(Te.value += Ne),
							rr({ value: Ne }),
							n.literalBrackets === !1 || Ui.hasRegexChars(Ee))
						)
							continue
						let xt = Ui.escapeRegex(Te.value)
						if (((Ve.output = Ve.output.slice(0, -Te.value.length)), n.literalBrackets === !0)) {
							;(Ve.output += xt), (Te.value = xt)
							continue
						}
						;(Te.value = `(${a}${xt}|${Te.value})`), (Ve.output += Te.value)
						continue
					}
					if (Ne === '{' && n.nobrace !== !0) {
						Wt('braces')
						let Ee = {
							type: 'brace',
							value: Ne,
							output: '(',
							outputIndex: Ve.output.length,
							tokensIndex: Ve.tokens.length
						}
						qt.push(Ee), vt(Ee)
						continue
					}
					if (Ne === '}') {
						let Ee = qt[qt.length - 1]
						if (n.nobrace === !0 || !Ee) {
							vt({ type: 'text', value: Ne, output: Ne })
							continue
						}
						let xt = ')'
						if (Ee.dots === !0) {
							let Nt = o.slice(),
								en = []
							for (let on = Nt.length - 1; on >= 0 && (o.pop(), Nt[on].type !== 'brace'); on--)
								Nt[on].type !== 'dots' && en.unshift(Nt[on].value)
							;(xt = B5(en, n)), (Ve.backtrack = !0)
						}
						if (Ee.comma !== !0 && Ee.dots !== !0) {
							let Nt = Ve.output.slice(0, Ee.outputIndex),
								en = Ve.tokens.slice(Ee.tokensIndex)
							;(Ee.value = Ee.output = '\\{'), (Ne = xt = '\\}'), (Ve.output = Nt)
							for (let on of en) Ve.output += on.output || on.value
						}
						vt({ type: 'brace', value: Ne, output: xt }), Ot('braces'), qt.pop()
						continue
					}
					if (Ne === '|') {
						Qt.length > 0 && Qt[Qt.length - 1].conditions++, vt({ type: 'text', value: Ne })
						continue
					}
					if (Ne === ',') {
						let Ee = Ne,
							xt = qt[qt.length - 1]
						xt && Bt[Bt.length - 1] === 'braces' && ((xt.comma = !0), (Ee = '|')),
							vt({ type: 'comma', value: Ne, output: Ee })
						continue
					}
					if (Ne === '/') {
						if (Te.type === 'dot' && Ve.index === Ve.start + 1) {
							;(Ve.start = Ve.index + 1), (Ve.consumed = ''), (Ve.output = ''), o.pop(), (Te = s)
							continue
						}
						vt({ type: 'slash', value: Ne, output: Q })
						continue
					}
					if (Ne === '.') {
						if (Ve.braces > 0 && Te.type === 'dot') {
							Te.value === '.' && (Te.output = N)
							let Ee = qt[qt.length - 1]
							;(Te.type = 'dots'), (Te.output += Ne), (Te.value += Ne), (Ee.dots = !0)
							continue
						}
						if (Ve.braces + Ve.parens === 0 && Te.type !== 'bos' && Te.type !== 'slash') {
							vt({ type: 'text', value: Ne, output: N })
							continue
						}
						vt({ type: 'dot', value: Ne, output: N })
						continue
					}
					if (Ne === '?') {
						if (!(Te && Te.value === '(') && n.noextglob !== !0 && Ct() === '(' && Ct(2) !== '?') {
							He('qmark', Ne)
							continue
						}
						if (Te && Te.type === 'paren') {
							let xt = Ct(),
								Nt = Ne
							if (xt === '<' && !Ui.supportsLookbehinds())
								throw new Error('Node.js v10 or higher is required for regex lookbehinds')
							;((Te.value === '(' && !/[!=<:]/.test(xt)) ||
								(xt === '<' && !/<([!=]|\w+>)/.test(xn()))) &&
								(Nt = `\\${Ne}`),
								vt({ type: 'text', value: Ne, output: Nt })
							continue
						}
						if (n.dot !== !0 && (Te.type === 'slash' || Te.type === 'bos')) {
							vt({ type: 'qmark', value: Ne, output: ze })
							continue
						}
						vt({ type: 'qmark', value: Ne, output: Ae })
						continue
					}
					if (Ne === '!') {
						if (n.noextglob !== !0 && Ct() === '(' && (Ct(2) !== '?' || !/[!=<:]/.test(Ct(3)))) {
							He('negate', Ne)
							continue
						}
						if (n.nonegate !== !0 && Ve.index === 0) {
							rt()
							continue
						}
					}
					if (Ne === '+') {
						if (n.noextglob !== !0 && Ct() === '(' && Ct(2) !== '?') {
							He('plus', Ne)
							continue
						}
						if ((Te && Te.value === '(') || n.regex === !1) {
							vt({ type: 'plus', value: Ne, output: I })
							continue
						}
						if (
							(Te && (Te.type === 'bracket' || Te.type === 'paren' || Te.type === 'brace')) ||
							Ve.parens > 0
						) {
							vt({ type: 'plus', value: Ne })
							continue
						}
						vt({ type: 'plus', value: I })
						continue
					}
					if (Ne === '@') {
						if (n.noextglob !== !0 && Ct() === '(' && Ct(2) !== '?') {
							vt({ type: 'at', extglob: !0, value: Ne, output: '' })
							continue
						}
						vt({ type: 'text', value: Ne })
						continue
					}
					if (Ne !== '*') {
						;(Ne === '$' || Ne === '^') && (Ne = `\\${Ne}`)
						let Ee = R5.exec(xn())
						Ee && ((Ne += Ee[0]), (Ve.index += Ee[0].length)), vt({ type: 'text', value: Ne })
						continue
					}
					if (Te && (Te.type === 'globstar' || Te.star === !0)) {
						;(Te.type = 'star'),
							(Te.star = !0),
							(Te.value += Ne),
							(Te.output = Je),
							(Ve.backtrack = !0),
							(Ve.globstar = !0),
							zn(Ne)
						continue
					}
					let be = xn()
					if (n.noextglob !== !0 && /^\([^?]/.test(be)) {
						He('star', Ne)
						continue
					}
					if (Te.type === 'star') {
						if (n.noglobstar === !0) {
							zn(Ne)
							continue
						}
						let Ee = Te.prev,
							xt = Ee.prev,
							Nt = Ee.type === 'slash' || Ee.type === 'bos',
							en = xt && (xt.type === 'star' || xt.type === 'globstar')
						if (n.bash === !0 && (!Nt || (be[0] && be[0] !== '/'))) {
							vt({ type: 'star', value: Ne, output: '' })
							continue
						}
						let on = Ve.braces > 0 && (Ee.type === 'comma' || Ee.type === 'brace'),
							Bn = Qt.length && (Ee.type === 'pipe' || Ee.type === 'paren')
						if (!Nt && Ee.type !== 'paren' && !on && !Bn) {
							vt({ type: 'star', value: Ne, output: '' })
							continue
						}
						for (; be.slice(0, 3) === '/**'; ) {
							let gn = e[Ve.index + 4]
							if (gn && gn !== '/') break
							;(be = be.slice(3)), zn('/**', 3)
						}
						if (Ee.type === 'bos' && Lt()) {
							;(Te.type = 'globstar'),
								(Te.value += Ne),
								(Te.output = _t(n)),
								(Ve.output = Te.output),
								(Ve.globstar = !0),
								zn(Ne)
							continue
						}
						if (Ee.type === 'slash' && Ee.prev.type !== 'bos' && !en && Lt()) {
							;(Ve.output = Ve.output.slice(0, -(Ee.output + Te.output).length)),
								(Ee.output = `(?:${Ee.output}`),
								(Te.type = 'globstar'),
								(Te.output = _t(n) + (n.strictSlashes ? ')' : '|$)')),
								(Te.value += Ne),
								(Ve.globstar = !0),
								(Ve.output += Ee.output + Te.output),
								zn(Ne)
							continue
						}
						if (Ee.type === 'slash' && Ee.prev.type !== 'bos' && be[0] === '/') {
							let gn = be[1] !== void 0 ? '|$' : ''
							;(Ve.output = Ve.output.slice(0, -(Ee.output + Te.output).length)),
								(Ee.output = `(?:${Ee.output}`),
								(Te.type = 'globstar'),
								(Te.output = `${_t(n)}${Q}|${Q}${gn})`),
								(Te.value += Ne),
								(Ve.output += Ee.output + Te.output),
								(Ve.globstar = !0),
								zn(Ne + pn()),
								vt({ type: 'slash', value: '/', output: '' })
							continue
						}
						if (Ee.type === 'bos' && be[0] === '/') {
							;(Te.type = 'globstar'),
								(Te.value += Ne),
								(Te.output = `(?:^|${Q}|${_t(n)}${Q})`),
								(Ve.output = Te.output),
								(Ve.globstar = !0),
								zn(Ne + pn()),
								vt({ type: 'slash', value: '/', output: '' })
							continue
						}
						;(Ve.output = Ve.output.slice(0, -Te.output.length)),
							(Te.type = 'globstar'),
							(Te.output = _t(n)),
							(Te.value += Ne),
							(Ve.output += Te.output),
							(Ve.globstar = !0),
							zn(Ne)
						continue
					}
					let tt = { type: 'star', value: Ne, output: Je }
					if (n.bash === !0) {
						;(tt.output = '.*?'),
							(Te.type === 'bos' || Te.type === 'slash') && (tt.output = ct + tt.output),
							vt(tt)
						continue
					}
					if (Te && (Te.type === 'bracket' || Te.type === 'paren') && n.regex === !0) {
						;(tt.output = Ne), vt(tt)
						continue
					}
					;(Ve.index === Ve.start || Te.type === 'slash' || Te.type === 'dot') &&
						(Te.type === 'dot'
							? ((Ve.output += Pe), (Te.output += Pe))
							: n.dot === !0
							? ((Ve.output += Ze), (Te.output += Ze))
							: ((Ve.output += ct), (Te.output += ct)),
						Ct() !== '*' && ((Ve.output += K), (Te.output += K))),
						vt(tt)
				}
				for (; Ve.brackets > 0; ) {
					if (n.strictBrackets === !0) throw new SyntaxError(Aa('closing', ']'))
					;(Ve.output = Ui.escapeLast(Ve.output, '[')), Ot('brackets')
				}
				for (; Ve.parens > 0; ) {
					if (n.strictBrackets === !0) throw new SyntaxError(Aa('closing', ')'))
					;(Ve.output = Ui.escapeLast(Ve.output, '(')), Ot('parens')
				}
				for (; Ve.braces > 0; ) {
					if (n.strictBrackets === !0) throw new SyntaxError(Aa('closing', '}'))
					;(Ve.output = Ui.escapeLast(Ve.output, '{')), Ot('braces')
				}
				if (
					(n.strictSlashes !== !0 &&
						(Te.type === 'star' || Te.type === 'bracket') &&
						vt({ type: 'maybe_slash', value: '', output: `${Q}?` }),
					Ve.backtrack === !0)
				) {
					Ve.output = ''
					for (let be of Ve.tokens)
						(Ve.output += be.output != null ? be.output : be.value),
							be.suffix && (Ve.output += be.suffix)
				}
				return Ve
			}
		P2.fastpaths = (e, t) => {
			let n = { ...t },
				r = typeof n.maxLength == 'number' ? Math.min(Kc, n.maxLength) : Kc,
				i = e.length
			if (i > r) throw new SyntaxError(`Input length: ${i}, exceeds maximum allowed length: ${r}`)
			e = B2[e] || e
			let {
					DOT_LITERAL: s,
					SLASH_LITERAL: o,
					ONE_CHAR: a,
					DOTS_SLASH: u,
					NO_DOT: h,
					NO_DOTS: N,
					NO_DOTS_SLASH: I,
					STAR: Q,
					START_ANCHOR: K
				} = Xc.globChars(n.windows),
				ue = n.dot ? N : h,
				de = n.dot ? I : h,
				Pe = n.capture ? '' : '?:',
				Ze = { negated: !1, prefix: '' },
				Ae = n.bash === !0 ? '.*?' : Q
			n.capture && (Ae = `(${Ae})`)
			let ze = (ct) => (ct.noglobstar === !0 ? Ae : `(${Pe}(?:(?!${K}${ct.dot ? u : s}).)*?)`),
				it = (ct) => {
					switch (ct) {
						case '*':
							return `${ue}${a}${Ae}`
						case '.*':
							return `${s}${a}${Ae}`
						case '*.*':
							return `${ue}${Ae}${s}${a}${Ae}`
						case '*/*':
							return `${ue}${Ae}${o}${a}${de}${Ae}`
						case '**':
							return ue + ze(n)
						case '**/*':
							return `(?:${ue}${ze(n)}${o})?${de}${a}${Ae}`
						case '**/*.*':
							return `(?:${ue}${ze(n)}${o})?${de}${Ae}${s}${a}${Ae}`
						case '**/.*':
							return `(?:${ue}${ze(n)}${o})?${s}${a}${Ae}`
						default: {
							let St = /^(.*?)\.(\w+)$/.exec(ct)
							if (!St) return
							let Je = it(St[1])
							return Je ? Je + s + St[2] : void 0
						}
					}
				},
				Et = Ui.removePrefix(e, Ze),
				_t = it(Et)
			return _t && n.strictSlashes !== !0 && (_t += `${o}?`), _t
		}
		M2.exports = P2
	})
	var U2 = as((vI, V2) => {
		'use strict'
		var P5 = O2(),
			Qd = j2(),
			$2 = Yc(),
			M5 = Iu(),
			j5 = (e) => e && typeof e == 'object' && !Array.isArray(e),
			kr = (e, t, n = !1) => {
				if (Array.isArray(e)) {
					let N = e.map((Q) => kr(Q, t, n))
					return (Q) => {
						for (let K of N) {
							let ue = K(Q)
							if (ue) return ue
						}
						return !1
					}
				}
				let r = j5(e) && e.tokens && e.input
				if (e === '' || (typeof e != 'string' && !r))
					throw new TypeError('Expected pattern to be a non-empty string')
				let i = t || {},
					s = i.windows,
					o = r ? kr.compileRe(e, t) : kr.makeRe(e, t, !1, !0),
					a = o.state
				delete o.state
				let u = () => !1
				if (i.ignore) {
					let N = { ...t, ignore: null, onMatch: null, onResult: null }
					u = kr(i.ignore, N, n)
				}
				let h = (N, I = !1) => {
					let { isMatch: Q, match: K, output: ue } = kr.test(N, o, t, { glob: e, posix: s }),
						de = {
							glob: e,
							state: a,
							regex: o,
							posix: s,
							input: N,
							output: ue,
							match: K,
							isMatch: Q
						}
					return (
						typeof i.onResult == 'function' && i.onResult(de),
						Q === !1
							? ((de.isMatch = !1), I ? de : !1)
							: u(N)
							? (typeof i.onIgnore == 'function' && i.onIgnore(de), (de.isMatch = !1), I ? de : !1)
							: (typeof i.onMatch == 'function' && i.onMatch(de), I ? de : !0)
					)
				}
				return n && (h.state = a), h
			}
		kr.test = (e, t, n, { glob: r, posix: i } = {}) => {
			if (typeof e != 'string') throw new TypeError('Expected input to be a string')
			if (e === '') return { isMatch: !1, output: '' }
			let s = n || {},
				o = s.format || (i ? $2.toPosixSlashes : null),
				a = e === r,
				u = a && o ? o(e) : e
			return (
				a === !1 && ((u = o ? o(e) : e), (a = u === r)),
				(a === !1 || s.capture === !0) &&
					(s.matchBase === !0 || s.basename === !0
						? (a = kr.matchBase(e, t, n, i))
						: (a = t.exec(u))),
				{ isMatch: !!a, match: a, output: u }
			)
		}
		kr.matchBase = (e, t, n) => (t instanceof RegExp ? t : kr.makeRe(t, n)).test($2.basename(e))
		kr.isMatch = (e, t, n) => kr(t, n)(e)
		kr.parse = (e, t) =>
			Array.isArray(e) ? e.map((n) => kr.parse(n, t)) : Qd(e, { ...t, fastpaths: !1 })
		kr.scan = (e, t) => P5(e, t)
		kr.compileRe = (e, t, n = !1, r = !1) => {
			if (n === !0) return e.output
			let i = t || {},
				s = i.contains ? '' : '^',
				o = i.contains ? '' : '$',
				a = `${s}(?:${e.output})${o}`
			e && e.negated === !0 && (a = `^(?!${a}).*$`)
			let u = kr.toRegex(a, t)
			return r === !0 && (u.state = e), u
		}
		kr.makeRe = (e, t, n = !1, r = !1) => {
			if (!e || typeof e != 'string') throw new TypeError('Expected a non-empty string')
			let i = t || {},
				s = { negated: !1, fastpaths: !0 },
				o = '',
				a
			return (
				e.startsWith('./') && ((e = e.slice(2)), (o = s.prefix = './')),
				i.fastpaths !== !1 && (e[0] === '.' || e[0] === '*') && (a = Qd.fastpaths(e, t)),
				a === void 0 ? ((s = Qd(e, t)), (s.prefix = o + (s.prefix || ''))) : (s.output = a),
				kr.compileRe(s, t, n, r)
			)
		}
		kr.toRegex = (e, t) => {
			try {
				let n = t || {}
				return new RegExp(e, n.flags || (n.nocase ? 'i' : ''))
			} catch (n) {
				if (t && t.debug === !0) throw n
				return /$^/
			}
		}
		kr.constants = M5
		V2.exports = kr
	})
	var G2 = as((xI, q2) => {
		'use strict'
		q2.exports = U2()
	})
	var Q2 = as((z2, Zd) => {
		;(function (e) {
			if (typeof z2 == 'object' && typeof Zd == 'object') Zd.exports = e()
			else if (typeof define == 'function' && define.amd) define(e)
			else {
				var t =
					typeof globalThis < 'u'
						? globalThis
						: typeof global < 'u'
						? global
						: typeof self < 'u'
						? self
						: this || {}
				t.prettier = e()
			}
		})(function () {
			'use strict'
			var e = (At, Le) => () => (Le || At((Le = { exports: {} }).exports, Le), Le.exports),
				t = e((At, Le) => {
					var Se = function (Re) {
						return Re && Re.Math == Math && Re
					}
					Le.exports =
						Se(typeof globalThis == 'object' && globalThis) ||
						Se(typeof window == 'object' && window) ||
						Se(typeof self == 'object' && self) ||
						Se(typeof global == 'object' && global) ||
						(function () {
							return this
						})() ||
						Function('return this')()
				}),
				n = e((At, Le) => {
					Le.exports = function (Se) {
						try {
							return !!Se()
						} catch {
							return !0
						}
					}
				}),
				r = e((At, Le) => {
					var Se = n()
					Le.exports = !Se(function () {
						return (
							Object.defineProperty({}, 1, {
								get: function () {
									return 7
								}
							})[1] != 7
						)
					})
				}),
				i = e((At, Le) => {
					var Se = n()
					Le.exports = !Se(function () {
						var Re = function () {}.bind()
						return typeof Re != 'function' || Re.hasOwnProperty('prototype')
					})
				}),
				s = e((At, Le) => {
					var Se = i(),
						Re = Function.prototype.call
					Le.exports = Se
						? Re.bind(Re)
						: function () {
								return Re.apply(Re, arguments)
						  }
				}),
				o = e((At) => {
					'use strict'
					var Le = {}.propertyIsEnumerable,
						Se = Object.getOwnPropertyDescriptor,
						Re = Se && !Le.call({ 1: 2 }, 1)
					At.f = Re
						? function (we) {
								var Ye = Se(this, we)
								return !!Ye && Ye.enumerable
						  }
						: Le
				}),
				a = e((At, Le) => {
					Le.exports = function (Se, Re) {
						return {
							enumerable: !(Se & 1),
							configurable: !(Se & 2),
							writable: !(Se & 4),
							value: Re
						}
					}
				}),
				u = e((At, Le) => {
					var Se = i(),
						Re = Function.prototype,
						we = Re.call,
						Ye = Se && Re.bind.bind(we, we)
					Le.exports = Se
						? Ye
						: function (ut) {
								return function () {
									return we.apply(ut, arguments)
								}
						  }
				}),
				h = e((At, Le) => {
					var Se = u(),
						Re = Se({}.toString),
						we = Se(''.slice)
					Le.exports = function (Ye) {
						return we(Re(Ye), 8, -1)
					}
				}),
				N = e((At, Le) => {
					var Se = u(),
						Re = n(),
						we = h(),
						Ye = Object,
						ut = Se(''.split)
					Le.exports = Re(function () {
						return !Ye('z').propertyIsEnumerable(0)
					})
						? function (bt) {
								return we(bt) == 'String' ? ut(bt, '') : Ye(bt)
						  }
						: Ye
				}),
				I = e((At, Le) => {
					Le.exports = function (Se) {
						return Se == null
					}
				}),
				Q = e((At, Le) => {
					var Se = I(),
						Re = TypeError
					Le.exports = function (we) {
						if (Se(we)) throw Re("Can't call method on " + we)
						return we
					}
				}),
				K = e((At, Le) => {
					var Se = N(),
						Re = Q()
					Le.exports = function (we) {
						return Se(Re(we))
					}
				}),
				ue = e((At, Le) => {
					var Se = typeof document == 'object' && document.all,
						Re = typeof Se > 'u' && Se !== void 0
					Le.exports = { all: Se, IS_HTMLDDA: Re }
				}),
				de = e((At, Le) => {
					var Se = ue(),
						Re = Se.all
					Le.exports = Se.IS_HTMLDDA
						? function (we) {
								return typeof we == 'function' || we === Re
						  }
						: function (we) {
								return typeof we == 'function'
						  }
				}),
				Pe = e((At, Le) => {
					var Se = de(),
						Re = ue(),
						we = Re.all
					Le.exports = Re.IS_HTMLDDA
						? function (Ye) {
								return typeof Ye == 'object' ? Ye !== null : Se(Ye) || Ye === we
						  }
						: function (Ye) {
								return typeof Ye == 'object' ? Ye !== null : Se(Ye)
						  }
				}),
				Ze = e((At, Le) => {
					var Se = t(),
						Re = de(),
						we = function (Ye) {
							return Re(Ye) ? Ye : void 0
						}
					Le.exports = function (Ye, ut) {
						return arguments.length < 2 ? we(Se[Ye]) : Se[Ye] && Se[Ye][ut]
					}
				}),
				Ae = e((At, Le) => {
					var Se = u()
					Le.exports = Se({}.isPrototypeOf)
				}),
				ze = e((At, Le) => {
					var Se = Ze()
					Le.exports = Se('navigator', 'userAgent') || ''
				}),
				it = e((At, Le) => {
					var Se = t(),
						Re = ze(),
						we = Se.process,
						Ye = Se.Deno,
						ut = (we && we.versions) || (Ye && Ye.version),
						bt = ut && ut.v8,
						ht,
						Tt
					bt && ((ht = bt.split('.')), (Tt = ht[0] > 0 && ht[0] < 4 ? 1 : +(ht[0] + ht[1]))),
						!Tt &&
							Re &&
							((ht = Re.match(/Edge\/(\d+)/)),
							(!ht || ht[1] >= 74) && ((ht = Re.match(/Chrome\/(\d+)/)), ht && (Tt = +ht[1]))),
						(Le.exports = Tt)
				}),
				Et = e((At, Le) => {
					var Se = it(),
						Re = n()
					Le.exports =
						!!Object.getOwnPropertySymbols &&
						!Re(function () {
							var we = Symbol()
							return (
								!String(we) || !(Object(we) instanceof Symbol) || (!Symbol.sham && Se && Se < 41)
							)
						})
				}),
				_t = e((At, Le) => {
					var Se = Et()
					Le.exports = Se && !Symbol.sham && typeof Symbol.iterator == 'symbol'
				}),
				ct = e((At, Le) => {
					var Se = Ze(),
						Re = de(),
						we = Ae(),
						Ye = _t(),
						ut = Object
					Le.exports = Ye
						? function (bt) {
								return typeof bt == 'symbol'
						  }
						: function (bt) {
								var ht = Se('Symbol')
								return Re(ht) && we(ht.prototype, ut(bt))
						  }
				}),
				St = e((At, Le) => {
					var Se = String
					Le.exports = function (Re) {
						try {
							return Se(Re)
						} catch {
							return 'Object'
						}
					}
				}),
				Je = e((At, Le) => {
					var Se = de(),
						Re = St(),
						we = TypeError
					Le.exports = function (Ye) {
						if (Se(Ye)) return Ye
						throw we(Re(Ye) + ' is not a function')
					}
				}),
				Ve = e((At, Le) => {
					var Se = Je(),
						Re = I()
					Le.exports = function (we, Ye) {
						var ut = we[Ye]
						return Re(ut) ? void 0 : Se(ut)
					}
				}),
				Qt = e((At, Le) => {
					var Se = s(),
						Re = de(),
						we = Pe(),
						Ye = TypeError
					Le.exports = function (ut, bt) {
						var ht, Tt
						if (
							(bt === 'string' && Re((ht = ut.toString)) && !we((Tt = Se(ht, ut)))) ||
							(Re((ht = ut.valueOf)) && !we((Tt = Se(ht, ut)))) ||
							(bt !== 'string' && Re((ht = ut.toString)) && !we((Tt = Se(ht, ut))))
						)
							return Tt
						throw Ye("Can't convert object to primitive value")
					}
				}),
				qt = e((At, Le) => {
					Le.exports = !1
				}),
				Bt = e((At, Le) => {
					var Se = t(),
						Re = Object.defineProperty
					Le.exports = function (we, Ye) {
						try {
							Re(Se, we, { value: Ye, configurable: !0, writable: !0 })
						} catch {
							Se[we] = Ye
						}
						return Ye
					}
				}),
				Te = e((At, Le) => {
					var Se = t(),
						Re = Bt(),
						we = '__core-js_shared__',
						Ye = Se[we] || Re(we, {})
					Le.exports = Ye
				}),
				Ne = e((At, Le) => {
					var Se = qt(),
						Re = Te()
					;(Le.exports = function (we, Ye) {
						return Re[we] || (Re[we] = Ye !== void 0 ? Ye : {})
					})('versions', []).push({
						version: '3.26.1',
						mode: Se ? 'pure' : 'global',
						copyright: '\xA9 2014-2022 Denis Pushkarev (zloirock.ru)',
						license: 'https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE',
						source: 'https://github.com/zloirock/core-js'
					})
				}),
				Lt = e((At, Le) => {
					var Se = Q(),
						Re = Object
					Le.exports = function (we) {
						return Re(Se(we))
					}
				}),
				Ct = e((At, Le) => {
					var Se = u(),
						Re = Lt(),
						we = Se({}.hasOwnProperty)
					Le.exports =
						Object.hasOwn ||
						function (Ye, ut) {
							return we(Re(Ye), ut)
						}
				}),
				pn = e((At, Le) => {
					var Se = u(),
						Re = 0,
						we = Math.random(),
						Ye = Se((1).toString)
					Le.exports = function (ut) {
						return 'Symbol(' + (ut === void 0 ? '' : ut) + ')_' + Ye(++Re + we, 36)
					}
				}),
				xn = e((At, Le) => {
					var Se = t(),
						Re = Ne(),
						we = Ct(),
						Ye = pn(),
						ut = Et(),
						bt = _t(),
						ht = Re('wks'),
						Tt = Se.Symbol,
						Xt = Tt && Tt.for,
						nn = bt ? Tt : (Tt && Tt.withoutSetter) || Ye
					Le.exports = function (sn) {
						if (!we(ht, sn) || !(ut || typeof ht[sn] == 'string')) {
							var Kt = 'Symbol.' + sn
							ut && we(Tt, sn)
								? (ht[sn] = Tt[sn])
								: bt && Xt
								? (ht[sn] = Xt(Kt))
								: (ht[sn] = nn(Kt))
						}
						return ht[sn]
					}
				}),
				zn = e((At, Le) => {
					var Se = s(),
						Re = Pe(),
						we = ct(),
						Ye = Ve(),
						ut = Qt(),
						bt = xn(),
						ht = TypeError,
						Tt = bt('toPrimitive')
					Le.exports = function (Xt, nn) {
						if (!Re(Xt) || we(Xt)) return Xt
						var sn = Ye(Xt, Tt),
							Kt
						if (sn) {
							if ((nn === void 0 && (nn = 'default'), (Kt = Se(sn, Xt, nn)), !Re(Kt) || we(Kt)))
								return Kt
							throw ht("Can't convert object to primitive value")
						}
						return nn === void 0 && (nn = 'number'), ut(Xt, nn)
					}
				}),
				rr = e((At, Le) => {
					var Se = zn(),
						Re = ct()
					Le.exports = function (we) {
						var Ye = Se(we, 'string')
						return Re(Ye) ? Ye : Ye + ''
					}
				}),
				rt = e((At, Le) => {
					var Se = t(),
						Re = Pe(),
						we = Se.document,
						Ye = Re(we) && Re(we.createElement)
					Le.exports = function (ut) {
						return Ye ? we.createElement(ut) : {}
					}
				}),
				Wt = e((At, Le) => {
					var Se = r(),
						Re = n(),
						we = rt()
					Le.exports =
						!Se &&
						!Re(function () {
							return (
								Object.defineProperty(we('div'), 'a', {
									get: function () {
										return 7
									}
								}).a != 7
							)
						})
				}),
				Ot = e((At) => {
					var Le = r(),
						Se = s(),
						Re = o(),
						we = a(),
						Ye = K(),
						ut = rr(),
						bt = Ct(),
						ht = Wt(),
						Tt = Object.getOwnPropertyDescriptor
					At.f = Le
						? Tt
						: function (Xt, nn) {
								if (((Xt = Ye(Xt)), (nn = ut(nn)), ht))
									try {
										return Tt(Xt, nn)
									} catch {}
								if (bt(Xt, nn)) return we(!Se(Re.f, Xt, nn), Xt[nn])
						  }
				}),
				vt = e((At, Le) => {
					var Se = r(),
						Re = n()
					Le.exports =
						Se &&
						Re(function () {
							return (
								Object.defineProperty(function () {}, 'prototype', { value: 42, writable: !1 })
									.prototype != 42
							)
						})
				}),
				He = e((At, Le) => {
					var Se = Pe(),
						Re = String,
						we = TypeError
					Le.exports = function (Ye) {
						if (Se(Ye)) return Ye
						throw we(Re(Ye) + ' is not an object')
					}
				}),
				dt = e((At) => {
					var Le = r(),
						Se = Wt(),
						Re = vt(),
						we = He(),
						Ye = rr(),
						ut = TypeError,
						bt = Object.defineProperty,
						ht = Object.getOwnPropertyDescriptor,
						Tt = 'enumerable',
						Xt = 'configurable',
						nn = 'writable'
					At.f = Le
						? Re
							? function (sn, Kt, le) {
									if (
										(we(sn),
										(Kt = Ye(Kt)),
										we(le),
										typeof sn == 'function' &&
											Kt === 'prototype' &&
											'value' in le &&
											nn in le &&
											!le[nn])
									) {
										var fn = ht(sn, Kt)
										fn &&
											fn[nn] &&
											((sn[Kt] = le.value),
											(le = {
												configurable: Xt in le ? le[Xt] : fn[Xt],
												enumerable: Tt in le ? le[Tt] : fn[Tt],
												writable: !1
											}))
									}
									return bt(sn, Kt, le)
							  }
							: bt
						: function (sn, Kt, le) {
								if ((we(sn), (Kt = Ye(Kt)), we(le), Se))
									try {
										return bt(sn, Kt, le)
									} catch {}
								if ('get' in le || 'set' in le) throw ut('Accessors not supported')
								return 'value' in le && (sn[Kt] = le.value), sn
						  }
				}),
				be = e((At, Le) => {
					var Se = r(),
						Re = dt(),
						we = a()
					Le.exports = Se
						? function (Ye, ut, bt) {
								return Re.f(Ye, ut, we(1, bt))
						  }
						: function (Ye, ut, bt) {
								return (Ye[ut] = bt), Ye
						  }
				}),
				tt = e((At, Le) => {
					var Se = r(),
						Re = Ct(),
						we = Function.prototype,
						Ye = Se && Object.getOwnPropertyDescriptor,
						ut = Re(we, 'name'),
						bt = ut && function () {}.name === 'something',
						ht = ut && (!Se || (Se && Ye(we, 'name').configurable))
					Le.exports = { EXISTS: ut, PROPER: bt, CONFIGURABLE: ht }
				}),
				Ee = e((At, Le) => {
					var Se = u(),
						Re = de(),
						we = Te(),
						Ye = Se(Function.toString)
					Re(we.inspectSource) ||
						(we.inspectSource = function (ut) {
							return Ye(ut)
						}),
						(Le.exports = we.inspectSource)
				}),
				xt = e((At, Le) => {
					var Se = t(),
						Re = de(),
						we = Se.WeakMap
					Le.exports = Re(we) && /native code/.test(String(we))
				}),
				Nt = e((At, Le) => {
					var Se = Ne(),
						Re = pn(),
						we = Se('keys')
					Le.exports = function (Ye) {
						return we[Ye] || (we[Ye] = Re(Ye))
					}
				}),
				en = e((At, Le) => {
					Le.exports = {}
				}),
				on = e((At, Le) => {
					var Se = xt(),
						Re = t(),
						we = Pe(),
						Ye = be(),
						ut = Ct(),
						bt = Te(),
						ht = Nt(),
						Tt = en(),
						Xt = 'Object already initialized',
						nn = Re.TypeError,
						sn = Re.WeakMap,
						Kt,
						le,
						fn,
						Cn = function (ge) {
							return fn(ge) ? le(ge) : Kt(ge, {})
						},
						Vn = function (ge) {
							return function (ei) {
								var Ps
								if (!we(ei) || (Ps = le(ei)).type !== ge)
									throw nn('Incompatible receiver, ' + ge + ' required')
								return Ps
							}
						}
					Se || bt.state
						? ((Mn = bt.state || (bt.state = new sn())),
						  (Mn.get = Mn.get),
						  (Mn.has = Mn.has),
						  (Mn.set = Mn.set),
						  (Kt = function (ge, ei) {
								if (Mn.has(ge)) throw nn(Xt)
								return (ei.facade = ge), Mn.set(ge, ei), ei
						  }),
						  (le = function (ge) {
								return Mn.get(ge) || {}
						  }),
						  (fn = function (ge) {
								return Mn.has(ge)
						  }))
						: ((mr = ht('state')),
						  (Tt[mr] = !0),
						  (Kt = function (ge, ei) {
								if (ut(ge, mr)) throw nn(Xt)
								return (ei.facade = ge), Ye(ge, mr, ei), ei
						  }),
						  (le = function (ge) {
								return ut(ge, mr) ? ge[mr] : {}
						  }),
						  (fn = function (ge) {
								return ut(ge, mr)
						  }))
					var Mn, mr
					Le.exports = { set: Kt, get: le, has: fn, enforce: Cn, getterFor: Vn }
				}),
				Bn = e((At, Le) => {
					var Se = n(),
						Re = de(),
						we = Ct(),
						Ye = r(),
						ut = tt().CONFIGURABLE,
						bt = Ee(),
						ht = on(),
						Tt = ht.enforce,
						Xt = ht.get,
						nn = Object.defineProperty,
						sn =
							Ye &&
							!Se(function () {
								return nn(function () {}, 'length', { value: 8 }).length !== 8
							}),
						Kt = String(String).split('String'),
						le = (Le.exports = function (fn, Cn, Vn) {
							String(Cn).slice(0, 7) === 'Symbol(' &&
								(Cn = '[' + String(Cn).replace(/^Symbol\(([^)]*)\)/, '$1') + ']'),
								Vn && Vn.getter && (Cn = 'get ' + Cn),
								Vn && Vn.setter && (Cn = 'set ' + Cn),
								(!we(fn, 'name') || (ut && fn.name !== Cn)) &&
									(Ye ? nn(fn, 'name', { value: Cn, configurable: !0 }) : (fn.name = Cn)),
								sn &&
									Vn &&
									we(Vn, 'arity') &&
									fn.length !== Vn.arity &&
									nn(fn, 'length', { value: Vn.arity })
							try {
								Vn && we(Vn, 'constructor') && Vn.constructor
									? Ye && nn(fn, 'prototype', { writable: !1 })
									: fn.prototype && (fn.prototype = void 0)
							} catch {}
							var Mn = Tt(fn)
							return we(Mn, 'source') || (Mn.source = Kt.join(typeof Cn == 'string' ? Cn : '')), fn
						})
					Function.prototype.toString = le(function () {
						return (Re(this) && Xt(this).source) || bt(this)
					}, 'toString')
				}),
				gn = e((At, Le) => {
					var Se = de(),
						Re = dt(),
						we = Bn(),
						Ye = Bt()
					Le.exports = function (ut, bt, ht, Tt) {
						Tt || (Tt = {})
						var Xt = Tt.enumerable,
							nn = Tt.name !== void 0 ? Tt.name : bt
						if ((Se(ht) && we(ht, nn, Tt), Tt.global)) Xt ? (ut[bt] = ht) : Ye(bt, ht)
						else {
							try {
								Tt.unsafe ? ut[bt] && (Xt = !0) : delete ut[bt]
							} catch {}
							Xt
								? (ut[bt] = ht)
								: Re.f(ut, bt, {
										value: ht,
										enumerable: !1,
										configurable: !Tt.nonConfigurable,
										writable: !Tt.nonWritable
								  })
						}
						return ut
					}
				}),
				Pn = e((At, Le) => {
					var Se = Math.ceil,
						Re = Math.floor
					Le.exports =
						Math.trunc ||
						function (we) {
							var Ye = +we
							return (Ye > 0 ? Re : Se)(Ye)
						}
				}),
				Gn = e((At, Le) => {
					var Se = Pn()
					Le.exports = function (Re) {
						var we = +Re
						return we !== we || we === 0 ? 0 : Se(we)
					}
				}),
				Ht = e((At, Le) => {
					var Se = Gn(),
						Re = Math.max,
						we = Math.min
					Le.exports = function (Ye, ut) {
						var bt = Se(Ye)
						return bt < 0 ? Re(bt + ut, 0) : we(bt, ut)
					}
				}),
				bn = e((At, Le) => {
					var Se = Gn(),
						Re = Math.min
					Le.exports = function (we) {
						return we > 0 ? Re(Se(we), 9007199254740991) : 0
					}
				}),
				gt = e((At, Le) => {
					var Se = bn()
					Le.exports = function (Re) {
						return Se(Re.length)
					}
				}),
				qe = e((At, Le) => {
					var Se = K(),
						Re = Ht(),
						we = gt(),
						Ye = function (ut) {
							return function (bt, ht, Tt) {
								var Xt = Se(bt),
									nn = we(Xt),
									sn = Re(Tt, nn),
									Kt
								if (ut && ht != ht) {
									for (; nn > sn; ) if (((Kt = Xt[sn++]), Kt != Kt)) return !0
								} else
									for (; nn > sn; sn++) if ((ut || sn in Xt) && Xt[sn] === ht) return ut || sn || 0
								return !ut && -1
							}
						}
					Le.exports = { includes: Ye(!0), indexOf: Ye(!1) }
				}),
				Xe = e((At, Le) => {
					var Se = u(),
						Re = Ct(),
						we = K(),
						Ye = qe().indexOf,
						ut = en(),
						bt = Se([].push)
					Le.exports = function (ht, Tt) {
						var Xt = we(ht),
							nn = 0,
							sn = [],
							Kt
						for (Kt in Xt) !Re(ut, Kt) && Re(Xt, Kt) && bt(sn, Kt)
						for (; Tt.length > nn; ) Re(Xt, (Kt = Tt[nn++])) && (~Ye(sn, Kt) || bt(sn, Kt))
						return sn
					}
				}),
				Mt = e((At, Le) => {
					Le.exports = [
						'constructor',
						'hasOwnProperty',
						'isPrototypeOf',
						'propertyIsEnumerable',
						'toLocaleString',
						'toString',
						'valueOf'
					]
				}),
				Ke = e((At) => {
					var Le = Xe(),
						Se = Mt(),
						Re = Se.concat('length', 'prototype')
					At.f =
						Object.getOwnPropertyNames ||
						function (we) {
							return Le(we, Re)
						}
				}),
				Yt = e((At) => {
					At.f = Object.getOwnPropertySymbols
				}),
				En = e((At, Le) => {
					var Se = Ze(),
						Re = u(),
						we = Ke(),
						Ye = Yt(),
						ut = He(),
						bt = Re([].concat)
					Le.exports =
						Se('Reflect', 'ownKeys') ||
						function (ht) {
							var Tt = we.f(ut(ht)),
								Xt = Ye.f
							return Xt ? bt(Tt, Xt(ht)) : Tt
						}
				}),
				Gt = e((At, Le) => {
					var Se = Ct(),
						Re = En(),
						we = Ot(),
						Ye = dt()
					Le.exports = function (ut, bt, ht) {
						for (var Tt = Re(bt), Xt = Ye.f, nn = we.f, sn = 0; sn < Tt.length; sn++) {
							var Kt = Tt[sn]
							!Se(ut, Kt) && !(ht && Se(ht, Kt)) && Xt(ut, Kt, nn(bt, Kt))
						}
					}
				}),
				rn = e((At, Le) => {
					var Se = n(),
						Re = de(),
						we = /#|\.prototype\./,
						Ye = function (Xt, nn) {
							var sn = bt[ut(Xt)]
							return sn == Tt ? !0 : sn == ht ? !1 : Re(nn) ? Se(nn) : !!nn
						},
						ut = (Ye.normalize = function (Xt) {
							return String(Xt).replace(we, '.').toLowerCase()
						}),
						bt = (Ye.data = {}),
						ht = (Ye.NATIVE = 'N'),
						Tt = (Ye.POLYFILL = 'P')
					Le.exports = Ye
				}),
				lt = e((At, Le) => {
					var Se = t(),
						Re = Ot().f,
						we = be(),
						Ye = gn(),
						ut = Bt(),
						bt = Gt(),
						ht = rn()
					Le.exports = function (Tt, Xt) {
						var nn = Tt.target,
							sn = Tt.global,
							Kt = Tt.stat,
							le,
							fn,
							Cn,
							Vn,
							Mn,
							mr
						if (
							(sn ? (fn = Se) : Kt ? (fn = Se[nn] || ut(nn, {})) : (fn = (Se[nn] || {}).prototype),
							fn)
						)
							for (Cn in Xt) {
								if (
									((Mn = Xt[Cn]),
									Tt.dontCallGetSet ? ((mr = Re(fn, Cn)), (Vn = mr && mr.value)) : (Vn = fn[Cn]),
									(le = ht(sn ? Cn : nn + (Kt ? '.' : '#') + Cn, Tt.forced)),
									!le && Vn !== void 0)
								) {
									if (typeof Mn == typeof Vn) continue
									bt(Mn, Vn)
								}
								;(Tt.sham || (Vn && Vn.sham)) && we(Mn, 'sham', !0), Ye(fn, Cn, Mn, Tt)
							}
					}
				}),
				$t = e((At, Le) => {
					var Se = h()
					Le.exports =
						Array.isArray ||
						function (Re) {
							return Se(Re) == 'Array'
						}
				}),
				Ft = e((At, Le) => {
					var Se = TypeError,
						Re = 9007199254740991
					Le.exports = function (we) {
						if (we > Re) throw Se('Maximum allowed index exceeded')
						return we
					}
				}),
				zt = e((At, Le) => {
					var Se = h(),
						Re = u()
					Le.exports = function (we) {
						if (Se(we) === 'Function') return Re(we)
					}
				}),
				kn = e((At, Le) => {
					var Se = zt(),
						Re = Je(),
						we = i(),
						Ye = Se(Se.bind)
					Le.exports = function (ut, bt) {
						return (
							Re(ut),
							bt === void 0
								? ut
								: we
								? Ye(ut, bt)
								: function () {
										return ut.apply(bt, arguments)
								  }
						)
					}
				}),
				jr = e((At, Le) => {
					'use strict'
					var Se = $t(),
						Re = gt(),
						we = Ft(),
						Ye = kn(),
						ut = function (bt, ht, Tt, Xt, nn, sn, Kt, le) {
							for (var fn = nn, Cn = 0, Vn = Kt ? Ye(Kt, le) : !1, Mn, mr; Cn < Xt; )
								Cn in Tt &&
									((Mn = Vn ? Vn(Tt[Cn], Cn, ht) : Tt[Cn]),
									sn > 0 && Se(Mn)
										? ((mr = Re(Mn)), (fn = ut(bt, ht, Mn, mr, fn, sn - 1) - 1))
										: (we(fn + 1), (bt[fn] = Mn)),
									fn++),
									Cn++
							return fn
						}
					Le.exports = ut
				}),
				di = e((At, Le) => {
					var Se = xn(),
						Re = Se('toStringTag'),
						we = {}
					;(we[Re] = 'z'), (Le.exports = String(we) === '[object z]')
				}),
				Ru = e((At, Le) => {
					var Se = di(),
						Re = de(),
						we = h(),
						Ye = xn(),
						ut = Ye('toStringTag'),
						bt = Object,
						ht =
							we(
								(function () {
									return arguments
								})()
							) == 'Arguments',
						Tt = function (Xt, nn) {
							try {
								return Xt[nn]
							} catch {}
						}
					Le.exports = Se
						? we
						: function (Xt) {
								var nn, sn, Kt
								return Xt === void 0
									? 'Undefined'
									: Xt === null
									? 'Null'
									: typeof (sn = Tt((nn = bt(Xt)), ut)) == 'string'
									? sn
									: ht
									? we(nn)
									: (Kt = we(nn)) == 'Object' && Re(nn.callee)
									? 'Arguments'
									: Kt
						  }
				}),
				Ca = e((At, Le) => {
					var Se = u(),
						Re = n(),
						we = de(),
						Ye = Ru(),
						ut = Ze(),
						bt = Ee(),
						ht = function () {},
						Tt = [],
						Xt = ut('Reflect', 'construct'),
						nn = /^\s*(?:class|function)\b/,
						sn = Se(nn.exec),
						Kt = !nn.exec(ht),
						le = function (Cn) {
							if (!we(Cn)) return !1
							try {
								return Xt(ht, Tt, Cn), !0
							} catch {
								return !1
							}
						},
						fn = function (Cn) {
							if (!we(Cn)) return !1
							switch (Ye(Cn)) {
								case 'AsyncFunction':
								case 'GeneratorFunction':
								case 'AsyncGeneratorFunction':
									return !1
							}
							try {
								return Kt || !!sn(nn, bt(Cn))
							} catch {
								return !0
							}
						}
					;(fn.sham = !0),
						(Le.exports =
							!Xt ||
							Re(function () {
								var Cn
								return (
									le(le.call) ||
									!le(Object) ||
									!le(function () {
										Cn = !0
									}) ||
									Cn
								)
							})
								? fn
								: le)
				}),
				Sa = e((At, Le) => {
					var Se = $t(),
						Re = Ca(),
						we = Pe(),
						Ye = xn(),
						ut = Ye('species'),
						bt = Array
					Le.exports = function (ht) {
						var Tt
						return (
							Se(ht) &&
								((Tt = ht.constructor),
								Re(Tt) && (Tt === bt || Se(Tt.prototype))
									? (Tt = void 0)
									: we(Tt) && ((Tt = Tt[ut]), Tt === null && (Tt = void 0))),
							Tt === void 0 ? bt : Tt
						)
					}
				}),
				ho = e((At, Le) => {
					var Se = Sa()
					Le.exports = function (Re, we) {
						return new (Se(Re))(we === 0 ? 0 : we)
					}
				}),
				Na = e(() => {
					'use strict'
					var At = lt(),
						Le = jr(),
						Se = Je(),
						Re = Lt(),
						we = gt(),
						Ye = ho()
					At(
						{ target: 'Array', proto: !0 },
						{
							flatMap: function (ut) {
								var bt = Re(this),
									ht = we(bt),
									Tt
								return (
									Se(ut),
									(Tt = Ye(bt, 0)),
									(Tt.length = Le(
										Tt,
										bt,
										bt,
										ht,
										0,
										1,
										ut,
										arguments.length > 1 ? arguments[1] : void 0
									)),
									Tt
								)
							}
						}
					)
				}),
				qi = e((At, Le) => {
					Le.exports = {}
				}),
				Gi = e((At, Le) => {
					var Se = xn(),
						Re = qi(),
						we = Se('iterator'),
						Ye = Array.prototype
					Le.exports = function (ut) {
						return ut !== void 0 && (Re.Array === ut || Ye[we] === ut)
					}
				}),
				mo = e((At, Le) => {
					var Se = Ru(),
						Re = Ve(),
						we = I(),
						Ye = qi(),
						ut = xn(),
						bt = ut('iterator')
					Le.exports = function (ht) {
						if (!we(ht)) return Re(ht, bt) || Re(ht, '@@iterator') || Ye[Se(ht)]
					}
				}),
				Fa = e((At, Le) => {
					var Se = s(),
						Re = Je(),
						we = He(),
						Ye = St(),
						ut = mo(),
						bt = TypeError
					Le.exports = function (ht, Tt) {
						var Xt = arguments.length < 2 ? ut(ht) : Tt
						if (Re(Xt)) return we(Se(Xt, ht))
						throw bt(Ye(ht) + ' is not iterable')
					}
				}),
				ms = e((At, Le) => {
					var Se = s(),
						Re = He(),
						we = Ve()
					Le.exports = function (Ye, ut, bt) {
						var ht, Tt
						Re(Ye)
						try {
							if (((ht = we(Ye, 'return')), !ht)) {
								if (ut === 'throw') throw bt
								return bt
							}
							ht = Se(ht, Ye)
						} catch (Xt) {
							;(Tt = !0), (ht = Xt)
						}
						if (ut === 'throw') throw bt
						if (Tt) throw ht
						return Re(ht), bt
					}
				}),
				go = e((At, Le) => {
					var Se = kn(),
						Re = s(),
						we = He(),
						Ye = St(),
						ut = Gi(),
						bt = gt(),
						ht = Ae(),
						Tt = Fa(),
						Xt = mo(),
						nn = ms(),
						sn = TypeError,
						Kt = function (fn, Cn) {
							;(this.stopped = fn), (this.result = Cn)
						},
						le = Kt.prototype
					Le.exports = function (fn, Cn, Vn) {
						var Mn = Vn && Vn.that,
							mr = !!(Vn && Vn.AS_ENTRIES),
							ge = !!(Vn && Vn.IS_RECORD),
							ei = !!(Vn && Vn.IS_ITERATOR),
							Ps = !!(Vn && Vn.INTERRUPTED),
							yo = Se(Cn, Mn),
							Fi,
							Ds,
							Ur,
							Bu,
							ki,
							Pu,
							Mu,
							ju = function (si) {
								return Fi && nn(Fi, 'normal', si), new Kt(!0, si)
							},
							$u = function (si) {
								return mr
									? (we(si), Ps ? yo(si[0], si[1], ju) : yo(si[0], si[1]))
									: Ps
									? yo(si, ju)
									: yo(si)
							}
						if (ge) Fi = fn.iterator
						else if (ei) Fi = fn
						else {
							if (((Ds = Xt(fn)), !Ds)) throw sn(Ye(fn) + ' is not iterable')
							if (ut(Ds)) {
								for (Ur = 0, Bu = bt(fn); Bu > Ur; Ur++)
									if (((ki = $u(fn[Ur])), ki && ht(le, ki))) return ki
								return new Kt(!1)
							}
							Fi = Tt(fn, Ds)
						}
						for (Pu = ge ? fn.next : Fi.next; !(Mu = Re(Pu, Fi)).done; ) {
							try {
								ki = $u(Mu.value)
							} catch (si) {
								nn(Fi, 'throw', si)
							}
							if (typeof ki == 'object' && ki && ht(le, ki)) return ki
						}
						return new Kt(!1)
					}
				}),
				Do = e((At, Le) => {
					'use strict'
					var Se = rr(),
						Re = dt(),
						we = a()
					Le.exports = function (Ye, ut, bt) {
						var ht = Se(ut)
						ht in Ye ? Re.f(Ye, ht, we(0, bt)) : (Ye[ht] = bt)
					}
				}),
				Ou = e(() => {
					var At = lt(),
						Le = go(),
						Se = Do()
					At(
						{ target: 'Object', stat: !0 },
						{
							fromEntries: function (Re) {
								var we = {}
								return (
									Le(
										Re,
										function (Ye, ut) {
											Se(we, Ye, ut)
										},
										{ AS_ENTRIES: !0 }
									),
									we
								)
							}
						}
					)
				}),
				ss = e((At, Le) => {
					var Se = Bn(),
						Re = dt()
					Le.exports = function (we, Ye, ut) {
						return (
							ut.get && Se(ut.get, Ye, { getter: !0 }),
							ut.set && Se(ut.set, Ye, { setter: !0 }),
							Re.f(we, Ye, ut)
						)
					}
				}),
				gs = e((At, Le) => {
					'use strict'
					var Se = He()
					Le.exports = function () {
						var Re = Se(this),
							we = ''
						return (
							Re.hasIndices && (we += 'd'),
							Re.global && (we += 'g'),
							Re.ignoreCase && (we += 'i'),
							Re.multiline && (we += 'm'),
							Re.dotAll && (we += 's'),
							Re.unicode && (we += 'u'),
							Re.unicodeSets && (we += 'v'),
							Re.sticky && (we += 'y'),
							we
						)
					}
				}),
				K2 = e(() => {
					var At = t(),
						Le = r(),
						Se = ss(),
						Re = gs(),
						we = n(),
						Ye = At.RegExp,
						ut = Ye.prototype,
						bt =
							Le &&
							we(function () {
								var ht = !0
								try {
									Ye('.', 'd')
								} catch {
									ht = !1
								}
								var Tt = {},
									Xt = '',
									nn = ht ? 'dgimsy' : 'gimsy',
									sn = function (Cn, Vn) {
										Object.defineProperty(Tt, Cn, {
											get: function () {
												return (Xt += Vn), !0
											}
										})
									},
									Kt = { dotAll: 's', global: 'g', ignoreCase: 'i', multiline: 'm', sticky: 'y' }
								ht && (Kt.hasIndices = 'd')
								for (var le in Kt) sn(le, Kt[le])
								var fn = Object.getOwnPropertyDescriptor(ut, 'flags').get.call(Tt)
								return fn !== nn || Xt !== nn
							})
					bt && Se(ut, 'flags', { configurable: !0, get: Re })
				}),
				Z2 = e(() => {
					var At = lt(),
						Le = t()
					At({ global: !0, forced: Le.globalThis !== Le }, { globalThis: Le })
				}),
				eD = e(() => {
					Z2()
				}),
				tD = e(() => {
					'use strict'
					var At = lt(),
						Le = jr(),
						Se = Lt(),
						Re = gt(),
						we = Gn(),
						Ye = ho()
					At(
						{ target: 'Array', proto: !0 },
						{
							flat: function () {
								var ut = arguments.length ? arguments[0] : void 0,
									bt = Se(this),
									ht = Re(bt),
									Tt = Ye(bt, 0)
								return (Tt.length = Le(Tt, bt, bt, ht, 0, ut === void 0 ? 1 : we(ut))), Tt
							}
						}
					)
				}),
				nD = e((At, Le) => {
					var Se = ['cliName', 'cliCategory', 'cliDescription'],
						Re = ['_'],
						we = ['languageId']
					function Ye(d, E) {
						if (d == null) return {}
						var c = ut(d, E),
							D,
							g
						if (Object.getOwnPropertySymbols) {
							var l = Object.getOwnPropertySymbols(d)
							for (g = 0; g < l.length; g++)
								(D = l[g]),
									!(E.indexOf(D) >= 0) &&
										Object.prototype.propertyIsEnumerable.call(d, D) &&
										(c[D] = d[D])
						}
						return c
					}
					function ut(d, E) {
						if (d == null) return {}
						var c = {},
							D = Object.keys(d),
							g,
							l
						for (l = 0; l < D.length; l++) (g = D[l]), !(E.indexOf(g) >= 0) && (c[g] = d[g])
						return c
					}
					Na(), Ou(), K2(), eD(), tD()
					var bt = Object.create,
						ht = Object.defineProperty,
						Tt = Object.getOwnPropertyDescriptor,
						Xt = Object.getOwnPropertyNames,
						nn = Object.getPrototypeOf,
						sn = Object.prototype.hasOwnProperty,
						Kt = (d, E) =>
							function () {
								return d && (E = (0, d[Xt(d)[0]])((d = 0))), E
							},
						le = (d, E) =>
							function () {
								return E || (0, d[Xt(d)[0]])((E = { exports: {} }).exports, E), E.exports
							},
						fn = (d, E) => {
							for (var c in E) ht(d, c, { get: E[c], enumerable: !0 })
						},
						Cn = (d, E, c, D) => {
							if ((E && typeof E == 'object') || typeof E == 'function')
								for (let g of Xt(E))
									!sn.call(d, g) &&
										g !== c &&
										ht(d, g, { get: () => E[g], enumerable: !(D = Tt(E, g)) || D.enumerable })
							return d
						},
						Vn = (d, E, c) => (
							(c = d != null ? bt(nn(d)) : {}),
							Cn(E || !d || !d.__esModule ? ht(c, 'default', { value: d, enumerable: !0 }) : c, d)
						),
						Mn = (d) => Cn(ht({}, '__esModule', { value: !0 }), d),
						mr,
						ge = Kt({
							'<define:process>'() {
								mr = { env: {}, argv: [] }
							}
						}),
						ei = le({
							'package.json'(d, E) {
								E.exports = { version: '2.8.8' }
							}
						}),
						Ps = le({
							'node_modules/diff/lib/diff/base.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 }), (d.default = E)
								function E() {}
								E.prototype = {
									diff: function (g, l) {
										var p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
											f = p.callback
										typeof p == 'function' && ((f = p), (p = {})), (this.options = p)
										var y = this
										function x(O) {
											return f
												? (setTimeout(function () {
														f(void 0, O)
												  }, 0),
												  !0)
												: O
										}
										;(g = this.castInput(g)),
											(l = this.castInput(l)),
											(g = this.removeEmpty(this.tokenize(g))),
											(l = this.removeEmpty(this.tokenize(l)))
										var _ = l.length,
											w = g.length,
											C = 1,
											v = _ + w,
											b = [{ newPos: -1, components: [] }],
											k = this.extractCommon(b[0], l, g, 0)
										if (b[0].newPos + 1 >= _ && k + 1 >= w)
											return x([{ value: this.join(l), count: l.length }])
										function q() {
											for (var O = -1 * C; O <= C; O += 2) {
												var U = void 0,
													j = b[O - 1],
													H = b[O + 1],
													W = (H ? H.newPos : 0) - O
												j && (b[O - 1] = void 0)
												var re = j && j.newPos + 1 < _,
													A = H && 0 <= W && W < w
												if (!re && !A) {
													b[O] = void 0
													continue
												}
												if (
													(!re || (A && j.newPos < H.newPos)
														? ((U = D(H)), y.pushComponent(U.components, void 0, !0))
														: ((U = j), U.newPos++, y.pushComponent(U.components, !0, void 0)),
													(W = y.extractCommon(U, l, g, O)),
													U.newPos + 1 >= _ && W + 1 >= w)
												)
													return x(c(y, U.components, l, g, y.useLongestToken))
												b[O] = U
											}
											C++
										}
										if (f)
											(function O() {
												setTimeout(function () {
													if (C > v) return f()
													q() || O()
												}, 0)
											})()
										else
											for (; C <= v; ) {
												var G = q()
												if (G) return G
											}
									},
									pushComponent: function (g, l, p) {
										var f = g[g.length - 1]
										f && f.added === l && f.removed === p
											? (g[g.length - 1] = { count: f.count + 1, added: l, removed: p })
											: g.push({ count: 1, added: l, removed: p })
									},
									extractCommon: function (g, l, p, f) {
										for (
											var y = l.length, x = p.length, _ = g.newPos, w = _ - f, C = 0;
											_ + 1 < y && w + 1 < x && this.equals(l[_ + 1], p[w + 1]);

										)
											_++, w++, C++
										return C && g.components.push({ count: C }), (g.newPos = _), w
									},
									equals: function (g, l) {
										return this.options.comparator
											? this.options.comparator(g, l)
											: g === l || (this.options.ignoreCase && g.toLowerCase() === l.toLowerCase())
									},
									removeEmpty: function (g) {
										for (var l = [], p = 0; p < g.length; p++) g[p] && l.push(g[p])
										return l
									},
									castInput: function (g) {
										return g
									},
									tokenize: function (g) {
										return g.split('')
									},
									join: function (g) {
										return g.join('')
									}
								}
								function c(g, l, p, f, y) {
									for (var x = 0, _ = l.length, w = 0, C = 0; x < _; x++) {
										var v = l[x]
										if (v.removed) {
											if (
												((v.value = g.join(f.slice(C, C + v.count))),
												(C += v.count),
												x && l[x - 1].added)
											) {
												var b = l[x - 1]
												;(l[x - 1] = l[x]), (l[x] = b)
											}
										} else {
											if (!v.added && y) {
												var k = p.slice(w, w + v.count)
												;(k = k.map(function (G, O) {
													var U = f[C + O]
													return U.length > G.length ? U : G
												})),
													(v.value = g.join(k))
											} else v.value = g.join(p.slice(w, w + v.count))
											;(w += v.count), v.added || (C += v.count)
										}
									}
									var q = l[_ - 1]
									return (
										_ > 1 &&
											typeof q.value == 'string' &&
											(q.added || q.removed) &&
											g.equals('', q.value) &&
											((l[_ - 2].value += q.value), l.pop()),
										l
									)
								}
								function D(g) {
									return { newPos: g.newPos, components: g.components.slice(0) }
								}
							}
						}),
						yo = le({
							'node_modules/diff/lib/diff/array.js'(d) {
								'use strict'
								ge(),
									Object.defineProperty(d, '__esModule', { value: !0 }),
									(d.diffArrays = g),
									(d.arrayDiff = void 0)
								var E = c(Ps())
								function c(l) {
									return l && l.__esModule ? l : { default: l }
								}
								var D = new E.default()
								;(d.arrayDiff = D),
									(D.tokenize = function (l) {
										return l.slice()
									}),
									(D.join = D.removeEmpty =
										function (l) {
											return l
										})
								function g(l, p, f) {
									return D.diff(l, p, f)
								}
							}
						}),
						Fi = le({
							'src/document/doc-builders.js'(d, E) {
								'use strict'
								ge()
								function c(R) {
									return { type: 'concat', parts: R }
								}
								function D(R) {
									return { type: 'indent', contents: R }
								}
								function g(R, m) {
									return { type: 'align', contents: m, n: R }
								}
								function l(R) {
									let m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
									return {
										type: 'group',
										id: m.id,
										contents: R,
										break: !!m.shouldBreak,
										expandedStates: m.expandedStates
									}
								}
								function p(R) {
									return g(Number.NEGATIVE_INFINITY, R)
								}
								function f(R) {
									return g({ type: 'root' }, R)
								}
								function y(R) {
									return g(-1, R)
								}
								function x(R, m) {
									return l(R[0], Object.assign(Object.assign({}, m), {}, { expandedStates: R }))
								}
								function _(R) {
									return { type: 'fill', parts: R }
								}
								function w(R, m) {
									let S = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
									return { type: 'if-break', breakContents: R, flatContents: m, groupId: S.groupId }
								}
								function C(R, m) {
									return {
										type: 'indent-if-break',
										contents: R,
										groupId: m.groupId,
										negate: m.negate
									}
								}
								function v(R) {
									return { type: 'line-suffix', contents: R }
								}
								var b = { type: 'line-suffix-boundary' },
									k = { type: 'break-parent' },
									q = { type: 'trim' },
									G = { type: 'line', hard: !0 },
									O = { type: 'line', hard: !0, literal: !0 },
									U = { type: 'line' },
									j = { type: 'line', soft: !0 },
									H = c([G, k]),
									W = c([O, k]),
									re = { type: 'cursor', placeholder: Symbol('cursor') }
								function A(R, m) {
									let S = []
									for (let L = 0; L < m.length; L++) L !== 0 && S.push(R), S.push(m[L])
									return c(S)
								}
								function $(R, m, S) {
									let L = R
									if (m > 0) {
										for (let P = 0; P < Math.floor(m / S); ++P) L = D(L)
										;(L = g(m % S, L)), (L = g(Number.NEGATIVE_INFINITY, L))
									}
									return L
								}
								function T(R, m) {
									return { type: 'label', label: R, contents: m }
								}
								E.exports = {
									concat: c,
									join: A,
									line: U,
									softline: j,
									hardline: H,
									literalline: W,
									group: l,
									conditionalGroup: x,
									fill: _,
									lineSuffix: v,
									lineSuffixBoundary: b,
									cursor: re,
									breakParent: k,
									ifBreak: w,
									trim: q,
									indent: D,
									indentIfBreak: C,
									align: g,
									addAlignmentToDoc: $,
									markAsRoot: f,
									dedentToRoot: p,
									dedent: y,
									hardlineWithoutBreakParent: G,
									literallineWithoutBreakParent: O,
									label: T
								}
							}
						}),
						Ds = le({
							'src/common/end-of-line.js'(d, E) {
								'use strict'
								ge()
								function c(p) {
									let f = p.indexOf('\r')
									return f >= 0
										? p.charAt(f + 1) ===
										  `
`
											? 'crlf'
											: 'cr'
										: 'lf'
								}
								function D(p) {
									switch (p) {
										case 'cr':
											return '\r'
										case 'crlf':
											return `\r
`
										default:
											return `
`
									}
								}
								function g(p, f) {
									let y
									switch (f) {
										case `
`:
											y = /\n/g
											break
										case '\r':
											y = /\r/g
											break
										case `\r
`:
											y = /\r\n/g
											break
										default:
											throw new Error(`Unexpected "eol" ${JSON.stringify(f)}.`)
									}
									let x = p.match(y)
									return x ? x.length : 0
								}
								function l(p) {
									return p.replace(
										/\r\n?/g,
										`
`
									)
								}
								E.exports = {
									guessEndOfLine: c,
									convertEndOfLineToChars: D,
									countEndOfLineChars: g,
									normalizeEndOfLine: l
								}
							}
						}),
						Ur = le({
							'src/utils/get-last.js'(d, E) {
								'use strict'
								ge()
								var c = (D) => D[D.length - 1]
								E.exports = c
							}
						})
					function Bu() {
						let { onlyFirst: d = !1 } =
								arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
							E = [
								'[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
								'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
							].join('|')
						return new RegExp(E, d ? void 0 : 'g')
					}
					var ki = Kt({
						'node_modules/strip-ansi/node_modules/ansi-regex/index.js'() {
							ge()
						}
					})
					function Pu(d) {
						if (typeof d != 'string')
							throw new TypeError(`Expected a \`string\`, got \`${typeof d}\``)
						return d.replace(Bu(), '')
					}
					var Mu = Kt({
						'node_modules/strip-ansi/index.js'() {
							ge(), ki()
						}
					})
					function ju(d) {
						return Number.isInteger(d)
							? d >= 4352 &&
									(d <= 4447 ||
										d === 9001 ||
										d === 9002 ||
										(11904 <= d && d <= 12871 && d !== 12351) ||
										(12880 <= d && d <= 19903) ||
										(19968 <= d && d <= 42182) ||
										(43360 <= d && d <= 43388) ||
										(44032 <= d && d <= 55203) ||
										(63744 <= d && d <= 64255) ||
										(65040 <= d && d <= 65049) ||
										(65072 <= d && d <= 65131) ||
										(65281 <= d && d <= 65376) ||
										(65504 <= d && d <= 65510) ||
										(110592 <= d && d <= 110593) ||
										(127488 <= d && d <= 127569) ||
										(131072 <= d && d <= 262141))
							: !1
					}
					var $u = Kt({
							'node_modules/is-fullwidth-code-point/index.js'() {
								ge()
							}
						}),
						si = le({
							'node_modules/emoji-regex/index.js'(d, E) {
								'use strict'
								ge(),
									(E.exports = function () {
										return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g
									})
							}
						}),
						t1 = {}
					fn(t1, { default: () => rD })
					function rD(d) {
						if (typeof d != 'string' || d.length === 0 || ((d = Pu(d)), d.length === 0)) return 0
						d = d.replace((0, n1.default)(), '  ')
						let E = 0
						for (let c = 0; c < d.length; c++) {
							let D = d.codePointAt(c)
							D <= 31 ||
								(D >= 127 && D <= 159) ||
								(D >= 768 && D <= 879) ||
								(D > 65535 && c++, (E += ju(D) ? 2 : 1))
						}
						return E
					}
					var n1,
						iD = Kt({
							'node_modules/string-width/index.js'() {
								ge(), Mu(), $u(), (n1 = Vn(si()))
							}
						}),
						r1 = le({
							'src/utils/get-string-width.js'(d, E) {
								'use strict'
								ge()
								var c = (iD(), Mn(t1)).default,
									D = /[^\x20-\x7F]/
								function g(l) {
									return l ? (D.test(l) ? c(l) : l.length) : 0
								}
								E.exports = g
							}
						}),
						_a = le({
							'src/document/doc-utils.js'(d, E) {
								'use strict'
								ge()
								var c = Ur(),
									{ literalline: D, join: g } = Fi(),
									l = (m) => Array.isArray(m) || (m && m.type === 'concat'),
									p = (m) => {
										if (Array.isArray(m)) return m
										if (m.type !== 'concat' && m.type !== 'fill')
											throw new Error('Expect doc type to be `concat` or `fill`.')
										return m.parts
									},
									f = {}
								function y(m, S, L, P) {
									let M = [m]
									for (; M.length > 0; ) {
										let V = M.pop()
										if (V === f) {
											L(M.pop())
											continue
										}
										if ((L && M.push(V, f), !S || S(V) !== !1))
											if (l(V) || V.type === 'fill') {
												let J = p(V)
												for (let Z = J.length, ne = Z - 1; ne >= 0; --ne) M.push(J[ne])
											} else if (V.type === 'if-break')
												V.flatContents && M.push(V.flatContents),
													V.breakContents && M.push(V.breakContents)
											else if (V.type === 'group' && V.expandedStates)
												if (P)
													for (let J = V.expandedStates.length, Z = J - 1; Z >= 0; --Z)
														M.push(V.expandedStates[Z])
												else M.push(V.contents)
											else V.contents && M.push(V.contents)
									}
								}
								function x(m, S) {
									let L = new Map()
									return P(m)
									function P(V) {
										if (L.has(V)) return L.get(V)
										let J = M(V)
										return L.set(V, J), J
									}
									function M(V) {
										if (Array.isArray(V)) return S(V.map(P))
										if (V.type === 'concat' || V.type === 'fill') {
											let J = V.parts.map(P)
											return S(Object.assign(Object.assign({}, V), {}, { parts: J }))
										}
										if (V.type === 'if-break') {
											let J = V.breakContents && P(V.breakContents),
												Z = V.flatContents && P(V.flatContents)
											return S(
												Object.assign(
													Object.assign({}, V),
													{},
													{ breakContents: J, flatContents: Z }
												)
											)
										}
										if (V.type === 'group' && V.expandedStates) {
											let J = V.expandedStates.map(P),
												Z = J[0]
											return S(
												Object.assign(Object.assign({}, V), {}, { contents: Z, expandedStates: J })
											)
										}
										if (V.contents) {
											let J = P(V.contents)
											return S(Object.assign(Object.assign({}, V), {}, { contents: J }))
										}
										return S(V)
									}
								}
								function _(m, S, L) {
									let P = L,
										M = !1
									function V(J) {
										let Z = S(J)
										if ((Z !== void 0 && ((M = !0), (P = Z)), M)) return !1
									}
									return y(m, V), P
								}
								function w(m) {
									if (
										(m.type === 'group' && m.break) ||
										(m.type === 'line' && m.hard) ||
										m.type === 'break-parent'
									)
										return !0
								}
								function C(m) {
									return _(m, w, !1)
								}
								function v(m) {
									if (m.length > 0) {
										let S = c(m)
										!S.expandedStates && !S.break && (S.break = 'propagated')
									}
									return null
								}
								function b(m) {
									let S = new Set(),
										L = []
									function P(V) {
										if ((V.type === 'break-parent' && v(L), V.type === 'group')) {
											if ((L.push(V), S.has(V))) return !1
											S.add(V)
										}
									}
									function M(V) {
										V.type === 'group' && L.pop().break && v(L)
									}
									y(m, P, M, !0)
								}
								function k(m) {
									return m.type === 'line' && !m.hard
										? m.soft
											? ''
											: ' '
										: m.type === 'if-break'
										? m.flatContents || ''
										: m
								}
								function q(m) {
									return x(m, k)
								}
								var G = (m, S) => m && m.type === 'line' && m.hard && S && S.type === 'break-parent'
								function O(m) {
									if (!m) return m
									if (l(m) || m.type === 'fill') {
										let S = p(m)
										for (; S.length > 1 && G(...S.slice(-2)); ) S.length -= 2
										if (S.length > 0) {
											let L = O(c(S))
											S[S.length - 1] = L
										}
										return Array.isArray(m)
											? S
											: Object.assign(Object.assign({}, m), {}, { parts: S })
									}
									switch (m.type) {
										case 'align':
										case 'indent':
										case 'indent-if-break':
										case 'group':
										case 'line-suffix':
										case 'label': {
											let S = O(m.contents)
											return Object.assign(Object.assign({}, m), {}, { contents: S })
										}
										case 'if-break': {
											let S = O(m.breakContents),
												L = O(m.flatContents)
											return Object.assign(
												Object.assign({}, m),
												{},
												{ breakContents: S, flatContents: L }
											)
										}
									}
									return m
								}
								function U(m) {
									return O(H(m))
								}
								function j(m) {
									switch (m.type) {
										case 'fill':
											if (m.parts.every((L) => L === '')) return ''
											break
										case 'group':
											if (!m.contents && !m.id && !m.break && !m.expandedStates) return ''
											if (
												m.contents.type === 'group' &&
												m.contents.id === m.id &&
												m.contents.break === m.break &&
												m.contents.expandedStates === m.expandedStates
											)
												return m.contents
											break
										case 'align':
										case 'indent':
										case 'indent-if-break':
										case 'line-suffix':
											if (!m.contents) return ''
											break
										case 'if-break':
											if (!m.flatContents && !m.breakContents) return ''
											break
									}
									if (!l(m)) return m
									let S = []
									for (let L of p(m)) {
										if (!L) continue
										let [P, ...M] = l(L) ? p(L) : [L]
										typeof P == 'string' && typeof c(S) == 'string'
											? (S[S.length - 1] += P)
											: S.push(P),
											S.push(...M)
									}
									return S.length === 0
										? ''
										: S.length === 1
										? S[0]
										: Array.isArray(m)
										? S
										: Object.assign(Object.assign({}, m), {}, { parts: S })
								}
								function H(m) {
									return x(m, (S) => j(S))
								}
								function W(m) {
									let S = [],
										L = m.filter(Boolean)
									for (; L.length > 0; ) {
										let P = L.shift()
										if (P) {
											if (l(P)) {
												L.unshift(...p(P))
												continue
											}
											if (S.length > 0 && typeof c(S) == 'string' && typeof P == 'string') {
												S[S.length - 1] += P
												continue
											}
											S.push(P)
										}
									}
									return S
								}
								function re(m) {
									return x(m, (S) =>
										Array.isArray(S)
											? W(S)
											: S.parts
											? Object.assign(Object.assign({}, S), {}, { parts: W(S.parts) })
											: S
									)
								}
								function A(m) {
									return x(m, (S) =>
										typeof S == 'string' &&
										S.includes(`
`)
											? $(S)
											: S
									)
								}
								function $(m) {
									let S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : D
									return g(
										S,
										m.split(`
`)
									).parts
								}
								function T(m) {
									if (m.type === 'line') return !0
								}
								function R(m) {
									return _(m, T, !1)
								}
								E.exports = {
									isConcat: l,
									getDocParts: p,
									willBreak: C,
									traverseDoc: y,
									findInDoc: _,
									mapDoc: x,
									propagateBreaks: b,
									removeLines: q,
									stripTrailingHardline: U,
									normalizeParts: W,
									normalizeDoc: re,
									cleanDoc: H,
									replaceTextEndOfLine: $,
									replaceEndOfLine: A,
									canBreak: R
								}
							}
						}),
						sD = le({
							'src/document/doc-printer.js'(d, E) {
								'use strict'
								ge()
								var { convertEndOfLineToChars: c } = Ds(),
									D = Ur(),
									g = r1(),
									{ fill: l, cursor: p, indent: f } = Fi(),
									{ isConcat: y, getDocParts: x } = _a(),
									_,
									w = 1,
									C = 2
								function v() {
									return { value: '', length: 0, queue: [] }
								}
								function b(j, H) {
									return q(j, { type: 'indent' }, H)
								}
								function k(j, H, W) {
									return H === Number.NEGATIVE_INFINITY
										? j.root || v()
										: H < 0
										? q(j, { type: 'dedent' }, W)
										: H
										? H.type === 'root'
											? Object.assign(Object.assign({}, j), {}, { root: j })
											: q(
													j,
													{ type: typeof H == 'string' ? 'stringAlign' : 'numberAlign', n: H },
													W
											  )
										: j
								}
								function q(j, H, W) {
									let re = H.type === 'dedent' ? j.queue.slice(0, -1) : [...j.queue, H],
										A = '',
										$ = 0,
										T = 0,
										R = 0
									for (let J of re)
										switch (J.type) {
											case 'indent':
												L(), W.useTabs ? m(1) : S(W.tabWidth)
												break
											case 'stringAlign':
												L(), (A += J.n), ($ += J.n.length)
												break
											case 'numberAlign':
												;(T += 1), (R += J.n)
												break
											default:
												throw new Error(`Unexpected type '${J.type}'`)
										}
									return (
										M(), Object.assign(Object.assign({}, j), {}, { value: A, length: $, queue: re })
									)
									function m(J) {
										;(A += '	'.repeat(J)), ($ += W.tabWidth * J)
									}
									function S(J) {
										;(A += ' '.repeat(J)), ($ += J)
									}
									function L() {
										W.useTabs ? P() : M()
									}
									function P() {
										T > 0 && m(T), V()
									}
									function M() {
										R > 0 && S(R), V()
									}
									function V() {
										;(T = 0), (R = 0)
									}
								}
								function G(j) {
									if (j.length === 0) return 0
									let H = 0
									for (; j.length > 0 && typeof D(j) == 'string' && /^[\t ]*$/.test(D(j)); )
										H += j.pop().length
									if (j.length > 0 && typeof D(j) == 'string') {
										let W = D(j).replace(/[\t ]*$/, '')
										;(H += D(j).length - W.length), (j[j.length - 1] = W)
									}
									return H
								}
								function O(j, H, W, re, A) {
									let $ = H.length,
										T = [j],
										R = []
									for (; W >= 0; ) {
										if (T.length === 0) {
											if ($ === 0) return !0
											T.push(H[--$])
											continue
										}
										let { mode: m, doc: S } = T.pop()
										if (typeof S == 'string') R.push(S), (W -= g(S))
										else if (y(S) || S.type === 'fill') {
											let L = x(S)
											for (let P = L.length - 1; P >= 0; P--) T.push({ mode: m, doc: L[P] })
										} else
											switch (S.type) {
												case 'indent':
												case 'align':
												case 'indent-if-break':
												case 'label':
													T.push({ mode: m, doc: S.contents })
													break
												case 'trim':
													W += G(R)
													break
												case 'group': {
													if (A && S.break) return !1
													let L = S.break ? w : m,
														P = S.expandedStates && L === w ? D(S.expandedStates) : S.contents
													T.push({ mode: L, doc: P })
													break
												}
												case 'if-break': {
													let L =
														(S.groupId ? _[S.groupId] || C : m) === w
															? S.breakContents
															: S.flatContents
													L && T.push({ mode: m, doc: L })
													break
												}
												case 'line':
													if (m === w || S.hard) return !0
													S.soft || (R.push(' '), W--)
													break
												case 'line-suffix':
													re = !0
													break
												case 'line-suffix-boundary':
													if (re) return !1
													break
											}
									}
									return !1
								}
								function U(j, H) {
									_ = {}
									let W = H.printWidth,
										re = c(H.endOfLine),
										A = 0,
										$ = [{ ind: v(), mode: w, doc: j }],
										T = [],
										R = !1,
										m = []
									for (; $.length > 0; ) {
										let { ind: L, mode: P, doc: M } = $.pop()
										if (typeof M == 'string') {
											let V =
												re !==
												`
`
													? M.replace(/\n/g, re)
													: M
											T.push(V), (A += g(V))
										} else if (y(M)) {
											let V = x(M)
											for (let J = V.length - 1; J >= 0; J--) $.push({ ind: L, mode: P, doc: V[J] })
										} else
											switch (M.type) {
												case 'cursor':
													T.push(p.placeholder)
													break
												case 'indent':
													$.push({ ind: b(L, H), mode: P, doc: M.contents })
													break
												case 'align':
													$.push({ ind: k(L, M.n, H), mode: P, doc: M.contents })
													break
												case 'trim':
													A -= G(T)
													break
												case 'group':
													switch (P) {
														case C:
															if (!R) {
																$.push({ ind: L, mode: M.break ? w : C, doc: M.contents })
																break
															}
														case w: {
															R = !1
															let V = { ind: L, mode: C, doc: M.contents },
																J = W - A,
																Z = m.length > 0
															if (!M.break && O(V, $, J, Z)) $.push(V)
															else if (M.expandedStates) {
																let ne = D(M.expandedStates)
																if (M.break) {
																	$.push({ ind: L, mode: w, doc: ne })
																	break
																} else
																	for (let ee = 1; ee < M.expandedStates.length + 1; ee++)
																		if (ee >= M.expandedStates.length) {
																			$.push({ ind: L, mode: w, doc: ne })
																			break
																		} else {
																			let ce = M.expandedStates[ee],
																				z = { ind: L, mode: C, doc: ce }
																			if (O(z, $, J, Z)) {
																				$.push(z)
																				break
																			}
																		}
															} else $.push({ ind: L, mode: w, doc: M.contents })
															break
														}
													}
													M.id && (_[M.id] = D($).mode)
													break
												case 'fill': {
													let V = W - A,
														{ parts: J } = M
													if (J.length === 0) break
													let [Z, ne] = J,
														ee = { ind: L, mode: C, doc: Z },
														ce = { ind: L, mode: w, doc: Z },
														z = O(ee, [], V, m.length > 0, !0)
													if (J.length === 1) {
														z ? $.push(ee) : $.push(ce)
														break
													}
													let ye = { ind: L, mode: C, doc: ne },
														te = { ind: L, mode: w, doc: ne }
													if (J.length === 2) {
														z ? $.push(ye, ee) : $.push(te, ce)
														break
													}
													J.splice(0, 2)
													let X = { ind: L, mode: P, doc: l(J) },
														De = J[0]
													O({ ind: L, mode: C, doc: [Z, ne, De] }, [], V, m.length > 0, !0)
														? $.push(X, ye, ee)
														: z
														? $.push(X, te, ee)
														: $.push(X, te, ce)
													break
												}
												case 'if-break':
												case 'indent-if-break': {
													let V = M.groupId ? _[M.groupId] : P
													if (V === w) {
														let J =
															M.type === 'if-break'
																? M.breakContents
																: M.negate
																? M.contents
																: f(M.contents)
														J && $.push({ ind: L, mode: P, doc: J })
													}
													if (V === C) {
														let J =
															M.type === 'if-break'
																? M.flatContents
																: M.negate
																? f(M.contents)
																: M.contents
														J && $.push({ ind: L, mode: P, doc: J })
													}
													break
												}
												case 'line-suffix':
													m.push({ ind: L, mode: P, doc: M.contents })
													break
												case 'line-suffix-boundary':
													m.length > 0 &&
														$.push({ ind: L, mode: P, doc: { type: 'line', hard: !0 } })
													break
												case 'line':
													switch (P) {
														case C:
															if (M.hard) R = !0
															else {
																M.soft || (T.push(' '), (A += 1))
																break
															}
														case w:
															if (m.length > 0) {
																$.push({ ind: L, mode: P, doc: M }, ...m.reverse()), (m.length = 0)
																break
															}
															M.literal
																? L.root
																	? (T.push(re, L.root.value), (A = L.root.length))
																	: (T.push(re), (A = 0))
																: ((A -= G(T)), T.push(re + L.value), (A = L.length))
															break
													}
													break
												case 'label':
													$.push({ ind: L, mode: P, doc: M.contents })
													break
												default:
											}
										$.length === 0 && m.length > 0 && ($.push(...m.reverse()), (m.length = 0))
									}
									let S = T.indexOf(p.placeholder)
									if (S !== -1) {
										let L = T.indexOf(p.placeholder, S + 1),
											P = T.slice(0, S).join(''),
											M = T.slice(S + 1, L).join(''),
											V = T.slice(L + 1).join('')
										return { formatted: P + M + V, cursorNodeStart: P.length, cursorNodeText: M }
									}
									return { formatted: T.join('') }
								}
								E.exports = { printDocToString: U }
							}
						}),
						oD = le({
							'src/document/doc-debug.js'(d, E) {
								'use strict'
								ge()
								var { isConcat: c, getDocParts: D } = _a()
								function g(p) {
									if (!p) return ''
									if (c(p)) {
										let f = []
										for (let y of D(p))
											if (c(y)) f.push(...g(y).parts)
											else {
												let x = g(y)
												x !== '' && f.push(x)
											}
										return { type: 'concat', parts: f }
									}
									return p.type === 'if-break'
										? Object.assign(
												Object.assign({}, p),
												{},
												{ breakContents: g(p.breakContents), flatContents: g(p.flatContents) }
										  )
										: p.type === 'group'
										? Object.assign(
												Object.assign({}, p),
												{},
												{
													contents: g(p.contents),
													expandedStates: p.expandedStates && p.expandedStates.map(g)
												}
										  )
										: p.type === 'fill'
										? { type: 'fill', parts: p.parts.map(g) }
										: p.contents
										? Object.assign(Object.assign({}, p), {}, { contents: g(p.contents) })
										: p
								}
								function l(p) {
									let f = Object.create(null),
										y = new Set()
									return x(g(p))
									function x(w, C, v) {
										if (typeof w == 'string') return JSON.stringify(w)
										if (c(w)) {
											let b = D(w).map(x).filter(Boolean)
											return b.length === 1 ? b[0] : `[${b.join(', ')}]`
										}
										if (w.type === 'line') {
											let b = Array.isArray(v) && v[C + 1] && v[C + 1].type === 'break-parent'
											return w.literal
												? b
													? 'literalline'
													: 'literallineWithoutBreakParent'
												: w.hard
												? b
													? 'hardline'
													: 'hardlineWithoutBreakParent'
												: w.soft
												? 'softline'
												: 'line'
										}
										if (w.type === 'break-parent')
											return Array.isArray(v) &&
												v[C - 1] &&
												v[C - 1].type === 'line' &&
												v[C - 1].hard
												? void 0
												: 'breakParent'
										if (w.type === 'trim') return 'trim'
										if (w.type === 'indent') return 'indent(' + x(w.contents) + ')'
										if (w.type === 'align')
											return w.n === Number.NEGATIVE_INFINITY
												? 'dedentToRoot(' + x(w.contents) + ')'
												: w.n < 0
												? 'dedent(' + x(w.contents) + ')'
												: w.n.type === 'root'
												? 'markAsRoot(' + x(w.contents) + ')'
												: 'align(' + JSON.stringify(w.n) + ', ' + x(w.contents) + ')'
										if (w.type === 'if-break')
											return (
												'ifBreak(' +
												x(w.breakContents) +
												(w.flatContents ? ', ' + x(w.flatContents) : '') +
												(w.groupId
													? (w.flatContents ? '' : ', ""') + `, { groupId: ${_(w.groupId)} }`
													: '') +
												')'
											)
										if (w.type === 'indent-if-break') {
											let b = []
											w.negate && b.push('negate: true'),
												w.groupId && b.push(`groupId: ${_(w.groupId)}`)
											let k = b.length > 0 ? `, { ${b.join(', ')} }` : ''
											return `indentIfBreak(${x(w.contents)}${k})`
										}
										if (w.type === 'group') {
											let b = []
											w.break && w.break !== 'propagated' && b.push('shouldBreak: true'),
												w.id && b.push(`id: ${_(w.id)}`)
											let k = b.length > 0 ? `, { ${b.join(', ')} }` : ''
											return w.expandedStates
												? `conditionalGroup([${w.expandedStates.map((q) => x(q)).join(',')}]${k})`
												: `group(${x(w.contents)}${k})`
										}
										if (w.type === 'fill') return `fill([${w.parts.map((b) => x(b)).join(', ')}])`
										if (w.type === 'line-suffix') return 'lineSuffix(' + x(w.contents) + ')'
										if (w.type === 'line-suffix-boundary') return 'lineSuffixBoundary'
										if (w.type === 'label')
											return `label(${JSON.stringify(w.label)}, ${x(w.contents)})`
										throw new Error('Unknown doc type ' + w.type)
									}
									function _(w) {
										if (typeof w != 'symbol') return JSON.stringify(String(w))
										if (w in f) return f[w]
										let C = String(w).slice(7, -1) || 'symbol'
										for (let v = 0; ; v++) {
											let b = C + (v > 0 ? ` #${v}` : '')
											if (!y.has(b)) return y.add(b), (f[w] = `Symbol.for(${JSON.stringify(b)})`)
										}
									}
								}
								E.exports = { printDocToDebug: l }
							}
						}),
						dn = le({
							'src/document/index.js'(d, E) {
								'use strict'
								ge(), (E.exports = { builders: Fi(), printer: sD(), utils: _a(), debug: oD() })
							}
						}),
						i1 = {}
					fn(i1, { default: () => aD })
					function aD(d) {
						if (typeof d != 'string') throw new TypeError('Expected a string')
						return d.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d')
					}
					var uD = Kt({
							'node_modules/escape-string-regexp/index.js'() {
								ge()
							}
						}),
						s1 = le({
							'node_modules/semver/internal/debug.js'(d, E) {
								ge()
								var c =
									typeof mr == 'object' &&
									mr.env &&
									mr.env.NODE_DEBUG &&
									/\bsemver\b/i.test(mr.env.NODE_DEBUG)
										? function () {
												for (var D = arguments.length, g = new Array(D), l = 0; l < D; l++)
													g[l] = arguments[l]
												return console.error('SEMVER', ...g)
										  }
										: () => {}
								E.exports = c
							}
						}),
						o1 = le({
							'node_modules/semver/internal/constants.js'(d, E) {
								ge()
								var c = '2.0.0',
									D = 256,
									g = Number.MAX_SAFE_INTEGER || 9007199254740991,
									l = 16
								E.exports = {
									SEMVER_SPEC_VERSION: c,
									MAX_LENGTH: D,
									MAX_SAFE_INTEGER: g,
									MAX_SAFE_COMPONENT_LENGTH: l
								}
							}
						}),
						lD = le({
							'node_modules/semver/internal/re.js'(d, E) {
								ge()
								var { MAX_SAFE_COMPONENT_LENGTH: c } = o1(),
									D = s1()
								d = E.exports = {}
								var g = (d.re = []),
									l = (d.src = []),
									p = (d.t = {}),
									f = 0,
									y = (x, _, w) => {
										let C = f++
										D(x, C, _), (p[x] = C), (l[C] = _), (g[C] = new RegExp(_, w ? 'g' : void 0))
									}
								y('NUMERICIDENTIFIER', '0|[1-9]\\d*'),
									y('NUMERICIDENTIFIERLOOSE', '[0-9]+'),
									y('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*'),
									y(
										'MAINVERSION',
										`(${l[p.NUMERICIDENTIFIER]})\\.(${l[p.NUMERICIDENTIFIER]})\\.(${
											l[p.NUMERICIDENTIFIER]
										})`
									),
									y(
										'MAINVERSIONLOOSE',
										`(${l[p.NUMERICIDENTIFIERLOOSE]})\\.(${l[p.NUMERICIDENTIFIERLOOSE]})\\.(${
											l[p.NUMERICIDENTIFIERLOOSE]
										})`
									),
									y(
										'PRERELEASEIDENTIFIER',
										`(?:${l[p.NUMERICIDENTIFIER]}|${l[p.NONNUMERICIDENTIFIER]})`
									),
									y(
										'PRERELEASEIDENTIFIERLOOSE',
										`(?:${l[p.NUMERICIDENTIFIERLOOSE]}|${l[p.NONNUMERICIDENTIFIER]})`
									),
									y(
										'PRERELEASE',
										`(?:-(${l[p.PRERELEASEIDENTIFIER]}(?:\\.${l[p.PRERELEASEIDENTIFIER]})*))`
									),
									y(
										'PRERELEASELOOSE',
										`(?:-?(${l[p.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${
											l[p.PRERELEASEIDENTIFIERLOOSE]
										})*))`
									),
									y('BUILDIDENTIFIER', '[0-9A-Za-z-]+'),
									y('BUILD', `(?:\\+(${l[p.BUILDIDENTIFIER]}(?:\\.${l[p.BUILDIDENTIFIER]})*))`),
									y('FULLPLAIN', `v?${l[p.MAINVERSION]}${l[p.PRERELEASE]}?${l[p.BUILD]}?`),
									y('FULL', `^${l[p.FULLPLAIN]}$`),
									y(
										'LOOSEPLAIN',
										`[v=\\s]*${l[p.MAINVERSIONLOOSE]}${l[p.PRERELEASELOOSE]}?${l[p.BUILD]}?`
									),
									y('LOOSE', `^${l[p.LOOSEPLAIN]}$`),
									y('GTLT', '((?:<|>)?=?)'),
									y('XRANGEIDENTIFIERLOOSE', `${l[p.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`),
									y('XRANGEIDENTIFIER', `${l[p.NUMERICIDENTIFIER]}|x|X|\\*`),
									y(
										'XRANGEPLAIN',
										`[v=\\s]*(${l[p.XRANGEIDENTIFIER]})(?:\\.(${l[p.XRANGEIDENTIFIER]})(?:\\.(${
											l[p.XRANGEIDENTIFIER]
										})(?:${l[p.PRERELEASE]})?${l[p.BUILD]}?)?)?`
									),
									y(
										'XRANGEPLAINLOOSE',
										`[v=\\s]*(${l[p.XRANGEIDENTIFIERLOOSE]})(?:\\.(${
											l[p.XRANGEIDENTIFIERLOOSE]
										})(?:\\.(${l[p.XRANGEIDENTIFIERLOOSE]})(?:${l[p.PRERELEASELOOSE]})?${
											l[p.BUILD]
										}?)?)?`
									),
									y('XRANGE', `^${l[p.GTLT]}\\s*${l[p.XRANGEPLAIN]}$`),
									y('XRANGELOOSE', `^${l[p.GTLT]}\\s*${l[p.XRANGEPLAINLOOSE]}$`),
									y(
										'COERCE',
										`(^|[^\\d])(\\d{1,${c}})(?:\\.(\\d{1,${c}}))?(?:\\.(\\d{1,${c}}))?(?:$|[^\\d])`
									),
									y('COERCERTL', l[p.COERCE], !0),
									y('LONETILDE', '(?:~>?)'),
									y('TILDETRIM', `(\\s*)${l[p.LONETILDE]}\\s+`, !0),
									(d.tildeTrimReplace = '$1~'),
									y('TILDE', `^${l[p.LONETILDE]}${l[p.XRANGEPLAIN]}$`),
									y('TILDELOOSE', `^${l[p.LONETILDE]}${l[p.XRANGEPLAINLOOSE]}$`),
									y('LONECARET', '(?:\\^)'),
									y('CARETTRIM', `(\\s*)${l[p.LONECARET]}\\s+`, !0),
									(d.caretTrimReplace = '$1^'),
									y('CARET', `^${l[p.LONECARET]}${l[p.XRANGEPLAIN]}$`),
									y('CARETLOOSE', `^${l[p.LONECARET]}${l[p.XRANGEPLAINLOOSE]}$`),
									y('COMPARATORLOOSE', `^${l[p.GTLT]}\\s*(${l[p.LOOSEPLAIN]})$|^$`),
									y('COMPARATOR', `^${l[p.GTLT]}\\s*(${l[p.FULLPLAIN]})$|^$`),
									y(
										'COMPARATORTRIM',
										`(\\s*)${l[p.GTLT]}\\s*(${l[p.LOOSEPLAIN]}|${l[p.XRANGEPLAIN]})`,
										!0
									),
									(d.comparatorTrimReplace = '$1$2$3'),
									y('HYPHENRANGE', `^\\s*(${l[p.XRANGEPLAIN]})\\s+-\\s+(${l[p.XRANGEPLAIN]})\\s*$`),
									y(
										'HYPHENRANGELOOSE',
										`^\\s*(${l[p.XRANGEPLAINLOOSE]})\\s+-\\s+(${l[p.XRANGEPLAINLOOSE]})\\s*$`
									),
									y('STAR', '(<|>)?=?\\s*\\*'),
									y('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$'),
									y('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$')
							}
						}),
						cD = le({
							'node_modules/semver/internal/parse-options.js'(d, E) {
								ge()
								var c = ['includePrerelease', 'loose', 'rtl'],
									D = (g) =>
										g
											? typeof g != 'object'
												? { loose: !0 }
												: c.filter((l) => g[l]).reduce((l, p) => ((l[p] = !0), l), {})
											: {}
								E.exports = D
							}
						}),
						pD = le({
							'node_modules/semver/internal/identifiers.js'(d, E) {
								ge()
								var c = /^[0-9]+$/,
									D = (l, p) => {
										let f = c.test(l),
											y = c.test(p)
										return (
											f && y && ((l = +l), (p = +p)),
											l === p ? 0 : f && !y ? -1 : y && !f ? 1 : l < p ? -1 : 1
										)
									},
									g = (l, p) => D(p, l)
								E.exports = { compareIdentifiers: D, rcompareIdentifiers: g }
							}
						}),
						fD = le({
							'node_modules/semver/classes/semver.js'(d, E) {
								ge()
								var c = s1(),
									{ MAX_LENGTH: D, MAX_SAFE_INTEGER: g } = o1(),
									{ re: l, t: p } = lD(),
									f = cD(),
									{ compareIdentifiers: y } = pD(),
									x = class {
										constructor(_, w) {
											if (((w = f(w)), _ instanceof x)) {
												if (_.loose === !!w.loose && _.includePrerelease === !!w.includePrerelease)
													return _
												_ = _.version
											} else if (typeof _ != 'string') throw new TypeError(`Invalid Version: ${_}`)
											if (_.length > D)
												throw new TypeError(`version is longer than ${D} characters`)
											c('SemVer', _, w),
												(this.options = w),
												(this.loose = !!w.loose),
												(this.includePrerelease = !!w.includePrerelease)
											let C = _.trim().match(w.loose ? l[p.LOOSE] : l[p.FULL])
											if (!C) throw new TypeError(`Invalid Version: ${_}`)
											if (
												((this.raw = _),
												(this.major = +C[1]),
												(this.minor = +C[2]),
												(this.patch = +C[3]),
												this.major > g || this.major < 0)
											)
												throw new TypeError('Invalid major version')
											if (this.minor > g || this.minor < 0)
												throw new TypeError('Invalid minor version')
											if (this.patch > g || this.patch < 0)
												throw new TypeError('Invalid patch version')
											C[4]
												? (this.prerelease = C[4].split('.').map((v) => {
														if (/^[0-9]+$/.test(v)) {
															let b = +v
															if (b >= 0 && b < g) return b
														}
														return v
												  }))
												: (this.prerelease = []),
												(this.build = C[5] ? C[5].split('.') : []),
												this.format()
										}
										format() {
											return (
												(this.version = `${this.major}.${this.minor}.${this.patch}`),
												this.prerelease.length && (this.version += `-${this.prerelease.join('.')}`),
												this.version
											)
										}
										toString() {
											return this.version
										}
										compare(_) {
											if ((c('SemVer.compare', this.version, this.options, _), !(_ instanceof x))) {
												if (typeof _ == 'string' && _ === this.version) return 0
												_ = new x(_, this.options)
											}
											return _.version === this.version
												? 0
												: this.compareMain(_) || this.comparePre(_)
										}
										compareMain(_) {
											return (
												_ instanceof x || (_ = new x(_, this.options)),
												y(this.major, _.major) || y(this.minor, _.minor) || y(this.patch, _.patch)
											)
										}
										comparePre(_) {
											if (
												(_ instanceof x || (_ = new x(_, this.options)),
												this.prerelease.length && !_.prerelease.length)
											)
												return -1
											if (!this.prerelease.length && _.prerelease.length) return 1
											if (!this.prerelease.length && !_.prerelease.length) return 0
											let w = 0
											do {
												let C = this.prerelease[w],
													v = _.prerelease[w]
												if ((c('prerelease compare', w, C, v), C === void 0 && v === void 0))
													return 0
												if (v === void 0) return 1
												if (C === void 0) return -1
												if (C !== v) return y(C, v)
											} while (++w)
										}
										compareBuild(_) {
											_ instanceof x || (_ = new x(_, this.options))
											let w = 0
											do {
												let C = this.build[w],
													v = _.build[w]
												if ((c('prerelease compare', w, C, v), C === void 0 && v === void 0))
													return 0
												if (v === void 0) return 1
												if (C === void 0) return -1
												if (C !== v) return y(C, v)
											} while (++w)
										}
										inc(_, w) {
											switch (_) {
												case 'premajor':
													;(this.prerelease.length = 0),
														(this.patch = 0),
														(this.minor = 0),
														this.major++,
														this.inc('pre', w)
													break
												case 'preminor':
													;(this.prerelease.length = 0),
														(this.patch = 0),
														this.minor++,
														this.inc('pre', w)
													break
												case 'prepatch':
													;(this.prerelease.length = 0), this.inc('patch', w), this.inc('pre', w)
													break
												case 'prerelease':
													this.prerelease.length === 0 && this.inc('patch', w), this.inc('pre', w)
													break
												case 'major':
													;(this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) &&
														this.major++,
														(this.minor = 0),
														(this.patch = 0),
														(this.prerelease = [])
													break
												case 'minor':
													;(this.patch !== 0 || this.prerelease.length === 0) && this.minor++,
														(this.patch = 0),
														(this.prerelease = [])
													break
												case 'patch':
													this.prerelease.length === 0 && this.patch++, (this.prerelease = [])
													break
												case 'pre':
													if (this.prerelease.length === 0) this.prerelease = [0]
													else {
														let C = this.prerelease.length
														for (; --C >= 0; )
															typeof this.prerelease[C] == 'number' &&
																(this.prerelease[C]++, (C = -2))
														C === -1 && this.prerelease.push(0)
													}
													w &&
														(y(this.prerelease[0], w) === 0
															? isNaN(this.prerelease[1]) && (this.prerelease = [w, 0])
															: (this.prerelease = [w, 0]))
													break
												default:
													throw new Error(`invalid increment argument: ${_}`)
											}
											return this.format(), (this.raw = this.version), this
										}
									}
								E.exports = x
							}
						}),
						tp = le({
							'node_modules/semver/functions/compare.js'(d, E) {
								ge()
								var c = fD(),
									D = (g, l, p) => new c(g, p).compare(new c(l, p))
								E.exports = D
							}
						}),
						dD = le({
							'node_modules/semver/functions/lt.js'(d, E) {
								ge()
								var c = tp(),
									D = (g, l, p) => c(g, l, p) < 0
								E.exports = D
							}
						}),
						hD = le({
							'node_modules/semver/functions/gte.js'(d, E) {
								ge()
								var c = tp(),
									D = (g, l, p) => c(g, l, p) >= 0
								E.exports = D
							}
						}),
						mD = le({
							'src/utils/arrayify.js'(d, E) {
								'use strict'
								ge(),
									(E.exports = (c, D) =>
										Object.entries(c).map((g) => {
											let [l, p] = g
											return Object.assign({ [D]: l }, p)
										}))
							}
						}),
						gD = le({
							'node_modules/outdent/lib/index.js'(d, E) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 }), (d.outdent = void 0)
								function c() {
									for (var O = [], U = 0; U < arguments.length; U++) O[U] = arguments[U]
								}
								function D() {
									return typeof WeakMap < 'u' ? new WeakMap() : g()
								}
								function g() {
									return {
										add: c,
										delete: c,
										get: c,
										set: c,
										has: function (O) {
											return !1
										}
									}
								}
								var l = Object.prototype.hasOwnProperty,
									p = function (O, U) {
										return l.call(O, U)
									}
								function f(O, U) {
									for (var j in U) p(U, j) && (O[j] = U[j])
									return O
								}
								var y = /^[ \t]*(?:\r\n|\r|\n)/,
									x = /(?:\r\n|\r|\n)[ \t]*$/,
									_ = /^(?:[\r\n]|$)/,
									w = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/,
									C = /^[ \t]*[\r\n][ \t\r\n]*$/
								function v(O, U, j) {
									var H = 0,
										W = O[0].match(w)
									W && (H = W[1].length)
									var re = '(\\r\\n|\\r|\\n).{0,' + H + '}',
										A = new RegExp(re, 'g')
									U && (O = O.slice(1))
									var $ = j.newline,
										T = j.trimLeadingNewline,
										R = j.trimTrailingNewline,
										m = typeof $ == 'string',
										S = O.length,
										L = O.map(function (P, M) {
											return (
												(P = P.replace(A, '$1')),
												M === 0 && T && (P = P.replace(y, '')),
												M === S - 1 && R && (P = P.replace(x, '')),
												m &&
													(P = P.replace(/\r\n|\n|\r/g, function (V) {
														return $
													})),
												P
											)
										})
									return L
								}
								function b(O, U) {
									for (var j = '', H = 0, W = O.length; H < W; H++)
										(j += O[H]), H < W - 1 && (j += U[H])
									return j
								}
								function k(O) {
									return p(O, 'raw') && p(O, 'length')
								}
								function q(O) {
									var U = D(),
										j = D()
									function H(re) {
										for (var A = [], $ = 1; $ < arguments.length; $++) A[$ - 1] = arguments[$]
										if (k(re)) {
											var T = re,
												R = (A[0] === H || A[0] === G) && C.test(T[0]) && _.test(T[1]),
												m = R ? j : U,
												S = m.get(T)
											if ((S || ((S = v(T, R, O)), m.set(T, S)), A.length === 0)) return S[0]
											var L = b(S, R ? A.slice(1) : A)
											return L
										} else return q(f(f({}, O), re || {}))
									}
									var W = f(H, {
										string: function (re) {
											return v([re], !1, O)[0]
										}
									})
									return W
								}
								var G = q({ trimLeadingNewline: !0, trimTrailingNewline: !0 })
								if (((d.outdent = G), (d.default = G), typeof E < 'u'))
									try {
										;(E.exports = G),
											Object.defineProperty(G, '__esModule', { value: !0 }),
											(G.default = G),
											(G.outdent = G)
									} catch {}
							}
						}),
						DD = le({
							'src/main/core-options.js'(d, E) {
								'use strict'
								ge()
								var { outdent: c } = gD(),
									D = 'Config',
									g = 'Editor',
									l = 'Format',
									p = 'Other',
									f = 'Output',
									y = 'Global',
									x = 'Special',
									_ = {
										cursorOffset: {
											since: '1.4.0',
											category: x,
											type: 'int',
											default: -1,
											range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 },
											description: c`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `,
											cliCategory: g
										},
										endOfLine: {
											since: '1.15.0',
											category: y,
											type: 'choice',
											default: [
												{ since: '1.15.0', value: 'auto' },
												{ since: '2.0.0', value: 'lf' }
											],
											description: 'Which end of line characters to apply.',
											choices: [
												{
													value: 'lf',
													description:
														'Line Feed only (\\n), common on Linux and macOS as well as inside git repos'
												},
												{
													value: 'crlf',
													description:
														'Carriage Return + Line Feed characters (\\r\\n), common on Windows'
												},
												{
													value: 'cr',
													description: 'Carriage Return character only (\\r), used very rarely'
												},
												{
													value: 'auto',
													description: c`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `
												}
											]
										},
										filepath: {
											since: '1.4.0',
											category: x,
											type: 'path',
											description:
												'Specify the input filepath. This will be used to do parser inference.',
											cliName: 'stdin-filepath',
											cliCategory: p,
											cliDescription: 'Path to the file to pretend that stdin comes from.'
										},
										insertPragma: {
											since: '1.8.0',
											category: x,
											type: 'boolean',
											default: !1,
											description: "Insert @format pragma into file's first docblock comment.",
											cliCategory: p
										},
										parser: {
											since: '0.0.10',
											category: y,
											type: 'choice',
											default: [
												{ since: '0.0.10', value: 'babylon' },
												{ since: '1.13.0', value: void 0 }
											],
											description: 'Which parser to use.',
											exception: (w) => typeof w == 'string' || typeof w == 'function',
											choices: [
												{ value: 'flow', description: 'Flow' },
												{ value: 'babel', since: '1.16.0', description: 'JavaScript' },
												{ value: 'babel-flow', since: '1.16.0', description: 'Flow' },
												{ value: 'babel-ts', since: '2.0.0', description: 'TypeScript' },
												{ value: 'typescript', since: '1.4.0', description: 'TypeScript' },
												{ value: 'acorn', since: '2.6.0', description: 'JavaScript' },
												{ value: 'espree', since: '2.2.0', description: 'JavaScript' },
												{ value: 'meriyah', since: '2.2.0', description: 'JavaScript' },
												{ value: 'css', since: '1.7.1', description: 'CSS' },
												{ value: 'less', since: '1.7.1', description: 'Less' },
												{ value: 'scss', since: '1.7.1', description: 'SCSS' },
												{ value: 'json', since: '1.5.0', description: 'JSON' },
												{ value: 'json5', since: '1.13.0', description: 'JSON5' },
												{ value: 'json-stringify', since: '1.13.0', description: 'JSON.stringify' },
												{ value: 'graphql', since: '1.5.0', description: 'GraphQL' },
												{ value: 'markdown', since: '1.8.0', description: 'Markdown' },
												{ value: 'mdx', since: '1.15.0', description: 'MDX' },
												{ value: 'vue', since: '1.10.0', description: 'Vue' },
												{ value: 'yaml', since: '1.14.0', description: 'YAML' },
												{ value: 'glimmer', since: '2.3.0', description: 'Ember / Handlebars' },
												{ value: 'html', since: '1.15.0', description: 'HTML' },
												{ value: 'angular', since: '1.15.0', description: 'Angular' },
												{ value: 'lwc', since: '1.17.0', description: 'Lightning Web Components' }
											]
										},
										plugins: {
											since: '1.10.0',
											type: 'path',
											array: !0,
											default: [{ value: [] }],
											category: y,
											description:
												'Add a plugin. Multiple plugins can be passed as separate `--plugin`s.',
											exception: (w) => typeof w == 'string' || typeof w == 'object',
											cliName: 'plugin',
											cliCategory: D
										},
										pluginSearchDirs: {
											since: '1.13.0',
											type: 'path',
											array: !0,
											default: [{ value: [] }],
											category: y,
											description: c`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `,
											exception: (w) => typeof w == 'string' || typeof w == 'object',
											cliName: 'plugin-search-dir',
											cliCategory: D
										},
										printWidth: {
											since: '0.0.0',
											category: y,
											type: 'int',
											default: 80,
											description: 'The line length where Prettier will try wrap.',
											range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }
										},
										rangeEnd: {
											since: '1.4.0',
											category: x,
											type: 'int',
											default: Number.POSITIVE_INFINITY,
											range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 },
											description: c`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `,
											cliCategory: g
										},
										rangeStart: {
											since: '1.4.0',
											category: x,
											type: 'int',
											default: 0,
											range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 },
											description: c`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `,
											cliCategory: g
										},
										requirePragma: {
											since: '1.7.0',
											category: x,
											type: 'boolean',
											default: !1,
											description: c`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `,
											cliCategory: p
										},
										tabWidth: {
											type: 'int',
											category: y,
											default: 2,
											description: 'Number of spaces per indentation level.',
											range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }
										},
										useTabs: {
											since: '1.0.0',
											category: y,
											type: 'boolean',
											default: !1,
											description: 'Indent with tabs instead of spaces.'
										},
										embeddedLanguageFormatting: {
											since: '2.1.0',
											category: y,
											type: 'choice',
											default: [{ since: '2.1.0', value: 'auto' }],
											description: 'Control how Prettier formats quoted code embedded in the file.',
											choices: [
												{
													value: 'auto',
													description:
														'Format embedded code if Prettier can automatically identify it.'
												},
												{ value: 'off', description: 'Never automatically format embedded code.' }
											]
										}
									}
								E.exports = {
									CATEGORY_CONFIG: D,
									CATEGORY_EDITOR: g,
									CATEGORY_FORMAT: l,
									CATEGORY_OTHER: p,
									CATEGORY_OUTPUT: f,
									CATEGORY_GLOBAL: y,
									CATEGORY_SPECIAL: x,
									options: _
								}
							}
						}),
						np = le({
							'src/main/support.js'(d, E) {
								'use strict'
								ge()
								var c = { compare: tp(), lt: dD(), gte: hD() },
									D = mD(),
									g = ei().version,
									l = DD().options
								function p() {
									let {
											plugins: y = [],
											showUnreleased: x = !1,
											showDeprecated: _ = !1,
											showInternal: w = !1
										} = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
										C = g.split('-', 1)[0],
										v = y.flatMap((O) => O.languages || []).filter(k),
										b = D(
											Object.assign(
												{},
												...y.map((O) => {
													let { options: U } = O
													return U
												}),
												l
											),
											'name'
										)
											.filter((O) => k(O) && q(O))
											.sort((O, U) => (O.name === U.name ? 0 : O.name < U.name ? -1 : 1))
											.map(G)
											.map((O) => {
												;(O = Object.assign({}, O)),
													Array.isArray(O.default) &&
														(O.default =
															O.default.length === 1
																? O.default[0].value
																: O.default.filter(k).sort((j, H) => c.compare(H.since, j.since))[0]
																		.value),
													Array.isArray(O.choices) &&
														((O.choices = O.choices.filter((j) => k(j) && q(j))),
														O.name === 'parser' && f(O, v, y))
												let U = Object.fromEntries(
													y
														.filter((j) => j.defaultOptions && j.defaultOptions[O.name] !== void 0)
														.map((j) => [j.name, j.defaultOptions[O.name]])
												)
												return Object.assign(Object.assign({}, O), {}, { pluginDefaults: U })
											})
									return { languages: v, options: b }
									function k(O) {
										return x || !('since' in O) || (O.since && c.gte(C, O.since))
									}
									function q(O) {
										return _ || !('deprecated' in O) || (O.deprecated && c.lt(C, O.deprecated))
									}
									function G(O) {
										if (w) return O
										let { cliName: U, cliCategory: j, cliDescription: H } = O
										return Ye(O, Se)
									}
								}
								function f(y, x, _) {
									let w = new Set(y.choices.map((C) => C.value))
									for (let C of x)
										if (C.parsers) {
											for (let v of C.parsers)
												if (!w.has(v)) {
													w.add(v)
													let b = _.find((q) => q.parsers && q.parsers[v]),
														k = C.name
													b && b.name && (k += ` (plugin: ${b.name})`),
														y.choices.push({ value: v, description: k })
												}
										}
								}
								E.exports = { getSupportInfo: p }
							}
						}),
						rp = le({
							'src/utils/is-non-empty-array.js'(d, E) {
								'use strict'
								ge()
								function c(D) {
									return Array.isArray(D) && D.length > 0
								}
								E.exports = c
							}
						}),
						Vu = le({
							'src/utils/text/skip.js'(d, E) {
								'use strict'
								ge()
								function c(f) {
									return (y, x, _) => {
										let w = _ && _.backwards
										if (x === !1) return !1
										let { length: C } = y,
											v = x
										for (; v >= 0 && v < C; ) {
											let b = y.charAt(v)
											if (f instanceof RegExp) {
												if (!f.test(b)) return v
											} else if (!f.includes(b)) return v
											w ? v-- : v++
										}
										return v === -1 || v === C ? v : !1
									}
								}
								var D = c(/\s/),
									g = c(' 	'),
									l = c(',; 	'),
									p = c(/[^\n\r]/)
								E.exports = {
									skipWhitespace: D,
									skipSpaces: g,
									skipToLineEnd: l,
									skipEverythingButNewLine: p
								}
							}
						}),
						a1 = le({
							'src/utils/text/skip-inline-comment.js'(d, E) {
								'use strict'
								ge()
								function c(D, g) {
									if (g === !1) return !1
									if (D.charAt(g) === '/' && D.charAt(g + 1) === '*') {
										for (let l = g + 2; l < D.length; ++l)
											if (D.charAt(l) === '*' && D.charAt(l + 1) === '/') return l + 2
									}
									return g
								}
								E.exports = c
							}
						}),
						u1 = le({
							'src/utils/text/skip-trailing-comment.js'(d, E) {
								'use strict'
								ge()
								var { skipEverythingButNewLine: c } = Vu()
								function D(g, l) {
									return l === !1
										? !1
										: g.charAt(l) === '/' && g.charAt(l + 1) === '/'
										? c(g, l)
										: l
								}
								E.exports = D
							}
						}),
						l1 = le({
							'src/utils/text/skip-newline.js'(d, E) {
								'use strict'
								ge()
								function c(D, g, l) {
									let p = l && l.backwards
									if (g === !1) return !1
									let f = D.charAt(g)
									if (p) {
										if (
											D.charAt(g - 1) === '\r' &&
											f ===
												`
`
										)
											return g - 2
										if (
											f ===
												`
` ||
											f === '\r' ||
											f === '\u2028' ||
											f === '\u2029'
										)
											return g - 1
									} else {
										if (
											f === '\r' &&
											D.charAt(g + 1) ===
												`
`
										)
											return g + 2
										if (
											f ===
												`
` ||
											f === '\r' ||
											f === '\u2028' ||
											f === '\u2029'
										)
											return g + 1
									}
									return g
								}
								E.exports = c
							}
						}),
						yD = le({
							'src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js'(
								d,
								E
							) {
								'use strict'
								ge()
								var c = a1(),
									D = l1(),
									g = u1(),
									{ skipSpaces: l } = Vu()
								function p(f, y) {
									let x = null,
										_ = y
									for (; _ !== x; )
										(x = _), (_ = l(f, _)), (_ = c(f, _)), (_ = g(f, _)), (_ = D(f, _))
									return _
								}
								E.exports = p
							}
						}),
						wn = le({
							'src/common/util.js'(d, E) {
								'use strict'
								ge()
								var { default: c } = (uD(), Mn(i1)),
									D = Ur(),
									{ getSupportInfo: g } = np(),
									l = rp(),
									p = r1(),
									{
										skipWhitespace: f,
										skipSpaces: y,
										skipToLineEnd: x,
										skipEverythingButNewLine: _
									} = Vu(),
									w = a1(),
									C = u1(),
									v = l1(),
									b = yD(),
									k = (te) => te[te.length - 2]
								function q(te) {
									return (X, De, Fe) => {
										let ve = Fe && Fe.backwards
										if (De === !1) return !1
										let { length: $e } = X,
											ie = De
										for (; ie >= 0 && ie < $e; ) {
											let fe = X.charAt(ie)
											if (te instanceof RegExp) {
												if (!te.test(fe)) return ie
											} else if (!te.includes(fe)) return ie
											ve ? ie-- : ie++
										}
										return ie === -1 || ie === $e ? ie : !1
									}
								}
								function G(te, X) {
									let De = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
										Fe = y(te, De.backwards ? X - 1 : X, De),
										ve = v(te, Fe, De)
									return Fe !== ve
								}
								function O(te, X, De) {
									for (let Fe = X; Fe < De; ++Fe)
										if (
											te.charAt(Fe) ===
											`
`
										)
											return !0
									return !1
								}
								function U(te, X, De) {
									let Fe = De(X) - 1
									;(Fe = y(te, Fe, { backwards: !0 })),
										(Fe = v(te, Fe, { backwards: !0 })),
										(Fe = y(te, Fe, { backwards: !0 }))
									let ve = v(te, Fe, { backwards: !0 })
									return Fe !== ve
								}
								function j(te, X) {
									let De = null,
										Fe = X
									for (; Fe !== De; )
										(De = Fe), (Fe = x(te, Fe)), (Fe = w(te, Fe)), (Fe = y(te, Fe))
									return (Fe = C(te, Fe)), (Fe = v(te, Fe)), Fe !== !1 && G(te, Fe)
								}
								function H(te, X, De) {
									return j(te, De(X))
								}
								function W(te, X, De) {
									return b(te, De(X))
								}
								function re(te, X, De) {
									return te.charAt(W(te, X, De))
								}
								function A(te, X) {
									let De = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
									return y(te, De.backwards ? X - 1 : X, De) !== X
								}
								function $(te, X) {
									let De = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
										Fe = 0
									for (let ve = De; ve < te.length; ++ve)
										te[ve] === '	' ? (Fe = Fe + X - (Fe % X)) : Fe++
									return Fe
								}
								function T(te, X) {
									let De = te.lastIndexOf(`
`)
									return De === -1 ? 0 : $(te.slice(De + 1).match(/^[\t ]*/)[0], X)
								}
								function R(te, X) {
									let De = { quote: '"', regex: /"/g, escaped: '&quot;' },
										Fe = { quote: "'", regex: /'/g, escaped: '&apos;' },
										ve = X === "'" ? Fe : De,
										$e = ve === Fe ? De : Fe,
										ie = ve
									if (te.includes(ve.quote) || te.includes($e.quote)) {
										let fe = (te.match(ve.regex) || []).length,
											Be = (te.match($e.regex) || []).length
										ie = fe > Be ? $e : ve
									}
									return ie
								}
								function m(te, X) {
									let De = te.slice(1, -1),
										Fe =
											X.parser === 'json' ||
											(X.parser === 'json5' && X.quoteProps === 'preserve' && !X.singleQuote)
												? '"'
												: X.__isInHtmlAttribute
												? "'"
												: R(De, X.singleQuote ? "'" : '"').quote
									return S(
										De,
										Fe,
										!(
											X.parser === 'css' ||
											X.parser === 'less' ||
											X.parser === 'scss' ||
											X.__embeddedInHtml
										)
									)
								}
								function S(te, X, De) {
									let Fe = X === '"' ? "'" : '"',
										ve = /\\(.)|(["'])/gs,
										$e = te.replace(ve, (ie, fe, Be) =>
											fe === Fe
												? fe
												: Be === X
												? '\\' + Be
												: Be ||
												  (De && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(fe) ? fe : '\\' + fe)
										)
									return X + $e + X
								}
								function L(te) {
									return te
										.toLowerCase()
										.replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, '$1$2$3')
										.replace(/^([+-]?[\d.]+)e[+-]?0+$/, '$1')
										.replace(/^([+-])?\./, '$10.')
										.replace(/(\.\d+?)0+(?=e|$)/, '$1')
										.replace(/\.(?=e|$)/, '')
								}
								function P(te, X) {
									let De = te.match(new RegExp(`(${c(X)})+`, 'g'))
									return De === null
										? 0
										: De.reduce((Fe, ve) => Math.max(Fe, ve.length / X.length), 0)
								}
								function M(te, X) {
									let De = te.match(new RegExp(`(${c(X)})+`, 'g'))
									if (De === null) return 0
									let Fe = new Map(),
										ve = 0
									for (let $e of De) {
										let ie = $e.length / X.length
										Fe.set(ie, !0), ie > ve && (ve = ie)
									}
									for (let $e = 1; $e < ve; $e++) if (!Fe.get($e)) return $e
									return ve + 1
								}
								function V(te, X) {
									;(te.comments || (te.comments = [])).push(X),
										(X.printed = !1),
										(X.nodeDescription = ye(te))
								}
								function J(te, X) {
									;(X.leading = !0), (X.trailing = !1), V(te, X)
								}
								function Z(te, X, De) {
									;(X.leading = !1), (X.trailing = !1), De && (X.marker = De), V(te, X)
								}
								function ne(te, X) {
									;(X.leading = !1), (X.trailing = !0), V(te, X)
								}
								function ee(te, X) {
									let { languages: De } = g({ plugins: X.plugins }),
										Fe =
											De.find((ve) => {
												let { name: $e } = ve
												return $e.toLowerCase() === te
											}) ||
											De.find((ve) => {
												let { aliases: $e } = ve
												return Array.isArray($e) && $e.includes(te)
											}) ||
											De.find((ve) => {
												let { extensions: $e } = ve
												return Array.isArray($e) && $e.includes(`.${te}`)
											})
									return Fe && Fe.parsers[0]
								}
								function ce(te) {
									return te && te.type === 'front-matter'
								}
								function z(te) {
									let X = new WeakMap()
									return function (De) {
										return X.has(De) || X.set(De, Symbol(te)), X.get(De)
									}
								}
								function ye(te) {
									let X = te.type || te.kind || '(unknown type)',
										De = String(
											te.name ||
												(te.id && (typeof te.id == 'object' ? te.id.name : te.id)) ||
												(te.key && (typeof te.key == 'object' ? te.key.name : te.key)) ||
												(te.value && (typeof te.value == 'object' ? '' : String(te.value))) ||
												te.operator ||
												''
										)
									return (
										De.length > 20 && (De = De.slice(0, 19) + '\u2026'), X + (De ? ' ' + De : '')
									)
								}
								E.exports = {
									inferParserByLanguage: ee,
									getStringWidth: p,
									getMaxContinuousCount: P,
									getMinNotPresentContinuousCount: M,
									getPenultimate: k,
									getLast: D,
									getNextNonSpaceNonCommentCharacterIndexWithStartIndex: b,
									getNextNonSpaceNonCommentCharacterIndex: W,
									getNextNonSpaceNonCommentCharacter: re,
									skip: q,
									skipWhitespace: f,
									skipSpaces: y,
									skipToLineEnd: x,
									skipEverythingButNewLine: _,
									skipInlineComment: w,
									skipTrailingComment: C,
									skipNewline: v,
									isNextLineEmptyAfterIndex: j,
									isNextLineEmpty: H,
									isPreviousLineEmpty: U,
									hasNewline: G,
									hasNewlineInRange: O,
									hasSpaces: A,
									getAlignmentSize: $,
									getIndentSize: T,
									getPreferredQuote: R,
									printString: m,
									printNumber: L,
									makeString: S,
									addLeadingComment: J,
									addDanglingComment: Z,
									addTrailingComment: ne,
									isFrontMatterNode: ce,
									isNonEmptyArray: l,
									createGroupIdMapper: z
								}
							}
						}),
						c1 = {}
					fn(c1, {
						basename: () => m1,
						default: () => y1,
						delimiter: () => up,
						dirname: () => h1,
						extname: () => g1,
						isAbsolute: () => sp,
						join: () => f1,
						normalize: () => ip,
						relative: () => d1,
						resolve: () => Uu,
						sep: () => ap
					})
					function p1(d, E) {
						for (var c = 0, D = d.length - 1; D >= 0; D--) {
							var g = d[D]
							g === '.'
								? d.splice(D, 1)
								: g === '..'
								? (d.splice(D, 1), c++)
								: c && (d.splice(D, 1), c--)
						}
						if (E) for (; c--; c) d.unshift('..')
						return d
					}
					function Uu() {
						for (var d = '', E = !1, c = arguments.length - 1; c >= -1 && !E; c--) {
							var D = c >= 0 ? arguments[c] : '/'
							if (typeof D != 'string')
								throw new TypeError('Arguments to path.resolve must be strings')
							D && ((d = D + '/' + d), (E = D.charAt(0) === '/'))
						}
						return (
							(d = p1(
								op(d.split('/'), function (g) {
									return !!g
								}),
								!E
							).join('/')),
							(E ? '/' : '') + d || '.'
						)
					}
					function ip(d) {
						var E = sp(d),
							c = E1(d, -1) === '/'
						return (
							(d = p1(
								op(d.split('/'), function (D) {
									return !!D
								}),
								!E
							).join('/')),
							!d && !E && (d = '.'),
							d && c && (d += '/'),
							(E ? '/' : '') + d
						)
					}
					function sp(d) {
						return d.charAt(0) === '/'
					}
					function f1() {
						var d = Array.prototype.slice.call(arguments, 0)
						return ip(
							op(d, function (E, c) {
								if (typeof E != 'string')
									throw new TypeError('Arguments to path.join must be strings')
								return E
							}).join('/')
						)
					}
					function d1(d, E) {
						;(d = Uu(d).substr(1)), (E = Uu(E).substr(1))
						function c(x) {
							for (var _ = 0; _ < x.length && x[_] === ''; _++);
							for (var w = x.length - 1; w >= 0 && x[w] === ''; w--);
							return _ > w ? [] : x.slice(_, w - _ + 1)
						}
						for (
							var D = c(d.split('/')),
								g = c(E.split('/')),
								l = Math.min(D.length, g.length),
								p = l,
								f = 0;
							f < l;
							f++
						)
							if (D[f] !== g[f]) {
								p = f
								break
							}
						for (var y = [], f = p; f < D.length; f++) y.push('..')
						return (y = y.concat(g.slice(p))), y.join('/')
					}
					function h1(d) {
						var E = qu(d),
							c = E[0],
							D = E[1]
						return !c && !D ? '.' : (D && (D = D.substr(0, D.length - 1)), c + D)
					}
					function m1(d, E) {
						var c = qu(d)[2]
						return E && c.substr(-1 * E.length) === E && (c = c.substr(0, c.length - E.length)), c
					}
					function g1(d) {
						return qu(d)[3]
					}
					function op(d, E) {
						if (d.filter) return d.filter(E)
						for (var c = [], D = 0; D < d.length; D++) E(d[D], D, d) && c.push(d[D])
						return c
					}
					var D1,
						qu,
						ap,
						up,
						y1,
						E1,
						ED = Kt({
							'node-modules-polyfills:path'() {
								ge(),
									(D1 = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/),
									(qu = function (d) {
										return D1.exec(d).slice(1)
									}),
									(ap = '/'),
									(up = ':'),
									(y1 = {
										extname: g1,
										basename: m1,
										dirname: h1,
										sep: ap,
										delimiter: up,
										relative: d1,
										join: f1,
										isAbsolute: sp,
										normalize: ip,
										resolve: Uu
									}),
									(E1 =
										'ab'.substr(-1) === 'b'
											? function (d, E, c) {
													return d.substr(E, c)
											  }
											: function (d, E, c) {
													return E < 0 && (E = d.length + E), d.substr(E, c)
											  })
							}
						}),
						vD = le({
							'node-modules-polyfills-commonjs:path'(d, E) {
								ge()
								var c = (ED(), Mn(c1))
								if (c && c.default) {
									E.exports = c.default
									for (let D in c) E.exports[D] = c[D]
								} else c && (E.exports = c)
							}
						}),
						wa = le({
							'src/common/errors.js'(d, E) {
								'use strict'
								ge()
								var c = class extends Error {},
									D = class extends Error {},
									g = class extends Error {},
									l = class extends Error {}
								E.exports = {
									ConfigError: c,
									DebugError: D,
									UndefinedParserError: g,
									ArgExpansionBailout: l
								}
							}
						}),
						os = {}
					fn(os, {
						__assign: () => Wu,
						__asyncDelegator: () => kD,
						__asyncGenerator: () => ID,
						__asyncValues: () => RD,
						__await: () => La,
						__awaiter: () => SD,
						__classPrivateFieldGet: () => MD,
						__classPrivateFieldSet: () => jD,
						__createBinding: () => FD,
						__decorate: () => TD,
						__exportStar: () => _D,
						__extends: () => xD,
						__generator: () => ND,
						__importDefault: () => PD,
						__importStar: () => BD,
						__makeTemplateObject: () => OD,
						__metadata: () => CD,
						__param: () => AD,
						__read: () => v1,
						__rest: () => bD,
						__spread: () => wD,
						__spreadArrays: () => LD,
						__values: () => lp
					})
					function xD(d, E) {
						Gu(d, E)
						function c() {
							this.constructor = d
						}
						d.prototype = E === null ? Object.create(E) : ((c.prototype = E.prototype), new c())
					}
					function bD(d, E) {
						var c = {}
						for (var D in d)
							Object.prototype.hasOwnProperty.call(d, D) && E.indexOf(D) < 0 && (c[D] = d[D])
						if (d != null && typeof Object.getOwnPropertySymbols == 'function')
							for (var g = 0, D = Object.getOwnPropertySymbols(d); g < D.length; g++)
								E.indexOf(D[g]) < 0 &&
									Object.prototype.propertyIsEnumerable.call(d, D[g]) &&
									(c[D[g]] = d[D[g]])
						return c
					}
					function TD(d, E, c, D) {
						var g = arguments.length,
							l = g < 3 ? E : D === null ? (D = Object.getOwnPropertyDescriptor(E, c)) : D,
							p
						if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function')
							l = Reflect.decorate(d, E, c, D)
						else
							for (var f = d.length - 1; f >= 0; f--)
								(p = d[f]) && (l = (g < 3 ? p(l) : g > 3 ? p(E, c, l) : p(E, c)) || l)
						return g > 3 && l && Object.defineProperty(E, c, l), l
					}
					function AD(d, E) {
						return function (c, D) {
							E(c, D, d)
						}
					}
					function CD(d, E) {
						if (typeof Reflect == 'object' && typeof Reflect.metadata == 'function')
							return Reflect.metadata(d, E)
					}
					function SD(d, E, c, D) {
						function g(l) {
							return l instanceof c
								? l
								: new c(function (p) {
										p(l)
								  })
						}
						return new (c || (c = Promise))(function (l, p) {
							function f(_) {
								try {
									x(D.next(_))
								} catch (w) {
									p(w)
								}
							}
							function y(_) {
								try {
									x(D.throw(_))
								} catch (w) {
									p(w)
								}
							}
							function x(_) {
								_.done ? l(_.value) : g(_.value).then(f, y)
							}
							x((D = D.apply(d, E || [])).next())
						})
					}
					function ND(d, E) {
						var c = {
								label: 0,
								sent: function () {
									if (l[0] & 1) throw l[1]
									return l[1]
								},
								trys: [],
								ops: []
							},
							D,
							g,
							l,
							p
						return (
							(p = { next: f(0), throw: f(1), return: f(2) }),
							typeof Symbol == 'function' &&
								(p[Symbol.iterator] = function () {
									return this
								}),
							p
						)
						function f(x) {
							return function (_) {
								return y([x, _])
							}
						}
						function y(x) {
							if (D) throw new TypeError('Generator is already executing.')
							for (; c; )
								try {
									if (
										((D = 1),
										g &&
											(l =
												x[0] & 2
													? g.return
													: x[0]
													? g.throw || ((l = g.return) && l.call(g), 0)
													: g.next) &&
											!(l = l.call(g, x[1])).done)
									)
										return l
									switch (((g = 0), l && (x = [x[0] & 2, l.value]), x[0])) {
										case 0:
										case 1:
											l = x
											break
										case 4:
											return c.label++, { value: x[1], done: !1 }
										case 5:
											c.label++, (g = x[1]), (x = [0])
											continue
										case 7:
											;(x = c.ops.pop()), c.trys.pop()
											continue
										default:
											if (
												((l = c.trys),
												!(l = l.length > 0 && l[l.length - 1]) && (x[0] === 6 || x[0] === 2))
											) {
												c = 0
												continue
											}
											if (x[0] === 3 && (!l || (x[1] > l[0] && x[1] < l[3]))) {
												c.label = x[1]
												break
											}
											if (x[0] === 6 && c.label < l[1]) {
												;(c.label = l[1]), (l = x)
												break
											}
											if (l && c.label < l[2]) {
												;(c.label = l[2]), c.ops.push(x)
												break
											}
											l[2] && c.ops.pop(), c.trys.pop()
											continue
									}
									x = E.call(d, c)
								} catch (_) {
									;(x = [6, _]), (g = 0)
								} finally {
									D = l = 0
								}
							if (x[0] & 5) throw x[1]
							return { value: x[0] ? x[1] : void 0, done: !0 }
						}
					}
					function FD(d, E, c, D) {
						D === void 0 && (D = c), (d[D] = E[c])
					}
					function _D(d, E) {
						for (var c in d) c !== 'default' && !E.hasOwnProperty(c) && (E[c] = d[c])
					}
					function lp(d) {
						var E = typeof Symbol == 'function' && Symbol.iterator,
							c = E && d[E],
							D = 0
						if (c) return c.call(d)
						if (d && typeof d.length == 'number')
							return {
								next: function () {
									return d && D >= d.length && (d = void 0), { value: d && d[D++], done: !d }
								}
							}
						throw new TypeError(E ? 'Object is not iterable.' : 'Symbol.iterator is not defined.')
					}
					function v1(d, E) {
						var c = typeof Symbol == 'function' && d[Symbol.iterator]
						if (!c) return d
						var D = c.call(d),
							g,
							l = [],
							p
						try {
							for (; (E === void 0 || E-- > 0) && !(g = D.next()).done; ) l.push(g.value)
						} catch (f) {
							p = { error: f }
						} finally {
							try {
								g && !g.done && (c = D.return) && c.call(D)
							} finally {
								if (p) throw p.error
							}
						}
						return l
					}
					function wD() {
						for (var d = [], E = 0; E < arguments.length; E++) d = d.concat(v1(arguments[E]))
						return d
					}
					function LD() {
						for (var d = 0, E = 0, c = arguments.length; E < c; E++) d += arguments[E].length
						for (var D = Array(d), g = 0, E = 0; E < c; E++)
							for (var l = arguments[E], p = 0, f = l.length; p < f; p++, g++) D[g] = l[p]
						return D
					}
					function La(d) {
						return this instanceof La ? ((this.v = d), this) : new La(d)
					}
					function ID(d, E, c) {
						if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.')
						var D = c.apply(d, E || []),
							g,
							l = []
						return (
							(g = {}),
							p('next'),
							p('throw'),
							p('return'),
							(g[Symbol.asyncIterator] = function () {
								return this
							}),
							g
						)
						function p(C) {
							D[C] &&
								(g[C] = function (v) {
									return new Promise(function (b, k) {
										l.push([C, v, b, k]) > 1 || f(C, v)
									})
								})
						}
						function f(C, v) {
							try {
								y(D[C](v))
							} catch (b) {
								w(l[0][3], b)
							}
						}
						function y(C) {
							C.value instanceof La ? Promise.resolve(C.value.v).then(x, _) : w(l[0][2], C)
						}
						function x(C) {
							f('next', C)
						}
						function _(C) {
							f('throw', C)
						}
						function w(C, v) {
							C(v), l.shift(), l.length && f(l[0][0], l[0][1])
						}
					}
					function kD(d) {
						var E, c
						return (
							(E = {}),
							D('next'),
							D('throw', function (g) {
								throw g
							}),
							D('return'),
							(E[Symbol.iterator] = function () {
								return this
							}),
							E
						)
						function D(g, l) {
							E[g] = d[g]
								? function (p) {
										return (c = !c) ? { value: La(d[g](p)), done: g === 'return' } : l ? l(p) : p
								  }
								: l
						}
					}
					function RD(d) {
						if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.')
						var E = d[Symbol.asyncIterator],
							c
						return E
							? E.call(d)
							: ((d = typeof lp == 'function' ? lp(d) : d[Symbol.iterator]()),
							  (c = {}),
							  D('next'),
							  D('throw'),
							  D('return'),
							  (c[Symbol.asyncIterator] = function () {
									return this
							  }),
							  c)
						function D(l) {
							c[l] =
								d[l] &&
								function (p) {
									return new Promise(function (f, y) {
										;(p = d[l](p)), g(f, y, p.done, p.value)
									})
								}
						}
						function g(l, p, f, y) {
							Promise.resolve(y).then(function (x) {
								l({ value: x, done: f })
							}, p)
						}
					}
					function OD(d, E) {
						return (
							Object.defineProperty ? Object.defineProperty(d, 'raw', { value: E }) : (d.raw = E), d
						)
					}
					function BD(d) {
						if (d && d.__esModule) return d
						var E = {}
						if (d != null) for (var c in d) Object.hasOwnProperty.call(d, c) && (E[c] = d[c])
						return (E.default = d), E
					}
					function PD(d) {
						return d && d.__esModule ? d : { default: d }
					}
					function MD(d, E) {
						if (!E.has(d)) throw new TypeError('attempted to get private field on non-instance')
						return E.get(d)
					}
					function jD(d, E, c) {
						if (!E.has(d)) throw new TypeError('attempted to set private field on non-instance')
						return E.set(d, c), c
					}
					var Gu,
						Wu,
						ys = Kt({
							'node_modules/tslib/tslib.es6.js'() {
								ge(),
									(Gu = function (d, E) {
										return (
											(Gu =
												Object.setPrototypeOf ||
												({ __proto__: [] } instanceof Array &&
													function (c, D) {
														c.__proto__ = D
													}) ||
												function (c, D) {
													for (var g in D) D.hasOwnProperty(g) && (c[g] = D[g])
												}),
											Gu(d, E)
										)
									}),
									(Wu = function () {
										return (
											(Wu =
												Object.assign ||
												function (d) {
													for (var E, c = 1, D = arguments.length; c < D; c++) {
														E = arguments[c]
														for (var g in E)
															Object.prototype.hasOwnProperty.call(E, g) && (d[g] = E[g])
													}
													return d
												}),
											Wu.apply(this, arguments)
										)
									})
							}
						}),
						x1 = le({
							'node_modules/vnopts/lib/descriptors/api.js'(d) {
								'use strict'
								ge(),
									Object.defineProperty(d, '__esModule', { value: !0 }),
									(d.apiDescriptor = {
										key: (E) => (/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(E) ? E : JSON.stringify(E)),
										value(E) {
											if (E === null || typeof E != 'object') return JSON.stringify(E)
											if (Array.isArray(E))
												return `[${E.map((D) => d.apiDescriptor.value(D)).join(', ')}]`
											let c = Object.keys(E)
											return c.length === 0
												? '{}'
												: `{ ${c
														.map((D) => `${d.apiDescriptor.key(D)}: ${d.apiDescriptor.value(E[D])}`)
														.join(', ')} }`
										},
										pair: (E) => {
											let { key: c, value: D } = E
											return d.apiDescriptor.value({ [c]: D })
										}
									})
							}
						}),
						$D = le({
							'node_modules/vnopts/lib/descriptors/index.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = (ys(), Mn(os))
								E.__exportStar(x1(), d)
							}
						}),
						Hu = le({
							'scripts/build/shims/chalk.cjs'(d, E) {
								'use strict'
								ge()
								var c = (D) => D
								;(c.grey = c),
									(c.red = c),
									(c.bold = c),
									(c.yellow = c),
									(c.blue = c),
									(c.default = c),
									(E.exports = c)
							}
						}),
						b1 = le({
							'node_modules/vnopts/lib/handlers/deprecated/common.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = Hu()
								d.commonDeprecatedHandler = (c, D, g) => {
									let { descriptor: l } = g,
										p = [
											`${E.default.yellow(
												typeof c == 'string' ? l.key(c) : l.pair(c)
											)} is deprecated`
										]
									return (
										D &&
											p.push(
												`we now treat it as ${E.default.blue(
													typeof D == 'string' ? l.key(D) : l.pair(D)
												)}`
											),
										p.join('; ') + '.'
									)
								}
							}
						}),
						VD = le({
							'node_modules/vnopts/lib/handlers/deprecated/index.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = (ys(), Mn(os))
								E.__exportStar(b1(), d)
							}
						}),
						UD = le({
							'node_modules/vnopts/lib/handlers/invalid/common.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = Hu()
								d.commonInvalidHandler = (c, D, g) =>
									[
										`Invalid ${E.default.red(g.descriptor.key(c))} value.`,
										`Expected ${E.default.blue(g.schemas[c].expected(g))},`,
										`but received ${E.default.red(g.descriptor.value(D))}.`
									].join(' ')
							}
						}),
						T1 = le({
							'node_modules/vnopts/lib/handlers/invalid/index.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = (ys(), Mn(os))
								E.__exportStar(UD(), d)
							}
						}),
						qD = le({
							'node_modules/vnopts/node_modules/leven/index.js'(d, E) {
								'use strict'
								ge()
								var c = [],
									D = []
								E.exports = function (g, l) {
									if (g === l) return 0
									var p = g
									g.length > l.length && ((g = l), (l = p))
									var f = g.length,
										y = l.length
									if (f === 0) return y
									if (y === 0) return f
									for (; f > 0 && g.charCodeAt(~-f) === l.charCodeAt(~-y); ) f--, y--
									if (f === 0) return y
									for (var x = 0; x < f && g.charCodeAt(x) === l.charCodeAt(x); ) x++
									if (((f -= x), (y -= x), f === 0)) return y
									for (var _, w, C, v, b = 0, k = 0; b < f; )
										(D[x + b] = g.charCodeAt(x + b)), (c[b] = ++b)
									for (; k < y; )
										for (_ = l.charCodeAt(x + k), C = k++, w = k, b = 0; b < f; b++)
											(v = _ === D[x + b] ? C : C + 1),
												(C = c[b]),
												(w = c[b] = C > w ? (v > w ? w + 1 : v) : v > C ? C + 1 : v)
									return w
								}
							}
						}),
						A1 = le({
							'node_modules/vnopts/lib/handlers/unknown/leven.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = Hu(),
									c = qD()
								d.levenUnknownHandler = (D, g, l) => {
									let { descriptor: p, logger: f, schemas: y } = l,
										x = [
											`Ignored unknown option ${E.default.yellow(p.pair({ key: D, value: g }))}.`
										],
										_ = Object.keys(y)
											.sort()
											.find((w) => c(D, w) < 3)
									_ && x.push(`Did you mean ${E.default.blue(p.key(_))}?`), f.warn(x.join(' '))
								}
							}
						}),
						GD = le({
							'node_modules/vnopts/lib/handlers/unknown/index.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = (ys(), Mn(os))
								E.__exportStar(A1(), d)
							}
						}),
						WD = le({
							'node_modules/vnopts/lib/handlers/index.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = (ys(), Mn(os))
								E.__exportStar(VD(), d), E.__exportStar(T1(), d), E.__exportStar(GD(), d)
							}
						}),
						Es = le({
							'node_modules/vnopts/lib/schema.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = [
									'default',
									'expected',
									'validate',
									'deprecated',
									'forward',
									'redirect',
									'overlap',
									'preprocess',
									'postprocess'
								]
								function c(l, p) {
									let f = new l(p),
										y = Object.create(f)
									for (let x of E) x in p && (y[x] = g(p[x], f, D.prototype[x].length))
									return y
								}
								d.createSchema = c
								var D = class {
									constructor(l) {
										this.name = l.name
									}
									static create(l) {
										return c(this, l)
									}
									default(l) {}
									expected(l) {
										return 'nothing'
									}
									validate(l, p) {
										return !1
									}
									deprecated(l, p) {
										return !1
									}
									forward(l, p) {}
									redirect(l, p) {}
									overlap(l, p, f) {
										return l
									}
									preprocess(l, p) {
										return l
									}
									postprocess(l, p) {
										return l
									}
								}
								d.Schema = D
								function g(l, p, f) {
									return typeof l == 'function'
										? function () {
												for (var y = arguments.length, x = new Array(y), _ = 0; _ < y; _++)
													x[_] = arguments[_]
												return l(...x.slice(0, f - 1), p, ...x.slice(f - 1))
										  }
										: () => l
								}
							}
						}),
						HD = le({
							'node_modules/vnopts/lib/schemas/alias.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = Es(),
									c = class extends E.Schema {
										constructor(D) {
											super(D), (this._sourceName = D.sourceName)
										}
										expected(D) {
											return D.schemas[this._sourceName].expected(D)
										}
										validate(D, g) {
											return g.schemas[this._sourceName].validate(D, g)
										}
										redirect(D, g) {
											return this._sourceName
										}
									}
								d.AliasSchema = c
							}
						}),
						JD = le({
							'node_modules/vnopts/lib/schemas/any.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = Es(),
									c = class extends E.Schema {
										expected() {
											return 'anything'
										}
										validate() {
											return !0
										}
									}
								d.AnySchema = c
							}
						}),
						zD = le({
							'node_modules/vnopts/lib/schemas/array.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = (ys(), Mn(os)),
									c = Es(),
									D = class extends c.Schema {
										constructor(l) {
											var { valueSchema: p, name: f = p.name } = l,
												y = E.__rest(l, ['valueSchema', 'name'])
											super(Object.assign({}, y, { name: f })), (this._valueSchema = p)
										}
										expected(l) {
											return `an array of ${this._valueSchema.expected(l)}`
										}
										validate(l, p) {
											if (!Array.isArray(l)) return !1
											let f = []
											for (let y of l) {
												let x = p.normalizeValidateResult(this._valueSchema.validate(y, p), y)
												x !== !0 && f.push(x.value)
											}
											return f.length === 0 ? !0 : { value: f }
										}
										deprecated(l, p) {
											let f = []
											for (let y of l) {
												let x = p.normalizeDeprecatedResult(this._valueSchema.deprecated(y, p), y)
												x !== !1 &&
													f.push(
														...x.map((_) => {
															let { value: w } = _
															return { value: [w] }
														})
													)
											}
											return f
										}
										forward(l, p) {
											let f = []
											for (let y of l) {
												let x = p.normalizeForwardResult(this._valueSchema.forward(y, p), y)
												f.push(...x.map(g))
											}
											return f
										}
										redirect(l, p) {
											let f = [],
												y = []
											for (let x of l) {
												let _ = p.normalizeRedirectResult(this._valueSchema.redirect(x, p), x)
												'remain' in _ && f.push(_.remain), y.push(..._.redirect.map(g))
											}
											return f.length === 0 ? { redirect: y } : { redirect: y, remain: f }
										}
										overlap(l, p) {
											return l.concat(p)
										}
									}
								d.ArraySchema = D
								function g(l) {
									let { from: p, to: f } = l
									return { from: [p], to: f }
								}
							}
						}),
						QD = le({
							'node_modules/vnopts/lib/schemas/boolean.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = Es(),
									c = class extends E.Schema {
										expected() {
											return 'true or false'
										}
										validate(D) {
											return typeof D == 'boolean'
										}
									}
								d.BooleanSchema = c
							}
						}),
						cp = le({
							'node_modules/vnopts/lib/utils.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								function E(v, b) {
									let k = Object.create(null)
									for (let q of v) {
										let G = q[b]
										if (k[G]) throw new Error(`Duplicate ${b} ${JSON.stringify(G)}`)
										k[G] = q
									}
									return k
								}
								d.recordFromArray = E
								function c(v, b) {
									let k = new Map()
									for (let q of v) {
										let G = q[b]
										if (k.has(G)) throw new Error(`Duplicate ${b} ${JSON.stringify(G)}`)
										k.set(G, q)
									}
									return k
								}
								d.mapFromArray = c
								function D() {
									let v = Object.create(null)
									return (b) => {
										let k = JSON.stringify(b)
										return v[k] ? !0 : ((v[k] = !0), !1)
									}
								}
								d.createAutoChecklist = D
								function g(v, b) {
									let k = [],
										q = []
									for (let G of v) b(G) ? k.push(G) : q.push(G)
									return [k, q]
								}
								d.partition = g
								function l(v) {
									return v === Math.floor(v)
								}
								d.isInt = l
								function p(v, b) {
									if (v === b) return 0
									let k = typeof v,
										q = typeof b,
										G = ['undefined', 'object', 'boolean', 'number', 'string']
									return k !== q
										? G.indexOf(k) - G.indexOf(q)
										: k !== 'string'
										? Number(v) - Number(b)
										: v.localeCompare(b)
								}
								d.comparePrimitive = p
								function f(v) {
									return v === void 0 ? {} : v
								}
								d.normalizeDefaultResult = f
								function y(v, b) {
									return v === !0 ? !0 : v === !1 ? { value: b } : v
								}
								d.normalizeValidateResult = y
								function x(v, b) {
									let k = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1
									return v === !1
										? !1
										: v === !0
										? k
											? !0
											: [{ value: b }]
										: 'value' in v
										? [v]
										: v.length === 0
										? !1
										: v
								}
								d.normalizeDeprecatedResult = x
								function _(v, b) {
									return typeof v == 'string' || 'key' in v
										? { from: b, to: v }
										: 'from' in v
										? { from: v.from, to: v.to }
										: { from: b, to: v.to }
								}
								d.normalizeTransferResult = _
								function w(v, b) {
									return v === void 0 ? [] : Array.isArray(v) ? v.map((k) => _(k, b)) : [_(v, b)]
								}
								d.normalizeForwardResult = w
								function C(v, b) {
									let k = w(typeof v == 'object' && 'redirect' in v ? v.redirect : v, b)
									return k.length === 0
										? { remain: b, redirect: k }
										: typeof v == 'object' && 'remain' in v
										? { remain: v.remain, redirect: k }
										: { redirect: k }
								}
								d.normalizeRedirectResult = C
							}
						}),
						YD = le({
							'node_modules/vnopts/lib/schemas/choice.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = Es(),
									c = cp(),
									D = class extends E.Schema {
										constructor(g) {
											super(g),
												(this._choices = c.mapFromArray(
													g.choices.map((l) => (l && typeof l == 'object' ? l : { value: l })),
													'value'
												))
										}
										expected(g) {
											let { descriptor: l } = g,
												p = Array.from(this._choices.keys())
													.map((x) => this._choices.get(x))
													.filter((x) => !x.deprecated)
													.map((x) => x.value)
													.sort(c.comparePrimitive)
													.map(l.value),
												f = p.slice(0, -2),
												y = p.slice(-2)
											return f.concat(y.join(' or ')).join(', ')
										}
										validate(g) {
											return this._choices.has(g)
										}
										deprecated(g) {
											let l = this._choices.get(g)
											return l && l.deprecated ? { value: g } : !1
										}
										forward(g) {
											let l = this._choices.get(g)
											return l ? l.forward : void 0
										}
										redirect(g) {
											let l = this._choices.get(g)
											return l ? l.redirect : void 0
										}
									}
								d.ChoiceSchema = D
							}
						}),
						C1 = le({
							'node_modules/vnopts/lib/schemas/number.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = Es(),
									c = class extends E.Schema {
										expected() {
											return 'a number'
										}
										validate(D, g) {
											return typeof D == 'number'
										}
									}
								d.NumberSchema = c
							}
						}),
						XD = le({
							'node_modules/vnopts/lib/schemas/integer.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = cp(),
									c = C1(),
									D = class extends c.NumberSchema {
										expected() {
											return 'an integer'
										}
										validate(g, l) {
											return l.normalizeValidateResult(super.validate(g, l), g) === !0 && E.isInt(g)
										}
									}
								d.IntegerSchema = D
							}
						}),
						KD = le({
							'node_modules/vnopts/lib/schemas/string.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = Es(),
									c = class extends E.Schema {
										expected() {
											return 'a string'
										}
										validate(D) {
											return typeof D == 'string'
										}
									}
								d.StringSchema = c
							}
						}),
						ZD = le({
							'node_modules/vnopts/lib/schemas/index.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = (ys(), Mn(os))
								E.__exportStar(HD(), d),
									E.__exportStar(JD(), d),
									E.__exportStar(zD(), d),
									E.__exportStar(QD(), d),
									E.__exportStar(YD(), d),
									E.__exportStar(XD(), d),
									E.__exportStar(C1(), d),
									E.__exportStar(KD(), d)
							}
						}),
						ey = le({
							'node_modules/vnopts/lib/defaults.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = x1(),
									c = b1(),
									D = T1(),
									g = A1()
								;(d.defaultDescriptor = E.apiDescriptor),
									(d.defaultUnknownHandler = g.levenUnknownHandler),
									(d.defaultInvalidHandler = D.commonInvalidHandler),
									(d.defaultDeprecatedHandler = c.commonDeprecatedHandler)
							}
						}),
						ty = le({
							'node_modules/vnopts/lib/normalize.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = ey(),
									c = cp()
								d.normalize = (g, l, p) => new D(l, p).normalize(g)
								var D = class {
									constructor(g, l) {
										let {
											logger: p = console,
											descriptor: f = E.defaultDescriptor,
											unknown: y = E.defaultUnknownHandler,
											invalid: x = E.defaultInvalidHandler,
											deprecated: _ = E.defaultDeprecatedHandler
										} = l || {}
										;(this._utils = {
											descriptor: f,
											logger: p || { warn: () => {} },
											schemas: c.recordFromArray(g, 'name'),
											normalizeDefaultResult: c.normalizeDefaultResult,
											normalizeDeprecatedResult: c.normalizeDeprecatedResult,
											normalizeForwardResult: c.normalizeForwardResult,
											normalizeRedirectResult: c.normalizeRedirectResult,
											normalizeValidateResult: c.normalizeValidateResult
										}),
											(this._unknownHandler = y),
											(this._invalidHandler = x),
											(this._deprecatedHandler = _),
											this.cleanHistory()
									}
									cleanHistory() {
										this._hasDeprecationWarned = c.createAutoChecklist()
									}
									normalize(g) {
										let l = {},
											p = [g],
											f = () => {
												for (; p.length !== 0; ) {
													let y = p.shift(),
														x = this._applyNormalization(y, l)
													p.push(...x)
												}
											}
										f()
										for (let y of Object.keys(this._utils.schemas)) {
											let x = this._utils.schemas[y]
											if (!(y in l)) {
												let _ = c.normalizeDefaultResult(x.default(this._utils))
												'value' in _ && p.push({ [y]: _.value })
											}
										}
										f()
										for (let y of Object.keys(this._utils.schemas)) {
											let x = this._utils.schemas[y]
											y in l && (l[y] = x.postprocess(l[y], this._utils))
										}
										return l
									}
									_applyNormalization(g, l) {
										let p = [],
											[f, y] = c.partition(Object.keys(g), (x) => x in this._utils.schemas)
										for (let x of f) {
											let _ = this._utils.schemas[x],
												w = _.preprocess(g[x], this._utils),
												C = c.normalizeValidateResult(_.validate(w, this._utils), w)
											if (C !== !0) {
												let { value: q } = C,
													G = this._invalidHandler(x, q, this._utils)
												throw typeof G == 'string' ? new Error(G) : G
											}
											let v = (q) => {
													let { from: G, to: O } = q
													p.push(typeof O == 'string' ? { [O]: G } : { [O.key]: O.value })
												},
												b = (q) => {
													let { value: G, redirectTo: O } = q,
														U = c.normalizeDeprecatedResult(_.deprecated(G, this._utils), w, !0)
													if (U !== !1)
														if (U === !0)
															this._hasDeprecationWarned(x) ||
																this._utils.logger.warn(this._deprecatedHandler(x, O, this._utils))
														else
															for (let { value: j } of U) {
																let H = { key: x, value: j }
																if (!this._hasDeprecationWarned(H)) {
																	let W = typeof O == 'string' ? { key: O, value: j } : O
																	this._utils.logger.warn(
																		this._deprecatedHandler(H, W, this._utils)
																	)
																}
															}
												}
											c.normalizeForwardResult(_.forward(w, this._utils), w).forEach(v)
											let k = c.normalizeRedirectResult(_.redirect(w, this._utils), w)
											if ((k.redirect.forEach(v), 'remain' in k)) {
												let q = k.remain
												;(l[x] = x in l ? _.overlap(l[x], q, this._utils) : q), b({ value: q })
											}
											for (let { from: q, to: G } of k.redirect) b({ value: q, redirectTo: G })
										}
										for (let x of y) {
											let _ = g[x],
												w = this._unknownHandler(x, _, this._utils)
											if (w)
												for (let C of Object.keys(w)) {
													let v = { [C]: w[C] }
													C in this._utils.schemas ? p.push(v) : Object.assign(l, v)
												}
										}
										return p
									}
								}
								d.Normalizer = D
							}
						}),
						ny = le({
							'node_modules/vnopts/lib/index.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = (ys(), Mn(os))
								E.__exportStar($D(), d),
									E.__exportStar(WD(), d),
									E.__exportStar(ZD(), d),
									E.__exportStar(ty(), d),
									E.__exportStar(Es(), d)
							}
						}),
						ry = le({
							'src/main/options-normalizer.js'(d, E) {
								'use strict'
								ge()
								var c = ny(),
									D = Ur(),
									g = {
										key: (C) => (C.length === 1 ? `-${C}` : `--${C}`),
										value: (C) => c.apiDescriptor.value(C),
										pair: (C) => {
											let { key: v, value: b } = C
											return b === !1
												? `--no-${v}`
												: b === !0
												? g.key(v)
												: b === ''
												? `${g.key(v)} without an argument`
												: `${g.key(v)}=${b}`
										}
									},
									l = (C) => {
										let { colorsModule: v, levenshteinDistance: b } = C
										return class extends c.ChoiceSchema {
											constructor(k) {
												let { name: q, flags: G } = k
												super({ name: q, choices: G }), (this._flags = [...G].sort())
											}
											preprocess(k, q) {
												if (typeof k == 'string' && k.length > 0 && !this._flags.includes(k)) {
													let G = this._flags.find((O) => b(O, k) < 3)
													if (G)
														return (
															q.logger.warn(
																[
																	`Unknown flag ${v.yellow(q.descriptor.value(k))},`,
																	`did you mean ${v.blue(q.descriptor.value(G))}?`
																].join(' ')
															),
															G
														)
												}
												return k
											}
											expected() {
												return 'a flag'
											}
										}
									},
									p
								function f(C, v) {
									let {
											logger: b = !1,
											isCLI: k = !1,
											passThrough: q = !1,
											colorsModule: G = null,
											levenshteinDistance: O = null
										} = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
										U = q
											? Array.isArray(q)
												? ($, T) => (q.includes($) ? { [$]: T } : void 0)
												: ($, T) => ({ [$]: T })
											: ($, T, R) => {
													let m = R.schemas,
														{ _: S } = m,
														L = Ye(m, Re)
													return c.levenUnknownHandler(
														$,
														T,
														Object.assign(Object.assign({}, R), {}, { schemas: L })
													)
											  },
										j = k ? g : c.apiDescriptor,
										H = y(v, { isCLI: k, colorsModule: G, levenshteinDistance: O }),
										W = new c.Normalizer(H, { logger: b, unknown: U, descriptor: j }),
										re = b !== !1
									re && p && (W._hasDeprecationWarned = p)
									let A = W.normalize(C)
									return (
										re && (p = W._hasDeprecationWarned),
										k && A['plugin-search'] === !1 && (A['plugin-search-dir'] = !1),
										A
									)
								}
								function y(C, v) {
									let { isCLI: b, colorsModule: k, levenshteinDistance: q } = v,
										G = []
									b && G.push(c.AnySchema.create({ name: '_' }))
									for (let O of C)
										G.push(
											x(O, { isCLI: b, optionInfos: C, colorsModule: k, levenshteinDistance: q })
										),
											O.alias &&
												b &&
												G.push(c.AliasSchema.create({ name: O.alias, sourceName: O.name }))
									return G
								}
								function x(C, v) {
									let { isCLI: b, optionInfos: k, colorsModule: q, levenshteinDistance: G } = v,
										{ name: O } = C
									if (O === 'plugin-search-dir' || O === 'pluginSearchDirs')
										return c.AnySchema.create({
											name: O,
											preprocess(W) {
												return W === !1 || (W = Array.isArray(W) ? W : [W]), W
											},
											validate(W) {
												return W === !1 ? !0 : W.every((re) => typeof re == 'string')
											},
											expected() {
												return 'false or paths to plugin search dir'
											}
										})
									let U = { name: O },
										j,
										H = {}
									switch (C.type) {
										case 'int':
											;(j = c.IntegerSchema), b && (U.preprocess = Number)
											break
										case 'string':
											j = c.StringSchema
											break
										case 'choice':
											;(j = c.ChoiceSchema),
												(U.choices = C.choices.map((W) =>
													typeof W == 'object' && W.redirect
														? Object.assign(
																Object.assign({}, W),
																{},
																{ redirect: { to: { key: C.name, value: W.redirect } } }
														  )
														: W
												))
											break
										case 'boolean':
											j = c.BooleanSchema
											break
										case 'flag':
											;(j = l({ colorsModule: q, levenshteinDistance: G })),
												(U.flags = k.flatMap((W) =>
													[
														W.alias,
														W.description && W.name,
														W.oppositeDescription && `no-${W.name}`
													].filter(Boolean)
												))
											break
										case 'path':
											j = c.StringSchema
											break
										default:
											throw new Error(`Unexpected type ${C.type}`)
									}
									if (
										(C.exception
											? (U.validate = (W, re, A) => C.exception(W) || re.validate(W, A))
											: (U.validate = (W, re, A) => W === void 0 || re.validate(W, A)),
										C.redirect &&
											(H.redirect = (W) =>
												W ? { to: { key: C.redirect.option, value: C.redirect.value } } : void 0),
										C.deprecated && (H.deprecated = !0),
										b && !C.array)
									) {
										let W = U.preprocess || ((re) => re)
										U.preprocess = (re, A, $) => A.preprocess(W(Array.isArray(re) ? D(re) : re), $)
									}
									return C.array
										? c.ArraySchema.create(
												Object.assign(
													Object.assign(
														Object.assign(
															{},
															b ? { preprocess: (W) => (Array.isArray(W) ? W : [W]) } : {}
														),
														H
													),
													{},
													{ valueSchema: j.create(U) }
												)
										  )
										: j.create(Object.assign(Object.assign({}, U), H))
								}
								function _(C, v, b) {
									return f(C, v, b)
								}
								function w(C, v, b) {
									return f(C, v, Object.assign({ isCLI: !0 }, b))
								}
								E.exports = { normalizeApiOptions: _, normalizeCliOptions: w }
							}
						}),
						Qr = le({
							'src/language-js/loc.js'(d, E) {
								'use strict'
								ge()
								var c = rp()
								function D(y) {
									var x, _
									let w = y.range ? y.range[0] : y.start,
										C =
											(x = (_ = y.declaration) === null || _ === void 0 ? void 0 : _.decorators) !==
												null && x !== void 0
												? x
												: y.decorators
									return c(C) ? Math.min(D(C[0]), w) : w
								}
								function g(y) {
									return y.range ? y.range[1] : y.end
								}
								function l(y, x) {
									let _ = D(y)
									return Number.isInteger(_) && _ === D(x)
								}
								function p(y, x) {
									let _ = g(y)
									return Number.isInteger(_) && _ === g(x)
								}
								function f(y, x) {
									return l(y, x) && p(y, x)
								}
								E.exports = { locStart: D, locEnd: g, hasSameLocStart: l, hasSameLoc: f }
							}
						}),
						iy = le({
							'src/main/load-parser.js'(d, E) {
								ge(), (E.exports = () => {})
							}
						}),
						sy = le({
							'scripts/build/shims/babel-highlight.cjs'(d, E) {
								'use strict'
								ge()
								var c = Hu(),
									D = { shouldHighlight: () => !1, getChalk: () => c }
								E.exports = D
							}
						}),
						oy = le({
							'node_modules/@babel/code-frame/lib/index.js'(d) {
								'use strict'
								ge(),
									Object.defineProperty(d, '__esModule', { value: !0 }),
									(d.codeFrameColumns = p),
									(d.default = f)
								var E = sy(),
									c = !1
								function D(y) {
									return { gutter: y.grey, marker: y.red.bold, message: y.red.bold }
								}
								var g = /\r\n|[\n\r\u2028\u2029]/
								function l(y, x, _) {
									let w = Object.assign({ column: 0, line: -1 }, y.start),
										C = Object.assign({}, w, y.end),
										{ linesAbove: v = 2, linesBelow: b = 3 } = _ || {},
										k = w.line,
										q = w.column,
										G = C.line,
										O = C.column,
										U = Math.max(k - (v + 1), 0),
										j = Math.min(x.length, G + b)
									k === -1 && (U = 0), G === -1 && (j = x.length)
									let H = G - k,
										W = {}
									if (H)
										for (let re = 0; re <= H; re++) {
											let A = re + k
											if (!q) W[A] = !0
											else if (re === 0) {
												let $ = x[A - 1].length
												W[A] = [q, $ - q + 1]
											} else if (re === H) W[A] = [0, O]
											else {
												let $ = x[A - re].length
												W[A] = [0, $]
											}
										}
									else q === O ? (q ? (W[k] = [q, 0]) : (W[k] = !0)) : (W[k] = [q, O - q])
									return { start: U, end: j, markerLines: W }
								}
								function p(y, x) {
									let _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
										w = (_.highlightCode || _.forceColor) && (0, E.shouldHighlight)(_),
										C = (0, E.getChalk)(_),
										v = D(C),
										b = (W, re) => (w ? W(re) : re),
										k = y.split(g),
										{ start: q, end: G, markerLines: O } = l(x, k, _),
										U = x.start && typeof x.start.column == 'number',
										j = String(G).length,
										H = (w ? (0, E.default)(y, _) : y)
											.split(g, G)
											.slice(q, G)
											.map((W, re) => {
												let A = q + 1 + re,
													$ = ` ${` ${A}`.slice(-j)} |`,
													T = O[A],
													R = !O[A + 1]
												if (T) {
													let m = ''
													if (Array.isArray(T)) {
														let S = W.slice(0, Math.max(T[0] - 1, 0)).replace(/[^\t]/g, ' '),
															L = T[1] || 1
														;(m = [
															`
 `,
															b(v.gutter, $.replace(/\d/g, ' ')),
															' ',
															S,
															b(v.marker, '^').repeat(L)
														].join('')),
															R && _.message && (m += ' ' + b(v.message, _.message))
													}
													return [
														b(v.marker, '>'),
														b(v.gutter, $),
														W.length > 0 ? ` ${W}` : '',
														m
													].join('')
												} else return ` ${b(v.gutter, $)}${W.length > 0 ? ` ${W}` : ''}`
											}).join(`
`)
									return (
										_.message &&
											!U &&
											(H = `${' '.repeat(j + 1)}${_.message}
${H}`),
										w ? C.reset(H) : H
									)
								}
								function f(y, x, _) {
									let w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}
									if (!c) {
										c = !0
										let C =
											'Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.'
										if (mr.emitWarning) mr.emitWarning(C, 'DeprecationWarning')
										else {
											let v = new Error(C)
											;(v.name = 'DeprecationWarning'), console.warn(new Error(C))
										}
									}
									return (_ = Math.max(_, 0)), p(y, { start: { column: _, line: x } }, w)
								}
							}
						}),
						pp = le({
							'src/main/parser.js'(d, E) {
								'use strict'
								ge()
								var { ConfigError: c } = wa(),
									D = Qr(),
									g = iy(),
									{ locStart: l, locEnd: p } = D,
									f = Object.getOwnPropertyNames,
									y = Object.getOwnPropertyDescriptor
								function x(C) {
									let v = {}
									for (let b of C.plugins)
										if (b.parsers)
											for (let k of f(b.parsers)) Object.defineProperty(v, k, y(b.parsers, k))
									return v
								}
								function _(C) {
									let v = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : x(C)
									if (typeof C.parser == 'function')
										return { parse: C.parser, astFormat: 'estree', locStart: l, locEnd: p }
									if (typeof C.parser == 'string') {
										if (Object.prototype.hasOwnProperty.call(v, C.parser)) return v[C.parser]
										throw new c(
											`Couldn't resolve parser "${C.parser}". Parsers must be explicitly added to the standalone bundle.`
										)
									}
								}
								function w(C, v) {
									let b = x(v),
										k = Object.defineProperties(
											{},
											Object.fromEntries(
												Object.keys(b).map((G) => [
													G,
													{
														enumerable: !0,
														get() {
															return b[G].parse
														}
													}
												])
											)
										),
										q = _(v, b)
									try {
										return (
											q.preprocess && (C = q.preprocess(C, v)), { text: C, ast: q.parse(C, k, v) }
										)
									} catch (G) {
										let { loc: O } = G
										if (O) {
											let { codeFrameColumns: U } = oy()
											throw (
												((G.codeFrame = U(C, O, { highlightCode: !0 })),
												(G.message +=
													`
` + G.codeFrame),
												G)
											)
										}
										throw G
									}
								}
								E.exports = { parse: w, resolveParser: _ }
							}
						}),
						S1 = le({
							'src/main/options.js'(d, E) {
								'use strict'
								ge()
								var c = vD(),
									{ UndefinedParserError: D } = wa(),
									{ getSupportInfo: g } = np(),
									l = ry(),
									{ resolveParser: p } = pp(),
									f = {
										astFormat: 'estree',
										printer: {},
										originalText: void 0,
										locStart: null,
										locEnd: null
									}
								function y(w) {
									let C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
										v = Object.assign({}, w),
										b = g({ plugins: w.plugins, showUnreleased: !0, showDeprecated: !0 }).options,
										k = Object.assign(
											Object.assign({}, f),
											Object.fromEntries(
												b.filter((j) => j.default !== void 0).map((j) => [j.name, j.default])
											)
										)
									if (!v.parser) {
										if (!v.filepath)
											(C.logger || console).warn(
												"No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."
											),
												(v.parser = 'babel')
										else if (((v.parser = _(v.filepath, v.plugins)), !v.parser))
											throw new D(`No parser could be inferred for file: ${v.filepath}`)
									}
									let q = p(
										l.normalizeApiOptions(v, [b.find((j) => j.name === 'parser')], {
											passThrough: !0,
											logger: !1
										})
									)
									;(v.astFormat = q.astFormat), (v.locEnd = q.locEnd), (v.locStart = q.locStart)
									let G = x(v)
									v.printer = G.printers[v.astFormat]
									let O = Object.fromEntries(
											b
												.filter((j) => j.pluginDefaults && j.pluginDefaults[G.name] !== void 0)
												.map((j) => [j.name, j.pluginDefaults[G.name]])
										),
										U = Object.assign(Object.assign({}, k), O)
									for (let [j, H] of Object.entries(U))
										(v[j] === null || v[j] === void 0) && (v[j] = H)
									return (
										v.parser === 'json' && (v.trailingComma = 'none'),
										l.normalizeApiOptions(v, b, Object.assign({ passThrough: Object.keys(f) }, C))
									)
								}
								function x(w) {
									let { astFormat: C } = w
									if (!C) throw new Error('getPlugin() requires astFormat to be set')
									let v = w.plugins.find((b) => b.printers && b.printers[C])
									if (!v) throw new Error(`Couldn't find plugin for AST format "${C}"`)
									return v
								}
								function _(w, C) {
									let v = c.basename(w).toLowerCase(),
										b = g({ plugins: C })
											.languages.filter((k) => k.since !== null)
											.find(
												(k) =>
													(k.extensions && k.extensions.some((q) => v.endsWith(q))) ||
													(k.filenames && k.filenames.some((q) => q.toLowerCase() === v))
											)
									return b && b.parsers[0]
								}
								E.exports = { normalize: y, hiddenDefaults: f, inferParser: _ }
							}
						}),
						ay = le({
							'src/main/massage-ast.js'(d, E) {
								'use strict'
								ge()
								function c(D, g, l) {
									if (Array.isArray(D)) return D.map((x) => c(x, g, l)).filter(Boolean)
									if (!D || typeof D != 'object') return D
									let p = g.printer.massageAstNode,
										f
									p && p.ignoredProperties ? (f = p.ignoredProperties) : (f = new Set())
									let y = {}
									for (let [x, _] of Object.entries(D))
										!f.has(x) && typeof _ != 'function' && (y[x] = c(_, g, D))
									if (p) {
										let x = p(D, y, l)
										if (x === null) return
										if (x) return x
									}
									return y
								}
								E.exports = c
							}
						}),
						Ia = le({
							'scripts/build/shims/assert.cjs'(d, E) {
								'use strict'
								ge()
								var c = () => {}
								;(c.ok = c), (c.strictEqual = c), (E.exports = c)
							}
						}),
						Sr = le({
							'src/main/comments.js'(d, E) {
								'use strict'
								ge()
								var c = Ia(),
									{
										builders: {
											line: D,
											hardline: g,
											breakParent: l,
											indent: p,
											lineSuffix: f,
											join: y,
											cursor: x
										}
									} = dn(),
									{
										hasNewline: _,
										skipNewline: w,
										skipSpaces: C,
										isPreviousLineEmpty: v,
										addLeadingComment: b,
										addDanglingComment: k,
										addTrailingComment: q
									} = wn(),
									G = new WeakMap()
								function O(J, Z, ne) {
									if (!J) return
									let { printer: ee, locStart: ce, locEnd: z } = Z
									if (ne) {
										if (ee.canAttachComment && ee.canAttachComment(J)) {
											let te
											for (
												te = ne.length - 1;
												te >= 0 && !(ce(ne[te]) <= ce(J) && z(ne[te]) <= z(J));
												--te
											);
											ne.splice(te + 1, 0, J)
											return
										}
									} else if (G.has(J)) return G.get(J)
									let ye =
										(ee.getCommentChildNodes && ee.getCommentChildNodes(J, Z)) ||
										(typeof J == 'object' &&
											Object.entries(J)
												.filter((te) => {
													let [X] = te
													return (
														X !== 'enclosingNode' &&
														X !== 'precedingNode' &&
														X !== 'followingNode' &&
														X !== 'tokens' &&
														X !== 'comments' &&
														X !== 'parent'
													)
												})
												.map((te) => {
													let [, X] = te
													return X
												}))
									if (ye) {
										ne || ((ne = []), G.set(J, ne))
										for (let te of ye) O(te, Z, ne)
										return ne
									}
								}
								function U(J, Z, ne, ee) {
									let { locStart: ce, locEnd: z } = ne,
										ye = ce(Z),
										te = z(Z),
										X = O(J, ne),
										De,
										Fe,
										ve = 0,
										$e = X.length
									for (; ve < $e; ) {
										let ie = (ve + $e) >> 1,
											fe = X[ie],
											Be = ce(fe),
											Me = z(fe)
										if (Be <= ye && te <= Me) return U(fe, Z, ne, fe)
										if (Me <= ye) {
											;(De = fe), (ve = ie + 1)
											continue
										}
										if (te <= Be) {
											;(Fe = fe), ($e = ie)
											continue
										}
										throw new Error('Comment location overlaps with node location')
									}
									if (ee && ee.type === 'TemplateLiteral') {
										let { quasis: ie } = ee,
											fe = R(ie, Z, ne)
										De && R(ie, De, ne) !== fe && (De = null),
											Fe && R(ie, Fe, ne) !== fe && (Fe = null)
									}
									return { enclosingNode: ee, precedingNode: De, followingNode: Fe }
								}
								var j = () => !1
								function H(J, Z, ne, ee) {
									if (!Array.isArray(J)) return
									let ce = [],
										{
											locStart: z,
											locEnd: ye,
											printer: { handleComments: te = {} }
										} = ee,
										{
											avoidAstMutation: X,
											ownLine: De = j,
											endOfLine: Fe = j,
											remaining: ve = j
										} = te,
										$e = J.map((ie, fe) =>
											Object.assign(
												Object.assign({}, U(Z, ie, ee)),
												{},
												{
													comment: ie,
													text: ne,
													options: ee,
													ast: Z,
													isLastComment: J.length - 1 === fe
												}
											)
										)
									for (let [ie, fe] of $e.entries()) {
										let {
											comment: Be,
											precedingNode: Me,
											enclosingNode: Dt,
											followingNode: me,
											text: ae,
											options: xe,
											ast: Ce,
											isLastComment: Ge
										} = fe
										if (
											xe.parser === 'json' ||
											xe.parser === 'json5' ||
											xe.parser === '__js_expression' ||
											xe.parser === '__vue_expression' ||
											xe.parser === '__vue_ts_expression'
										) {
											if (z(Be) - z(Ce) <= 0) {
												b(Ce, Be)
												continue
											}
											if (ye(Be) - ye(Ce) >= 0) {
												q(Ce, Be)
												continue
											}
										}
										let nt
										if (
											(X
												? (nt = [fe])
												: ((Be.enclosingNode = Dt),
												  (Be.precedingNode = Me),
												  (Be.followingNode = me),
												  (nt = [Be, ae, xe, Ce, Ge])),
											re(ae, xe, $e, ie))
										)
											(Be.placement = 'ownLine'),
												De(...nt) || (me ? b(me, Be) : Me ? q(Me, Be) : k(Dt || Ce, Be))
										else if (A(ae, xe, $e, ie))
											(Be.placement = 'endOfLine'),
												Fe(...nt) || (Me ? q(Me, Be) : me ? b(me, Be) : k(Dt || Ce, Be))
										else if (((Be.placement = 'remaining'), !ve(...nt)))
											if (Me && me) {
												let ot = ce.length
												ot > 0 && ce[ot - 1].followingNode !== me && $(ce, ae, xe), ce.push(fe)
											} else Me ? q(Me, Be) : me ? b(me, Be) : k(Dt || Ce, Be)
									}
									if (($(ce, ne, ee), !X))
										for (let ie of J)
											delete ie.precedingNode, delete ie.enclosingNode, delete ie.followingNode
								}
								var W = (J) => !/[\S\n\u2028\u2029]/.test(J)
								function re(J, Z, ne, ee) {
									let { comment: ce, precedingNode: z } = ne[ee],
										{ locStart: ye, locEnd: te } = Z,
										X = ye(ce)
									if (z)
										for (let De = ee - 1; De >= 0; De--) {
											let { comment: Fe, precedingNode: ve } = ne[De]
											if (ve !== z || !W(J.slice(te(Fe), X))) break
											X = ye(Fe)
										}
									return _(J, X, { backwards: !0 })
								}
								function A(J, Z, ne, ee) {
									let { comment: ce, followingNode: z } = ne[ee],
										{ locStart: ye, locEnd: te } = Z,
										X = te(ce)
									if (z)
										for (let De = ee + 1; De < ne.length; De++) {
											let { comment: Fe, followingNode: ve } = ne[De]
											if (ve !== z || !W(J.slice(X, ye(Fe)))) break
											X = te(Fe)
										}
									return _(J, X)
								}
								function $(J, Z, ne) {
									let ee = J.length
									if (ee === 0) return
									let { precedingNode: ce, followingNode: z, enclosingNode: ye } = J[0],
										te = (ne.printer.getGapRegex && ne.printer.getGapRegex(ye)) || /^[\s(]*$/,
										X = ne.locStart(z),
										De
									for (De = ee; De > 0; --De) {
										let { comment: Fe, precedingNode: ve, followingNode: $e } = J[De - 1]
										c.strictEqual(ve, ce), c.strictEqual($e, z)
										let ie = Z.slice(ne.locEnd(Fe), X)
										if (te.test(ie)) X = ne.locStart(Fe)
										else break
									}
									for (let [Fe, { comment: ve }] of J.entries()) Fe < De ? q(ce, ve) : b(z, ve)
									for (let Fe of [ce, z])
										Fe.comments &&
											Fe.comments.length > 1 &&
											Fe.comments.sort((ve, $e) => ne.locStart(ve) - ne.locStart($e))
									J.length = 0
								}
								function T(J, Z) {
									let ne = J.getValue()
									return (ne.printed = !0), Z.printer.printComment(J, Z)
								}
								function R(J, Z, ne) {
									let ee = ne.locStart(Z) - 1
									for (let ce = 1; ce < J.length; ++ce) if (ee < ne.locStart(J[ce])) return ce - 1
									return 0
								}
								function m(J, Z) {
									let ne = J.getValue(),
										ee = [T(J, Z)],
										{ printer: ce, originalText: z, locStart: ye, locEnd: te } = Z
									if (ce.isBlockComment && ce.isBlockComment(ne)) {
										let De = _(z, te(ne)) ? (_(z, ye(ne), { backwards: !0 }) ? g : D) : ' '
										ee.push(De)
									} else ee.push(g)
									let X = w(z, C(z, te(ne)))
									return X !== !1 && _(z, X) && ee.push(g), ee
								}
								function S(J, Z) {
									let ne = J.getValue(),
										ee = T(J, Z),
										{ printer: ce, originalText: z, locStart: ye } = Z,
										te = ce.isBlockComment && ce.isBlockComment(ne)
									if (_(z, ye(ne), { backwards: !0 })) {
										let De = v(z, ne, ye)
										return f([g, De ? g : '', ee])
									}
									let X = [' ', ee]
									return te || (X = [f(X), l]), X
								}
								function L(J, Z, ne, ee) {
									let ce = [],
										z = J.getValue()
									return !z ||
										!z.comments ||
										(J.each(() => {
											let ye = J.getValue()
											!ye.leading && !ye.trailing && (!ee || ee(ye)) && ce.push(T(J, Z))
										}, 'comments'),
										ce.length === 0)
										? ''
										: ne
										? y(g, ce)
										: p([g, y(g, ce)])
								}
								function P(J, Z, ne) {
									let ee = J.getValue()
									if (!ee) return {}
									let ce = ee.comments || []
									ne && (ce = ce.filter((X) => !ne.has(X)))
									let z = ee === Z.cursorNode
									if (ce.length === 0) {
										let X = z ? x : ''
										return { leading: X, trailing: X }
									}
									let ye = [],
										te = []
									return (
										J.each(() => {
											let X = J.getValue()
											if (ne && ne.has(X)) return
											let { leading: De, trailing: Fe } = X
											De ? ye.push(m(J, Z)) : Fe && te.push(S(J, Z))
										}, 'comments'),
										z && (ye.unshift(x), te.push(x)),
										{ leading: ye, trailing: te }
									)
								}
								function M(J, Z, ne, ee) {
									let { leading: ce, trailing: z } = P(J, ne, ee)
									return !ce && !z ? Z : [ce, Z, z]
								}
								function V(J) {
									if (J)
										for (let Z of J) {
											if (!Z.printed)
												throw new Error(
													'Comment "' +
														Z.value.trim() +
														'" was not printed. Please report this error!'
												)
											delete Z.printed
										}
								}
								E.exports = {
									attach: H,
									printComments: M,
									printCommentsSeparately: P,
									printDanglingComments: L,
									getSortedChildNodes: O,
									ensureAllCommentsPrinted: V
								}
							}
						}),
						uy = le({
							'src/common/ast-path.js'(d, E) {
								'use strict'
								ge()
								var c = Ur()
								function D(p, f) {
									let y = g(p.stack, f)
									return y === -1 ? null : p.stack[y]
								}
								function g(p, f) {
									for (let y = p.length - 1; y >= 0; y -= 2) {
										let x = p[y]
										if (x && !Array.isArray(x) && --f < 0) return y
									}
									return -1
								}
								var l = class {
									constructor(p) {
										this.stack = [p]
									}
									getName() {
										let { stack: p } = this,
											{ length: f } = p
										return f > 1 ? p[f - 2] : null
									}
									getValue() {
										return c(this.stack)
									}
									getNode() {
										let p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0
										return D(this, p)
									}
									getParentNode() {
										let p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0
										return D(this, p + 1)
									}
									call(p) {
										let { stack: f } = this,
											{ length: y } = f,
											x = c(f)
										for (
											var _ = arguments.length, w = new Array(_ > 1 ? _ - 1 : 0), C = 1;
											C < _;
											C++
										)
											w[C - 1] = arguments[C]
										for (let b of w) (x = x[b]), f.push(b, x)
										let v = p(this)
										return (f.length = y), v
									}
									callParent(p) {
										let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
											y = g(this.stack, f + 1),
											x = this.stack.splice(y + 1),
											_ = p(this)
										return this.stack.push(...x), _
									}
									each(p) {
										let { stack: f } = this,
											{ length: y } = f,
											x = c(f)
										for (
											var _ = arguments.length, w = new Array(_ > 1 ? _ - 1 : 0), C = 1;
											C < _;
											C++
										)
											w[C - 1] = arguments[C]
										for (let v of w) (x = x[v]), f.push(v, x)
										for (let v = 0; v < x.length; ++v)
											f.push(v, x[v]), p(this, v, x), (f.length -= 2)
										f.length = y
									}
									map(p) {
										let f = []
										for (
											var y = arguments.length, x = new Array(y > 1 ? y - 1 : 0), _ = 1;
											_ < y;
											_++
										)
											x[_ - 1] = arguments[_]
										return (
											this.each((w, C, v) => {
												f[C] = p(w, C, v)
											}, ...x),
											f
										)
									}
									try(p) {
										let { stack: f } = this,
											y = [...f]
										try {
											return p()
										} finally {
											;(f.length = 0), f.push(...y)
										}
									}
									match() {
										let p = this.stack.length - 1,
											f = null,
											y = this.stack[p--]
										for (var x = arguments.length, _ = new Array(x), w = 0; w < x; w++)
											_[w] = arguments[w]
										for (let C of _) {
											if (y === void 0) return !1
											let v = null
											if (
												(typeof f == 'number' &&
													((v = f), (f = this.stack[p--]), (y = this.stack[p--])),
												C && !C(y, f, v))
											)
												return !1
											;(f = this.stack[p--]), (y = this.stack[p--])
										}
										return !0
									}
									findAncestor(p) {
										let f = this.stack.length - 1,
											y = null,
											x = this.stack[f--]
										for (; x; ) {
											let _ = null
											if (
												(typeof y == 'number' &&
													((_ = y), (y = this.stack[f--]), (x = this.stack[f--])),
												y !== null && p(x, y, _))
											)
												return x
											;(y = this.stack[f--]), (x = this.stack[f--])
										}
									}
								}
								E.exports = l
							}
						}),
						ly = le({
							'src/main/multiparser.js'(d, E) {
								'use strict'
								ge()
								var {
										utils: { stripTrailingHardline: c }
									} = dn(),
									{ normalize: D } = S1(),
									g = Sr()
								function l(f, y, x, _) {
									if (x.printer.embed && x.embeddedLanguageFormatting === 'auto')
										return x.printer.embed(f, y, (w, C, v) => p(w, C, x, _, v), x)
								}
								function p(f, y, x, _) {
									let { stripTrailingHardline: w = !1 } =
											arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {},
										C = D(
											Object.assign(
												Object.assign(Object.assign({}, x), y),
												{},
												{ parentParser: x.parser, originalText: f }
											),
											{ passThrough: !0 }
										),
										v = pp().parse(f, C),
										{ ast: b } = v
									f = v.text
									let k = b.comments
									delete b.comments,
										g.attach(k, b, f, C),
										(C[Symbol.for('comments')] = k || []),
										(C[Symbol.for('tokens')] = b.tokens || [])
									let q = _(b, C)
									return (
										g.ensureAllCommentsPrinted(k),
										w ? (typeof q == 'string' ? q.replace(/(?:\r?\n)*$/, '') : c(q)) : q
									)
								}
								E.exports = { printSubtree: l }
							}
						}),
						cy = le({
							'src/main/ast-to-doc.js'(d, E) {
								'use strict'
								ge()
								var c = uy(),
									{
										builders: { hardline: D, addAlignmentToDoc: g },
										utils: { propagateBreaks: l }
									} = dn(),
									{ printComments: p } = Sr(),
									f = ly()
								function y(w, C) {
									let v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
										{ printer: b } = C
									b.preprocess && (w = b.preprocess(w, C))
									let k = new Map(),
										q = new c(w),
										G = O()
									return v > 0 && (G = g([D, G], v, C.tabWidth)), l(G), G
									function O(j, H) {
										return j === void 0 || j === q
											? U(H)
											: Array.isArray(j)
											? q.call(() => U(H), ...j)
											: q.call(() => U(H), j)
									}
									function U(j) {
										let H = q.getValue(),
											W = H && typeof H == 'object' && j === void 0
										if (W && k.has(H)) return k.get(H)
										let re = _(q, C, O, j)
										return W && k.set(H, re), re
									}
								}
								function x(w, C) {
									let { originalText: v, [Symbol.for('comments')]: b, locStart: k, locEnd: q } = C,
										G = k(w),
										O = q(w),
										U = new Set()
									for (let j of b) k(j) >= G && q(j) <= O && ((j.printed = !0), U.add(j))
									return { doc: v.slice(G, O), printedComments: U }
								}
								function _(w, C, v, b) {
									let k = w.getValue(),
										{ printer: q } = C,
										G,
										O
									if (q.hasPrettierIgnore && q.hasPrettierIgnore(w))
										({ doc: G, printedComments: O } = x(k, C))
									else {
										if (k)
											try {
												G = f.printSubtree(w, v, C, y)
											} catch (U) {
												if (globalThis.PRETTIER_DEBUG) throw U
											}
										G || (G = q.print(w, C, v, b))
									}
									return (
										(!q.willPrintOwnComments || !q.willPrintOwnComments(w, C)) &&
											(G = p(w, G, C, O)),
										G
									)
								}
								E.exports = y
							}
						}),
						py = le({
							'src/main/range-util.js'(d, E) {
								'use strict'
								ge()
								var c = Ia(),
									D = Sr(),
									g = (b) => {
										let { parser: k } = b
										return k === 'json' || k === 'json5' || k === 'json-stringify'
									}
								function l(b, k) {
									let q = [b.node, ...b.parentNodes],
										G = new Set([k.node, ...k.parentNodes])
									return q.find((O) => _.has(O.type) && G.has(O))
								}
								function p(b) {
									let k = b.length - 1
									for (;;) {
										let q = b[k]
										if (q && (q.type === 'Program' || q.type === 'File')) k--
										else break
									}
									return b.slice(0, k + 1)
								}
								function f(b, k, q) {
									let { locStart: G, locEnd: O } = q,
										U = b.node,
										j = k.node
									if (U === j) return { startNode: U, endNode: j }
									let H = G(b.node)
									for (let re of p(k.parentNodes))
										if (G(re) >= H) j = re
										else break
									let W = O(k.node)
									for (let re of p(b.parentNodes)) {
										if (O(re) <= W) U = re
										else break
										if (U === j) break
									}
									return { startNode: U, endNode: j }
								}
								function y(b, k, q, G) {
									let O = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [],
										U = arguments.length > 5 ? arguments[5] : void 0,
										{ locStart: j, locEnd: H } = q,
										W = j(b),
										re = H(b)
									if (
										!(
											k > re ||
											k < W ||
											(U === 'rangeEnd' && k === W) ||
											(U === 'rangeStart' && k === re)
										)
									) {
										for (let A of D.getSortedChildNodes(b, q)) {
											let $ = y(A, k, q, G, [b, ...O], U)
											if ($) return $
										}
										if (!G || G(b, O[0])) return { node: b, parentNodes: O }
									}
								}
								function x(b, k) {
									return (
										k !== 'DeclareExportDeclaration' &&
										b !== 'TypeParameterDeclaration' &&
										(b === 'Directive' ||
											b === 'TypeAlias' ||
											b === 'TSExportAssignment' ||
											b.startsWith('Declare') ||
											b.startsWith('TSDeclare') ||
											b.endsWith('Statement') ||
											b.endsWith('Declaration'))
									)
								}
								var _ = new Set([
										'ObjectExpression',
										'ArrayExpression',
										'StringLiteral',
										'NumericLiteral',
										'BooleanLiteral',
										'NullLiteral',
										'UnaryExpression',
										'TemplateLiteral'
									]),
									w = new Set([
										'OperationDefinition',
										'FragmentDefinition',
										'VariableDefinition',
										'TypeExtensionDefinition',
										'ObjectTypeDefinition',
										'FieldDefinition',
										'DirectiveDefinition',
										'EnumTypeDefinition',
										'EnumValueDefinition',
										'InputValueDefinition',
										'InputObjectTypeDefinition',
										'SchemaDefinition',
										'OperationTypeDefinition',
										'InterfaceTypeDefinition',
										'UnionTypeDefinition',
										'ScalarTypeDefinition'
									])
								function C(b, k, q) {
									if (!k) return !1
									switch (b.parser) {
										case 'flow':
										case 'babel':
										case 'babel-flow':
										case 'babel-ts':
										case 'typescript':
										case 'acorn':
										case 'espree':
										case 'meriyah':
										case '__babel_estree':
											return x(k.type, q && q.type)
										case 'json':
										case 'json5':
										case 'json-stringify':
											return _.has(k.type)
										case 'graphql':
											return w.has(k.kind)
										case 'vue':
											return k.tag !== 'root'
									}
									return !1
								}
								function v(b, k, q) {
									let { rangeStart: G, rangeEnd: O, locStart: U, locEnd: j } = k
									c.ok(O > G)
									let H = b.slice(G, O).search(/\S/),
										W = H === -1
									if (!W) for (G += H; O > G && !/\S/.test(b[O - 1]); --O);
									let re = y(q, G, k, (R, m) => C(k, R, m), [], 'rangeStart'),
										A = W ? re : y(q, O, k, (R) => C(k, R), [], 'rangeEnd')
									if (!re || !A) return { rangeStart: 0, rangeEnd: 0 }
									let $, T
									if (g(k)) {
										let R = l(re, A)
										;($ = R), (T = R)
									} else ({ startNode: $, endNode: T } = f(re, A, k))
									return { rangeStart: Math.min(U($), U(T)), rangeEnd: Math.max(j($), j(T)) }
								}
								E.exports = { calculateRange: v, findNodeAtOffset: y }
							}
						}),
						fy = le({
							'src/main/core.js'(d, E) {
								'use strict'
								ge()
								var { diffArrays: c } = yo(),
									{
										printer: { printDocToString: D },
										debug: { printDocToDebug: g }
									} = dn(),
									{ getAlignmentSize: l } = wn(),
									{
										guessEndOfLine: p,
										convertEndOfLineToChars: f,
										countEndOfLineChars: y,
										normalizeEndOfLine: x
									} = Ds(),
									_ = S1().normalize,
									w = ay(),
									C = Sr(),
									v = pp(),
									b = cy(),
									k = py(),
									q = '\uFEFF',
									G = Symbol('cursor')
								function O(T, R, m) {
									let S = R.comments
									return (
										S && (delete R.comments, C.attach(S, R, T, m)),
										(m[Symbol.for('comments')] = S || []),
										(m[Symbol.for('tokens')] = R.tokens || []),
										(m.originalText = T),
										S
									)
								}
								function U(T, R) {
									let m = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0
									if (!T || T.trim().length === 0)
										return { formatted: '', cursorOffset: -1, comments: [] }
									let { ast: S, text: L } = v.parse(T, R)
									if (R.cursorOffset >= 0) {
										let J = k.findNodeAtOffset(S, R.cursorOffset, R)
										J && J.node && (R.cursorNode = J.node)
									}
									let P = O(L, S, R),
										M = b(S, R, m),
										V = D(M, R)
									if ((C.ensureAllCommentsPrinted(P), m > 0)) {
										let J = V.formatted.trim()
										V.cursorNodeStart !== void 0 && (V.cursorNodeStart -= V.formatted.indexOf(J)),
											(V.formatted = J + f(R.endOfLine))
									}
									if (R.cursorOffset >= 0) {
										let J, Z, ne, ee, ce
										if (
											(R.cursorNode && V.cursorNodeText
												? ((J = R.locStart(R.cursorNode)),
												  (Z = L.slice(J, R.locEnd(R.cursorNode))),
												  (ne = R.cursorOffset - J),
												  (ee = V.cursorNodeStart),
												  (ce = V.cursorNodeText))
												: ((J = 0), (Z = L), (ne = R.cursorOffset), (ee = 0), (ce = V.formatted)),
											Z === ce)
										)
											return { formatted: V.formatted, cursorOffset: ee + ne, comments: P }
										let z = [...Z]
										z.splice(ne, 0, G)
										let ye = [...ce],
											te = c(z, ye),
											X = ee
										for (let De of te)
											if (De.removed) {
												if (De.value.includes(G)) break
											} else X += De.count
										return { formatted: V.formatted, cursorOffset: X, comments: P }
									}
									return { formatted: V.formatted, cursorOffset: -1, comments: P }
								}
								function j(T, R) {
									let { ast: m, text: S } = v.parse(T, R),
										{ rangeStart: L, rangeEnd: P } = k.calculateRange(S, R, m),
										M = S.slice(L, P),
										V = Math.min(
											L,
											S.lastIndexOf(
												`
`,
												L
											) + 1
										),
										J = S.slice(V, L).match(/^\s*/)[0],
										Z = l(J, R.tabWidth),
										ne = U(
											M,
											Object.assign(
												Object.assign({}, R),
												{},
												{
													rangeStart: 0,
													rangeEnd: Number.POSITIVE_INFINITY,
													cursorOffset:
														R.cursorOffset > L && R.cursorOffset <= P ? R.cursorOffset - L : -1,
													endOfLine: 'lf'
												}
											),
											Z
										),
										ee = ne.formatted.trimEnd(),
										{ cursorOffset: ce } = R
									ce > P
										? (ce += ee.length - M.length)
										: ne.cursorOffset >= 0 && (ce = ne.cursorOffset + L)
									let z = S.slice(0, L) + ee + S.slice(P)
									if (R.endOfLine !== 'lf') {
										let ye = f(R.endOfLine)
										ce >= 0 &&
											ye ===
												`\r
` &&
											(ce += y(
												z.slice(0, ce),
												`
`
											)),
											(z = z.replace(/\n/g, ye))
									}
									return { formatted: z, cursorOffset: ce, comments: ne.comments }
								}
								function H(T, R, m) {
									return typeof R != 'number' || Number.isNaN(R) || R < 0 || R > T.length ? m : R
								}
								function W(T, R) {
									let { cursorOffset: m, rangeStart: S, rangeEnd: L } = R
									return (
										(m = H(T, m, -1)),
										(S = H(T, S, 0)),
										(L = H(T, L, T.length)),
										Object.assign(
											Object.assign({}, R),
											{},
											{ cursorOffset: m, rangeStart: S, rangeEnd: L }
										)
									)
								}
								function re(T, R) {
									let { cursorOffset: m, rangeStart: S, rangeEnd: L, endOfLine: P } = W(T, R),
										M = T.charAt(0) === q
									if (
										(M && ((T = T.slice(1)), m--, S--, L--),
										P === 'auto' && (P = p(T)),
										T.includes('\r'))
									) {
										let V = (J) =>
											y(
												T.slice(0, Math.max(J, 0)),
												`\r
`
											)
										;(m -= V(m)), (S -= V(S)), (L -= V(L)), (T = x(T))
									}
									return {
										hasBOM: M,
										text: T,
										options: W(
											T,
											Object.assign(
												Object.assign({}, R),
												{},
												{ cursorOffset: m, rangeStart: S, rangeEnd: L, endOfLine: P }
											)
										)
									}
								}
								function A(T, R) {
									let m = v.resolveParser(R)
									return !m.hasPragma || m.hasPragma(T)
								}
								function $(T, R) {
									let { hasBOM: m, text: S, options: L } = re(T, _(R))
									if ((L.rangeStart >= L.rangeEnd && S !== '') || (L.requirePragma && !A(S, L)))
										return { formatted: T, cursorOffset: R.cursorOffset, comments: [] }
									let P
									return (
										L.rangeStart > 0 || L.rangeEnd < S.length
											? (P = j(S, L))
											: (!L.requirePragma &&
													L.insertPragma &&
													L.printer.insertPragma &&
													!A(S, L) &&
													(S = L.printer.insertPragma(S)),
											  (P = U(S, L))),
										m && ((P.formatted = q + P.formatted), P.cursorOffset >= 0 && P.cursorOffset++),
										P
									)
								}
								E.exports = {
									formatWithCursor: $,
									parse(T, R, m) {
										let { text: S, options: L } = re(T, _(R)),
											P = v.parse(S, L)
										return m && (P.ast = w(P.ast, L)), P
									},
									formatAST(T, R) {
										R = _(R)
										let m = b(T, R)
										return D(m, R)
									},
									formatDoc(T, R) {
										return $(
											g(T),
											Object.assign(Object.assign({}, R), {}, { parser: '__js_expression' })
										).formatted
									},
									printToDoc(T, R) {
										R = _(R)
										let { ast: m, text: S } = v.parse(T, R)
										return O(S, m, R), b(m, R)
									},
									printDocToString(T, R) {
										return D(T, _(R))
									}
								}
							}
						}),
						dy = le({
							'src/common/util-shared.js'(d, E) {
								'use strict'
								ge()
								var {
									getMaxContinuousCount: c,
									getStringWidth: D,
									getAlignmentSize: g,
									getIndentSize: l,
									skip: p,
									skipWhitespace: f,
									skipSpaces: y,
									skipNewline: x,
									skipToLineEnd: _,
									skipEverythingButNewLine: w,
									skipInlineComment: C,
									skipTrailingComment: v,
									hasNewline: b,
									hasNewlineInRange: k,
									hasSpaces: q,
									isNextLineEmpty: G,
									isNextLineEmptyAfterIndex: O,
									isPreviousLineEmpty: U,
									getNextNonSpaceNonCommentCharacterIndex: j,
									makeString: H,
									addLeadingComment: W,
									addDanglingComment: re,
									addTrailingComment: A
								} = wn()
								E.exports = {
									getMaxContinuousCount: c,
									getStringWidth: D,
									getAlignmentSize: g,
									getIndentSize: l,
									skip: p,
									skipWhitespace: f,
									skipSpaces: y,
									skipNewline: x,
									skipToLineEnd: _,
									skipEverythingButNewLine: w,
									skipInlineComment: C,
									skipTrailingComment: v,
									hasNewline: b,
									hasNewlineInRange: k,
									hasSpaces: q,
									isNextLineEmpty: G,
									isNextLineEmptyAfterIndex: O,
									isPreviousLineEmpty: U,
									getNextNonSpaceNonCommentCharacterIndex: j,
									makeString: H,
									addLeadingComment: W,
									addDanglingComment: re,
									addTrailingComment: A
								}
							}
						}),
						Ms = le({
							'src/utils/create-language.js'(d, E) {
								'use strict'
								ge(),
									(E.exports = function (c, D) {
										let { languageId: g } = c,
											l = Ye(c, we)
										return Object.assign(Object.assign({ linguistLanguageId: g }, l), D(c))
									})
							}
						}),
						hy = le({
							'node_modules/esutils/lib/ast.js'(d, E) {
								ge(),
									(function () {
										'use strict'
										function c(y) {
											if (y == null) return !1
											switch (y.type) {
												case 'ArrayExpression':
												case 'AssignmentExpression':
												case 'BinaryExpression':
												case 'CallExpression':
												case 'ConditionalExpression':
												case 'FunctionExpression':
												case 'Identifier':
												case 'Literal':
												case 'LogicalExpression':
												case 'MemberExpression':
												case 'NewExpression':
												case 'ObjectExpression':
												case 'SequenceExpression':
												case 'ThisExpression':
												case 'UnaryExpression':
												case 'UpdateExpression':
													return !0
											}
											return !1
										}
										function D(y) {
											if (y == null) return !1
											switch (y.type) {
												case 'DoWhileStatement':
												case 'ForInStatement':
												case 'ForStatement':
												case 'WhileStatement':
													return !0
											}
											return !1
										}
										function g(y) {
											if (y == null) return !1
											switch (y.type) {
												case 'BlockStatement':
												case 'BreakStatement':
												case 'ContinueStatement':
												case 'DebuggerStatement':
												case 'DoWhileStatement':
												case 'EmptyStatement':
												case 'ExpressionStatement':
												case 'ForInStatement':
												case 'ForStatement':
												case 'IfStatement':
												case 'LabeledStatement':
												case 'ReturnStatement':
												case 'SwitchStatement':
												case 'ThrowStatement':
												case 'TryStatement':
												case 'VariableDeclaration':
												case 'WhileStatement':
												case 'WithStatement':
													return !0
											}
											return !1
										}
										function l(y) {
											return g(y) || (y != null && y.type === 'FunctionDeclaration')
										}
										function p(y) {
											switch (y.type) {
												case 'IfStatement':
													return y.alternate != null ? y.alternate : y.consequent
												case 'LabeledStatement':
												case 'ForStatement':
												case 'ForInStatement':
												case 'WhileStatement':
												case 'WithStatement':
													return y.body
											}
											return null
										}
										function f(y) {
											var x
											if (y.type !== 'IfStatement' || y.alternate == null) return !1
											x = y.consequent
											do {
												if (x.type === 'IfStatement' && x.alternate == null) return !0
												x = p(x)
											} while (x)
											return !1
										}
										E.exports = {
											isExpression: c,
											isStatement: g,
											isIterationStatement: D,
											isSourceElement: l,
											isProblematicIfStatement: f,
											trailingStatement: p
										}
									})()
							}
						}),
						N1 = le({
							'node_modules/esutils/lib/code.js'(d, E) {
								ge(),
									(function () {
										'use strict'
										var c, D, g, l, p, f
										;(D = {
											NonAsciiIdentifierStart:
												/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
											NonAsciiIdentifierPart:
												/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
										}),
											(c = {
												NonAsciiIdentifierStart:
													/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
												NonAsciiIdentifierPart:
													/[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
											})
										function y(O) {
											return 48 <= O && O <= 57
										}
										function x(O) {
											return (48 <= O && O <= 57) || (97 <= O && O <= 102) || (65 <= O && O <= 70)
										}
										function _(O) {
											return O >= 48 && O <= 55
										}
										g = [
											5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239,
											8287, 12288, 65279
										]
										function w(O) {
											return (
												O === 32 ||
												O === 9 ||
												O === 11 ||
												O === 12 ||
												O === 160 ||
												(O >= 5760 && g.indexOf(O) >= 0)
											)
										}
										function C(O) {
											return O === 10 || O === 13 || O === 8232 || O === 8233
										}
										function v(O) {
											if (O <= 65535) return String.fromCharCode(O)
											var U = String.fromCharCode(Math.floor((O - 65536) / 1024) + 55296),
												j = String.fromCharCode(((O - 65536) % 1024) + 56320)
											return U + j
										}
										for (l = new Array(128), f = 0; f < 128; ++f)
											l[f] = (f >= 97 && f <= 122) || (f >= 65 && f <= 90) || f === 36 || f === 95
										for (p = new Array(128), f = 0; f < 128; ++f)
											p[f] =
												(f >= 97 && f <= 122) ||
												(f >= 65 && f <= 90) ||
												(f >= 48 && f <= 57) ||
												f === 36 ||
												f === 95
										function b(O) {
											return O < 128 ? l[O] : D.NonAsciiIdentifierStart.test(v(O))
										}
										function k(O) {
											return O < 128 ? p[O] : D.NonAsciiIdentifierPart.test(v(O))
										}
										function q(O) {
											return O < 128 ? l[O] : c.NonAsciiIdentifierStart.test(v(O))
										}
										function G(O) {
											return O < 128 ? p[O] : c.NonAsciiIdentifierPart.test(v(O))
										}
										E.exports = {
											isDecimalDigit: y,
											isHexDigit: x,
											isOctalDigit: _,
											isWhiteSpace: w,
											isLineTerminator: C,
											isIdentifierStartES5: b,
											isIdentifierPartES5: k,
											isIdentifierStartES6: q,
											isIdentifierPartES6: G
										}
									})()
							}
						}),
						my = le({
							'node_modules/esutils/lib/keyword.js'(d, E) {
								ge(),
									(function () {
										'use strict'
										var c = N1()
										function D(b) {
											switch (b) {
												case 'implements':
												case 'interface':
												case 'package':
												case 'private':
												case 'protected':
												case 'public':
												case 'static':
												case 'let':
													return !0
												default:
													return !1
											}
										}
										function g(b, k) {
											return !k && b === 'yield' ? !1 : l(b, k)
										}
										function l(b, k) {
											if (k && D(b)) return !0
											switch (b.length) {
												case 2:
													return b === 'if' || b === 'in' || b === 'do'
												case 3:
													return b === 'var' || b === 'for' || b === 'new' || b === 'try'
												case 4:
													return (
														b === 'this' ||
														b === 'else' ||
														b === 'case' ||
														b === 'void' ||
														b === 'with' ||
														b === 'enum'
													)
												case 5:
													return (
														b === 'while' ||
														b === 'break' ||
														b === 'catch' ||
														b === 'throw' ||
														b === 'const' ||
														b === 'yield' ||
														b === 'class' ||
														b === 'super'
													)
												case 6:
													return (
														b === 'return' ||
														b === 'typeof' ||
														b === 'delete' ||
														b === 'switch' ||
														b === 'export' ||
														b === 'import'
													)
												case 7:
													return b === 'default' || b === 'finally' || b === 'extends'
												case 8:
													return b === 'function' || b === 'continue' || b === 'debugger'
												case 10:
													return b === 'instanceof'
												default:
													return !1
											}
										}
										function p(b, k) {
											return b === 'null' || b === 'true' || b === 'false' || g(b, k)
										}
										function f(b, k) {
											return b === 'null' || b === 'true' || b === 'false' || l(b, k)
										}
										function y(b) {
											return b === 'eval' || b === 'arguments'
										}
										function x(b) {
											var k, q, G
											if (b.length === 0 || ((G = b.charCodeAt(0)), !c.isIdentifierStartES5(G)))
												return !1
											for (k = 1, q = b.length; k < q; ++k)
												if (((G = b.charCodeAt(k)), !c.isIdentifierPartES5(G))) return !1
											return !0
										}
										function _(b, k) {
											return (b - 55296) * 1024 + (k - 56320) + 65536
										}
										function w(b) {
											var k, q, G, O, U
											if (b.length === 0) return !1
											for (U = c.isIdentifierStartES6, k = 0, q = b.length; k < q; ++k) {
												if (((G = b.charCodeAt(k)), 55296 <= G && G <= 56319)) {
													if ((++k, k >= q || ((O = b.charCodeAt(k)), !(56320 <= O && O <= 57343))))
														return !1
													G = _(G, O)
												}
												if (!U(G)) return !1
												U = c.isIdentifierPartES6
											}
											return !0
										}
										function C(b, k) {
											return x(b) && !p(b, k)
										}
										function v(b, k) {
											return w(b) && !f(b, k)
										}
										E.exports = {
											isKeywordES5: g,
											isKeywordES6: l,
											isReservedWordES5: p,
											isReservedWordES6: f,
											isRestrictedWord: y,
											isIdentifierNameES5: x,
											isIdentifierNameES6: w,
											isIdentifierES5: C,
											isIdentifierES6: v
										}
									})()
							}
						}),
						gy = le({
							'node_modules/esutils/lib/utils.js'(d) {
								ge(),
									(function () {
										'use strict'
										;(d.ast = hy()), (d.code = N1()), (d.keyword = my())
									})()
							}
						}),
						js = le({
							'src/language-js/utils/is-block-comment.js'(d, E) {
								'use strict'
								ge()
								var c = new Set(['Block', 'CommentBlock', 'MultiLine']),
									D = (g) => c.has(g?.type)
								E.exports = D
							}
						}),
						Dy = le({
							'src/language-js/utils/is-node-matches.js'(d, E) {
								'use strict'
								ge()
								function c(g, l) {
									let p = l.split('.')
									for (let f = p.length - 1; f >= 0; f--) {
										let y = p[f]
										if (f === 0) return g.type === 'Identifier' && g.name === y
										if (
											g.type !== 'MemberExpression' ||
											g.optional ||
											g.computed ||
											g.property.type !== 'Identifier' ||
											g.property.name !== y
										)
											return !1
										g = g.object
									}
								}
								function D(g, l) {
									return l.some((p) => c(g, p))
								}
								E.exports = D
							}
						}),
						er = le({
							'src/language-js/utils/index.js'(d, E) {
								'use strict'
								ge()
								var c = gy().keyword.isIdentifierNameES5,
									{
										getLast: D,
										hasNewline: g,
										skipWhitespace: l,
										isNonEmptyArray: p,
										isNextLineEmptyAfterIndex: f,
										getStringWidth: y
									} = wn(),
									{ locStart: x, locEnd: _, hasSameLocStart: w } = Qr(),
									C = js(),
									v = Dy(),
									b = '(?:(?=.)\\s)',
									k = new RegExp(`^${b}*:`),
									q = new RegExp(`^${b}*::`)
								function G(Y) {
									var We, Zt
									return (
										((We = Y.extra) === null || We === void 0 ? void 0 : We.parenthesized) &&
										C((Zt = Y.trailingComments) === null || Zt === void 0 ? void 0 : Zt[0]) &&
										k.test(Y.trailingComments[0].value)
									)
								}
								function O(Y) {
									let We = Y?.[0]
									return C(We) && q.test(We.value)
								}
								function U(Y, We) {
									if (!Y || typeof Y != 'object') return !1
									if (Array.isArray(Y)) return Y.some((Ln) => U(Ln, We))
									let Zt = We(Y)
									return typeof Zt == 'boolean' ? Zt : Object.values(Y).some((Ln) => U(Ln, We))
								}
								function j(Y) {
									return (
										Y.type === 'AssignmentExpression' ||
										Y.type === 'BinaryExpression' ||
										Y.type === 'LogicalExpression' ||
										Y.type === 'NGPipeExpression' ||
										Y.type === 'ConditionalExpression' ||
										Be(Y) ||
										Me(Y) ||
										Y.type === 'SequenceExpression' ||
										Y.type === 'TaggedTemplateExpression' ||
										Y.type === 'BindExpression' ||
										(Y.type === 'UpdateExpression' && !Y.prefix) ||
										gi(Y) ||
										Y.type === 'TSNonNullExpression'
									)
								}
								function H(Y) {
									var We, Zt, Ln, In, oi, pr
									return Y.expressions
										? Y.expressions[0]
										: (We =
												(Zt =
													(Ln =
														(In =
															(oi = (pr = Y.left) !== null && pr !== void 0 ? pr : Y.test) !==
																null && oi !== void 0
																? oi
																: Y.callee) !== null && In !== void 0
															? In
															: Y.object) !== null && Ln !== void 0
														? Ln
														: Y.tag) !== null && Zt !== void 0
													? Zt
													: Y.argument) !== null && We !== void 0
										? We
										: Y.expression
								}
								function W(Y, We) {
									if (We.expressions) return ['expressions', 0]
									if (We.left) return ['left']
									if (We.test) return ['test']
									if (We.object) return ['object']
									if (We.callee) return ['callee']
									if (We.tag) return ['tag']
									if (We.argument) return ['argument']
									if (We.expression) return ['expression']
									throw new Error('Unexpected node has no left side.')
								}
								function re(Y) {
									return (Y = new Set(Y)), (We) => Y.has(We?.type)
								}
								var A = re([
										'Line',
										'CommentLine',
										'SingleLine',
										'HashbangComment',
										'HTMLOpen',
										'HTMLClose'
									]),
									$ = re([
										'ExportDefaultDeclaration',
										'ExportDefaultSpecifier',
										'DeclareExportDeclaration',
										'ExportNamedDeclaration',
										'ExportAllDeclaration'
									])
								function T(Y) {
									let We = Y.getParentNode()
									return Y.getName() === 'declaration' && $(We) ? We : null
								}
								var R = re([
									'BooleanLiteral',
									'DirectiveLiteral',
									'Literal',
									'NullLiteral',
									'NumericLiteral',
									'BigIntLiteral',
									'DecimalLiteral',
									'RegExpLiteral',
									'StringLiteral',
									'TemplateLiteral',
									'TSTypeLiteral',
									'JSXText'
								])
								function m(Y) {
									return (
										Y.type === 'NumericLiteral' ||
										(Y.type === 'Literal' && typeof Y.value == 'number')
									)
								}
								function S(Y) {
									return (
										Y.type === 'UnaryExpression' &&
										(Y.operator === '+' || Y.operator === '-') &&
										m(Y.argument)
									)
								}
								function L(Y) {
									return (
										Y.type === 'StringLiteral' ||
										(Y.type === 'Literal' && typeof Y.value == 'string')
									)
								}
								var P = re(['ObjectTypeAnnotation', 'TSTypeLiteral', 'TSMappedType']),
									M = re(['FunctionExpression', 'ArrowFunctionExpression'])
								function V(Y) {
									return (
										Y.type === 'FunctionExpression' ||
										(Y.type === 'ArrowFunctionExpression' && Y.body.type === 'BlockStatement')
									)
								}
								function J(Y) {
									return (
										Be(Y) &&
										Y.callee.type === 'Identifier' &&
										['async', 'inject', 'fakeAsync', 'waitForAsync'].includes(Y.callee.name)
									)
								}
								var Z = re(['JSXElement', 'JSXFragment'])
								function ne(Y, We) {
									if (Y.parentParser !== 'markdown' && Y.parentParser !== 'mdx') return !1
									let Zt = We.getNode()
									if (!Zt.expression || !Z(Zt.expression)) return !1
									let Ln = We.getParentNode()
									return Ln.type === 'Program' && Ln.body.length === 1
								}
								function ee(Y) {
									return Y.kind === 'get' || Y.kind === 'set'
								}
								function ce(Y) {
									return ee(Y) || w(Y, Y.value)
								}
								function z(Y) {
									return (
										(Y.type === 'ObjectTypeProperty' || Y.type === 'ObjectTypeInternalSlot') &&
										Y.value.type === 'FunctionTypeAnnotation' &&
										!Y.static &&
										!ce(Y)
									)
								}
								function ye(Y) {
									return (
										(Y.type === 'TypeAnnotation' || Y.type === 'TSTypeAnnotation') &&
										Y.typeAnnotation.type === 'FunctionTypeAnnotation' &&
										!Y.static &&
										!w(Y, Y.typeAnnotation)
									)
								}
								var te = re(['BinaryExpression', 'LogicalExpression', 'NGPipeExpression'])
								function X(Y) {
									return Me(Y) || (Y.type === 'BindExpression' && !!Y.object)
								}
								var De = new Set([
									'AnyTypeAnnotation',
									'TSAnyKeyword',
									'NullLiteralTypeAnnotation',
									'TSNullKeyword',
									'ThisTypeAnnotation',
									'TSThisType',
									'NumberTypeAnnotation',
									'TSNumberKeyword',
									'VoidTypeAnnotation',
									'TSVoidKeyword',
									'BooleanTypeAnnotation',
									'TSBooleanKeyword',
									'BigIntTypeAnnotation',
									'TSBigIntKeyword',
									'SymbolTypeAnnotation',
									'TSSymbolKeyword',
									'StringTypeAnnotation',
									'TSStringKeyword',
									'BooleanLiteralTypeAnnotation',
									'StringLiteralTypeAnnotation',
									'BigIntLiteralTypeAnnotation',
									'NumberLiteralTypeAnnotation',
									'TSLiteralType',
									'TSTemplateLiteralType',
									'EmptyTypeAnnotation',
									'MixedTypeAnnotation',
									'TSNeverKeyword',
									'TSObjectKeyword',
									'TSUndefinedKeyword',
									'TSUnknownKeyword'
								])
								function Fe(Y) {
									return Y
										? !!(
												((Y.type === 'GenericTypeAnnotation' || Y.type === 'TSTypeReference') &&
													!Y.typeParameters) ||
												De.has(Y.type)
										  )
										: !1
								}
								function ve(Y) {
									let We = /^(?:before|after)(?:Each|All)$/
									return (
										Y.callee.type === 'Identifier' &&
										We.test(Y.callee.name) &&
										Y.arguments.length === 1
									)
								}
								var $e = [
									'it',
									'it.only',
									'it.skip',
									'describe',
									'describe.only',
									'describe.skip',
									'test',
									'test.only',
									'test.skip',
									'test.step',
									'test.describe',
									'test.describe.only',
									'test.describe.parallel',
									'test.describe.parallel.only',
									'test.describe.serial',
									'test.describe.serial.only',
									'skip',
									'xit',
									'xdescribe',
									'xtest',
									'fit',
									'fdescribe',
									'ftest'
								]
								function ie(Y) {
									return v(Y, $e)
								}
								function fe(Y, We) {
									if (Y.type !== 'CallExpression') return !1
									if (Y.arguments.length === 1) {
										if (J(Y) && We && fe(We)) return M(Y.arguments[0])
										if (ve(Y)) return J(Y.arguments[0])
									} else if (
										(Y.arguments.length === 2 || Y.arguments.length === 3) &&
										(Y.arguments[0].type === 'TemplateLiteral' || L(Y.arguments[0])) &&
										ie(Y.callee)
									)
										return Y.arguments[2] && !m(Y.arguments[2])
											? !1
											: (Y.arguments.length === 2
													? M(Y.arguments[1])
													: V(Y.arguments[1]) && at(Y.arguments[1]).length <= 1) ||
													J(Y.arguments[1])
									return !1
								}
								var Be = re(['CallExpression', 'OptionalCallExpression']),
									Me = re(['MemberExpression', 'OptionalMemberExpression'])
								function Dt(Y) {
									let We = 'expressions'
									Y.type === 'TSTemplateLiteralType' && (We = 'types')
									let Zt = Y[We]
									return Zt.length === 0
										? !1
										: Zt.every((Ln) => {
												if (ln(Ln)) return !1
												if (Ln.type === 'Identifier' || Ln.type === 'ThisExpression') return !0
												if (Me(Ln)) {
													let In = Ln
													for (; Me(In); )
														if (
															(In.property.type !== 'Identifier' &&
																In.property.type !== 'Literal' &&
																In.property.type !== 'StringLiteral' &&
																In.property.type !== 'NumericLiteral') ||
															((In = In.object), ln(In))
														)
															return !1
													return In.type === 'Identifier' || In.type === 'ThisExpression'
												}
												return !1
										  })
								}
								function me(Y, We) {
									return Y === '+' || Y === '-' ? Y + We : We
								}
								function ae(Y, We) {
									let Zt = x(We),
										Ln = l(Y, _(We))
									return Ln !== !1 && Y.slice(Zt, Zt + 2) === '/*' && Y.slice(Ln, Ln + 2) === '*/'
								}
								function xe(Y, We) {
									return Z(We) ? yn(We) : ln(We, Pt.Leading, (Zt) => g(Y, _(Zt)))
								}
								function Ce(Y, We) {
									return (
										We.parser !== 'json' &&
										L(Y.key) &&
										Ie(Y.key).slice(1, -1) === Y.key.value &&
										((c(Y.key.value) &&
											!(
												(We.parser === 'babel-ts' && Y.type === 'ClassProperty') ||
												(We.parser === 'typescript' && Y.type === 'PropertyDefinition')
											)) ||
											(Ge(Y.key.value) &&
												String(Number(Y.key.value)) === Y.key.value &&
												(We.parser === 'babel' ||
													We.parser === 'acorn' ||
													We.parser === 'espree' ||
													We.parser === 'meriyah' ||
													We.parser === '__babel_estree')))
									)
								}
								function Ge(Y) {
									return /^(?:\d+|\d+\.\d+)$/.test(Y)
								}
								function nt(Y, We) {
									let Zt = /^[fx]?(?:describe|it|test)$/
									return (
										We.type === 'TaggedTemplateExpression' &&
										We.quasi === Y &&
										We.tag.type === 'MemberExpression' &&
										We.tag.property.type === 'Identifier' &&
										We.tag.property.name === 'each' &&
										((We.tag.object.type === 'Identifier' && Zt.test(We.tag.object.name)) ||
											(We.tag.object.type === 'MemberExpression' &&
												We.tag.object.property.type === 'Identifier' &&
												(We.tag.object.property.name === 'only' ||
													We.tag.object.property.name === 'skip') &&
												We.tag.object.object.type === 'Identifier' &&
												Zt.test(We.tag.object.object.name)))
									)
								}
								function ot(Y) {
									return Y.quasis.some((We) =>
										We.value.raw.includes(`
`)
									)
								}
								function Ut(Y, We) {
									return (
										((Y.type === 'TemplateLiteral' && ot(Y)) ||
											(Y.type === 'TaggedTemplateExpression' && ot(Y.quasi))) &&
										!g(We, x(Y), { backwards: !0 })
									)
								}
								function vn(Y) {
									if (!ln(Y)) return !1
									let We = D(ke(Y, Pt.Dangling))
									return We && !C(We)
								}
								function Dn(Y) {
									if (Y.length <= 1) return !1
									let We = 0
									for (let Zt of Y)
										if (M(Zt)) {
											if (((We += 1), We > 1)) return !0
										} else if (Be(Zt)) {
											for (let Ln of Zt.arguments) if (M(Ln)) return !0
										}
									return !1
								}
								function Vt(Y) {
									let We = Y.getValue(),
										Zt = Y.getParentNode()
									return (
										Be(We) &&
										Be(Zt) &&
										Zt.callee === We &&
										We.arguments.length > Zt.arguments.length &&
										Zt.arguments.length > 0
									)
								}
								function tn(Y, We) {
									if (We >= 2) return !1
									let Zt = (pr) => tn(pr, We + 1),
										Ln =
											(Y.type === 'Literal' && 'regex' in Y && Y.regex.pattern) ||
											(Y.type === 'RegExpLiteral' && Y.pattern)
									if (Ln && y(Ln) > 5) return !1
									if (
										Y.type === 'Literal' ||
										Y.type === 'BigIntLiteral' ||
										Y.type === 'DecimalLiteral' ||
										Y.type === 'BooleanLiteral' ||
										Y.type === 'NullLiteral' ||
										Y.type === 'NumericLiteral' ||
										Y.type === 'RegExpLiteral' ||
										Y.type === 'StringLiteral' ||
										Y.type === 'Identifier' ||
										Y.type === 'ThisExpression' ||
										Y.type === 'Super' ||
										Y.type === 'PrivateName' ||
										Y.type === 'PrivateIdentifier' ||
										Y.type === 'ArgumentPlaceholder' ||
										Y.type === 'Import'
									)
										return !0
									if (Y.type === 'TemplateLiteral')
										return (
											Y.quasis.every(
												(pr) =>
													!pr.value.raw.includes(`
`)
											) && Y.expressions.every(Zt)
										)
									if (Y.type === 'ObjectExpression')
										return Y.properties.every(
											(pr) => !pr.computed && (pr.shorthand || (pr.value && Zt(pr.value)))
										)
									if (Y.type === 'ArrayExpression')
										return Y.elements.every((pr) => pr === null || Zt(pr))
									if (qr(Y))
										return (Y.type === 'ImportExpression' || tn(Y.callee, We)) && ir(Y).every(Zt)
									if (Me(Y)) return tn(Y.object, We) && tn(Y.property, We)
									let In = { '!': !0, '-': !0, '+': !0, '~': !0 }
									if (Y.type === 'UnaryExpression' && In[Y.operator]) return tn(Y.argument, We)
									let oi = { '++': !0, '--': !0 }
									return Y.type === 'UpdateExpression' && oi[Y.operator]
										? tn(Y.argument, We)
										: Y.type === 'TSNonNullExpression'
										? tn(Y.expression, We)
										: !1
								}
								function Ie(Y) {
									var We, Zt
									return (We = (Zt = Y.extra) === null || Zt === void 0 ? void 0 : Zt.raw) !==
										null && We !== void 0
										? We
										: Y.raw
								}
								function se(Y) {
									return Y
								}
								function je(Y) {
									return Y.filepath && /\.tsx$/i.test(Y.filepath)
								}
								function he(Y) {
									let We = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'es5'
									return (
										(Y.trailingComma === 'es5' && We === 'es5') ||
										(Y.trailingComma === 'all' && (We === 'all' || We === 'es5'))
									)
								}
								function Oe(Y, We) {
									switch (Y.type) {
										case 'BinaryExpression':
										case 'LogicalExpression':
										case 'AssignmentExpression':
										case 'NGPipeExpression':
											return Oe(Y.left, We)
										case 'MemberExpression':
										case 'OptionalMemberExpression':
											return Oe(Y.object, We)
										case 'TaggedTemplateExpression':
											return Y.tag.type === 'FunctionExpression' ? !1 : Oe(Y.tag, We)
										case 'CallExpression':
										case 'OptionalCallExpression':
											return Y.callee.type === 'FunctionExpression' ? !1 : Oe(Y.callee, We)
										case 'ConditionalExpression':
											return Oe(Y.test, We)
										case 'UpdateExpression':
											return !Y.prefix && Oe(Y.argument, We)
										case 'BindExpression':
											return Y.object && Oe(Y.object, We)
										case 'SequenceExpression':
											return Oe(Y.expressions[0], We)
										case 'TSSatisfiesExpression':
										case 'TSAsExpression':
										case 'TSNonNullExpression':
											return Oe(Y.expression, We)
										default:
											return We(Y)
									}
								}
								var wt = { '==': !0, '!=': !0, '===': !0, '!==': !0 },
									mt = { '*': !0, '/': !0, '%': !0 },
									Ue = { '>>': !0, '>>>': !0, '<<': !0 }
								function B(Y, We) {
									return !(
										_e(We) !== _e(Y) ||
										Y === '**' ||
										(wt[Y] && wt[We]) ||
										(We === '%' && mt[Y]) ||
										(Y === '%' && mt[We]) ||
										(We !== Y && mt[We] && mt[Y]) ||
										(Ue[Y] && Ue[We])
									)
								}
								var pe = new Map(
									[
										['|>'],
										['??'],
										['||'],
										['&&'],
										['|'],
										['^'],
										['&'],
										['==', '===', '!=', '!=='],
										['<', '>', '<=', '>=', 'in', 'instanceof'],
										['>>', '<<', '>>>'],
										['+', '-'],
										['*', '/', '%'],
										['**']
									].flatMap((Y, We) => Y.map((Zt) => [Zt, We]))
								)
								function _e(Y) {
									return pe.get(Y)
								}
								function st(Y) {
									return !!Ue[Y] || Y === '|' || Y === '^' || Y === '&'
								}
								function pt(Y) {
									var We
									if (Y.rest) return !0
									let Zt = at(Y)
									return (
										((We = D(Zt)) === null || We === void 0 ? void 0 : We.type) === 'RestElement'
									)
								}
								var jt = new WeakMap()
								function at(Y) {
									if (jt.has(Y)) return jt.get(Y)
									let We = []
									return (
										Y.this && We.push(Y.this),
										Array.isArray(Y.parameters)
											? We.push(...Y.parameters)
											: Array.isArray(Y.params) && We.push(...Y.params),
										Y.rest && We.push(Y.rest),
										jt.set(Y, We),
										We
									)
								}
								function ar(Y, We) {
									let Zt = Y.getValue(),
										Ln = 0,
										In = (oi) => We(oi, Ln++)
									Zt.this && Y.call(In, 'this'),
										Array.isArray(Zt.parameters)
											? Y.each(In, 'parameters')
											: Array.isArray(Zt.params) && Y.each(In, 'params'),
										Zt.rest && Y.call(In, 'rest')
								}
								var Rt = new WeakMap()
								function ir(Y) {
									if (Rt.has(Y)) return Rt.get(Y)
									let We = Y.arguments
									return (
										Y.type === 'ImportExpression' &&
											((We = [Y.source]), Y.attributes && We.push(Y.attributes)),
										Rt.set(Y, We),
										We
									)
								}
								function It(Y, We) {
									let Zt = Y.getValue()
									Zt.type === 'ImportExpression'
										? (Y.call((Ln) => We(Ln, 0), 'source'),
										  Zt.attributes && Y.call((Ln) => We(Ln, 1), 'attributes'))
										: Y.each(We, 'arguments')
								}
								function an(Y) {
									return Y.value.trim() === 'prettier-ignore' && !Y.unignore
								}
								function yn(Y) {
									return Y && (Y.prettierIgnore || ln(Y, Pt.PrettierIgnore))
								}
								function Qn(Y) {
									let We = Y.getValue()
									return yn(We)
								}
								var Pt = {
										Leading: 2,
										Trailing: 4,
										Dangling: 8,
										Block: 16,
										Line: 32,
										PrettierIgnore: 64,
										First: 128,
										Last: 256
									},
									mn = (Y, We) => {
										if ((typeof Y == 'function' && ((We = Y), (Y = 0)), Y || We))
											return (Zt, Ln, In) =>
												!(
													(Y & Pt.Leading && !Zt.leading) ||
													(Y & Pt.Trailing && !Zt.trailing) ||
													(Y & Pt.Dangling && (Zt.leading || Zt.trailing)) ||
													(Y & Pt.Block && !C(Zt)) ||
													(Y & Pt.Line && !A(Zt)) ||
													(Y & Pt.First && Ln !== 0) ||
													(Y & Pt.Last && Ln !== In.length - 1) ||
													(Y & Pt.PrettierIgnore && !an(Zt)) ||
													(We && !We(Zt))
												)
									}
								function ln(Y, We, Zt) {
									if (!p(Y?.comments)) return !1
									let Ln = mn(We, Zt)
									return Ln ? Y.comments.some(Ln) : !0
								}
								function ke(Y, We, Zt) {
									if (!Array.isArray(Y?.comments)) return []
									let Ln = mn(We, Zt)
									return Ln ? Y.comments.filter(Ln) : Y.comments
								}
								var mi = (Y, We) => {
									let { originalText: Zt } = We
									return f(Zt, _(Y))
								}
								function qr(Y) {
									return Be(Y) || Y.type === 'NewExpression' || Y.type === 'ImportExpression'
								}
								function Sn(Y) {
									return (
										Y &&
										(Y.type === 'ObjectProperty' ||
											(Y.type === 'Property' && !Y.method && Y.kind === 'init'))
									)
								}
								function _n(Y) {
									return !!Y.__isUsingHackPipeline
								}
								var Kn = Symbol('ifWithoutBlockAndSameLineComment')
								function gi(Y) {
									return Y.type === 'TSAsExpression' || Y.type === 'TSSatisfiesExpression'
								}
								E.exports = {
									getFunctionParameters: at,
									iterateFunctionParametersPath: ar,
									getCallArguments: ir,
									iterateCallArgumentsPath: It,
									hasRestParameter: pt,
									getLeftSide: H,
									getLeftSidePathName: W,
									getParentExportDeclaration: T,
									getTypeScriptMappedTypeModifier: me,
									hasFlowAnnotationComment: O,
									hasFlowShorthandAnnotationComment: G,
									hasLeadingOwnLineComment: xe,
									hasNakedLeftSide: j,
									hasNode: U,
									hasIgnoreComment: Qn,
									hasNodeIgnoreComment: yn,
									identity: se,
									isBinaryish: te,
									isCallLikeExpression: qr,
									isEnabledHackPipeline: _n,
									isLineComment: A,
									isPrettierIgnoreComment: an,
									isCallExpression: Be,
									isMemberExpression: Me,
									isExportDeclaration: $,
									isFlowAnnotationComment: ae,
									isFunctionCompositionArgs: Dn,
									isFunctionNotation: ce,
									isFunctionOrArrowExpression: M,
									isGetterOrSetter: ee,
									isJestEachTemplateLiteral: nt,
									isJsxNode: Z,
									isLiteral: R,
									isLongCurriedCallExpression: Vt,
									isSimpleCallArgument: tn,
									isMemberish: X,
									isNumericLiteral: m,
									isSignedNumericLiteral: S,
									isObjectProperty: Sn,
									isObjectType: P,
									isObjectTypePropertyAFunction: z,
									isSimpleType: Fe,
									isSimpleNumber: Ge,
									isSimpleTemplateLiteral: Dt,
									isStringLiteral: L,
									isStringPropSafeToUnquote: Ce,
									isTemplateOnItsOwnLine: Ut,
									isTestCall: fe,
									isTheOnlyJsxElementInMarkdown: ne,
									isTSXFile: je,
									isTypeAnnotationAFunction: ye,
									isNextLineEmpty: mi,
									needsHardlineAfterDanglingComment: vn,
									rawText: Ie,
									shouldPrintComma: he,
									isBitwiseOperator: st,
									shouldFlatten: B,
									startsWithNoLookaheadToken: Oe,
									getPrecedence: _e,
									hasComment: ln,
									getComments: ke,
									CommentCheckFlags: Pt,
									markerForIfWithoutBlockAndSameLineComment: Kn,
									isTSTypeExpression: gi
								}
							}
						}),
						Eo = le({
							'src/language-js/print/template-literal.js'(d, E) {
								'use strict'
								ge()
								var c = Ur(),
									{ getStringWidth: D, getIndentSize: g } = wn(),
									{
										builders: {
											join: l,
											hardline: p,
											softline: f,
											group: y,
											indent: x,
											align: _,
											lineSuffixBoundary: w,
											addAlignmentToDoc: C
										},
										printer: { printDocToString: v },
										utils: { mapDoc: b }
									} = dn(),
									{
										isBinaryish: k,
										isJestEachTemplateLiteral: q,
										isSimpleTemplateLiteral: G,
										hasComment: O,
										isMemberExpression: U,
										isTSTypeExpression: j
									} = er()
								function H(R, m, S) {
									let L = R.getValue()
									if (L.type === 'TemplateLiteral' && q(L, R.getParentNode())) {
										let Z = W(R, S, m)
										if (Z) return Z
									}
									let P = 'expressions'
									L.type === 'TSTemplateLiteralType' && (P = 'types')
									let M = [],
										V = R.map(m, P),
										J = G(L)
									return (
										J &&
											(V = V.map(
												(Z) =>
													v(
														Z,
														Object.assign(
															Object.assign({}, S),
															{},
															{ printWidth: Number.POSITIVE_INFINITY }
														)
													).formatted
											)),
										M.push(w, '`'),
										R.each((Z) => {
											let ne = Z.getName()
											if ((M.push(m()), ne < V.length)) {
												let { tabWidth: ee } = S,
													ce = Z.getValue(),
													z = g(ce.value.raw, ee),
													ye = V[ne]
												if (!J) {
													let X = L[P][ne]
													;(O(X) ||
														U(X) ||
														X.type === 'ConditionalExpression' ||
														X.type === 'SequenceExpression' ||
														j(X) ||
														k(X)) &&
														(ye = [x([f, ye]), f])
												}
												let te =
													z === 0 &&
													ce.value.raw.endsWith(`
`)
														? _(Number.NEGATIVE_INFINITY, ye)
														: C(ye, z, ee)
												M.push(y(['${', te, w, '}']))
											}
										}, 'quasis'),
										M.push('`'),
										M
									)
								}
								function W(R, m, S) {
									let L = R.getNode(),
										P = L.quasis[0].value.raw.trim().split(/\s*\|\s*/)
									if (P.length > 1 || P.some((M) => M.length > 0)) {
										m.__inJestEach = !0
										let M = R.map(S, 'expressions')
										m.__inJestEach = !1
										let V = [],
											J = M.map(
												(z) =>
													'${' +
													v(
														z,
														Object.assign(
															Object.assign({}, m),
															{},
															{ printWidth: Number.POSITIVE_INFINITY, endOfLine: 'lf' }
														)
													).formatted +
													'}'
											),
											Z = [{ hasLineBreak: !1, cells: [] }]
										for (let z = 1; z < L.quasis.length; z++) {
											let ye = c(Z),
												te = J[z - 1]
											ye.cells.push(te),
												te.includes(`
`) && (ye.hasLineBreak = !0),
												L.quasis[z].value.raw.includes(`
`) && Z.push({ hasLineBreak: !1, cells: [] })
										}
										let ne = Math.max(P.length, ...Z.map((z) => z.cells.length)),
											ee = Array.from({ length: ne }).fill(0),
											ce = [{ cells: P }, ...Z.filter((z) => z.cells.length > 0)]
										for (let { cells: z } of ce.filter((ye) => !ye.hasLineBreak))
											for (let [ye, te] of z.entries()) ee[ye] = Math.max(ee[ye], D(te))
										return (
											V.push(
												w,
												'`',
												x([
													p,
													l(
														p,
														ce.map((z) =>
															l(
																' | ',
																z.cells.map((ye, te) =>
																	z.hasLineBreak ? ye : ye + ' '.repeat(ee[te] - D(ye))
																)
															)
														)
													)
												]),
												p,
												'`'
											),
											V
										)
									}
								}
								function re(R, m) {
									let S = R.getValue(),
										L = m()
									return O(S) && (L = y([x([f, L]), f])), ['${', L, w, '}']
								}
								function A(R, m) {
									return R.map((S) => re(S, m), 'expressions')
								}
								function $(R, m) {
									return b(R, (S) =>
										typeof S == 'string' ? (m ? S.replace(/(\\*)`/g, '$1$1\\`') : T(S)) : S
									)
								}
								function T(R) {
									return R.replace(/([\\`]|\${)/g, '\\$1')
								}
								E.exports = {
									printTemplateLiteral: H,
									printTemplateExpressions: A,
									escapeTemplateCharacters: $,
									uncookTemplateElementValue: T
								}
							}
						}),
						yy = le({
							'src/language-js/embed/markdown.js'(d, E) {
								'use strict'
								ge()
								var {
										builders: { indent: c, softline: D, literalline: g, dedentToRoot: l }
									} = dn(),
									{ escapeTemplateCharacters: p } = Eo()
								function f(x, _, w) {
									let C = x
											.getValue()
											.quasis[0].value.raw.replace(
												/((?:\\\\)*)\\`/g,
												(q, G) => '\\'.repeat(G.length / 2) + '`'
											),
										v = y(C),
										b = v !== ''
									b && (C = C.replace(new RegExp(`^${v}`, 'gm'), ''))
									let k = p(
										w(C, { parser: 'markdown', __inJsTemplate: !0 }, { stripTrailingHardline: !0 }),
										!0
									)
									return ['`', b ? c([D, k]) : [g, l(k)], D, '`']
								}
								function y(x) {
									let _ = x.match(/^([^\S\n]*)\S/m)
									return _ === null ? '' : _[1]
								}
								E.exports = f
							}
						}),
						Ey = le({
							'src/language-js/embed/css.js'(d, E) {
								'use strict'
								ge()
								var { isNonEmptyArray: c } = wn(),
									{
										builders: { indent: D, hardline: g, softline: l },
										utils: { mapDoc: p, replaceEndOfLine: f, cleanDoc: y }
									} = dn(),
									{ printTemplateExpressions: x } = Eo()
								function _(v, b, k) {
									let q = v.getValue(),
										G = q.quasis.map((W) => W.value.raw),
										O = 0,
										U = G.reduce(
											(W, re, A) =>
												A === 0 ? re : W + '@prettier-placeholder-' + O++ + '-id' + re,
											''
										),
										j = k(U, { parser: 'scss' }, { stripTrailingHardline: !0 }),
										H = x(v, b)
									return w(j, q, H)
								}
								function w(v, b, k) {
									if (b.quasis.length === 1 && !b.quasis[0].value.raw.trim()) return '``'
									let q = C(v, k)
									if (!q) throw new Error("Couldn't insert all the expressions")
									return ['`', D([g, q]), l, '`']
								}
								function C(v, b) {
									if (!c(b)) return v
									let k = 0,
										q = p(y(v), (G) =>
											typeof G != 'string' || !G.includes('@prettier-placeholder')
												? G
												: G.split(/@prettier-placeholder-(\d+)-id/).map((O, U) =>
														U % 2 === 0 ? f(O) : (k++, b[O])
												  )
										)
									return b.length === k ? q : null
								}
								E.exports = _
							}
						}),
						vy = le({
							'src/language-js/embed/graphql.js'(d, E) {
								'use strict'
								ge()
								var {
										builders: { indent: c, join: D, hardline: g }
									} = dn(),
									{ escapeTemplateCharacters: l, printTemplateExpressions: p } = Eo()
								function f(x, _, w) {
									let C = x.getValue(),
										v = C.quasis.length
									if (v === 1 && C.quasis[0].value.raw.trim() === '') return '``'
									let b = p(x, _),
										k = []
									for (let q = 0; q < v; q++) {
										let G = C.quasis[q],
											O = q === 0,
											U = q === v - 1,
											j = G.value.cooked,
											H = j.split(`
`),
											W = H.length,
											re = b[q],
											A = W > 2 && H[0].trim() === '' && H[1].trim() === '',
											$ = W > 2 && H[W - 1].trim() === '' && H[W - 2].trim() === '',
											T = H.every((m) => /^\s*(?:#[^\n\r]*)?$/.test(m))
										if (!U && /#[^\n\r]*$/.test(H[W - 1])) return null
										let R = null
										T
											? (R = y(H))
											: (R = w(j, { parser: 'graphql' }, { stripTrailingHardline: !0 })),
											R
												? ((R = l(R, !1)), !O && A && k.push(''), k.push(R), !U && $ && k.push(''))
												: !O && !U && A && k.push(''),
											re && k.push(re)
									}
									return ['`', c([g, D(g, k)]), g, '`']
								}
								function y(x) {
									let _ = [],
										w = !1,
										C = x.map((v) => v.trim())
									for (let [v, b] of C.entries())
										b !== '' && (C[v - 1] === '' && w ? _.push([g, b]) : _.push(b), (w = !0))
									return _.length === 0 ? null : D(g, _)
								}
								E.exports = f
							}
						}),
						xy = le({
							'src/language-js/embed/html.js'(d, E) {
								'use strict'
								ge()
								var {
										builders: { indent: c, line: D, hardline: g, group: l },
										utils: { mapDoc: p }
									} = dn(),
									{ printTemplateExpressions: f, uncookTemplateElementValue: y } = Eo(),
									x = 0
								function _(w, C, v, b, k) {
									let { parser: q } = k,
										G = w.getValue(),
										O = x
									x = (x + 1) >>> 0
									let U = (S) => `PRETTIER_HTML_PLACEHOLDER_${S}_${O}_IN_JS`,
										j = G.quasis
											.map((S, L, P) =>
												L === P.length - 1 ? S.value.cooked : S.value.cooked + U(L)
											)
											.join(''),
										H = f(w, C)
									if (H.length === 0 && j.trim().length === 0) return '``'
									let W = new RegExp(U('(\\d+)'), 'g'),
										re = 0,
										A = v(
											j,
											{
												parser: q,
												__onHtmlRoot(S) {
													re = S.children.length
												}
											},
											{ stripTrailingHardline: !0 }
										),
										$ = p(A, (S) => {
											if (typeof S != 'string') return S
											let L = [],
												P = S.split(W)
											for (let M = 0; M < P.length; M++) {
												let V = P[M]
												if (M % 2 === 0) {
													V &&
														((V = y(V)),
														b.__embeddedInHtml && (V = V.replace(/<\/(script)\b/gi, '<\\/$1')),
														L.push(V))
													continue
												}
												let J = Number(V)
												L.push(H[J])
											}
											return L
										}),
										T = /^\s/.test(j) ? ' ' : '',
										R = /\s$/.test(j) ? ' ' : '',
										m = b.htmlWhitespaceSensitivity === 'ignore' ? g : T && R ? D : null
									return l(
										m ? ['`', c([m, l($)]), m, '`'] : ['`', T, re > 1 ? c(l($)) : l($), R, '`']
									)
								}
								E.exports = _
							}
						}),
						by = le({
							'src/language-js/embed.js'(d, E) {
								'use strict'
								ge()
								var { hasComment: c, CommentCheckFlags: D, isObjectProperty: g } = er(),
									l = yy(),
									p = Ey(),
									f = vy(),
									y = xy()
								function x(A) {
									if (C(A) || q(A) || G(A) || v(A)) return 'css'
									if (j(A)) return 'graphql'
									if (W(A)) return 'html'
									if (b(A)) return 'angular'
									if (w(A)) return 'markdown'
								}
								function _(A, $, T, R) {
									let m = A.getValue()
									if (m.type !== 'TemplateLiteral' || re(m)) return
									let S = x(A)
									if (S) {
										if (S === 'markdown') return l(A, $, T)
										if (S === 'css') return p(A, $, T)
										if (S === 'graphql') return f(A, $, T)
										if (S === 'html' || S === 'angular') return y(A, $, T, R, { parser: S })
									}
								}
								function w(A) {
									let $ = A.getValue(),
										T = A.getParentNode()
									return (
										T &&
										T.type === 'TaggedTemplateExpression' &&
										$.quasis.length === 1 &&
										T.tag.type === 'Identifier' &&
										(T.tag.name === 'md' || T.tag.name === 'markdown')
									)
								}
								function C(A) {
									let $ = A.getValue(),
										T = A.getParentNode(),
										R = A.getParentNode(1)
									return (
										(R &&
											$.quasis &&
											T.type === 'JSXExpressionContainer' &&
											R.type === 'JSXElement' &&
											R.openingElement.name.name === 'style' &&
											R.openingElement.attributes.some((m) => m.name.name === 'jsx')) ||
										(T &&
											T.type === 'TaggedTemplateExpression' &&
											T.tag.type === 'Identifier' &&
											T.tag.name === 'css') ||
										(T &&
											T.type === 'TaggedTemplateExpression' &&
											T.tag.type === 'MemberExpression' &&
											T.tag.object.name === 'css' &&
											(T.tag.property.name === 'global' || T.tag.property.name === 'resolve'))
									)
								}
								function v(A) {
									return A.match(
										($) => $.type === 'TemplateLiteral',
										($, T) => $.type === 'ArrayExpression' && T === 'elements',
										($, T) =>
											g($) &&
											$.key.type === 'Identifier' &&
											$.key.name === 'styles' &&
											T === 'value',
										...k
									)
								}
								function b(A) {
									return A.match(
										($) => $.type === 'TemplateLiteral',
										($, T) =>
											g($) &&
											$.key.type === 'Identifier' &&
											$.key.name === 'template' &&
											T === 'value',
										...k
									)
								}
								var k = [
									(A, $) => A.type === 'ObjectExpression' && $ === 'properties',
									(A, $) =>
										A.type === 'CallExpression' &&
										A.callee.type === 'Identifier' &&
										A.callee.name === 'Component' &&
										$ === 'arguments',
									(A, $) => A.type === 'Decorator' && $ === 'expression'
								]
								function q(A) {
									let $ = A.getParentNode()
									if (!$ || $.type !== 'TaggedTemplateExpression') return !1
									let T = $.tag.type === 'ParenthesizedExpression' ? $.tag.expression : $.tag
									switch (T.type) {
										case 'MemberExpression':
											return O(T.object) || U(T)
										case 'CallExpression':
											return (
												O(T.callee) ||
												(T.callee.type === 'MemberExpression' &&
													((T.callee.object.type === 'MemberExpression' &&
														(O(T.callee.object.object) || U(T.callee.object))) ||
														(T.callee.object.type === 'CallExpression' &&
															O(T.callee.object.callee))))
											)
										case 'Identifier':
											return T.name === 'css'
										default:
											return !1
									}
								}
								function G(A) {
									let $ = A.getParentNode(),
										T = A.getParentNode(1)
									return (
										T &&
										$.type === 'JSXExpressionContainer' &&
										T.type === 'JSXAttribute' &&
										T.name.type === 'JSXIdentifier' &&
										T.name.name === 'css'
									)
								}
								function O(A) {
									return A.type === 'Identifier' && A.name === 'styled'
								}
								function U(A) {
									return /^[A-Z]/.test(A.object.name) && A.property.name === 'extend'
								}
								function j(A) {
									let $ = A.getValue(),
										T = A.getParentNode()
									return (
										H($, 'GraphQL') ||
										(T &&
											((T.type === 'TaggedTemplateExpression' &&
												((T.tag.type === 'MemberExpression' &&
													T.tag.object.name === 'graphql' &&
													T.tag.property.name === 'experimental') ||
													(T.tag.type === 'Identifier' &&
														(T.tag.name === 'gql' || T.tag.name === 'graphql')))) ||
												(T.type === 'CallExpression' &&
													T.callee.type === 'Identifier' &&
													T.callee.name === 'graphql')))
									)
								}
								function H(A, $) {
									return c(A, D.Block | D.Leading, (T) => {
										let { value: R } = T
										return R === ` ${$} `
									})
								}
								function W(A) {
									return (
										H(A.getValue(), 'HTML') ||
										A.match(
											($) => $.type === 'TemplateLiteral',
											($, T) =>
												$.type === 'TaggedTemplateExpression' &&
												$.tag.type === 'Identifier' &&
												$.tag.name === 'html' &&
												T === 'quasi'
										)
									)
								}
								function re(A) {
									let { quasis: $ } = A
									return $.some((T) => {
										let {
											value: { cooked: R }
										} = T
										return R === null
									})
								}
								E.exports = _
							}
						}),
						Ty = le({
							'src/language-js/clean.js'(d, E) {
								'use strict'
								ge()
								var c = js(),
									D = new Set([
										'range',
										'raw',
										'comments',
										'leadingComments',
										'trailingComments',
										'innerComments',
										'extra',
										'start',
										'end',
										'loc',
										'flags',
										'errors',
										'tokens'
									]),
									g = (p) => {
										for (let f of p.quasis) delete f.value
									}
								function l(p, f, y) {
									if (
										(p.type === 'Program' && delete f.sourceType,
										(p.type === 'BigIntLiteral' || p.type === 'BigIntLiteralTypeAnnotation') &&
											f.value &&
											(f.value = f.value.toLowerCase()),
										(p.type === 'BigIntLiteral' || p.type === 'Literal') &&
											f.bigint &&
											(f.bigint = f.bigint.toLowerCase()),
										p.type === 'DecimalLiteral' && (f.value = Number(f.value)),
										p.type === 'Literal' && f.decimal && (f.decimal = Number(f.decimal)),
										p.type === 'EmptyStatement' ||
											p.type === 'JSXText' ||
											(p.type === 'JSXExpressionContainer' &&
												(p.expression.type === 'Literal' ||
													p.expression.type === 'StringLiteral') &&
												p.expression.value === ' '))
									)
										return null
									if (
										((p.type === 'Property' ||
											p.type === 'ObjectProperty' ||
											p.type === 'MethodDefinition' ||
											p.type === 'ClassProperty' ||
											p.type === 'ClassMethod' ||
											p.type === 'PropertyDefinition' ||
											p.type === 'TSDeclareMethod' ||
											p.type === 'TSPropertySignature' ||
											p.type === 'ObjectTypeProperty') &&
											typeof p.key == 'object' &&
											p.key &&
											(p.key.type === 'Literal' ||
												p.key.type === 'NumericLiteral' ||
												p.key.type === 'StringLiteral' ||
												p.key.type === 'Identifier') &&
											delete f.key,
										p.type === 'JSXElement' &&
											p.openingElement.name.name === 'style' &&
											p.openingElement.attributes.some((w) => w.name.name === 'jsx'))
									)
										for (let { type: w, expression: C } of f.children)
											w === 'JSXExpressionContainer' && C.type === 'TemplateLiteral' && g(C)
									p.type === 'JSXAttribute' &&
										p.name.name === 'css' &&
										p.value.type === 'JSXExpressionContainer' &&
										p.value.expression.type === 'TemplateLiteral' &&
										g(f.value.expression),
										p.type === 'JSXAttribute' &&
											p.value &&
											p.value.type === 'Literal' &&
											/["']|&quot;|&apos;/.test(p.value.value) &&
											(f.value.value = f.value.value.replace(/["']|&quot;|&apos;/g, '"'))
									let x = p.expression || p.callee
									if (
										p.type === 'Decorator' &&
										x.type === 'CallExpression' &&
										x.callee.name === 'Component' &&
										x.arguments.length === 1
									) {
										let w = p.expression.arguments[0].properties
										for (let [C, v] of f.expression.arguments[0].properties.entries())
											switch (w[C].key.name) {
												case 'styles':
													v.value.type === 'ArrayExpression' && g(v.value.elements[0])
													break
												case 'template':
													v.value.type === 'TemplateLiteral' && g(v.value)
													break
											}
									}
									if (
										(p.type === 'TaggedTemplateExpression' &&
											(p.tag.type === 'MemberExpression' ||
												(p.tag.type === 'Identifier' &&
													(p.tag.name === 'gql' ||
														p.tag.name === 'graphql' ||
														p.tag.name === 'css' ||
														p.tag.name === 'md' ||
														p.tag.name === 'markdown' ||
														p.tag.name === 'html')) ||
												p.tag.type === 'CallExpression') &&
											g(f.quasi),
										p.type === 'TemplateLiteral')
									) {
										var _
										;((!((_ = p.leadingComments) === null || _ === void 0) &&
											_.some(
												(w) => c(w) && ['GraphQL', 'HTML'].some((C) => w.value === ` ${C} `)
											)) ||
											(y.type === 'CallExpression' && y.callee.name === 'graphql') ||
											!p.leadingComments) &&
											g(f)
									}
									if (
										(p.type === 'InterpreterDirective' && (f.value = f.value.trimEnd()),
										(p.type === 'TSIntersectionType' || p.type === 'TSUnionType') &&
											p.types.length === 1)
									)
										return f.types[0]
								}
								;(l.ignoredProperties = D), (E.exports = l)
							}
						}),
						F1 = {}
					fn(F1, {
						EOL: () => hp,
						arch: () => Ay,
						cpus: () => O1,
						default: () => $1,
						endianness: () => _1,
						freemem: () => k1,
						getNetworkInterfaces: () => j1,
						hostname: () => w1,
						loadavg: () => L1,
						networkInterfaces: () => M1,
						platform: () => Cy,
						release: () => P1,
						tmpDir: () => fp,
						tmpdir: () => dp,
						totalmem: () => R1,
						type: () => B1,
						uptime: () => I1
					})
					function _1() {
						if (typeof Ju > 'u') {
							var d = new ArrayBuffer(2),
								E = new Uint8Array(d),
								c = new Uint16Array(d)
							if (((E[0] = 1), (E[1] = 2), c[0] === 258)) Ju = 'BE'
							else if (c[0] === 513) Ju = 'LE'
							else throw new Error('unable to figure out endianess')
						}
						return Ju
					}
					function w1() {
						return typeof globalThis.location < 'u' ? globalThis.location.hostname : ''
					}
					function L1() {
						return []
					}
					function I1() {
						return 0
					}
					function k1() {
						return Number.MAX_VALUE
					}
					function R1() {
						return Number.MAX_VALUE
					}
					function O1() {
						return []
					}
					function B1() {
						return 'Browser'
					}
					function P1() {
						return typeof globalThis.navigator < 'u' ? globalThis.navigator.appVersion : ''
					}
					function M1() {}
					function j1() {}
					function Ay() {
						return 'javascript'
					}
					function Cy() {
						return 'browser'
					}
					function fp() {
						return '/tmp'
					}
					var Ju,
						dp,
						hp,
						$1,
						Sy = Kt({
							'node-modules-polyfills:os'() {
								ge(),
									(dp = fp),
									(hp = `
`),
									($1 = {
										EOL: hp,
										tmpdir: dp,
										tmpDir: fp,
										networkInterfaces: M1,
										getNetworkInterfaces: j1,
										release: P1,
										type: B1,
										cpus: O1,
										totalmem: R1,
										freemem: k1,
										uptime: I1,
										loadavg: L1,
										hostname: w1,
										endianness: _1
									})
							}
						}),
						Ny = le({
							'node-modules-polyfills-commonjs:os'(d, E) {
								ge()
								var c = (Sy(), Mn(F1))
								if (c && c.default) {
									E.exports = c.default
									for (let D in c) E.exports[D] = c[D]
								} else c && (E.exports = c)
							}
						}),
						Fy = le({
							'node_modules/detect-newline/index.js'(d, E) {
								'use strict'
								ge()
								var c = (D) => {
									if (typeof D != 'string') throw new TypeError('Expected a string')
									let g = D.match(/(?:\r?\n)/g) || []
									if (g.length === 0) return
									let l = g.filter(
											(f) =>
												f ===
												`\r
`
										).length,
										p = g.length - l
									return l > p
										? `\r
`
										: `
`
								}
								;(E.exports = c),
									(E.exports.graceful = (D) =>
										(typeof D == 'string' && c(D)) ||
										`
`)
							}
						}),
						_y = le({
							'node_modules/jest-docblock/build/index.js'(d) {
								'use strict'
								ge(),
									Object.defineProperty(d, '__esModule', { value: !0 }),
									(d.extract = v),
									(d.parse = k),
									(d.parseWithComments = q),
									(d.print = G),
									(d.strip = b)
								function E() {
									let U = Ny()
									return (
										(E = function () {
											return U
										}),
										U
									)
								}
								function c() {
									let U = D(Fy())
									return (
										(c = function () {
											return U
										}),
										U
									)
								}
								function D(U) {
									return U && U.__esModule ? U : { default: U }
								}
								var g = /\*\/$/,
									l = /^\/\*\*?/,
									p = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,
									f = /(^|\s+)\/\/([^\r\n]*)/g,
									y = /^(\r?\n)+/,
									x =
										/(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g,
									_ = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g,
									w = /(\r?\n|^) *\* ?/g,
									C = []
								function v(U) {
									let j = U.match(p)
									return j ? j[0].trimLeft() : ''
								}
								function b(U) {
									let j = U.match(p)
									return j && j[0] ? U.substring(j[0].length) : U
								}
								function k(U) {
									return q(U).pragmas
								}
								function q(U) {
									let j = (0, c().default)(U) || E().EOL
									U = U.replace(l, '').replace(g, '').replace(w, '$1')
									let H = ''
									for (; H !== U; ) (H = U), (U = U.replace(x, `${j}$1 $2${j}`))
									U = U.replace(y, '').trimRight()
									let W = Object.create(null),
										re = U.replace(_, '').replace(y, '').trimRight(),
										A
									for (; (A = _.exec(U)); ) {
										let $ = A[2].replace(f, '')
										typeof W[A[1]] == 'string' || Array.isArray(W[A[1]])
											? (W[A[1]] = C.concat(W[A[1]], $))
											: (W[A[1]] = $)
									}
									return { comments: re, pragmas: W }
								}
								function G(U) {
									let { comments: j = '', pragmas: H = {} } = U,
										W = (0, c().default)(j) || E().EOL,
										re = '/**',
										A = ' *',
										$ = ' */',
										T = Object.keys(H),
										R = T.map((S) => O(S, H[S]))
											.reduce((S, L) => S.concat(L), [])
											.map((S) => `${A} ${S}${W}`)
											.join('')
									if (!j) {
										if (T.length === 0) return ''
										if (T.length === 1 && !Array.isArray(H[T[0]])) {
											let S = H[T[0]]
											return `${re} ${O(T[0], S)[0]}${$}`
										}
									}
									let m =
										j
											.split(W)
											.map((S) => `${A} ${S}`)
											.join(W) + W
									return re + W + (j ? m : '') + (j && T.length ? A + W : '') + R + $
								}
								function O(U, j) {
									return C.concat(j).map((H) => `@${U} ${H}`.trim())
								}
							}
						}),
						wy = le({
							'src/language-js/utils/get-shebang.js'(d, E) {
								'use strict'
								ge()
								function c(D) {
									if (!D.startsWith('#!')) return ''
									let g = D.indexOf(`
`)
									return g === -1 ? D : D.slice(0, g)
								}
								E.exports = c
							}
						}),
						V1 = le({
							'src/language-js/pragma.js'(d, E) {
								'use strict'
								ge()
								var { parseWithComments: c, strip: D, extract: g, print: l } = _y(),
									{ normalizeEndOfLine: p } = Ds(),
									f = wy()
								function y(w) {
									let C = f(w)
									C && (w = w.slice(C.length + 1))
									let v = g(w),
										{ pragmas: b, comments: k } = c(v)
									return { shebang: C, text: w, pragmas: b, comments: k }
								}
								function x(w) {
									let C = Object.keys(y(w).pragmas)
									return C.includes('prettier') || C.includes('format')
								}
								function _(w) {
									let { shebang: C, text: v, pragmas: b, comments: k } = y(w),
										q = D(v),
										G = l({ pragmas: Object.assign({ format: '' }, b), comments: k.trimStart() })
									return (
										(C
											? `${C}
`
											: '') +
										p(G) +
										(q.startsWith(`
`)
											? `
`
											: `

`) +
										q
									)
								}
								E.exports = { hasPragma: x, insertPragma: _ }
							}
						}),
						Ly = le({
							'src/language-js/utils/is-type-cast-comment.js'(d, E) {
								'use strict'
								ge()
								var c = js()
								function D(g) {
									return c(g) && g.value[0] === '*' && /@(?:type|satisfies)\b/.test(g.value)
								}
								E.exports = D
							}
						}),
						U1 = le({
							'src/language-js/comments.js'(d, E) {
								'use strict'
								ge()
								var {
										getLast: c,
										hasNewline: D,
										getNextNonSpaceNonCommentCharacterIndexWithStartIndex: g,
										getNextNonSpaceNonCommentCharacter: l,
										hasNewlineInRange: p,
										addLeadingComment: f,
										addTrailingComment: y,
										addDanglingComment: x,
										getNextNonSpaceNonCommentCharacterIndex: _,
										isNonEmptyArray: w
									} = wn(),
									{
										getFunctionParameters: C,
										isPrettierIgnoreComment: v,
										isJsxNode: b,
										hasFlowShorthandAnnotationComment: k,
										hasFlowAnnotationComment: q,
										hasIgnoreComment: G,
										isCallLikeExpression: O,
										getCallArguments: U,
										isCallExpression: j,
										isMemberExpression: H,
										isObjectProperty: W,
										isLineComment: re,
										getComments: A,
										CommentCheckFlags: $,
										markerForIfWithoutBlockAndSameLineComment: T
									} = er(),
									{ locStart: R, locEnd: m } = Qr(),
									S = js(),
									L = Ly()
								function P(Ue) {
									return [se, Dt, ye, ee, ce, z, Fe, ot, Ce, nt, Ut, vn, $e, me, ae].some((B) =>
										B(Ue)
									)
								}
								function M(Ue) {
									return [ne, Dt, te, Ut, ee, ce, z, Fe, me, xe, Ge, nt, tn, ae, he].some((B) =>
										B(Ue)
									)
								}
								function V(Ue) {
									return [se, ee, ce, X, Me, $e, nt, Be, fe, je, ae, Ie].some((B) => B(Ue))
								}
								function J(Ue, B) {
									let pe = (Ue.body || Ue.properties).find((_e) => {
										let { type: st } = _e
										return st !== 'EmptyStatement'
									})
									pe ? f(pe, B) : x(Ue, B)
								}
								function Z(Ue, B) {
									Ue.type === 'BlockStatement' ? J(Ue, B) : f(Ue, B)
								}
								function ne(Ue) {
									let { comment: B, followingNode: pe } = Ue
									return pe && L(B) ? (f(pe, B), !0) : !1
								}
								function ee(Ue) {
									let {
										comment: B,
										precedingNode: pe,
										enclosingNode: _e,
										followingNode: st,
										text: pt
									} = Ue
									if (_e?.type !== 'IfStatement' || !st) return !1
									if (l(pt, B, m) === ')') return y(pe, B), !0
									if (pe === _e.consequent && st === _e.alternate) {
										if (pe.type === 'BlockStatement') y(pe, B)
										else {
											let jt = B.type === 'SingleLine' || B.loc.start.line === B.loc.end.line,
												at = B.loc.start.line === pe.loc.start.line
											jt && at ? x(pe, B, T) : x(_e, B)
										}
										return !0
									}
									return st.type === 'BlockStatement'
										? (J(st, B), !0)
										: st.type === 'IfStatement'
										? (Z(st.consequent, B), !0)
										: _e.consequent === st
										? (f(st, B), !0)
										: !1
								}
								function ce(Ue) {
									let {
										comment: B,
										precedingNode: pe,
										enclosingNode: _e,
										followingNode: st,
										text: pt
									} = Ue
									return _e?.type !== 'WhileStatement' || !st
										? !1
										: l(pt, B, m) === ')'
										? (y(pe, B), !0)
										: st.type === 'BlockStatement'
										? (J(st, B), !0)
										: _e.body === st
										? (f(st, B), !0)
										: !1
								}
								function z(Ue) {
									let { comment: B, precedingNode: pe, enclosingNode: _e, followingNode: st } = Ue
									return (_e?.type !== 'TryStatement' && _e?.type !== 'CatchClause') || !st
										? !1
										: _e.type === 'CatchClause' && pe
										? (y(pe, B), !0)
										: st.type === 'BlockStatement'
										? (J(st, B), !0)
										: st.type === 'TryStatement'
										? (Z(st.finalizer, B), !0)
										: st.type === 'CatchClause'
										? (Z(st.body, B), !0)
										: !1
								}
								function ye(Ue) {
									let { comment: B, enclosingNode: pe, followingNode: _e } = Ue
									return H(pe) && _e?.type === 'Identifier' ? (f(pe, B), !0) : !1
								}
								function te(Ue) {
									let {
											comment: B,
											precedingNode: pe,
											enclosingNode: _e,
											followingNode: st,
											text: pt
										} = Ue,
										jt = pe && !p(pt, m(pe), R(B))
									return (!pe || !jt) &&
										(_e?.type === 'ConditionalExpression' || _e?.type === 'TSConditionalType') &&
										st
										? (f(st, B), !0)
										: !1
								}
								function X(Ue) {
									let { comment: B, precedingNode: pe, enclosingNode: _e } = Ue
									return W(_e) &&
										_e.shorthand &&
										_e.key === pe &&
										_e.value.type === 'AssignmentPattern'
										? (y(_e.value.left, B), !0)
										: !1
								}
								var De = new Set([
									'ClassDeclaration',
									'ClassExpression',
									'DeclareClass',
									'DeclareInterface',
									'InterfaceDeclaration',
									'TSInterfaceDeclaration'
								])
								function Fe(Ue) {
									let { comment: B, precedingNode: pe, enclosingNode: _e, followingNode: st } = Ue
									if (De.has(_e?.type)) {
										if (w(_e.decorators) && !(st && st.type === 'Decorator'))
											return y(c(_e.decorators), B), !0
										if (_e.body && st === _e.body) return J(_e.body, B), !0
										if (st) {
											if (
												_e.superClass &&
												st === _e.superClass &&
												pe &&
												(pe === _e.id || pe === _e.typeParameters)
											)
												return y(pe, B), !0
											for (let pt of ['implements', 'extends', 'mixins'])
												if (_e[pt] && st === _e[pt][0])
													return (
														pe && (pe === _e.id || pe === _e.typeParameters || pe === _e.superClass)
															? y(pe, B)
															: x(_e, B, pt),
														!0
													)
										}
									}
									return !1
								}
								var ve = new Set([
									'ClassMethod',
									'ClassProperty',
									'PropertyDefinition',
									'TSAbstractPropertyDefinition',
									'TSAbstractMethodDefinition',
									'TSDeclareMethod',
									'MethodDefinition',
									'ClassAccessorProperty',
									'AccessorProperty',
									'TSAbstractAccessorProperty'
								])
								function $e(Ue) {
									let { comment: B, precedingNode: pe, enclosingNode: _e, text: st } = Ue
									return (_e &&
										pe &&
										l(st, B, m) === '(' &&
										(_e.type === 'Property' ||
											_e.type === 'TSDeclareMethod' ||
											_e.type === 'TSAbstractMethodDefinition') &&
										pe.type === 'Identifier' &&
										_e.key === pe &&
										l(st, pe, m) !== ':') ||
										(pe?.type === 'Decorator' && ve.has(_e?.type))
										? (y(pe, B), !0)
										: !1
								}
								var ie = new Set([
									'FunctionDeclaration',
									'FunctionExpression',
									'ClassMethod',
									'MethodDefinition',
									'ObjectMethod'
								])
								function fe(Ue) {
									let { comment: B, precedingNode: pe, enclosingNode: _e, text: st } = Ue
									return l(st, B, m) !== '(' ? !1 : pe && ie.has(_e?.type) ? (y(pe, B), !0) : !1
								}
								function Be(Ue) {
									let { comment: B, enclosingNode: pe, text: _e } = Ue
									if (pe?.type !== 'ArrowFunctionExpression') return !1
									let st = _(_e, B, m)
									return st !== !1 && _e.slice(st, st + 2) === '=>' ? (x(pe, B), !0) : !1
								}
								function Me(Ue) {
									let { comment: B, enclosingNode: pe, text: _e } = Ue
									return l(_e, B, m) !== ')'
										? !1
										: pe && ((Oe(pe) && C(pe).length === 0) || (O(pe) && U(pe).length === 0))
										? (x(pe, B), !0)
										: (pe?.type === 'MethodDefinition' ||
												pe?.type === 'TSAbstractMethodDefinition') &&
										  C(pe.value).length === 0
										? (x(pe.value, B), !0)
										: !1
								}
								function Dt(Ue) {
									let {
										comment: B,
										precedingNode: pe,
										enclosingNode: _e,
										followingNode: st,
										text: pt
									} = Ue
									if (
										(pe?.type === 'FunctionTypeParam' &&
											_e?.type === 'FunctionTypeAnnotation' &&
											st?.type !== 'FunctionTypeParam') ||
										((pe?.type === 'Identifier' || pe?.type === 'AssignmentPattern') &&
											_e &&
											Oe(_e) &&
											l(pt, B, m) === ')')
									)
										return y(pe, B), !0
									if (_e?.type === 'FunctionDeclaration' && st?.type === 'BlockStatement') {
										let jt = (() => {
											let at = C(_e)
											if (at.length > 0) return g(pt, m(c(at)))
											let ar = g(pt, m(_e.id))
											return ar !== !1 && g(pt, ar + 1)
										})()
										if (R(B) > jt) return J(st, B), !0
									}
									return !1
								}
								function me(Ue) {
									let { comment: B, enclosingNode: pe } = Ue
									return pe?.type === 'LabeledStatement' ? (f(pe, B), !0) : !1
								}
								function ae(Ue) {
									let { comment: B, enclosingNode: pe } = Ue
									return (pe?.type === 'ContinueStatement' || pe?.type === 'BreakStatement') &&
										!pe.label
										? (y(pe, B), !0)
										: !1
								}
								function xe(Ue) {
									let { comment: B, precedingNode: pe, enclosingNode: _e } = Ue
									return j(_e) && pe && _e.callee === pe && _e.arguments.length > 0
										? (f(_e.arguments[0], B), !0)
										: !1
								}
								function Ce(Ue) {
									let { comment: B, precedingNode: pe, enclosingNode: _e, followingNode: st } = Ue
									return _e?.type === 'UnionTypeAnnotation' || _e?.type === 'TSUnionType'
										? (v(B) && ((st.prettierIgnore = !0), (B.unignore = !0)),
										  pe ? (y(pe, B), !0) : !1)
										: ((st?.type === 'UnionTypeAnnotation' || st?.type === 'TSUnionType') &&
												v(B) &&
												((st.types[0].prettierIgnore = !0), (B.unignore = !0)),
										  !1)
								}
								function Ge(Ue) {
									let { comment: B, enclosingNode: pe } = Ue
									return W(pe) ? (f(pe, B), !0) : !1
								}
								function nt(Ue) {
									let {
										comment: B,
										enclosingNode: pe,
										followingNode: _e,
										ast: st,
										isLastComment: pt
									} = Ue
									return st && st.body && st.body.length === 0
										? (pt ? x(st, B) : f(st, B), !0)
										: pe?.type === 'Program' && pe?.body.length === 0 && !w(pe.directives)
										? (pt ? x(pe, B) : f(pe, B), !0)
										: _e?.type === 'Program' &&
										  _e?.body.length === 0 &&
										  pe?.type === 'ModuleExpression'
										? (x(_e, B), !0)
										: !1
								}
								function ot(Ue) {
									let { comment: B, enclosingNode: pe } = Ue
									return pe?.type === 'ForInStatement' || pe?.type === 'ForOfStatement'
										? (f(pe, B), !0)
										: !1
								}
								function Ut(Ue) {
									let { comment: B, precedingNode: pe, enclosingNode: _e, text: st } = Ue
									if (_e?.type === 'ImportSpecifier' || _e?.type === 'ExportSpecifier')
										return f(_e, B), !0
									let pt = pe?.type === 'ImportSpecifier' && _e?.type === 'ImportDeclaration',
										jt = pe?.type === 'ExportSpecifier' && _e?.type === 'ExportNamedDeclaration'
									return (pt || jt) && D(st, m(B)) ? (y(pe, B), !0) : !1
								}
								function vn(Ue) {
									let { comment: B, enclosingNode: pe } = Ue
									return pe?.type === 'AssignmentPattern' ? (f(pe, B), !0) : !1
								}
								var Dn = new Set([
										'VariableDeclarator',
										'AssignmentExpression',
										'TypeAlias',
										'TSTypeAliasDeclaration'
									]),
									Vt = new Set([
										'ObjectExpression',
										'ArrayExpression',
										'TemplateLiteral',
										'TaggedTemplateExpression',
										'ObjectTypeAnnotation',
										'TSTypeLiteral'
									])
								function tn(Ue) {
									let { comment: B, enclosingNode: pe, followingNode: _e } = Ue
									return Dn.has(pe?.type) && _e && (Vt.has(_e.type) || S(B)) ? (f(_e, B), !0) : !1
								}
								function Ie(Ue) {
									let { comment: B, enclosingNode: pe, followingNode: _e, text: st } = Ue
									return !_e &&
										(pe?.type === 'TSMethodSignature' ||
											pe?.type === 'TSDeclareFunction' ||
											pe?.type === 'TSAbstractMethodDefinition') &&
										l(st, B, m) === ';'
										? (y(pe, B), !0)
										: !1
								}
								function se(Ue) {
									let { comment: B, enclosingNode: pe, followingNode: _e } = Ue
									if (
										v(B) &&
										pe?.type === 'TSMappedType' &&
										_e?.type === 'TSTypeParameter' &&
										_e.constraint
									)
										return (pe.prettierIgnore = !0), (B.unignore = !0), !0
								}
								function je(Ue) {
									let { comment: B, precedingNode: pe, enclosingNode: _e, followingNode: st } = Ue
									return _e?.type !== 'TSMappedType'
										? !1
										: st?.type === 'TSTypeParameter' && st.name
										? (f(st.name, B), !0)
										: pe?.type === 'TSTypeParameter' && pe.constraint
										? (y(pe.constraint, B), !0)
										: !1
								}
								function he(Ue) {
									let { comment: B, enclosingNode: pe, followingNode: _e } = Ue
									return !pe ||
										pe.type !== 'SwitchCase' ||
										pe.test ||
										!_e ||
										_e !== pe.consequent[0]
										? !1
										: (_e.type === 'BlockStatement' && re(B) ? J(_e, B) : x(pe, B), !0)
								}
								function Oe(Ue) {
									return (
										Ue.type === 'ArrowFunctionExpression' ||
										Ue.type === 'FunctionExpression' ||
										Ue.type === 'FunctionDeclaration' ||
										Ue.type === 'ObjectMethod' ||
										Ue.type === 'ClassMethod' ||
										Ue.type === 'TSDeclareFunction' ||
										Ue.type === 'TSCallSignatureDeclaration' ||
										Ue.type === 'TSConstructSignatureDeclaration' ||
										Ue.type === 'TSMethodSignature' ||
										Ue.type === 'TSConstructorType' ||
										Ue.type === 'TSFunctionType' ||
										Ue.type === 'TSDeclareMethod'
									)
								}
								function wt(Ue, B) {
									if (
										(B.parser === 'typescript' ||
											B.parser === 'flow' ||
											B.parser === 'acorn' ||
											B.parser === 'espree' ||
											B.parser === 'meriyah' ||
											B.parser === '__babel_estree') &&
										Ue.type === 'MethodDefinition' &&
										Ue.value &&
										Ue.value.type === 'FunctionExpression' &&
										C(Ue.value).length === 0 &&
										!Ue.value.returnType &&
										!w(Ue.value.typeParameters) &&
										Ue.value.body
									)
										return [...(Ue.decorators || []), Ue.key, Ue.value.body]
								}
								function mt(Ue) {
									let B = Ue.getValue(),
										pe = Ue.getParentNode(),
										_e = (st) => q(A(st, $.Leading)) || q(A(st, $.Trailing))
									return (
										((B && (b(B) || k(B) || (j(pe) && _e(B)))) ||
											(pe &&
												(pe.type === 'JSXSpreadAttribute' ||
													pe.type === 'JSXSpreadChild' ||
													pe.type === 'UnionTypeAnnotation' ||
													pe.type === 'TSUnionType' ||
													((pe.type === 'ClassDeclaration' || pe.type === 'ClassExpression') &&
														pe.superClass === B)))) &&
										(!G(Ue) || pe.type === 'UnionTypeAnnotation' || pe.type === 'TSUnionType')
									)
								}
								E.exports = {
									handleOwnLineComment: P,
									handleEndOfLineComment: M,
									handleRemainingComment: V,
									getCommentChildNodes: wt,
									willPrintOwnComments: mt
								}
							}
						}),
						vo = le({
							'src/language-js/needs-parens.js'(d, E) {
								'use strict'
								ge()
								var c = Ur(),
									D = rp(),
									{
										getFunctionParameters: g,
										getLeftSidePathName: l,
										hasFlowShorthandAnnotationComment: p,
										hasNakedLeftSide: f,
										hasNode: y,
										isBitwiseOperator: x,
										startsWithNoLookaheadToken: _,
										shouldFlatten: w,
										getPrecedence: C,
										isCallExpression: v,
										isMemberExpression: b,
										isObjectProperty: k,
										isTSTypeExpression: q
									} = er()
								function G(A, $) {
									let T = A.getParentNode()
									if (!T) return !1
									let R = A.getName(),
										m = A.getNode()
									if ($.__isInHtmlInterpolation && !$.bracketSpacing && H(m) && W(A)) return !0
									if (O(m)) return !1
									if ($.parser !== 'flow' && p(A.getValue())) return !0
									if (m.type === 'Identifier') {
										if (
											(m.extra &&
												m.extra.parenthesized &&
												/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(m.name)) ||
											(R === 'left' &&
												((m.name === 'async' && !T.await) || m.name === 'let') &&
												T.type === 'ForOfStatement')
										)
											return !0
										if (m.name === 'let') {
											var S
											let P =
												(S = A.findAncestor((M) => M.type === 'ForOfStatement')) === null ||
												S === void 0
													? void 0
													: S.left
											if (P && _(P, (M) => M === m)) return !0
										}
										if (
											R === 'object' &&
											m.name === 'let' &&
											T.type === 'MemberExpression' &&
											T.computed &&
											!T.optional
										) {
											let P = A.findAncestor(
													(V) =>
														V.type === 'ExpressionStatement' ||
														V.type === 'ForStatement' ||
														V.type === 'ForInStatement'
												),
												M = P
													? P.type === 'ExpressionStatement'
														? P.expression
														: P.type === 'ForStatement'
														? P.init
														: P.left
													: void 0
											if (M && _(M, (V) => V === m)) return !0
										}
										return !1
									}
									if (
										m.type === 'ObjectExpression' ||
										m.type === 'FunctionExpression' ||
										m.type === 'ClassExpression' ||
										m.type === 'DoExpression'
									) {
										var L
										let P =
											(L = A.findAncestor((M) => M.type === 'ExpressionStatement')) === null ||
											L === void 0
												? void 0
												: L.expression
										if (P && _(P, (M) => M === m)) return !0
									}
									switch (T.type) {
										case 'ParenthesizedExpression':
											return !1
										case 'ClassDeclaration':
										case 'ClassExpression': {
											if (
												R === 'superClass' &&
												(m.type === 'ArrowFunctionExpression' ||
													m.type === 'AssignmentExpression' ||
													m.type === 'AwaitExpression' ||
													m.type === 'BinaryExpression' ||
													m.type === 'ConditionalExpression' ||
													m.type === 'LogicalExpression' ||
													m.type === 'NewExpression' ||
													m.type === 'ObjectExpression' ||
													m.type === 'SequenceExpression' ||
													m.type === 'TaggedTemplateExpression' ||
													m.type === 'UnaryExpression' ||
													m.type === 'UpdateExpression' ||
													m.type === 'YieldExpression' ||
													m.type === 'TSNonNullExpression')
											)
												return !0
											break
										}
										case 'ExportDefaultDeclaration':
											return re(A, $) || m.type === 'SequenceExpression'
										case 'Decorator': {
											if (R === 'expression') {
												if (b(m) && m.computed) return !0
												let P = !1,
													M = !1,
													V = m
												for (; V; )
													switch (V.type) {
														case 'MemberExpression':
															;(M = !0), (V = V.object)
															break
														case 'CallExpression':
															if (M || P) return $.parser !== 'typescript'
															;(P = !0), (V = V.callee)
															break
														case 'Identifier':
															return !1
														case 'TaggedTemplateExpression':
															return $.parser !== 'typescript'
														default:
															return !0
													}
												return !0
											}
											break
										}
										case 'ArrowFunctionExpression': {
											if (
												R === 'body' &&
												m.type !== 'SequenceExpression' &&
												_(m, (P) => P.type === 'ObjectExpression')
											)
												return !0
											break
										}
									}
									switch (m.type) {
										case 'UpdateExpression':
											if (T.type === 'UnaryExpression')
												return (
													m.prefix &&
													((m.operator === '++' && T.operator === '+') ||
														(m.operator === '--' && T.operator === '-'))
												)
										case 'UnaryExpression':
											switch (T.type) {
												case 'UnaryExpression':
													return (
														m.operator === T.operator && (m.operator === '+' || m.operator === '-')
													)
												case 'BindExpression':
													return !0
												case 'MemberExpression':
												case 'OptionalMemberExpression':
													return R === 'object'
												case 'TaggedTemplateExpression':
													return !0
												case 'NewExpression':
												case 'CallExpression':
												case 'OptionalCallExpression':
													return R === 'callee'
												case 'BinaryExpression':
													return R === 'left' && T.operator === '**'
												case 'TSNonNullExpression':
													return !0
												default:
													return !1
											}
										case 'BinaryExpression': {
											if (T.type === 'UpdateExpression' || (m.operator === 'in' && U(A))) return !0
											if (m.operator === '|>' && m.extra && m.extra.parenthesized) {
												let P = A.getParentNode(1)
												if (P.type === 'BinaryExpression' && P.operator === '|>') return !0
											}
										}
										case 'TSTypeAssertion':
										case 'TSAsExpression':
										case 'TSSatisfiesExpression':
										case 'LogicalExpression':
											switch (T.type) {
												case 'TSSatisfiesExpression':
												case 'TSAsExpression':
													return !q(m)
												case 'ConditionalExpression':
													return q(m)
												case 'CallExpression':
												case 'NewExpression':
												case 'OptionalCallExpression':
													return R === 'callee'
												case 'ClassExpression':
												case 'ClassDeclaration':
													return R === 'superClass'
												case 'TSTypeAssertion':
												case 'TaggedTemplateExpression':
												case 'UnaryExpression':
												case 'JSXSpreadAttribute':
												case 'SpreadElement':
												case 'SpreadProperty':
												case 'BindExpression':
												case 'AwaitExpression':
												case 'TSNonNullExpression':
												case 'UpdateExpression':
													return !0
												case 'MemberExpression':
												case 'OptionalMemberExpression':
													return R === 'object'
												case 'AssignmentExpression':
												case 'AssignmentPattern':
													return R === 'left' && (m.type === 'TSTypeAssertion' || q(m))
												case 'LogicalExpression':
													if (m.type === 'LogicalExpression') return T.operator !== m.operator
												case 'BinaryExpression': {
													let { operator: P, type: M } = m
													if (!P && M !== 'TSTypeAssertion') return !0
													let V = C(P),
														J = T.operator,
														Z = C(J)
													return Z > V || (R === 'right' && Z === V) || (Z === V && !w(J, P))
														? !0
														: Z < V && P === '%'
														? J === '+' || J === '-'
														: !!x(J)
												}
												default:
													return !1
											}
										case 'SequenceExpression':
											switch (T.type) {
												case 'ReturnStatement':
													return !1
												case 'ForStatement':
													return !1
												case 'ExpressionStatement':
													return R !== 'expression'
												case 'ArrowFunctionExpression':
													return R !== 'body'
												default:
													return !0
											}
										case 'YieldExpression':
											if (
												T.type === 'UnaryExpression' ||
												T.type === 'AwaitExpression' ||
												q(T) ||
												T.type === 'TSNonNullExpression'
											)
												return !0
										case 'AwaitExpression':
											switch (T.type) {
												case 'TaggedTemplateExpression':
												case 'UnaryExpression':
												case 'LogicalExpression':
												case 'SpreadElement':
												case 'SpreadProperty':
												case 'TSAsExpression':
												case 'TSSatisfiesExpression':
												case 'TSNonNullExpression':
												case 'BindExpression':
													return !0
												case 'MemberExpression':
												case 'OptionalMemberExpression':
													return R === 'object'
												case 'NewExpression':
												case 'CallExpression':
												case 'OptionalCallExpression':
													return R === 'callee'
												case 'ConditionalExpression':
													return R === 'test'
												case 'BinaryExpression':
													return !(!m.argument && T.operator === '|>')
												default:
													return !1
											}
										case 'TSConditionalType':
										case 'TSFunctionType':
										case 'TSConstructorType':
											if (R === 'extendsType' && T.type === 'TSConditionalType') {
												if (m.type === 'TSConditionalType') return !0
												let { typeAnnotation: P } = m.returnType || m.typeAnnotation
												if (
													(P.type === 'TSTypePredicate' &&
														P.typeAnnotation &&
														(P = P.typeAnnotation.typeAnnotation),
													P.type === 'TSInferType' && P.typeParameter.constraint)
												)
													return !0
											}
											if (R === 'checkType' && T.type === 'TSConditionalType') return !0
										case 'TSUnionType':
										case 'TSIntersectionType':
											if (
												(T.type === 'TSUnionType' || T.type === 'TSIntersectionType') &&
												T.types.length > 1 &&
												(!m.types || m.types.length > 1)
											)
												return !0
										case 'TSInferType':
											if (m.type === 'TSInferType' && T.type === 'TSRestType') return !1
										case 'TSTypeOperator':
											return (
												T.type === 'TSArrayType' ||
												T.type === 'TSOptionalType' ||
												T.type === 'TSRestType' ||
												(R === 'objectType' && T.type === 'TSIndexedAccessType') ||
												T.type === 'TSTypeOperator' ||
												(T.type === 'TSTypeAnnotation' &&
													A.getParentNode(1).type.startsWith('TSJSDoc'))
											)
										case 'TSTypeQuery':
											return (
												(R === 'objectType' && T.type === 'TSIndexedAccessType') ||
												(R === 'elementType' && T.type === 'TSArrayType')
											)
										case 'TypeofTypeAnnotation':
											return (
												(R === 'objectType' &&
													(T.type === 'IndexedAccessType' ||
														T.type === 'OptionalIndexedAccessType')) ||
												(R === 'elementType' && T.type === 'ArrayTypeAnnotation')
											)
										case 'ArrayTypeAnnotation':
											return T.type === 'NullableTypeAnnotation'
										case 'IntersectionTypeAnnotation':
										case 'UnionTypeAnnotation':
											return (
												T.type === 'ArrayTypeAnnotation' ||
												T.type === 'NullableTypeAnnotation' ||
												T.type === 'IntersectionTypeAnnotation' ||
												T.type === 'UnionTypeAnnotation' ||
												(R === 'objectType' &&
													(T.type === 'IndexedAccessType' ||
														T.type === 'OptionalIndexedAccessType'))
											)
										case 'NullableTypeAnnotation':
											return (
												T.type === 'ArrayTypeAnnotation' ||
												(R === 'objectType' &&
													(T.type === 'IndexedAccessType' ||
														T.type === 'OptionalIndexedAccessType'))
											)
										case 'FunctionTypeAnnotation': {
											let P = T.type === 'NullableTypeAnnotation' ? A.getParentNode(1) : T
											return (
												P.type === 'UnionTypeAnnotation' ||
												P.type === 'IntersectionTypeAnnotation' ||
												P.type === 'ArrayTypeAnnotation' ||
												(R === 'objectType' &&
													(P.type === 'IndexedAccessType' ||
														P.type === 'OptionalIndexedAccessType')) ||
												P.type === 'NullableTypeAnnotation' ||
												(T.type === 'FunctionTypeParam' &&
													T.name === null &&
													g(m).some(
														(M) =>
															M.typeAnnotation && M.typeAnnotation.type === 'NullableTypeAnnotation'
													))
											)
										}
										case 'OptionalIndexedAccessType':
											return R === 'objectType' && T.type === 'IndexedAccessType'
										case 'StringLiteral':
										case 'NumericLiteral':
										case 'Literal':
											if (
												typeof m.value == 'string' &&
												T.type === 'ExpressionStatement' &&
												!T.directive
											) {
												let P = A.getParentNode(1)
												return P.type === 'Program' || P.type === 'BlockStatement'
											}
											return (
												R === 'object' &&
												T.type === 'MemberExpression' &&
												typeof m.value == 'number'
											)
										case 'AssignmentExpression': {
											let P = A.getParentNode(1)
											return R === 'body' && T.type === 'ArrowFunctionExpression'
												? !0
												: (R === 'key' &&
														(T.type === 'ClassProperty' || T.type === 'PropertyDefinition') &&
														T.computed) ||
												  ((R === 'init' || R === 'update') && T.type === 'ForStatement')
												? !1
												: T.type === 'ExpressionStatement'
												? m.left.type === 'ObjectPattern'
												: !(
														(R === 'key' && T.type === 'TSPropertySignature') ||
														T.type === 'AssignmentExpression' ||
														(T.type === 'SequenceExpression' &&
															P &&
															P.type === 'ForStatement' &&
															(P.init === T || P.update === T)) ||
														(R === 'value' &&
															T.type === 'Property' &&
															P &&
															P.type === 'ObjectPattern' &&
															P.properties.includes(T)) ||
														T.type === 'NGChainedExpression'
												  )
										}
										case 'ConditionalExpression':
											switch (T.type) {
												case 'TaggedTemplateExpression':
												case 'UnaryExpression':
												case 'SpreadElement':
												case 'SpreadProperty':
												case 'BinaryExpression':
												case 'LogicalExpression':
												case 'NGPipeExpression':
												case 'ExportDefaultDeclaration':
												case 'AwaitExpression':
												case 'JSXSpreadAttribute':
												case 'TSTypeAssertion':
												case 'TypeCastExpression':
												case 'TSAsExpression':
												case 'TSSatisfiesExpression':
												case 'TSNonNullExpression':
													return !0
												case 'NewExpression':
												case 'CallExpression':
												case 'OptionalCallExpression':
													return R === 'callee'
												case 'ConditionalExpression':
													return R === 'test'
												case 'MemberExpression':
												case 'OptionalMemberExpression':
													return R === 'object'
												default:
													return !1
											}
										case 'FunctionExpression':
											switch (T.type) {
												case 'NewExpression':
												case 'CallExpression':
												case 'OptionalCallExpression':
													return R === 'callee'
												case 'TaggedTemplateExpression':
													return !0
												default:
													return !1
											}
										case 'ArrowFunctionExpression':
											switch (T.type) {
												case 'BinaryExpression':
													return T.operator !== '|>' || (m.extra && m.extra.parenthesized)
												case 'NewExpression':
												case 'CallExpression':
												case 'OptionalCallExpression':
													return R === 'callee'
												case 'MemberExpression':
												case 'OptionalMemberExpression':
													return R === 'object'
												case 'TSAsExpression':
												case 'TSSatisfiesExpression':
												case 'TSNonNullExpression':
												case 'BindExpression':
												case 'TaggedTemplateExpression':
												case 'UnaryExpression':
												case 'LogicalExpression':
												case 'AwaitExpression':
												case 'TSTypeAssertion':
													return !0
												case 'ConditionalExpression':
													return R === 'test'
												default:
													return !1
											}
										case 'ClassExpression':
											if (D(m.decorators)) return !0
											switch (T.type) {
												case 'NewExpression':
													return R === 'callee'
												default:
													return !1
											}
										case 'OptionalMemberExpression':
										case 'OptionalCallExpression': {
											let P = A.getParentNode(1)
											if (
												(R === 'object' && T.type === 'MemberExpression') ||
												(R === 'callee' &&
													(T.type === 'CallExpression' || T.type === 'NewExpression')) ||
												(T.type === 'TSNonNullExpression' &&
													P.type === 'MemberExpression' &&
													P.object === T)
											)
												return !0
										}
										case 'CallExpression':
										case 'MemberExpression':
										case 'TaggedTemplateExpression':
										case 'TSNonNullExpression':
											if (
												R === 'callee' &&
												(T.type === 'BindExpression' || T.type === 'NewExpression')
											) {
												let P = m
												for (; P; )
													switch (P.type) {
														case 'CallExpression':
														case 'OptionalCallExpression':
															return !0
														case 'MemberExpression':
														case 'OptionalMemberExpression':
														case 'BindExpression':
															P = P.object
															break
														case 'TaggedTemplateExpression':
															P = P.tag
															break
														case 'TSNonNullExpression':
															P = P.expression
															break
														default:
															return !1
													}
											}
											return !1
										case 'BindExpression':
											return (
												(R === 'callee' &&
													(T.type === 'BindExpression' || T.type === 'NewExpression')) ||
												(R === 'object' && b(T))
											)
										case 'NGPipeExpression':
											return !(
												T.type === 'NGRoot' ||
												T.type === 'NGMicrosyntaxExpression' ||
												(T.type === 'ObjectProperty' && !(m.extra && m.extra.parenthesized)) ||
												T.type === 'ArrayExpression' ||
												(v(T) && T.arguments[R] === m) ||
												(R === 'right' && T.type === 'NGPipeExpression') ||
												(R === 'property' && T.type === 'MemberExpression') ||
												T.type === 'AssignmentExpression'
											)
										case 'JSXFragment':
										case 'JSXElement':
											return (
												R === 'callee' ||
												(R === 'left' && T.type === 'BinaryExpression' && T.operator === '<') ||
												(T.type !== 'ArrayExpression' &&
													T.type !== 'ArrowFunctionExpression' &&
													T.type !== 'AssignmentExpression' &&
													T.type !== 'AssignmentPattern' &&
													T.type !== 'BinaryExpression' &&
													T.type !== 'NewExpression' &&
													T.type !== 'ConditionalExpression' &&
													T.type !== 'ExpressionStatement' &&
													T.type !== 'JsExpressionRoot' &&
													T.type !== 'JSXAttribute' &&
													T.type !== 'JSXElement' &&
													T.type !== 'JSXExpressionContainer' &&
													T.type !== 'JSXFragment' &&
													T.type !== 'LogicalExpression' &&
													!v(T) &&
													!k(T) &&
													T.type !== 'ReturnStatement' &&
													T.type !== 'ThrowStatement' &&
													T.type !== 'TypeCastExpression' &&
													T.type !== 'VariableDeclarator' &&
													T.type !== 'YieldExpression')
											)
										case 'TypeAnnotation':
											return R === 'returnType' && T.type === 'ArrowFunctionExpression' && j(m)
									}
									return !1
								}
								function O(A) {
									return (
										A.type === 'BlockStatement' ||
										A.type === 'BreakStatement' ||
										A.type === 'ClassBody' ||
										A.type === 'ClassDeclaration' ||
										A.type === 'ClassMethod' ||
										A.type === 'ClassProperty' ||
										A.type === 'PropertyDefinition' ||
										A.type === 'ClassPrivateProperty' ||
										A.type === 'ContinueStatement' ||
										A.type === 'DebuggerStatement' ||
										A.type === 'DeclareClass' ||
										A.type === 'DeclareExportAllDeclaration' ||
										A.type === 'DeclareExportDeclaration' ||
										A.type === 'DeclareFunction' ||
										A.type === 'DeclareInterface' ||
										A.type === 'DeclareModule' ||
										A.type === 'DeclareModuleExports' ||
										A.type === 'DeclareVariable' ||
										A.type === 'DoWhileStatement' ||
										A.type === 'EnumDeclaration' ||
										A.type === 'ExportAllDeclaration' ||
										A.type === 'ExportDefaultDeclaration' ||
										A.type === 'ExportNamedDeclaration' ||
										A.type === 'ExpressionStatement' ||
										A.type === 'ForInStatement' ||
										A.type === 'ForOfStatement' ||
										A.type === 'ForStatement' ||
										A.type === 'FunctionDeclaration' ||
										A.type === 'IfStatement' ||
										A.type === 'ImportDeclaration' ||
										A.type === 'InterfaceDeclaration' ||
										A.type === 'LabeledStatement' ||
										A.type === 'MethodDefinition' ||
										A.type === 'ReturnStatement' ||
										A.type === 'SwitchStatement' ||
										A.type === 'ThrowStatement' ||
										A.type === 'TryStatement' ||
										A.type === 'TSDeclareFunction' ||
										A.type === 'TSEnumDeclaration' ||
										A.type === 'TSImportEqualsDeclaration' ||
										A.type === 'TSInterfaceDeclaration' ||
										A.type === 'TSModuleDeclaration' ||
										A.type === 'TSNamespaceExportDeclaration' ||
										A.type === 'TypeAlias' ||
										A.type === 'VariableDeclaration' ||
										A.type === 'WhileStatement' ||
										A.type === 'WithStatement'
									)
								}
								function U(A) {
									let $ = 0,
										T = A.getValue()
									for (; T; ) {
										let R = A.getParentNode($++)
										if (R && R.type === 'ForStatement' && R.init === T) return !0
										T = R
									}
									return !1
								}
								function j(A) {
									return y(
										A,
										($) =>
											($.type === 'ObjectTypeAnnotation' &&
												y($, (T) => T.type === 'FunctionTypeAnnotation' || void 0)) ||
											void 0
									)
								}
								function H(A) {
									switch (A.type) {
										case 'ObjectExpression':
											return !0
										default:
											return !1
									}
								}
								function W(A) {
									let $ = A.getValue(),
										T = A.getParentNode(),
										R = A.getName()
									switch (T.type) {
										case 'NGPipeExpression':
											if (
												typeof R == 'number' &&
												T.arguments[R] === $ &&
												T.arguments.length - 1 === R
											)
												return A.callParent(W)
											break
										case 'ObjectProperty':
											if (R === 'value') {
												let m = A.getParentNode(1)
												return c(m.properties) === T
											}
											break
										case 'BinaryExpression':
										case 'LogicalExpression':
											if (R === 'right') return A.callParent(W)
											break
										case 'ConditionalExpression':
											if (R === 'alternate') return A.callParent(W)
											break
										case 'UnaryExpression':
											if (T.prefix) return A.callParent(W)
											break
									}
									return !1
								}
								function re(A, $) {
									let T = A.getValue(),
										R = A.getParentNode()
									return T.type === 'FunctionExpression' || T.type === 'ClassExpression'
										? R.type === 'ExportDefaultDeclaration' || !G(A, $)
										: !f(T) || (R.type !== 'ExportDefaultDeclaration' && G(A, $))
										? !1
										: A.call((m) => re(m, $), ...l(A, T))
								}
								E.exports = G
							}
						}),
						q1 = le({
							'src/language-js/print-preprocess.js'(d, E) {
								'use strict'
								ge()
								function c(D, g) {
									switch (g.parser) {
										case 'json':
										case 'json5':
										case 'json-stringify':
										case '__js_expression':
										case '__vue_expression':
										case '__vue_ts_expression':
											return Object.assign(
												Object.assign({}, D),
												{},
												{
													type: g.parser.startsWith('__') ? 'JsExpressionRoot' : 'JsonRoot',
													node: D,
													comments: [],
													rootMarker: g.rootMarker
												}
											)
										default:
											return D
									}
								}
								E.exports = c
							}
						}),
						Iy = le({
							'src/language-js/print/html-binding.js'(d, E) {
								'use strict'
								ge()
								var {
									builders: { join: c, line: D, group: g, softline: l, indent: p }
								} = dn()
								function f(x, _, w) {
									let C = x.getValue()
									if (
										(_.__onHtmlBindingRoot && x.getName() === null && _.__onHtmlBindingRoot(C, _),
										C.type === 'File')
									) {
										if (_.__isVueForBindingLeft)
											return x.call(
												(v) => {
													let b = c([',', D], v.map(w, 'params')),
														{ params: k } = v.getValue()
													return k.length === 1 ? b : ['(', p([l, g(b)]), l, ')']
												},
												'program',
												'body',
												0
											)
										if (_.__isVueBindings)
											return x.call((v) => c([',', D], v.map(w, 'params')), 'program', 'body', 0)
									}
								}
								function y(x) {
									switch (x.type) {
										case 'MemberExpression':
											switch (x.property.type) {
												case 'Identifier':
												case 'NumericLiteral':
												case 'StringLiteral':
													return y(x.object)
											}
											return !1
										case 'Identifier':
											return !0
										default:
											return !1
									}
								}
								E.exports = { isVueEventBindingExpression: y, printHtmlBinding: f }
							}
						}),
						mp = le({
							'src/language-js/print/binaryish.js'(d, E) {
								'use strict'
								ge()
								var { printComments: c } = Sr(),
									{ getLast: D } = wn(),
									{
										builders: {
											join: g,
											line: l,
											softline: p,
											group: f,
											indent: y,
											align: x,
											indentIfBreak: _
										},
										utils: { cleanDoc: w, getDocParts: C, isConcat: v }
									} = dn(),
									{
										hasLeadingOwnLineComment: b,
										isBinaryish: k,
										isJsxNode: q,
										shouldFlatten: G,
										hasComment: O,
										CommentCheckFlags: U,
										isCallExpression: j,
										isMemberExpression: H,
										isObjectProperty: W,
										isEnabledHackPipeline: re
									} = er(),
									A = 0
								function $(m, S, L) {
									let P = m.getValue(),
										M = m.getParentNode(),
										V = m.getParentNode(1),
										J =
											P !== M.body &&
											(M.type === 'IfStatement' ||
												M.type === 'WhileStatement' ||
												M.type === 'SwitchStatement' ||
												M.type === 'DoWhileStatement'),
										Z = re(S) && P.operator === '|>',
										ne = T(m, L, S, !1, J)
									if (J) return ne
									if (Z) return f(ne)
									if (
										(j(M) && M.callee === P) ||
										M.type === 'UnaryExpression' ||
										(H(M) && !M.computed)
									)
										return f([y([p, ...ne]), p])
									let ee =
											M.type === 'ReturnStatement' ||
											M.type === 'ThrowStatement' ||
											(M.type === 'JSXExpressionContainer' && V.type === 'JSXAttribute') ||
											(P.operator !== '|' && M.type === 'JsExpressionRoot') ||
											(P.type !== 'NGPipeExpression' &&
												((M.type === 'NGRoot' && S.parser === '__ng_binding') ||
													(M.type === 'NGMicrosyntaxExpression' &&
														V.type === 'NGMicrosyntax' &&
														V.body.length === 1))) ||
											(P === M.body && M.type === 'ArrowFunctionExpression') ||
											(P !== M.body && M.type === 'ForStatement') ||
											(M.type === 'ConditionalExpression' &&
												V.type !== 'ReturnStatement' &&
												V.type !== 'ThrowStatement' &&
												!j(V)) ||
											M.type === 'TemplateLiteral',
										ce =
											M.type === 'AssignmentExpression' ||
											M.type === 'VariableDeclarator' ||
											M.type === 'ClassProperty' ||
											M.type === 'PropertyDefinition' ||
											M.type === 'TSAbstractPropertyDefinition' ||
											M.type === 'ClassPrivateProperty' ||
											W(M),
										z = k(P.left) && G(P.operator, P.left.operator)
									if (ee || (R(P) && !z) || (!R(P) && ce)) return f(ne)
									if (ne.length === 0) return ''
									let ye = q(P.right),
										te = ne.findIndex(
											(ie) => typeof ie != 'string' && !Array.isArray(ie) && ie.type === 'group'
										),
										X = ne.slice(0, te === -1 ? 1 : te + 1),
										De = ne.slice(X.length, ye ? -1 : void 0),
										Fe = Symbol('logicalChain-' + ++A),
										ve = f([...X, y(De)], { id: Fe })
									if (!ye) return ve
									let $e = D(ne)
									return f([ve, _($e, { groupId: Fe })])
								}
								function T(m, S, L, P, M) {
									let V = m.getValue()
									if (!k(V)) return [f(S())]
									let J = []
									G(V.operator, V.left.operator)
										? (J = m.call((De) => T(De, S, L, !0, M), 'left'))
										: J.push(f(S('left')))
									let Z = R(V),
										ne =
											(V.operator === '|>' ||
												V.type === 'NGPipeExpression' ||
												(V.operator === '|' && L.parser === '__vue_expression')) &&
											!b(L.originalText, V.right),
										ee = V.type === 'NGPipeExpression' ? '|' : V.operator,
										ce =
											V.type === 'NGPipeExpression' && V.arguments.length > 0
												? f(
														y([
															l,
															': ',
															g(
																[l, ': '],
																m.map(S, 'arguments').map((De) => x(2, f(De)))
															)
														])
												  )
												: '',
										z
									if (Z) z = [ee, ' ', S('right'), ce]
									else {
										let De =
											re(L) && ee === '|>'
												? m.call((Fe) => T(Fe, S, L, !0, M), 'right')
												: S('right')
										z = [ne ? l : '', ee, ne ? ' ' : l, De, ce]
									}
									let ye = m.getParentNode(),
										te = O(V.left, U.Trailing | U.Line),
										X =
											te ||
											(!(M && V.type === 'LogicalExpression') &&
												ye.type !== V.type &&
												V.left.type !== V.type &&
												V.right.type !== V.type)
									if ((J.push(ne ? '' : ' ', X ? f(z, { shouldBreak: te }) : z), P && O(V))) {
										let De = w(c(m, J, L))
										return v(De) || De.type === 'fill' ? C(De) : [De]
									}
									return J
								}
								function R(m) {
									return m.type !== 'LogicalExpression'
										? !1
										: !!(
												(m.right.type === 'ObjectExpression' && m.right.properties.length > 0) ||
												(m.right.type === 'ArrayExpression' && m.right.elements.length > 0) ||
												q(m.right)
										  )
								}
								E.exports = { printBinaryishExpression: $, shouldInlineLogicalExpression: R }
							}
						}),
						ky = le({
							'src/language-js/print/angular.js'(d, E) {
								'use strict'
								ge()
								var {
										builders: { join: c, line: D, group: g }
									} = dn(),
									{ hasNode: l, hasComment: p, getComments: f } = er(),
									{ printBinaryishExpression: y } = mp()
								function x(C, v, b) {
									let k = C.getValue()
									if (k.type.startsWith('NG'))
										switch (k.type) {
											case 'NGRoot':
												return [b('node'), p(k.node) ? ' //' + f(k.node)[0].value.trimEnd() : '']
											case 'NGPipeExpression':
												return y(C, v, b)
											case 'NGChainedExpression':
												return g(
													c(
														[';', D],
														C.map((q) => (w(q) ? b() : ['(', b(), ')']), 'expressions')
													)
												)
											case 'NGEmptyExpression':
												return ''
											case 'NGQuotedExpression':
												return [k.prefix, ': ', k.value.trim()]
											case 'NGMicrosyntax':
												return C.map(
													(q, G) => [G === 0 ? '' : _(q.getValue(), G, k) ? ' ' : [';', D], b()],
													'body'
												)
											case 'NGMicrosyntaxKey':
												return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(k.name)
													? k.name
													: JSON.stringify(k.name)
											case 'NGMicrosyntaxExpression':
												return [b('expression'), k.alias === null ? '' : [' as ', b('alias')]]
											case 'NGMicrosyntaxKeyedExpression': {
												let q = C.getName(),
													G = C.getParentNode(),
													O =
														_(k, q, G) ||
														(((q === 1 && (k.key.name === 'then' || k.key.name === 'else')) ||
															(q === 2 &&
																k.key.name === 'else' &&
																G.body[q - 1].type === 'NGMicrosyntaxKeyedExpression' &&
																G.body[q - 1].key.name === 'then')) &&
															G.body[0].type === 'NGMicrosyntaxExpression')
												return [b('key'), O ? ' ' : ': ', b('expression')]
											}
											case 'NGMicrosyntaxLet':
												return ['let ', b('key'), k.value === null ? '' : [' = ', b('value')]]
											case 'NGMicrosyntaxAs':
												return [b('key'), ' as ', b('alias')]
											default:
												throw new Error(`Unknown Angular node type: ${JSON.stringify(k.type)}.`)
										}
								}
								function _(C, v, b) {
									return (
										C.type === 'NGMicrosyntaxKeyedExpression' &&
										C.key.name === 'of' &&
										v === 1 &&
										b.body[0].type === 'NGMicrosyntaxLet' &&
										b.body[0].value === null
									)
								}
								function w(C) {
									return l(C.getValue(), (v) => {
										switch (v.type) {
											case void 0:
												return !1
											case 'CallExpression':
											case 'OptionalCallExpression':
											case 'AssignmentExpression':
												return !0
										}
									})
								}
								E.exports = { printAngular: x }
							}
						}),
						Ry = le({
							'src/language-js/print/jsx.js'(d, E) {
								'use strict'
								ge()
								var {
										printComments: c,
										printDanglingComments: D,
										printCommentsSeparately: g
									} = Sr(),
									{
										builders: {
											line: l,
											hardline: p,
											softline: f,
											group: y,
											indent: x,
											conditionalGroup: _,
											fill: w,
											ifBreak: C,
											lineSuffixBoundary: v,
											join: b
										},
										utils: { willBreak: k }
									} = dn(),
									{ getLast: q, getPreferredQuote: G } = wn(),
									{
										isJsxNode: O,
										rawText: U,
										isCallExpression: j,
										isStringLiteral: H,
										isBinaryish: W,
										hasComment: re,
										CommentCheckFlags: A,
										hasNodeIgnoreComment: $
									} = er(),
									T = vo(),
									{ willPrintOwnComments: R } = U1(),
									m = (ae) => ae === '' || ae === l || ae === p || ae === f
								function S(ae, xe, Ce) {
									let Ge = ae.getValue()
									if (Ge.type === 'JSXElement' && Be(Ge))
										return [Ce('openingElement'), Ce('closingElement')]
									let nt = Ge.type === 'JSXElement' ? Ce('openingElement') : Ce('openingFragment'),
										ot = Ge.type === 'JSXElement' ? Ce('closingElement') : Ce('closingFragment')
									if (
										Ge.children.length === 1 &&
										Ge.children[0].type === 'JSXExpressionContainer' &&
										(Ge.children[0].expression.type === 'TemplateLiteral' ||
											Ge.children[0].expression.type === 'TaggedTemplateExpression')
									)
										return [nt, ...ae.map(Ce, 'children'), ot]
									Ge.children = Ge.children.map((B) =>
										Dt(B) ? { type: 'JSXText', value: ' ', raw: ' ' } : B
									)
									let Ut = Ge.children.some(O),
										vn = Ge.children.filter((B) => B.type === 'JSXExpressionContainer').length > 1,
										Dn = Ge.type === 'JSXElement' && Ge.openingElement.attributes.length > 1,
										Vt = k(nt) || Ut || Dn || vn,
										tn = ae.getParentNode().rootMarker === 'mdx',
										Ie = xe.singleQuote ? "{' '}" : '{" "}',
										se = tn ? ' ' : C([Ie, f], ' '),
										je =
											Ge.openingElement &&
											Ge.openingElement.name &&
											Ge.openingElement.name.name === 'fbt',
										he = L(ae, xe, Ce, se, je),
										Oe = Ge.children.some((B) => Me(B))
									for (let B = he.length - 2; B >= 0; B--) {
										let pe = he[B] === '' && he[B + 1] === '',
											_e = he[B] === p && he[B + 1] === '' && he[B + 2] === p,
											st = (he[B] === f || he[B] === p) && he[B + 1] === '' && he[B + 2] === se,
											pt = he[B] === se && he[B + 1] === '' && (he[B + 2] === f || he[B + 2] === p),
											jt = he[B] === se && he[B + 1] === '' && he[B + 2] === se,
											at =
												(he[B] === f && he[B + 1] === '' && he[B + 2] === p) ||
												(he[B] === p && he[B + 1] === '' && he[B + 2] === f)
										;(_e && Oe) || pe || st || jt || at
											? he.splice(B, 2)
											: pt && he.splice(B + 1, 2)
									}
									for (; he.length > 0 && m(q(he)); ) he.pop()
									for (; he.length > 1 && m(he[0]) && m(he[1]); ) he.shift(), he.shift()
									let wt = []
									for (let [B, pe] of he.entries()) {
										if (pe === se) {
											if (B === 1 && he[B - 1] === '') {
												if (he.length === 2) {
													wt.push(Ie)
													continue
												}
												wt.push([Ie, p])
												continue
											} else if (B === he.length - 1) {
												wt.push(Ie)
												continue
											} else if (he[B - 1] === '' && he[B - 2] === p) {
												wt.push(Ie)
												continue
											}
										}
										wt.push(pe), k(pe) && (Vt = !0)
									}
									let mt = Oe ? w(wt) : y(wt, { shouldBreak: !0 })
									if (tn) return mt
									let Ue = y([nt, x([p, mt]), p, ot])
									return Vt ? Ue : _([y([nt, ...he, ot]), Ue])
								}
								function L(ae, xe, Ce, Ge, nt) {
									let ot = []
									return (
										ae.each((Ut, vn, Dn) => {
											let Vt = Ut.getValue()
											if (Vt.type === 'JSXText') {
												let tn = U(Vt)
												if (Me(Vt)) {
													let Ie = tn.split($e)
													if (Ie[0] === '') {
														if ((ot.push(''), Ie.shift(), /\n/.test(Ie[0]))) {
															let je = Dn[vn + 1]
															ot.push(M(nt, Ie[1], Vt, je))
														} else ot.push(Ge)
														Ie.shift()
													}
													let se
													if ((q(Ie) === '' && (Ie.pop(), (se = Ie.pop())), Ie.length === 0)) return
													for (let [je, he] of Ie.entries()) je % 2 === 1 ? ot.push(l) : ot.push(he)
													if (se !== void 0)
														if (/\n/.test(se)) {
															let je = Dn[vn + 1]
															ot.push(M(nt, q(ot), Vt, je))
														} else ot.push(Ge)
													else {
														let je = Dn[vn + 1]
														ot.push(P(nt, q(ot), Vt, je))
													}
												} else
													/\n/.test(tn)
														? tn.match(/\n/g).length > 1 && ot.push('', p)
														: ot.push('', Ge)
											} else {
												let tn = Ce()
												ot.push(tn)
												let Ie = Dn[vn + 1]
												if (Ie && Me(Ie)) {
													let se = fe(U(Ie)).split($e)[0]
													ot.push(P(nt, se, Vt, Ie))
												} else ot.push(p)
											}
										}, 'children'),
										ot
									)
								}
								function P(ae, xe, Ce, Ge) {
									return ae
										? ''
										: (Ce.type === 'JSXElement' && !Ce.closingElement) ||
										  (Ge && Ge.type === 'JSXElement' && !Ge.closingElement)
										? xe.length === 1
											? f
											: p
										: f
								}
								function M(ae, xe, Ce, Ge) {
									return ae
										? p
										: xe.length === 1
										? (Ce.type === 'JSXElement' && !Ce.closingElement) ||
										  (Ge && Ge.type === 'JSXElement' && !Ge.closingElement)
											? p
											: f
										: p
								}
								function V(ae, xe, Ce) {
									let Ge = ae.getParentNode()
									if (
										!Ge ||
										{
											ArrayExpression: !0,
											JSXAttribute: !0,
											JSXElement: !0,
											JSXExpressionContainer: !0,
											JSXFragment: !0,
											ExpressionStatement: !0,
											CallExpression: !0,
											OptionalCallExpression: !0,
											ConditionalExpression: !0,
											JsExpressionRoot: !0
										}[Ge.type]
									)
										return xe
									let nt = ae.match(
											void 0,
											(Ut) => Ut.type === 'ArrowFunctionExpression',
											j,
											(Ut) => Ut.type === 'JSXExpressionContainer'
										),
										ot = T(ae, Ce)
									return y([ot ? '' : C('('), x([f, xe]), f, ot ? '' : C(')')], { shouldBreak: nt })
								}
								function J(ae, xe, Ce) {
									let Ge = ae.getValue(),
										nt = []
									if ((nt.push(Ce('name')), Ge.value)) {
										let ot
										if (H(Ge.value)) {
											let Ut = U(Ge.value)
													.slice(1, -1)
													.replace(/&apos;/g, "'")
													.replace(/&quot;/g, '"'),
												{ escaped: vn, quote: Dn, regex: Vt } = G(Ut, xe.jsxSingleQuote ? "'" : '"')
											Ut = Ut.replace(Vt, vn)
											let { leading: tn, trailing: Ie } = ae.call(() => g(ae, xe), 'value')
											ot = [tn, Dn, Ut, Dn, Ie]
										} else ot = Ce('value')
										nt.push('=', ot)
									}
									return nt
								}
								function Z(ae, xe, Ce) {
									let Ge = ae.getValue(),
										nt = (ot, Ut) =>
											ot.type === 'JSXEmptyExpression' ||
											(!re(ot) &&
												(ot.type === 'ArrayExpression' ||
													ot.type === 'ObjectExpression' ||
													ot.type === 'ArrowFunctionExpression' ||
													(ot.type === 'AwaitExpression' &&
														(nt(ot.argument, ot) || ot.argument.type === 'JSXElement')) ||
													j(ot) ||
													ot.type === 'FunctionExpression' ||
													ot.type === 'TemplateLiteral' ||
													ot.type === 'TaggedTemplateExpression' ||
													ot.type === 'DoExpression' ||
													(O(Ut) && (ot.type === 'ConditionalExpression' || W(ot)))))
									return nt(Ge.expression, ae.getParentNode(0))
										? y(['{', Ce('expression'), v, '}'])
										: y(['{', x([f, Ce('expression')]), f, v, '}'])
								}
								function ne(ae, xe, Ce) {
									let Ge = ae.getValue(),
										nt = (Ge.name && re(Ge.name)) || (Ge.typeParameters && re(Ge.typeParameters))
									if (Ge.selfClosing && Ge.attributes.length === 0 && !nt)
										return ['<', Ce('name'), Ce('typeParameters'), ' />']
									if (
										Ge.attributes &&
										Ge.attributes.length === 1 &&
										Ge.attributes[0].value &&
										H(Ge.attributes[0].value) &&
										!Ge.attributes[0].value.value.includes(`
`) &&
										!nt &&
										!re(Ge.attributes[0])
									)
										return y([
											'<',
											Ce('name'),
											Ce('typeParameters'),
											' ',
											...ae.map(Ce, 'attributes'),
											Ge.selfClosing ? ' />' : '>'
										])
									let ot =
											Ge.attributes &&
											Ge.attributes.some(
												(vn) =>
													vn.value &&
													H(vn.value) &&
													vn.value.value.includes(`
`)
											),
										Ut = xe.singleAttributePerLine && Ge.attributes.length > 1 ? p : l
									return y(
										[
											'<',
											Ce('name'),
											Ce('typeParameters'),
											x(ae.map(() => [Ut, Ce()], 'attributes')),
											...ee(Ge, xe, nt)
										],
										{ shouldBreak: ot }
									)
								}
								function ee(ae, xe, Ce) {
									return ae.selfClosing ? [l, '/>'] : ce(ae, xe, Ce) ? ['>'] : [f, '>']
								}
								function ce(ae, xe, Ce) {
									let Ge = ae.attributes.length > 0 && re(q(ae.attributes), A.Trailing)
									return (
										(ae.attributes.length === 0 && !Ce) ||
										((xe.bracketSameLine || xe.jsxBracketSameLine) &&
											(!Ce || ae.attributes.length > 0) &&
											!Ge)
									)
								}
								function z(ae, xe, Ce) {
									let Ge = ae.getValue(),
										nt = []
									nt.push('</')
									let ot = Ce('name')
									return (
										re(Ge.name, A.Leading | A.Line)
											? nt.push(x([p, ot]), p)
											: re(Ge.name, A.Leading | A.Block)
											? nt.push(' ', ot)
											: nt.push(ot),
										nt.push('>'),
										nt
									)
								}
								function ye(ae, xe) {
									let Ce = ae.getValue(),
										Ge = re(Ce),
										nt = re(Ce, A.Line),
										ot = Ce.type === 'JSXOpeningFragment'
									return [
										ot ? '<' : '</',
										x([nt ? p : Ge && !ot ? ' ' : '', D(ae, xe, !0)]),
										nt ? p : '',
										'>'
									]
								}
								function te(ae, xe, Ce) {
									let Ge = c(ae, S(ae, xe, Ce), xe)
									return V(ae, Ge, xe)
								}
								function X(ae, xe) {
									let Ce = ae.getValue(),
										Ge = re(Ce, A.Line)
									return [D(ae, xe, !Ge), Ge ? p : '']
								}
								function De(ae, xe, Ce) {
									let Ge = ae.getValue()
									return [
										'{',
										ae.call(
											(nt) => {
												let ot = ['...', Ce()],
													Ut = nt.getValue()
												return !re(Ut) || !R(nt) ? ot : [x([f, c(nt, ot, xe)]), f]
											},
											Ge.type === 'JSXSpreadAttribute' ? 'argument' : 'expression'
										),
										'}'
									]
								}
								function Fe(ae, xe, Ce) {
									let Ge = ae.getValue()
									if (Ge.type.startsWith('JSX'))
										switch (Ge.type) {
											case 'JSXAttribute':
												return J(ae, xe, Ce)
											case 'JSXIdentifier':
												return String(Ge.name)
											case 'JSXNamespacedName':
												return b(':', [Ce('namespace'), Ce('name')])
											case 'JSXMemberExpression':
												return b('.', [Ce('object'), Ce('property')])
											case 'JSXSpreadAttribute':
												return De(ae, xe, Ce)
											case 'JSXSpreadChild':
												return De(ae, xe, Ce)
											case 'JSXExpressionContainer':
												return Z(ae, xe, Ce)
											case 'JSXFragment':
											case 'JSXElement':
												return te(ae, xe, Ce)
											case 'JSXOpeningElement':
												return ne(ae, xe, Ce)
											case 'JSXClosingElement':
												return z(ae, xe, Ce)
											case 'JSXOpeningFragment':
											case 'JSXClosingFragment':
												return ye(ae, xe)
											case 'JSXEmptyExpression':
												return X(ae, xe)
											case 'JSXText':
												throw new Error('JSXText should be handled by JSXElement')
											default:
												throw new Error(`Unknown JSX node type: ${JSON.stringify(Ge.type)}.`)
										}
								}
								var ve = ` 
\r	`,
									$e = new RegExp('([' + ve + ']+)'),
									ie = new RegExp('[^' + ve + ']'),
									fe = (ae) =>
										ae.replace(new RegExp('(?:^' + $e.source + '|' + $e.source + '$)'), '')
								function Be(ae) {
									if (ae.children.length === 0) return !0
									if (ae.children.length > 1) return !1
									let xe = ae.children[0]
									return xe.type === 'JSXText' && !Me(xe)
								}
								function Me(ae) {
									return ae.type === 'JSXText' && (ie.test(U(ae)) || !/\n/.test(U(ae)))
								}
								function Dt(ae) {
									return (
										ae.type === 'JSXExpressionContainer' &&
										H(ae.expression) &&
										ae.expression.value === ' ' &&
										!re(ae.expression)
									)
								}
								function me(ae) {
									let xe = ae.getValue(),
										Ce = ae.getParentNode()
									if (!Ce || !xe || !O(xe) || !O(Ce)) return !1
									let Ge = Ce.children.indexOf(xe),
										nt = null
									for (let ot = Ge; ot > 0; ot--) {
										let Ut = Ce.children[ot - 1]
										if (!(Ut.type === 'JSXText' && !Me(Ut))) {
											nt = Ut
											break
										}
									}
									return (
										nt &&
										nt.type === 'JSXExpressionContainer' &&
										nt.expression.type === 'JSXEmptyExpression' &&
										$(nt.expression)
									)
								}
								E.exports = { hasJsxIgnoreComment: me, printJsx: Fe }
							}
						}),
						hi = le({
							'src/language-js/print/misc.js'(d, E) {
								'use strict'
								ge()
								var { isNonEmptyArray: c } = wn(),
									{
										builders: { indent: D, join: g, line: l }
									} = dn(),
									{ isFlowAnnotationComment: p } = er()
								function f(q) {
									let G = q.getValue()
									return !G.optional || (G.type === 'Identifier' && G === q.getParentNode().key)
										? ''
										: G.type === 'OptionalCallExpression' ||
										  (G.type === 'OptionalMemberExpression' && G.computed)
										? '?.'
										: '?'
								}
								function y(q) {
									return q.getValue().definite ||
										q.match(
											void 0,
											(G, O) => O === 'id' && G.type === 'VariableDeclarator' && G.definite
										)
										? '!'
										: ''
								}
								function x(q, G, O) {
									let U = q.getValue()
									return U.typeArguments
										? O('typeArguments')
										: U.typeParameters
										? O('typeParameters')
										: ''
								}
								function _(q, G, O) {
									let U = q.getValue()
									if (!U.typeAnnotation) return ''
									let j = q.getParentNode(),
										H = j.type === 'DeclareFunction' && j.id === U
									return p(G.originalText, U.typeAnnotation)
										? [' /*: ', O('typeAnnotation'), ' */']
										: [H ? '' : ': ', O('typeAnnotation')]
								}
								function w(q, G, O) {
									return ['::', O('callee')]
								}
								function C(q, G, O) {
									let U = q.getValue()
									return c(U.modifiers) ? [g(' ', q.map(O, 'modifiers')), ' '] : ''
								}
								function v(q, G, O) {
									return q.type === 'EmptyStatement'
										? ';'
										: q.type === 'BlockStatement' || O
										? [' ', G]
										: D([l, G])
								}
								function b(q, G, O) {
									return ['...', O('argument'), _(q, G, O)]
								}
								function k(q, G) {
									let O = q.slice(1, -1)
									if (O.includes('"') || O.includes("'")) return q
									let U = G.singleQuote ? "'" : '"'
									return U + O + U
								}
								E.exports = {
									printOptionalToken: f,
									printDefiniteToken: y,
									printFunctionTypeParameters: x,
									printBindExpressionCallee: w,
									printTypeScriptModifiers: C,
									printTypeAnnotation: _,
									printRestSpread: b,
									adjustClause: v,
									printDirective: k
								}
							}
						}),
						ka = le({
							'src/language-js/print/array.js'(d, E) {
								'use strict'
								ge()
								var { printDanglingComments: c } = Sr(),
									{
										builders: {
											line: D,
											softline: g,
											hardline: l,
											group: p,
											indent: f,
											ifBreak: y,
											fill: x
										}
									} = dn(),
									{ getLast: _, hasNewline: w } = wn(),
									{
										shouldPrintComma: C,
										hasComment: v,
										CommentCheckFlags: b,
										isNextLineEmpty: k,
										isNumericLiteral: q,
										isSignedNumericLiteral: G
									} = er(),
									{ locStart: O } = Qr(),
									{ printOptionalToken: U, printTypeAnnotation: j } = hi()
								function H($, T, R) {
									let m = $.getValue(),
										S = [],
										L = m.type === 'TupleExpression' ? '#[' : '[',
										P = ']'
									if (m.elements.length === 0)
										v(m, b.Dangling) ? S.push(p([L, c($, T), g, P])) : S.push(L, P)
									else {
										let M = _(m.elements),
											V = !(M && M.type === 'RestElement'),
											J = M === null,
											Z = Symbol('array'),
											ne =
												!T.__inJestEach &&
												m.elements.length > 1 &&
												m.elements.every((z, ye, te) => {
													let X = z && z.type
													if (X !== 'ArrayExpression' && X !== 'ObjectExpression') return !1
													let De = te[ye + 1]
													if (De && X !== De.type) return !1
													let Fe = X === 'ArrayExpression' ? 'elements' : 'properties'
													return z[Fe] && z[Fe].length > 1
												}),
											ee = W(m, T),
											ce = V
												? J
													? ','
													: C(T)
													? ee
														? y(',', '', { groupId: Z })
														: y(',')
													: ''
												: ''
										S.push(
											p(
												[
													L,
													f([g, ee ? A($, T, R, ce) : [re($, T, 'elements', R), ce], c($, T, !0)]),
													g,
													P
												],
												{ shouldBreak: ne, id: Z }
											)
										)
									}
									return S.push(U($), j($, T, R)), S
								}
								function W($, T) {
									return (
										$.elements.length > 1 &&
										$.elements.every(
											(R) =>
												R &&
												(q(R) || (G(R) && !v(R.argument))) &&
												!v(
													R,
													b.Trailing | b.Line,
													(m) => !w(T.originalText, O(m), { backwards: !0 })
												)
										)
									)
								}
								function re($, T, R, m) {
									let S = [],
										L = []
									return (
										$.each((P) => {
											S.push(L, p(m())),
												(L = [',', D]),
												P.getValue() && k(P.getValue(), T) && L.push(g)
										}, R),
										S
									)
								}
								function A($, T, R, m) {
									let S = []
									return (
										$.each((L, P, M) => {
											let V = P === M.length - 1
											S.push([R(), V ? m : ',']),
												V ||
													S.push(
														k(L.getValue(), T) ? [l, l] : v(M[P + 1], b.Leading | b.Line) ? l : D
													)
										}, 'elements'),
										x(S)
									)
								}
								E.exports = { printArray: H, printArrayItems: re, isConciselyPrintedArray: W }
							}
						}),
						G1 = le({
							'src/language-js/print/call-arguments.js'(d, E) {
								'use strict'
								ge()
								var { printDanglingComments: c } = Sr(),
									{ getLast: D, getPenultimate: g } = wn(),
									{
										getFunctionParameters: l,
										hasComment: p,
										CommentCheckFlags: f,
										isFunctionCompositionArgs: y,
										isJsxNode: x,
										isLongCurriedCallExpression: _,
										shouldPrintComma: w,
										getCallArguments: C,
										iterateCallArgumentsPath: v,
										isNextLineEmpty: b,
										isCallExpression: k,
										isStringLiteral: q,
										isObjectProperty: G,
										isTSTypeExpression: O
									} = er(),
									{
										builders: {
											line: U,
											hardline: j,
											softline: H,
											group: W,
											indent: re,
											conditionalGroup: A,
											ifBreak: $,
											breakParent: T
										},
										utils: { willBreak: R }
									} = dn(),
									{ ArgExpansionBailout: m } = wa(),
									{ isConciselyPrintedArray: S } = ka()
								function L(ee, ce, z) {
									let ye = ee.getValue(),
										te = ye.type === 'ImportExpression',
										X = C(ye)
									if (X.length === 0) return ['(', c(ee, ce, !0), ')']
									if (J(X)) return ['(', z(['arguments', 0]), ', ', z(['arguments', 1]), ')']
									let De = !1,
										Fe = !1,
										ve = X.length - 1,
										$e = []
									v(ee, (me, ae) => {
										let xe = me.getNode(),
											Ce = [z()]
										ae === ve ||
											(b(xe, ce)
												? (ae === 0 && (Fe = !0), (De = !0), Ce.push(',', j, j))
												: Ce.push(',', U)),
											$e.push(Ce)
									})
									let ie =
										!(te || (ye.callee && ye.callee.type === 'Import')) && w(ce, 'all') ? ',' : ''
									function fe() {
										return W(['(', re([U, ...$e]), ie, U, ')'], { shouldBreak: !0 })
									}
									if (De || (ee.getParentNode().type !== 'Decorator' && y(X))) return fe()
									let Be = V(X),
										Me = M(X, ce)
									if (Be || Me) {
										if (Be ? $e.slice(1).some(R) : $e.slice(0, -1).some(R)) return fe()
										let me = []
										try {
											ee.try(() => {
												v(ee, (ae, xe) => {
													Be &&
														xe === 0 &&
														(me = [
															[
																z([], { expandFirstArg: !0 }),
																$e.length > 1 ? ',' : '',
																Fe ? j : U,
																Fe ? j : ''
															],
															...$e.slice(1)
														]),
														Me &&
															xe === ve &&
															(me = [...$e.slice(0, -1), z([], { expandLastArg: !0 })])
												})
											})
										} catch (ae) {
											if (ae instanceof m) return fe()
											throw ae
										}
										return [
											$e.some(R) ? T : '',
											A([
												['(', ...me, ')'],
												Be
													? ['(', W(me[0], { shouldBreak: !0 }), ...me.slice(1), ')']
													: ['(', ...$e.slice(0, -1), W(D(me), { shouldBreak: !0 }), ')'],
												fe()
											])
										]
									}
									let Dt = ['(', re([H, ...$e]), $(ie), H, ')']
									return _(ee) ? Dt : W(Dt, { shouldBreak: $e.some(R) || De })
								}
								function P(ee) {
									let ce = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1
									return (
										(ee.type === 'ObjectExpression' && (ee.properties.length > 0 || p(ee))) ||
										(ee.type === 'ArrayExpression' && (ee.elements.length > 0 || p(ee))) ||
										(ee.type === 'TSTypeAssertion' && P(ee.expression)) ||
										(O(ee) && P(ee.expression)) ||
										ee.type === 'FunctionExpression' ||
										(ee.type === 'ArrowFunctionExpression' &&
											(!ee.returnType ||
												!ee.returnType.typeAnnotation ||
												ee.returnType.typeAnnotation.type !== 'TSTypeReference' ||
												Z(ee.body)) &&
											(ee.body.type === 'BlockStatement' ||
												(ee.body.type === 'ArrowFunctionExpression' && P(ee.body, !0)) ||
												ee.body.type === 'ObjectExpression' ||
												ee.body.type === 'ArrayExpression' ||
												(!ce && (k(ee.body) || ee.body.type === 'ConditionalExpression')) ||
												x(ee.body))) ||
										ee.type === 'DoExpression' ||
										ee.type === 'ModuleExpression'
									)
								}
								function M(ee, ce) {
									let z = D(ee),
										ye = g(ee)
									return (
										!p(z, f.Leading) &&
										!p(z, f.Trailing) &&
										P(z) &&
										(!ye || ye.type !== z.type) &&
										(ee.length !== 2 ||
											ye.type !== 'ArrowFunctionExpression' ||
											z.type !== 'ArrayExpression') &&
										!(ee.length > 1 && z.type === 'ArrayExpression' && S(z, ce))
									)
								}
								function V(ee) {
									if (ee.length !== 2) return !1
									let [ce, z] = ee
									return ce.type === 'ModuleExpression' && ne(z)
										? !0
										: !p(ce) &&
												(ce.type === 'FunctionExpression' ||
													(ce.type === 'ArrowFunctionExpression' &&
														ce.body.type === 'BlockStatement')) &&
												z.type !== 'FunctionExpression' &&
												z.type !== 'ArrowFunctionExpression' &&
												z.type !== 'ConditionalExpression' &&
												!P(z)
								}
								function J(ee) {
									return (
										ee.length === 2 &&
										ee[0].type === 'ArrowFunctionExpression' &&
										l(ee[0]).length === 0 &&
										ee[0].body.type === 'BlockStatement' &&
										ee[1].type === 'ArrayExpression' &&
										!ee.some((ce) => p(ce))
									)
								}
								function Z(ee) {
									return (
										ee.type === 'BlockStatement' &&
										(ee.body.some((ce) => ce.type !== 'EmptyStatement') || p(ee, f.Dangling))
									)
								}
								function ne(ee) {
									return (
										ee.type === 'ObjectExpression' &&
										ee.properties.length === 1 &&
										G(ee.properties[0]) &&
										ee.properties[0].key.type === 'Identifier' &&
										ee.properties[0].key.name === 'type' &&
										q(ee.properties[0].value) &&
										ee.properties[0].value.value === 'module'
									)
								}
								E.exports = L
							}
						}),
						W1 = le({
							'src/language-js/print/member.js'(d, E) {
								'use strict'
								ge()
								var {
										builders: { softline: c, group: D, indent: g, label: l }
									} = dn(),
									{ isNumericLiteral: p, isMemberExpression: f, isCallExpression: y } = er(),
									{ printOptionalToken: x } = hi()
								function _(C, v, b) {
									let k = C.getValue(),
										q = C.getParentNode(),
										G,
										O = 0
									do (G = C.getParentNode(O)), O++
									while (G && (f(G) || G.type === 'TSNonNullExpression'))
									let U = b('object'),
										j = w(C, v, b),
										H =
											(G &&
												(G.type === 'NewExpression' ||
													G.type === 'BindExpression' ||
													(G.type === 'AssignmentExpression' && G.left.type !== 'Identifier'))) ||
											k.computed ||
											(k.object.type === 'Identifier' &&
												k.property.type === 'Identifier' &&
												!f(q)) ||
											((q.type === 'AssignmentExpression' || q.type === 'VariableDeclarator') &&
												((y(k.object) && k.object.arguments.length > 0) ||
													(k.object.type === 'TSNonNullExpression' &&
														y(k.object.expression) &&
														k.object.expression.arguments.length > 0) ||
													U.label === 'member-chain'))
									return l(U.label === 'member-chain' ? 'member-chain' : 'member', [
										U,
										H ? j : D(g([c, j]))
									])
								}
								function w(C, v, b) {
									let k = b('property'),
										q = C.getValue(),
										G = x(C)
									return q.computed
										? !q.property || p(q.property)
											? [G, '[', k, ']']
											: D([G, '[', g([c, k]), c, ']'])
										: [G, '.', k]
								}
								E.exports = { printMemberExpression: _, printMemberLookup: w }
							}
						}),
						Oy = le({
							'src/language-js/print/member-chain.js'(d, E) {
								'use strict'
								ge()
								var { printComments: c } = Sr(),
									{
										getLast: D,
										isNextLineEmptyAfterIndex: g,
										getNextNonSpaceNonCommentCharacterIndex: l
									} = wn(),
									p = vo(),
									{
										isCallExpression: f,
										isMemberExpression: y,
										isFunctionOrArrowExpression: x,
										isLongCurriedCallExpression: _,
										isMemberish: w,
										isNumericLiteral: C,
										isSimpleCallArgument: v,
										hasComment: b,
										CommentCheckFlags: k,
										isNextLineEmpty: q
									} = er(),
									{ locEnd: G } = Qr(),
									{
										builders: {
											join: O,
											hardline: U,
											group: j,
											indent: H,
											conditionalGroup: W,
											breakParent: re,
											label: A
										},
										utils: { willBreak: $ }
									} = dn(),
									T = G1(),
									{ printMemberLookup: R } = W1(),
									{
										printOptionalToken: m,
										printFunctionTypeParameters: S,
										printBindExpressionCallee: L
									} = hi()
								function P(M, V, J) {
									let Z = M.getParentNode(),
										ne = !Z || Z.type === 'ExpressionStatement',
										ee = []
									function ce(Vt) {
										let { originalText: tn } = V,
											Ie = l(tn, Vt, G)
										return tn.charAt(Ie) === ')' ? Ie !== !1 && g(tn, Ie + 1) : q(Vt, V)
									}
									function z(Vt) {
										let tn = Vt.getValue()
										f(tn) && (w(tn.callee) || f(tn.callee))
											? (ee.unshift({
													node: tn,
													printed: [c(Vt, [m(Vt), S(Vt, V, J), T(Vt, V, J)], V), ce(tn) ? U : '']
											  }),
											  Vt.call((Ie) => z(Ie), 'callee'))
											: w(tn)
											? (ee.unshift({
													node: tn,
													needsParens: p(Vt, V),
													printed: c(Vt, y(tn) ? R(Vt, V, J) : L(Vt, V, J), V)
											  }),
											  Vt.call((Ie) => z(Ie), 'object'))
											: tn.type === 'TSNonNullExpression'
											? (ee.unshift({ node: tn, printed: c(Vt, '!', V) }),
											  Vt.call((Ie) => z(Ie), 'expression'))
											: ee.unshift({ node: tn, printed: J() })
									}
									let ye = M.getValue()
									ee.unshift({ node: ye, printed: [m(M), S(M, V, J), T(M, V, J)] }),
										ye.callee && M.call((Vt) => z(Vt), 'callee')
									let te = [],
										X = [ee[0]],
										De = 1
									for (
										;
										De < ee.length &&
										(ee[De].node.type === 'TSNonNullExpression' ||
											f(ee[De].node) ||
											(y(ee[De].node) && ee[De].node.computed && C(ee[De].node.property)));
										++De
									)
										X.push(ee[De])
									if (!f(ee[0].node))
										for (; De + 1 < ee.length && w(ee[De].node) && w(ee[De + 1].node); ++De)
											X.push(ee[De])
									te.push(X), (X = [])
									let Fe = !1
									for (; De < ee.length; ++De) {
										if (Fe && w(ee[De].node)) {
											if (ee[De].node.computed && C(ee[De].node.property)) {
												X.push(ee[De])
												continue
											}
											te.push(X), (X = []), (Fe = !1)
										}
										;(f(ee[De].node) || ee[De].node.type === 'ImportExpression') && (Fe = !0),
											X.push(ee[De]),
											b(ee[De].node, k.Trailing) && (te.push(X), (X = []), (Fe = !1))
									}
									X.length > 0 && te.push(X)
									function ve(Vt) {
										return /^[A-Z]|^[$_]+$/.test(Vt)
									}
									function $e(Vt) {
										return Vt.length <= V.tabWidth
									}
									function ie(Vt) {
										let tn = Vt[1].length > 0 && Vt[1][0].node.computed
										if (Vt[0].length === 1) {
											let se = Vt[0][0].node
											return (
												se.type === 'ThisExpression' ||
												(se.type === 'Identifier' && (ve(se.name) || (ne && $e(se.name)) || tn))
											)
										}
										let Ie = D(Vt[0]).node
										return (
											y(Ie) && Ie.property.type === 'Identifier' && (ve(Ie.property.name) || tn)
										)
									}
									let fe = te.length >= 2 && !b(te[1][0].node) && ie(te)
									function Be(Vt) {
										let tn = Vt.map((Ie) => Ie.printed)
										return Vt.length > 0 && D(Vt).needsParens ? ['(', ...tn, ')'] : tn
									}
									function Me(Vt) {
										return Vt.length === 0 ? '' : H(j([U, O(U, Vt.map(Be))]))
									}
									let Dt = te.map(Be),
										me = Dt,
										ae = fe ? 3 : 2,
										xe = te.flat(),
										Ce =
											xe.slice(1, -1).some((Vt) => b(Vt.node, k.Leading)) ||
											xe.slice(0, -1).some((Vt) => b(Vt.node, k.Trailing)) ||
											(te[ae] && b(te[ae][0].node, k.Leading))
									if (te.length <= ae && !Ce) return _(M) ? me : j(me)
									let Ge = D(te[fe ? 1 : 0]).node,
										nt = !f(Ge) && ce(Ge),
										ot = [
											Be(te[0]),
											fe ? te.slice(1, 2).map(Be) : '',
											nt ? U : '',
											Me(te.slice(fe ? 2 : 1))
										],
										Ut = ee
											.map((Vt) => {
												let { node: tn } = Vt
												return tn
											})
											.filter(f)
									function vn() {
										let Vt = D(D(te)).node,
											tn = D(Dt)
										return f(Vt) && $(tn) && Ut.slice(0, -1).some((Ie) => Ie.arguments.some(x))
									}
									let Dn
									return (
										Ce ||
										(Ut.length > 2 && Ut.some((Vt) => !Vt.arguments.every((tn) => v(tn, 0)))) ||
										Dt.slice(0, -1).some($) ||
										vn()
											? (Dn = j(ot))
											: (Dn = [$(me) || nt ? re : '', W([me, ot])]),
										A('member-chain', Dn)
									)
								}
								E.exports = P
							}
						}),
						H1 = le({
							'src/language-js/print/call-expression.js'(d, E) {
								'use strict'
								ge()
								var {
										builders: { join: c, group: D }
									} = dn(),
									g = vo(),
									{
										getCallArguments: l,
										hasFlowAnnotationComment: p,
										isCallExpression: f,
										isMemberish: y,
										isStringLiteral: x,
										isTemplateOnItsOwnLine: _,
										isTestCall: w,
										iterateCallArgumentsPath: C
									} = er(),
									v = Oy(),
									b = G1(),
									{ printOptionalToken: k, printFunctionTypeParameters: q } = hi()
								function G(U, j, H) {
									let W = U.getValue(),
										re = U.getParentNode(),
										A = W.type === 'NewExpression',
										$ = W.type === 'ImportExpression',
										T = k(U),
										R = l(W)
									if (
										R.length > 0 &&
										((!$ && !A && O(W, re)) ||
											(R.length === 1 && _(R[0], j.originalText)) ||
											(!A && w(W, re)))
									) {
										let L = []
										return (
											C(U, () => {
												L.push(H())
											}),
											[A ? 'new ' : '', H('callee'), T, q(U, j, H), '(', c(', ', L), ')']
										)
									}
									let m =
										(j.parser === 'babel' || j.parser === 'babel-flow') &&
										W.callee &&
										W.callee.type === 'Identifier' &&
										p(W.callee.trailingComments)
									if (
										(m && (W.callee.trailingComments[0].printed = !0),
										!$ && !A && y(W.callee) && !U.call((L) => g(L, j), 'callee'))
									)
										return v(U, j, H)
									let S = [
										A ? 'new ' : '',
										$ ? 'import' : H('callee'),
										T,
										m ? `/*:: ${W.callee.trailingComments[0].value.slice(2).trim()} */` : '',
										q(U, j, H),
										b(U, j, H)
									]
									return $ || f(W.callee) ? D(S) : S
								}
								function O(U, j) {
									if (U.callee.type !== 'Identifier') return !1
									if (U.callee.name === 'require') return !0
									if (U.callee.name === 'define') {
										let H = l(U)
										return (
											j.type === 'ExpressionStatement' &&
											(H.length === 1 ||
												(H.length === 2 && H[0].type === 'ArrayExpression') ||
												(H.length === 3 && x(H[0]) && H[1].type === 'ArrayExpression'))
										)
									}
									return !1
								}
								E.exports = { printCallExpression: G }
							}
						}),
						Ra = le({
							'src/language-js/print/assignment.js'(d, E) {
								'use strict'
								ge()
								var { isNonEmptyArray: c, getStringWidth: D } = wn(),
									{
										builders: {
											line: g,
											group: l,
											indent: p,
											indentIfBreak: f,
											lineSuffixBoundary: y
										},
										utils: { cleanDoc: x, willBreak: _, canBreak: w }
									} = dn(),
									{
										hasLeadingOwnLineComment: C,
										isBinaryish: v,
										isStringLiteral: b,
										isLiteral: k,
										isNumericLiteral: q,
										isCallExpression: G,
										isMemberExpression: O,
										getCallArguments: U,
										rawText: j,
										hasComment: H,
										isSignedNumericLiteral: W,
										isObjectProperty: re
									} = er(),
									{ shouldInlineLogicalExpression: A } = mp(),
									{ printCallExpression: $ } = H1()
								function T(ie, fe, Be, Me, Dt, me) {
									let ae = S(ie, fe, Be, Me, me),
										xe = Be(me, { assignmentLayout: ae })
									switch (ae) {
										case 'break-after-operator':
											return l([l(Me), Dt, l(p([g, xe]))])
										case 'never-break-after-operator':
											return l([l(Me), Dt, ' ', xe])
										case 'fluid': {
											let Ce = Symbol('assignment')
											return l([l(Me), Dt, l(p(g), { id: Ce }), y, f(xe, { groupId: Ce })])
										}
										case 'break-lhs':
											return l([Me, Dt, ' ', l(xe)])
										case 'chain':
											return [l(Me), Dt, g, xe]
										case 'chain-tail':
											return [l(Me), Dt, p([g, xe])]
										case 'chain-tail-arrow-chain':
											return [l(Me), Dt, xe]
										case 'only-left':
											return Me
									}
								}
								function R(ie, fe, Be) {
									let Me = ie.getValue()
									return T(ie, fe, Be, Be('left'), [' ', Me.operator], 'right')
								}
								function m(ie, fe, Be) {
									return T(ie, fe, Be, Be('id'), ' =', 'init')
								}
								function S(ie, fe, Be, Me, Dt) {
									let me = ie.getValue(),
										ae = me[Dt]
									if (!ae) return 'only-left'
									let xe = !M(ae)
									if (
										ie.match(
											M,
											V,
											(Ge) =>
												!xe ||
												(Ge.type !== 'ExpressionStatement' && Ge.type !== 'VariableDeclaration')
										)
									)
										return xe
											? ae.type === 'ArrowFunctionExpression' &&
											  ae.body.type === 'ArrowFunctionExpression'
												? 'chain-tail-arrow-chain'
												: 'chain-tail'
											: 'chain'
									if ((!xe && M(ae.right)) || C(fe.originalText, ae)) return 'break-after-operator'
									if (
										(ae.type === 'CallExpression' && ae.callee.name === 'require') ||
										fe.parser === 'json5' ||
										fe.parser === 'json'
									)
										return 'never-break-after-operator'
									if (P(me) || J(me) || ee(me) || (ce(me) && w(Me))) return 'break-lhs'
									let Ce = Fe(me, Me, fe)
									return ie.call(() => L(ie, fe, Be, Ce), Dt)
										? 'break-after-operator'
										: Ce ||
										  ae.type === 'TemplateLiteral' ||
										  ae.type === 'TaggedTemplateExpression' ||
										  ae.type === 'BooleanLiteral' ||
										  q(ae) ||
										  ae.type === 'ClassExpression'
										? 'never-break-after-operator'
										: 'fluid'
								}
								function L(ie, fe, Be, Me) {
									let Dt = ie.getValue()
									if (v(Dt) && !A(Dt)) return !0
									switch (Dt.type) {
										case 'StringLiteralTypeAnnotation':
										case 'SequenceExpression':
											return !0
										case 'ConditionalExpression': {
											let { test: xe } = Dt
											return v(xe) && !A(xe)
										}
										case 'ClassExpression':
											return c(Dt.decorators)
									}
									if (Me) return !1
									let me = Dt,
										ae = []
									for (;;)
										if (me.type === 'UnaryExpression') (me = me.argument), ae.push('argument')
										else if (me.type === 'TSNonNullExpression')
											(me = me.expression), ae.push('expression')
										else break
									return !!(b(me) || ie.call(() => te(ie, fe, Be), ...ae))
								}
								function P(ie) {
									if (V(ie)) {
										let fe = ie.left || ie.id
										return (
											fe.type === 'ObjectPattern' &&
											fe.properties.length > 2 &&
											fe.properties.some(
												(Be) =>
													re(Be) &&
													(!Be.shorthand || (Be.value && Be.value.type === 'AssignmentPattern'))
											)
										)
									}
									return !1
								}
								function M(ie) {
									return ie.type === 'AssignmentExpression'
								}
								function V(ie) {
									return M(ie) || ie.type === 'VariableDeclarator'
								}
								function J(ie) {
									let fe = Z(ie)
									if (c(fe)) {
										let Be = ie.type === 'TSTypeAliasDeclaration' ? 'constraint' : 'bound'
										if (fe.length > 1 && fe.some((Me) => Me[Be] || Me.default)) return !0
									}
									return !1
								}
								function Z(ie) {
									return ne(ie) && ie.typeParameters && ie.typeParameters.params
										? ie.typeParameters.params
										: null
								}
								function ne(ie) {
									return ie.type === 'TSTypeAliasDeclaration' || ie.type === 'TypeAlias'
								}
								function ee(ie) {
									if (ie.type !== 'VariableDeclarator') return !1
									let { typeAnnotation: fe } = ie.id
									if (!fe || !fe.typeAnnotation) return !1
									let Be = z(fe.typeAnnotation)
									return (
										c(Be) &&
										Be.length > 1 &&
										Be.some((Me) => c(z(Me)) || Me.type === 'TSConditionalType')
									)
								}
								function ce(ie) {
									return (
										ie.type === 'VariableDeclarator' &&
										ie.init &&
										ie.init.type === 'ArrowFunctionExpression'
									)
								}
								function z(ie) {
									return ye(ie) && ie.typeParameters && ie.typeParameters.params
										? ie.typeParameters.params
										: null
								}
								function ye(ie) {
									return ie.type === 'TSTypeReference' || ie.type === 'GenericTypeAnnotation'
								}
								function te(ie, fe, Be) {
									let Me = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1,
										Dt = ie.getValue(),
										me = () => te(ie, fe, Be, !0)
									if (Dt.type === 'TSNonNullExpression') return ie.call(me, 'expression')
									if (G(Dt)) {
										if ($(ie, fe, Be).label === 'member-chain') return !1
										let ae = U(Dt)
										return !(ae.length === 0 || (ae.length === 1 && De(ae[0], fe))) || ve(Dt, Be)
											? !1
											: ie.call(me, 'callee')
									}
									return O(Dt)
										? ie.call(me, 'object')
										: Me && (Dt.type === 'Identifier' || Dt.type === 'ThisExpression')
								}
								var X = 0.25
								function De(ie, fe) {
									let { printWidth: Be } = fe
									if (H(ie)) return !1
									let Me = Be * X
									if (
										ie.type === 'ThisExpression' ||
										(ie.type === 'Identifier' && ie.name.length <= Me) ||
										(W(ie) && !H(ie.argument))
									)
										return !0
									let Dt =
										(ie.type === 'Literal' && 'regex' in ie && ie.regex.pattern) ||
										(ie.type === 'RegExpLiteral' && ie.pattern)
									return Dt
										? Dt.length <= Me
										: b(ie)
										? j(ie).length <= Me
										: ie.type === 'TemplateLiteral'
										? ie.expressions.length === 0 &&
										  ie.quasis[0].value.raw.length <= Me &&
										  !ie.quasis[0].value.raw.includes(`
`)
										: k(ie)
								}
								function Fe(ie, fe, Be) {
									if (!re(ie)) return !1
									fe = x(fe)
									let Me = 3
									return typeof fe == 'string' && D(fe) < Be.tabWidth + Me
								}
								function ve(ie, fe) {
									let Be = $e(ie)
									if (c(Be)) {
										if (Be.length > 1) return !0
										if (Be.length === 1) {
											let Dt = Be[0]
											if (
												Dt.type === 'TSUnionType' ||
												Dt.type === 'UnionTypeAnnotation' ||
												Dt.type === 'TSIntersectionType' ||
												Dt.type === 'IntersectionTypeAnnotation' ||
												Dt.type === 'TSTypeLiteral' ||
												Dt.type === 'ObjectTypeAnnotation'
											)
												return !0
										}
										let Me = ie.typeParameters ? 'typeParameters' : 'typeArguments'
										if (_(fe(Me))) return !0
									}
									return !1
								}
								function $e(ie) {
									return (
										(ie.typeParameters && ie.typeParameters.params) ||
										(ie.typeArguments && ie.typeArguments.params)
									)
								}
								E.exports = {
									printVariableDeclarator: m,
									printAssignmentExpression: R,
									printAssignment: T,
									isArrowFunctionVariableDeclarator: ce
								}
							}
						}),
						zu = le({
							'src/language-js/print/function-parameters.js'(d, E) {
								'use strict'
								ge()
								var { getNextNonSpaceNonCommentCharacter: c } = wn(),
									{ printDanglingComments: D } = Sr(),
									{
										builders: {
											line: g,
											hardline: l,
											softline: p,
											group: f,
											indent: y,
											ifBreak: x
										},
										utils: { removeLines: _, willBreak: w }
									} = dn(),
									{
										getFunctionParameters: C,
										iterateFunctionParametersPath: v,
										isSimpleType: b,
										isTestCall: k,
										isTypeAnnotationAFunction: q,
										isObjectType: G,
										isObjectTypePropertyAFunction: O,
										hasRestParameter: U,
										shouldPrintComma: j,
										hasComment: H,
										isNextLineEmpty: W
									} = er(),
									{ locEnd: re } = Qr(),
									{ ArgExpansionBailout: A } = wa(),
									{ printFunctionTypeParameters: $ } = hi()
								function T(L, P, M, V, J) {
									let Z = L.getValue(),
										ne = C(Z),
										ee = J ? $(L, M, P) : ''
									if (ne.length === 0)
										return [ee, '(', D(L, M, !0, (De) => c(M.originalText, De, re) === ')'), ')']
									let ce = L.getParentNode(),
										z = k(ce),
										ye = R(Z),
										te = []
									if (
										(v(L, (De, Fe) => {
											let ve = Fe === ne.length - 1
											ve && Z.rest && te.push('...'),
												te.push(P()),
												!ve &&
													(te.push(','),
													z || ye ? te.push(' ') : W(ne[Fe], M) ? te.push(l, l) : te.push(g))
										}),
										V)
									) {
										if (w(ee) || w(te)) throw new A()
										return f([_(ee), '(', _(te), ')'])
									}
									let X = ne.every((De) => !De.decorators)
									return ye && X
										? [ee, '(', ...te, ')']
										: z
										? [ee, '(', ...te, ')']
										: (O(ce) ||
												q(ce) ||
												ce.type === 'TypeAlias' ||
												ce.type === 'UnionTypeAnnotation' ||
												ce.type === 'TSUnionType' ||
												ce.type === 'IntersectionTypeAnnotation' ||
												(ce.type === 'FunctionTypeAnnotation' && ce.returnType === Z)) &&
										  ne.length === 1 &&
										  ne[0].name === null &&
										  Z.this !== ne[0] &&
										  ne[0].typeAnnotation &&
										  Z.typeParameters === null &&
										  b(ne[0].typeAnnotation) &&
										  !Z.rest
										? M.arrowParens === 'always'
											? ['(', ...te, ')']
											: te
										: [ee, '(', y([p, ...te]), x(!U(Z) && j(M, 'all') ? ',' : ''), p, ')']
								}
								function R(L) {
									if (!L) return !1
									let P = C(L)
									if (P.length !== 1) return !1
									let [M] = P
									return (
										!H(M) &&
										(M.type === 'ObjectPattern' ||
											M.type === 'ArrayPattern' ||
											(M.type === 'Identifier' &&
												M.typeAnnotation &&
												(M.typeAnnotation.type === 'TypeAnnotation' ||
													M.typeAnnotation.type === 'TSTypeAnnotation') &&
												G(M.typeAnnotation.typeAnnotation)) ||
											(M.type === 'FunctionTypeParam' && G(M.typeAnnotation)) ||
											(M.type === 'AssignmentPattern' &&
												(M.left.type === 'ObjectPattern' || M.left.type === 'ArrayPattern') &&
												(M.right.type === 'Identifier' ||
													(M.right.type === 'ObjectExpression' &&
														M.right.properties.length === 0) ||
													(M.right.type === 'ArrayExpression' && M.right.elements.length === 0))))
									)
								}
								function m(L) {
									let P
									return (
										L.returnType
											? ((P = L.returnType), P.typeAnnotation && (P = P.typeAnnotation))
											: L.typeAnnotation && (P = L.typeAnnotation),
										P
									)
								}
								function S(L, P) {
									let M = m(L)
									if (!M) return !1
									let V = L.typeParameters && L.typeParameters.params
									if (V) {
										if (V.length > 1) return !1
										if (V.length === 1) {
											let J = V[0]
											if (J.constraint || J.default) return !1
										}
									}
									return C(L).length === 1 && (G(M) || w(P))
								}
								E.exports = {
									printFunctionParameters: T,
									shouldHugFunctionParameters: R,
									shouldGroupFunctionParameters: S
								}
							}
						}),
						Qu = le({
							'src/language-js/print/type-annotation.js'(d, E) {
								'use strict'
								ge()
								var { printComments: c, printDanglingComments: D } = Sr(),
									{ isNonEmptyArray: g } = wn(),
									{
										builders: {
											group: l,
											join: p,
											line: f,
											softline: y,
											indent: x,
											align: _,
											ifBreak: w
										}
									} = dn(),
									C = vo(),
									{ locStart: v } = Qr(),
									{
										isSimpleType: b,
										isObjectType: k,
										hasLeadingOwnLineComment: q,
										isObjectTypePropertyAFunction: G,
										shouldPrintComma: O
									} = er(),
									{ printAssignment: U } = Ra(),
									{ printFunctionParameters: j, shouldGroupFunctionParameters: H } = zu(),
									{ printArrayItems: W } = ka()
								function re(M) {
									if (b(M) || k(M)) return !0
									if (M.type === 'UnionTypeAnnotation' || M.type === 'TSUnionType') {
										let V = M.types.filter(
												(Z) =>
													Z.type === 'VoidTypeAnnotation' ||
													Z.type === 'TSVoidKeyword' ||
													Z.type === 'NullLiteralTypeAnnotation' ||
													Z.type === 'TSNullKeyword'
											).length,
											J = M.types.some(
												(Z) =>
													Z.type === 'ObjectTypeAnnotation' ||
													Z.type === 'TSTypeLiteral' ||
													Z.type === 'GenericTypeAnnotation' ||
													Z.type === 'TSTypeReference'
											)
										if (M.types.length - 1 === V && J) return !0
									}
									return !1
								}
								function A(M, V, J) {
									let Z = V.semi ? ';' : '',
										ne = M.getValue(),
										ee = []
									return (
										ee.push('opaque type ', J('id'), J('typeParameters')),
										ne.supertype && ee.push(': ', J('supertype')),
										ne.impltype && ee.push(' = ', J('impltype')),
										ee.push(Z),
										ee
									)
								}
								function $(M, V, J) {
									let Z = V.semi ? ';' : '',
										ne = M.getValue(),
										ee = []
									ne.declare && ee.push('declare '), ee.push('type ', J('id'), J('typeParameters'))
									let ce = ne.type === 'TSTypeAliasDeclaration' ? 'typeAnnotation' : 'right'
									return [U(M, V, J, ee, ' =', ce), Z]
								}
								function T(M, V, J) {
									let Z = M.getValue(),
										ne = M.map(J, 'types'),
										ee = [],
										ce = !1
									for (let z = 0; z < ne.length; ++z)
										z === 0
											? ee.push(ne[z])
											: k(Z.types[z - 1]) && k(Z.types[z])
											? ee.push([' & ', ce ? x(ne[z]) : ne[z]])
											: !k(Z.types[z - 1]) && !k(Z.types[z])
											? ee.push(x([' &', f, ne[z]]))
											: (z > 1 && (ce = !0), ee.push(' & ', z > 1 ? x(ne[z]) : ne[z]))
									return l(ee)
								}
								function R(M, V, J) {
									let Z = M.getValue(),
										ne = M.getParentNode(),
										ee =
											ne.type !== 'TypeParameterInstantiation' &&
											ne.type !== 'TSTypeParameterInstantiation' &&
											ne.type !== 'GenericTypeAnnotation' &&
											ne.type !== 'TSTypeReference' &&
											ne.type !== 'TSTypeAssertion' &&
											ne.type !== 'TupleTypeAnnotation' &&
											ne.type !== 'TSTupleType' &&
											!(
												ne.type === 'FunctionTypeParam' &&
												!ne.name &&
												M.getParentNode(1).this !== ne
											) &&
											!(
												(ne.type === 'TypeAlias' ||
													ne.type === 'VariableDeclarator' ||
													ne.type === 'TSTypeAliasDeclaration') &&
												q(V.originalText, Z)
											),
										ce = re(Z),
										z = M.map((X) => {
											let De = J()
											return ce || (De = _(2, De)), c(X, De, V)
										}, 'types')
									if (ce) return p(' | ', z)
									let ye = ee && !q(V.originalText, Z),
										te = [w([ye ? f : '', '| ']), p([f, '| '], z)]
									return C(M, V)
										? l([x(te), y])
										: (ne.type === 'TupleTypeAnnotation' && ne.types.length > 1) ||
										  (ne.type === 'TSTupleType' && ne.elementTypes.length > 1)
										? l([x([w(['(', y]), te]), y, w(')')])
										: l(ee ? x(te) : te)
								}
								function m(M, V, J) {
									let Z = M.getValue(),
										ne = [],
										ee = M.getParentNode(0),
										ce = M.getParentNode(1),
										z = M.getParentNode(2),
										ye =
											Z.type === 'TSFunctionType' ||
											!(
												((ee.type === 'ObjectTypeProperty' ||
													ee.type === 'ObjectTypeInternalSlot') &&
													!ee.variance &&
													!ee.optional &&
													v(ee) === v(Z)) ||
												ee.type === 'ObjectTypeCallProperty' ||
												(z && z.type === 'DeclareFunction')
											),
										te = ye && (ee.type === 'TypeAnnotation' || ee.type === 'TSTypeAnnotation'),
										X =
											te &&
											ye &&
											(ee.type === 'TypeAnnotation' || ee.type === 'TSTypeAnnotation') &&
											ce.type === 'ArrowFunctionExpression'
									G(ee) && ((ye = !0), (te = !0)), X && ne.push('(')
									let De = j(M, J, V, !1, !0),
										Fe =
											Z.returnType || Z.predicate || Z.typeAnnotation
												? [ye ? ' => ' : ': ', J('returnType'), J('predicate'), J('typeAnnotation')]
												: '',
										ve = H(Z, Fe)
									return ne.push(ve ? l(De) : De), Fe && ne.push(Fe), X && ne.push(')'), l(ne)
								}
								function S(M, V, J) {
									let Z = M.getValue(),
										ne = Z.type === 'TSTupleType' ? 'elementTypes' : 'types',
										ee = Z[ne],
										ce = g(ee),
										z = ce ? y : ''
									return l([
										'[',
										x([z, W(M, V, ne, J)]),
										w(ce && O(V, 'all') ? ',' : ''),
										D(M, V, !0),
										z,
										']'
									])
								}
								function L(M, V, J) {
									let Z = M.getValue(),
										ne = Z.type === 'OptionalIndexedAccessType' && Z.optional ? '?.[' : '['
									return [J('objectType'), ne, J('indexType'), ']']
								}
								function P(M, V, J) {
									let Z = M.getValue()
									return [Z.postfix ? '' : J, V('typeAnnotation'), Z.postfix ? J : '']
								}
								E.exports = {
									printOpaqueType: A,
									printTypeAlias: $,
									printIntersectionType: T,
									printUnionType: R,
									printFunctionType: m,
									printTupleType: S,
									printIndexedAccessType: L,
									shouldHugType: re,
									printJSDocType: P
								}
							}
						}),
						Yu = le({
							'src/language-js/print/type-parameters.js'(d, E) {
								'use strict'
								ge()
								var { printDanglingComments: c } = Sr(),
									{
										builders: {
											join: D,
											line: g,
											hardline: l,
											softline: p,
											group: f,
											indent: y,
											ifBreak: x
										}
									} = dn(),
									{
										isTestCall: _,
										hasComment: w,
										CommentCheckFlags: C,
										isTSXFile: v,
										shouldPrintComma: b,
										getFunctionParameters: k,
										isObjectType: q,
										getTypeScriptMappedTypeModifier: G
									} = er(),
									{ createGroupIdMapper: O } = wn(),
									{ shouldHugType: U } = Qu(),
									{ isArrowFunctionVariableDeclarator: j } = Ra(),
									H = O('typeParameters')
								function W($, T, R, m) {
									let S = $.getValue()
									if (!S[m]) return ''
									if (!Array.isArray(S[m])) return R(m)
									let L = $.getNode(2),
										P = L && _(L),
										M = $.match(
											(J) => !(J[m].length === 1 && q(J[m][0])),
											void 0,
											(J, Z) => Z === 'typeAnnotation',
											(J) => J.type === 'Identifier',
											j
										)
									if (
										S[m].length === 0 ||
										(!M &&
											(P ||
												(S[m].length === 1 &&
													(S[m][0].type === 'NullableTypeAnnotation' || U(S[m][0])))))
									)
										return ['<', D(', ', $.map(R, m)), re($, T), '>']
									let V =
										S.type === 'TSTypeParameterInstantiation'
											? ''
											: k(S).length === 1 &&
											  v(T) &&
											  !S[m][0].constraint &&
											  $.getParentNode().type === 'ArrowFunctionExpression'
											? ','
											: b(T, 'all')
											? x(',')
											: ''
									return f(['<', y([p, D([',', g], $.map(R, m))]), V, p, '>'], { id: H(S) })
								}
								function re($, T) {
									let R = $.getValue()
									if (!w(R, C.Dangling)) return ''
									let m = !w(R, C.Line),
										S = c($, T, m)
									return m ? S : [S, l]
								}
								function A($, T, R) {
									let m = $.getValue(),
										S = [m.type === 'TSTypeParameter' && m.const ? 'const ' : ''],
										L = $.getParentNode()
									return L.type === 'TSMappedType'
										? (L.readonly && S.push(G(L.readonly, 'readonly'), ' '),
										  S.push('[', R('name')),
										  m.constraint && S.push(' in ', R('constraint')),
										  L.nameType &&
												S.push(
													' as ',
													$.callParent(() => R('nameType'))
												),
										  S.push(']'),
										  S)
										: (m.variance && S.push(R('variance')),
										  m.in && S.push('in '),
										  m.out && S.push('out '),
										  S.push(R('name')),
										  m.bound && S.push(': ', R('bound')),
										  m.constraint && S.push(' extends ', R('constraint')),
										  m.default && S.push(' = ', R('default')),
										  S)
								}
								E.exports = {
									printTypeParameter: A,
									printTypeParameters: W,
									getTypeParametersGroupId: H
								}
							}
						}),
						Oa = le({
							'src/language-js/print/property.js'(d, E) {
								'use strict'
								ge()
								var { printComments: c } = Sr(),
									{ printString: D, printNumber: g } = wn(),
									{
										isNumericLiteral: l,
										isSimpleNumber: p,
										isStringLiteral: f,
										isStringPropSafeToUnquote: y,
										rawText: x
									} = er(),
									{ printAssignment: _ } = Ra(),
									w = new WeakMap()
								function C(b, k, q) {
									let G = b.getNode()
									if (G.computed) return ['[', q('key'), ']']
									let O = b.getParentNode(),
										{ key: U } = G
									if (k.quoteProps === 'consistent' && !w.has(O)) {
										let j = (O.properties || O.body || O.members).some(
											(H) => !H.computed && H.key && f(H.key) && !y(H, k)
										)
										w.set(O, j)
									}
									if (
										(U.type === 'Identifier' ||
											(l(U) &&
												p(g(x(U))) &&
												String(U.value) === g(x(U)) &&
												!(k.parser === 'typescript' || k.parser === 'babel-ts'))) &&
										(k.parser === 'json' || (k.quoteProps === 'consistent' && w.get(O)))
									) {
										let j = D(
											JSON.stringify(U.type === 'Identifier' ? U.name : U.value.toString()),
											k
										)
										return b.call((H) => c(H, j, k), 'key')
									}
									return y(G, k) &&
										(k.quoteProps === 'as-needed' || (k.quoteProps === 'consistent' && !w.get(O)))
										? b.call((j) => c(j, /^\d/.test(U.value) ? g(U.value) : U.value, k), 'key')
										: q('key')
								}
								function v(b, k, q) {
									return b.getValue().shorthand ? q('value') : _(b, k, q, C(b, k, q), ':', 'value')
								}
								E.exports = { printProperty: v, printPropertyKey: C }
							}
						}),
						Xu = le({
							'src/language-js/print/function.js'(d, E) {
								'use strict'
								ge()
								var c = Ia(),
									{ printDanglingComments: D, printCommentsSeparately: g } = Sr(),
									l = Ur(),
									{ getNextNonSpaceNonCommentCharacterIndex: p } = wn(),
									{
										builders: {
											line: f,
											softline: y,
											group: x,
											indent: _,
											ifBreak: w,
											hardline: C,
											join: v,
											indentIfBreak: b
										},
										utils: { removeLines: k, willBreak: q }
									} = dn(),
									{ ArgExpansionBailout: G } = wa(),
									{
										getFunctionParameters: O,
										hasLeadingOwnLineComment: U,
										isFlowAnnotationComment: j,
										isJsxNode: H,
										isTemplateOnItsOwnLine: W,
										shouldPrintComma: re,
										startsWithNoLookaheadToken: A,
										isBinaryish: $,
										isLineComment: T,
										hasComment: R,
										getComments: m,
										CommentCheckFlags: S,
										isCallLikeExpression: L,
										isCallExpression: P,
										getCallArguments: M,
										hasNakedLeftSide: V,
										getLeftSide: J
									} = er(),
									{ locEnd: Z } = Qr(),
									{ printFunctionParameters: ne, shouldGroupFunctionParameters: ee } = zu(),
									{ printPropertyKey: ce } = Oa(),
									{ printFunctionTypeParameters: z } = hi()
								function ye(ae, xe, Ce, Ge) {
									let nt = ae.getValue(),
										ot = !1
									if (
										(nt.type === 'FunctionDeclaration' || nt.type === 'FunctionExpression') &&
										Ge &&
										Ge.expandLastArg
									) {
										let tn = ae.getParentNode()
										P(tn) && M(tn).length > 1 && (ot = !0)
									}
									let Ut = []
									nt.type === 'TSDeclareFunction' && nt.declare && Ut.push('declare '),
										nt.async && Ut.push('async '),
										nt.generator ? Ut.push('function* ') : Ut.push('function '),
										nt.id && Ut.push(xe('id'))
									let vn = ne(ae, xe, Ce, ot),
										Dn = fe(ae, xe, Ce),
										Vt = ee(nt, Dn)
									return (
										Ut.push(
											z(ae, Ce, xe),
											x([Vt ? x(vn) : vn, Dn]),
											nt.body ? ' ' : '',
											xe('body')
										),
										Ce.semi && (nt.declare || !nt.body) && Ut.push(';'),
										Ut
									)
								}
								function te(ae, xe, Ce) {
									let Ge = ae.getNode(),
										{ kind: nt } = Ge,
										ot = Ge.value || Ge,
										Ut = []
									return (
										!nt || nt === 'init' || nt === 'method' || nt === 'constructor'
											? ot.async && Ut.push('async ')
											: (c.ok(nt === 'get' || nt === 'set'), Ut.push(nt, ' ')),
										ot.generator && Ut.push('*'),
										Ut.push(ce(ae, xe, Ce), Ge.optional || Ge.key.optional ? '?' : ''),
										Ge === ot
											? Ut.push(X(ae, xe, Ce))
											: ot.type === 'FunctionExpression'
											? Ut.push(ae.call((vn) => X(vn, xe, Ce), 'value'))
											: Ut.push(Ce('value')),
										Ut
									)
								}
								function X(ae, xe, Ce) {
									let Ge = ae.getNode(),
										nt = ne(ae, Ce, xe),
										ot = fe(ae, Ce, xe),
										Ut = ee(Ge, ot),
										vn = [z(ae, xe, Ce), x([Ut ? x(nt) : nt, ot])]
									return Ge.body ? vn.push(' ', Ce('body')) : vn.push(xe.semi ? ';' : ''), vn
								}
								function De(ae, xe, Ce, Ge) {
									let nt = ae.getValue(),
										ot = []
									if ((nt.async && ot.push('async '), ie(ae, xe))) ot.push(Ce(['params', 0]))
									else {
										let vn = Ge && (Ge.expandLastArg || Ge.expandFirstArg),
											Dn = fe(ae, Ce, xe)
										if (vn) {
											if (q(Dn)) throw new G()
											Dn = x(k(Dn))
										}
										ot.push(x([ne(ae, Ce, xe, vn, !0), Dn]))
									}
									let Ut = D(ae, xe, !0, (vn) => {
										let Dn = p(xe.originalText, vn, Z)
										return Dn !== !1 && xe.originalText.slice(Dn, Dn + 2) === '=>'
									})
									return Ut && ot.push(' ', Ut), ot
								}
								function Fe(ae, xe, Ce, Ge, nt, ot) {
									let Ut = ae.getName(),
										vn = ae.getParentNode(),
										Dn = L(vn) && Ut === 'callee',
										Vt = !!(xe && xe.assignmentLayout),
										tn =
											ot.body.type !== 'BlockStatement' &&
											ot.body.type !== 'ObjectExpression' &&
											ot.body.type !== 'SequenceExpression',
										Ie = (Dn && tn) || (xe && xe.assignmentLayout === 'chain-tail-arrow-chain'),
										se = Symbol('arrow-chain')
									return (
										ot.body.type === 'SequenceExpression' && (nt = x(['(', _([y, nt]), y, ')'])),
										x([
											x(_([Dn || Vt ? y : '', x(v([' =>', f], Ce), { shouldBreak: Ge })]), {
												id: se,
												shouldBreak: Ie
											}),
											' =>',
											b(tn ? _([f, nt]) : [' ', nt], { groupId: se }),
											Dn ? w(y, '', { groupId: se }) : ''
										])
									)
								}
								function ve(ae, xe, Ce, Ge) {
									let nt = ae.getValue(),
										ot = [],
										Ut = [],
										vn = !1
									if (
										((function se() {
											let je = De(ae, xe, Ce, Ge)
											if (ot.length === 0) ot.push(je)
											else {
												let { leading: he, trailing: Oe } = g(ae, xe)
												ot.push([he, je]), Ut.unshift(Oe)
											}
											;(vn =
												vn ||
												(nt.returnType && O(nt).length > 0) ||
												nt.typeParameters ||
												O(nt).some((he) => he.type !== 'Identifier')),
												nt.body.type !== 'ArrowFunctionExpression' || (Ge && Ge.expandLastArg)
													? Ut.unshift(Ce('body', Ge))
													: ((nt = nt.body), ae.call(se, 'body'))
										})(),
										ot.length > 1)
									)
										return Fe(ae, Ge, ot, vn, Ut, nt)
									let Dn = ot
									if (
										(Dn.push(' =>'),
										!U(xe.originalText, nt.body) &&
											(nt.body.type === 'ArrayExpression' ||
												nt.body.type === 'ObjectExpression' ||
												nt.body.type === 'BlockStatement' ||
												H(nt.body) ||
												W(nt.body, xe.originalText) ||
												nt.body.type === 'ArrowFunctionExpression' ||
												nt.body.type === 'DoExpression'))
									)
										return x([...Dn, ' ', Ut])
									if (nt.body.type === 'SequenceExpression')
										return x([...Dn, x([' (', _([y, Ut]), y, ')'])])
									let Vt =
											((Ge && Ge.expandLastArg) ||
												ae.getParentNode().type === 'JSXExpressionContainer') &&
											!R(nt),
										tn = Ge && Ge.expandLastArg && re(xe, 'all'),
										Ie =
											nt.body.type === 'ConditionalExpression' &&
											!A(nt.body, (se) => se.type === 'ObjectExpression')
									return x([
										...Dn,
										x([
											_([f, Ie ? w('', '(') : '', Ut, Ie ? w('', ')') : '']),
											Vt ? [w(tn ? ',' : ''), y] : ''
										])
									])
								}
								function $e(ae) {
									let xe = O(ae)
									return (
										xe.length === 1 &&
										!ae.typeParameters &&
										!R(ae, S.Dangling) &&
										xe[0].type === 'Identifier' &&
										!xe[0].typeAnnotation &&
										!R(xe[0]) &&
										!xe[0].optional &&
										!ae.predicate &&
										!ae.returnType
									)
								}
								function ie(ae, xe) {
									if (xe.arrowParens === 'always') return !1
									if (xe.arrowParens === 'avoid') {
										let Ce = ae.getValue()
										return $e(Ce)
									}
									return !1
								}
								function fe(ae, xe, Ce) {
									let Ge = ae.getValue(),
										nt = xe('returnType')
									if (Ge.returnType && j(Ce.originalText, Ge.returnType))
										return [' /*: ', nt, ' */']
									let ot = [nt]
									return (
										Ge.returnType && Ge.returnType.typeAnnotation && ot.unshift(': '),
										Ge.predicate && ot.push(Ge.returnType ? ' ' : ': ', xe('predicate')),
										ot
									)
								}
								function Be(ae, xe, Ce) {
									let Ge = ae.getValue(),
										nt = xe.semi ? ';' : '',
										ot = []
									Ge.argument &&
										(me(xe, Ge.argument)
											? ot.push([' (', _([C, Ce('argument')]), C, ')'])
											: $(Ge.argument) || Ge.argument.type === 'SequenceExpression'
											? ot.push(x([w(' (', ' '), _([y, Ce('argument')]), y, w(')')]))
											: ot.push(' ', Ce('argument')))
									let Ut = m(Ge),
										vn = l(Ut),
										Dn = vn && T(vn)
									return (
										Dn && ot.push(nt),
										R(Ge, S.Dangling) && ot.push(' ', D(ae, xe, !0)),
										Dn || ot.push(nt),
										ot
									)
								}
								function Me(ae, xe, Ce) {
									return ['return', Be(ae, xe, Ce)]
								}
								function Dt(ae, xe, Ce) {
									return ['throw', Be(ae, xe, Ce)]
								}
								function me(ae, xe) {
									if (U(ae.originalText, xe)) return !0
									if (V(xe)) {
										let Ce = xe,
											Ge
										for (; (Ge = J(Ce)); ) if (((Ce = Ge), U(ae.originalText, Ce))) return !0
									}
									return !1
								}
								E.exports = {
									printFunction: ye,
									printArrowFunction: ve,
									printMethod: te,
									printReturnStatement: Me,
									printThrowStatement: Dt,
									printMethodInternal: X,
									shouldPrintParamsWithoutParens: ie
								}
							}
						}),
						gp = le({
							'src/language-js/print/decorators.js'(d, E) {
								'use strict'
								ge()
								var { isNonEmptyArray: c, hasNewline: D } = wn(),
									{
										builders: { line: g, hardline: l, join: p, breakParent: f, group: y }
									} = dn(),
									{ locStart: x, locEnd: _ } = Qr(),
									{ getParentExportDeclaration: w } = er()
								function C(G, O, U) {
									let j = G.getValue()
									return y([p(g, G.map(U, 'decorators')), k(j, O) ? l : g])
								}
								function v(G, O, U) {
									return [p(l, G.map(U, 'declaration', 'decorators')), l]
								}
								function b(G, O, U) {
									let j = G.getValue(),
										{ decorators: H } = j
									if (!c(H) || q(G.getParentNode())) return
									let W = j.type === 'ClassExpression' || j.type === 'ClassDeclaration' || k(j, O)
									return [w(G) ? l : W ? f : '', p(g, G.map(U, 'decorators')), g]
								}
								function k(G, O) {
									return G.decorators.some((U) => D(O.originalText, _(U)))
								}
								function q(G) {
									if (
										G.type !== 'ExportDefaultDeclaration' &&
										G.type !== 'ExportNamedDeclaration' &&
										G.type !== 'DeclareExportDeclaration'
									)
										return !1
									let O = G.declaration && G.declaration.decorators
									return c(O) && x(G) === x(O[0])
								}
								E.exports = {
									printDecorators: b,
									printClassMemberDecorators: C,
									printDecoratorsBeforeExport: v,
									hasDecoratorsBeforeExport: q
								}
							}
						}),
						Ba = le({
							'src/language-js/print/class.js'(d, E) {
								'use strict'
								ge()
								var { isNonEmptyArray: c, createGroupIdMapper: D } = wn(),
									{ printComments: g, printDanglingComments: l } = Sr(),
									{
										builders: {
											join: p,
											line: f,
											hardline: y,
											softline: x,
											group: _,
											indent: w,
											ifBreak: C
										}
									} = dn(),
									{ hasComment: v, CommentCheckFlags: b } = er(),
									{ getTypeParametersGroupId: k } = Yu(),
									{ printMethod: q } = Xu(),
									{ printOptionalToken: G, printTypeAnnotation: O, printDefiniteToken: U } = hi(),
									{ printPropertyKey: j } = Oa(),
									{ printAssignment: H } = Ra(),
									{ printClassMemberDecorators: W } = gp()
								function re(M, V, J) {
									let Z = M.getValue(),
										ne = []
									Z.declare && ne.push('declare '),
										Z.abstract && ne.push('abstract '),
										ne.push('class')
									let ee =
											(Z.id && v(Z.id, b.Trailing)) ||
											(Z.typeParameters && v(Z.typeParameters, b.Trailing)) ||
											(Z.superClass && v(Z.superClass)) ||
											c(Z.extends) ||
											c(Z.mixins) ||
											c(Z.implements),
										ce = [],
										z = []
									if ((Z.id && ce.push(' ', J('id')), ce.push(J('typeParameters')), Z.superClass)) {
										let ye = [S(M, V, J), J('superTypeParameters')],
											te = M.call((X) => ['extends ', g(X, ye, V)], 'superClass')
										ee ? z.push(f, _(te)) : z.push(' ', te)
									} else z.push(m(M, V, J, 'extends'))
									if ((z.push(m(M, V, J, 'mixins'), m(M, V, J, 'implements')), ee)) {
										let ye
										R(Z) ? (ye = [...ce, w(z)]) : (ye = w([...ce, z])), ne.push(_(ye, { id: A(Z) }))
									} else ne.push(...ce, ...z)
									return ne.push(' ', J('body')), ne
								}
								var A = D('heritageGroup')
								function $(M) {
									return C(y, '', { groupId: A(M) })
								}
								function T(M) {
									return (
										['superClass', 'extends', 'mixins', 'implements'].filter((V) => !!M[V]).length >
										1
									)
								}
								function R(M) {
									return M.typeParameters && !v(M.typeParameters, b.Trailing | b.Line) && !T(M)
								}
								function m(M, V, J, Z) {
									let ne = M.getValue()
									if (!c(ne[Z])) return ''
									let ee = l(M, V, !0, (ce) => {
										let { marker: z } = ce
										return z === Z
									})
									return [
										R(ne) ? C(' ', f, { groupId: k(ne.typeParameters) }) : f,
										ee,
										ee && y,
										Z,
										_(w([f, p([',', f], M.map(J, Z))]))
									]
								}
								function S(M, V, J) {
									let Z = J('superClass')
									return M.getParentNode().type === 'AssignmentExpression'
										? _(C(['(', w([x, Z]), x, ')'], Z))
										: Z
								}
								function L(M, V, J) {
									let Z = M.getValue(),
										ne = []
									return (
										c(Z.decorators) && ne.push(W(M, V, J)),
										Z.accessibility && ne.push(Z.accessibility + ' '),
										Z.readonly && ne.push('readonly '),
										Z.declare && ne.push('declare '),
										Z.static && ne.push('static '),
										(Z.type === 'TSAbstractMethodDefinition' || Z.abstract) && ne.push('abstract '),
										Z.override && ne.push('override '),
										ne.push(q(M, V, J)),
										ne
									)
								}
								function P(M, V, J) {
									let Z = M.getValue(),
										ne = [],
										ee = V.semi ? ';' : ''
									return (
										c(Z.decorators) && ne.push(W(M, V, J)),
										Z.accessibility && ne.push(Z.accessibility + ' '),
										Z.declare && ne.push('declare '),
										Z.static && ne.push('static '),
										(Z.type === 'TSAbstractPropertyDefinition' ||
											Z.type === 'TSAbstractAccessorProperty' ||
											Z.abstract) &&
											ne.push('abstract '),
										Z.override && ne.push('override '),
										Z.readonly && ne.push('readonly '),
										Z.variance && ne.push(J('variance')),
										(Z.type === 'ClassAccessorProperty' ||
											Z.type === 'AccessorProperty' ||
											Z.type === 'TSAbstractAccessorProperty') &&
											ne.push('accessor '),
										ne.push(j(M, V, J), G(M), U(M), O(M, V, J)),
										[H(M, V, J, ne, ' =', 'value'), ee]
									)
								}
								E.exports = {
									printClass: re,
									printClassMethod: L,
									printClassProperty: P,
									printHardlineAfterHeritage: $
								}
							}
						}),
						J1 = le({
							'src/language-js/print/interface.js'(d, E) {
								'use strict'
								ge()
								var { isNonEmptyArray: c } = wn(),
									{
										builders: { join: D, line: g, group: l, indent: p, ifBreak: f }
									} = dn(),
									{ hasComment: y, identity: x, CommentCheckFlags: _ } = er(),
									{ getTypeParametersGroupId: w } = Yu(),
									{ printTypeScriptModifiers: C } = hi()
								function v(b, k, q) {
									let G = b.getValue(),
										O = []
									G.declare && O.push('declare '),
										G.type === 'TSInterfaceDeclaration' &&
											O.push(G.abstract ? 'abstract ' : '', C(b, k, q)),
										O.push('interface')
									let U = [],
										j = []
									G.type !== 'InterfaceTypeAnnotation' && U.push(' ', q('id'), q('typeParameters'))
									let H = G.typeParameters && !y(G.typeParameters, _.Trailing | _.Line)
									return (
										c(G.extends) &&
											j.push(
												H ? f(' ', g, { groupId: w(G.typeParameters) }) : g,
												'extends ',
												(G.extends.length === 1 ? x : p)(D([',', g], b.map(q, 'extends')))
											),
										(G.id && y(G.id, _.Trailing)) || c(G.extends)
											? H
												? O.push(l([...U, p(j)]))
												: O.push(l(p([...U, ...j])))
											: O.push(...U, ...j),
										O.push(' ', q('body')),
										l(O)
									)
								}
								E.exports = { printInterface: v }
							}
						}),
						z1 = le({
							'src/language-js/print/module.js'(d, E) {
								'use strict'
								ge()
								var { isNonEmptyArray: c } = wn(),
									{
										builders: {
											softline: D,
											group: g,
											indent: l,
											join: p,
											line: f,
											ifBreak: y,
											hardline: x
										}
									} = dn(),
									{ printDanglingComments: _ } = Sr(),
									{
										hasComment: w,
										CommentCheckFlags: C,
										shouldPrintComma: v,
										needsHardlineAfterDanglingComment: b,
										isStringLiteral: k,
										rawText: q
									} = er(),
									{ locStart: G, hasSameLoc: O } = Qr(),
									{ hasDecoratorsBeforeExport: U, printDecoratorsBeforeExport: j } = gp()
								function H(P, M, V) {
									let J = P.getValue(),
										Z = M.semi ? ';' : '',
										ne = [],
										{ importKind: ee } = J
									return (
										ne.push('import'),
										ee && ee !== 'value' && ne.push(' ', ee),
										ne.push(T(P, M, V), $(P, M, V), m(P, M, V), Z),
										ne
									)
								}
								function W(P, M, V) {
									let J = P.getValue(),
										Z = []
									U(J) && Z.push(j(P, M, V))
									let { type: ne, exportKind: ee, declaration: ce } = J
									return (
										Z.push('export'),
										(J.default || ne === 'ExportDefaultDeclaration') && Z.push(' default'),
										w(J, C.Dangling) && (Z.push(' ', _(P, M, !0)), b(J) && Z.push(x)),
										ce
											? Z.push(' ', V('declaration'))
											: Z.push(ee === 'type' ? ' type' : '', T(P, M, V), $(P, M, V), m(P, M, V)),
										A(J, M) && Z.push(';'),
										Z
									)
								}
								function re(P, M, V) {
									let J = P.getValue(),
										Z = M.semi ? ';' : '',
										ne = [],
										{ exportKind: ee, exported: ce } = J
									return (
										ne.push('export'),
										ee === 'type' && ne.push(' type'),
										ne.push(' *'),
										ce && ne.push(' as ', V('exported')),
										ne.push($(P, M, V), m(P, M, V), Z),
										ne
									)
								}
								function A(P, M) {
									if (!M.semi) return !1
									let { type: V, declaration: J } = P,
										Z = P.default || V === 'ExportDefaultDeclaration'
									if (!J) return !0
									let { type: ne } = J
									return !!(
										Z &&
										ne !== 'ClassDeclaration' &&
										ne !== 'FunctionDeclaration' &&
										ne !== 'TSInterfaceDeclaration' &&
										ne !== 'DeclareClass' &&
										ne !== 'DeclareFunction' &&
										ne !== 'TSDeclareFunction' &&
										ne !== 'EnumDeclaration'
									)
								}
								function $(P, M, V) {
									let J = P.getValue()
									if (!J.source) return ''
									let Z = []
									return R(J, M) || Z.push(' from'), Z.push(' ', V('source')), Z
								}
								function T(P, M, V) {
									let J = P.getValue()
									if (R(J, M)) return ''
									let Z = [' ']
									if (c(J.specifiers)) {
										let ne = [],
											ee = []
										P.each(() => {
											let ce = P.getValue().type
											if (
												ce === 'ExportNamespaceSpecifier' ||
												ce === 'ExportDefaultSpecifier' ||
												ce === 'ImportNamespaceSpecifier' ||
												ce === 'ImportDefaultSpecifier'
											)
												ne.push(V())
											else if (ce === 'ExportSpecifier' || ce === 'ImportSpecifier') ee.push(V())
											else throw new Error(`Unknown specifier type ${JSON.stringify(ce)}`)
										}, 'specifiers'),
											Z.push(p(', ', ne)),
											ee.length > 0 &&
												(ne.length > 0 && Z.push(', '),
												ee.length > 1 || ne.length > 0 || J.specifiers.some((ce) => w(ce))
													? Z.push(
															g([
																'{',
																l([M.bracketSpacing ? f : D, p([',', f], ee)]),
																y(v(M) ? ',' : ''),
																M.bracketSpacing ? f : D,
																'}'
															])
													  )
													: Z.push([
															'{',
															M.bracketSpacing ? ' ' : '',
															...ee,
															M.bracketSpacing ? ' ' : '',
															'}'
													  ]))
									} else Z.push('{}')
									return Z
								}
								function R(P, M) {
									let { type: V, importKind: J, source: Z, specifiers: ne } = P
									return V !== 'ImportDeclaration' || c(ne) || J === 'type'
										? !1
										: !/{\s*}/.test(M.originalText.slice(G(P), G(Z)))
								}
								function m(P, M, V) {
									let J = P.getNode()
									return c(J.assertions)
										? [
												' assert {',
												M.bracketSpacing ? ' ' : '',
												p(', ', P.map(V, 'assertions')),
												M.bracketSpacing ? ' ' : '',
												'}'
										  ]
										: ''
								}
								function S(P, M, V) {
									let J = P.getNode(),
										{ type: Z } = J,
										ne = [],
										ee = Z === 'ImportSpecifier' ? J.importKind : J.exportKind
									ee && ee !== 'value' && ne.push(ee, ' ')
									let ce = Z.startsWith('Import'),
										z = ce ? 'imported' : 'local',
										ye = ce ? 'local' : 'exported',
										te = J[z],
										X = J[ye],
										De = '',
										Fe = ''
									return (
										Z === 'ExportNamespaceSpecifier' || Z === 'ImportNamespaceSpecifier'
											? (De = '*')
											: te && (De = V(z)),
										X && !L(J) && (Fe = V(ye)),
										ne.push(De, De && Fe ? ' as ' : '', Fe),
										ne
									)
								}
								function L(P) {
									if (P.type !== 'ImportSpecifier' && P.type !== 'ExportSpecifier') return !1
									let { local: M, [P.type === 'ImportSpecifier' ? 'imported' : 'exported']: V } = P
									if (M.type !== V.type || !O(M, V)) return !1
									if (k(M)) return M.value === V.value && q(M) === q(V)
									switch (M.type) {
										case 'Identifier':
											return M.name === V.name
										default:
											return !1
									}
								}
								E.exports = {
									printImportDeclaration: H,
									printExportDeclaration: W,
									printExportAllDeclaration: re,
									printModuleSpecifier: S
								}
							}
						}),
						Dp = le({
							'src/language-js/print/object.js'(d, E) {
								'use strict'
								ge()
								var { printDanglingComments: c } = Sr(),
									{
										builders: { line: D, softline: g, group: l, indent: p, ifBreak: f, hardline: y }
									} = dn(),
									{ getLast: x, hasNewlineInRange: _, hasNewline: w, isNonEmptyArray: C } = wn(),
									{
										shouldPrintComma: v,
										hasComment: b,
										getComments: k,
										CommentCheckFlags: q,
										isNextLineEmpty: G
									} = er(),
									{ locStart: O, locEnd: U } = Qr(),
									{ printOptionalToken: j, printTypeAnnotation: H } = hi(),
									{ shouldHugFunctionParameters: W } = zu(),
									{ shouldHugType: re } = Qu(),
									{ printHardlineAfterHeritage: A } = Ba()
								function $(T, R, m) {
									let S = R.semi ? ';' : '',
										L = T.getValue(),
										P
									L.type === 'TSTypeLiteral'
										? (P = 'members')
										: L.type === 'TSInterfaceBody'
										? (P = 'body')
										: (P = 'properties')
									let M = L.type === 'ObjectTypeAnnotation',
										V = [P]
									M && V.push('indexers', 'callProperties', 'internalSlots')
									let J = V.map((ie) => L[ie][0]).sort((ie, fe) => O(ie) - O(fe))[0],
										Z = T.getParentNode(0),
										ne =
											M &&
											Z &&
											(Z.type === 'InterfaceDeclaration' ||
												Z.type === 'DeclareInterface' ||
												Z.type === 'DeclareClass') &&
											T.getName() === 'body',
										ee =
											L.type === 'TSInterfaceBody' ||
											ne ||
											(L.type === 'ObjectPattern' &&
												Z.type !== 'FunctionDeclaration' &&
												Z.type !== 'FunctionExpression' &&
												Z.type !== 'ArrowFunctionExpression' &&
												Z.type !== 'ObjectMethod' &&
												Z.type !== 'ClassMethod' &&
												Z.type !== 'ClassPrivateMethod' &&
												Z.type !== 'AssignmentPattern' &&
												Z.type !== 'CatchClause' &&
												L.properties.some(
													(ie) =>
														ie.value &&
														(ie.value.type === 'ObjectPattern' || ie.value.type === 'ArrayPattern')
												)) ||
											(L.type !== 'ObjectPattern' && J && _(R.originalText, O(L), O(J))),
										ce = ne
											? ';'
											: L.type === 'TSInterfaceBody' || L.type === 'TSTypeLiteral'
											? f(S, ';')
											: ',',
										z = L.type === 'RecordExpression' ? '#{' : L.exact ? '{|' : '{',
										ye = L.exact ? '|}' : '}',
										te = []
									for (let ie of V)
										T.each((fe) => {
											let Be = fe.getValue()
											te.push({ node: Be, printed: m(), loc: O(Be) })
										}, ie)
									V.length > 1 && te.sort((ie, fe) => ie.loc - fe.loc)
									let X = [],
										De = te.map((ie) => {
											let fe = [...X, l(ie.printed)]
											return (
												(X = [ce, D]),
												(ie.node.type === 'TSPropertySignature' ||
													ie.node.type === 'TSMethodSignature' ||
													ie.node.type === 'TSConstructSignatureDeclaration') &&
													b(ie.node, q.PrettierIgnore) &&
													X.shift(),
												G(ie.node, R) && X.push(y),
												fe
											)
										})
									if (L.inexact) {
										let ie
										if (b(L, q.Dangling)) {
											let fe = b(L, q.Line)
											ie = [c(T, R, !0), fe || w(R.originalText, U(x(k(L)))) ? y : D, '...']
										} else ie = ['...']
										De.push([...X, ...ie])
									}
									let Fe = x(L[P]),
										ve = !(
											L.inexact ||
											(Fe && Fe.type === 'RestElement') ||
											(Fe &&
												(Fe.type === 'TSPropertySignature' ||
													Fe.type === 'TSCallSignatureDeclaration' ||
													Fe.type === 'TSMethodSignature' ||
													Fe.type === 'TSConstructSignatureDeclaration') &&
												b(Fe, q.PrettierIgnore))
										),
										$e
									if (De.length === 0) {
										if (!b(L, q.Dangling)) return [z, ye, H(T, R, m)]
										$e = l([z, c(T, R), g, ye, j(T), H(T, R, m)])
									} else
										$e = [
											ne && C(L.properties) ? A(Z) : '',
											z,
											p([R.bracketSpacing ? D : g, ...De]),
											f(ve && (ce !== ',' || v(R)) ? ce : ''),
											R.bracketSpacing ? D : g,
											ye,
											j(T),
											H(T, R, m)
										]
									return T.match(
										(ie) => ie.type === 'ObjectPattern' && !ie.decorators,
										(ie, fe, Be) =>
											W(ie) &&
											(fe === 'params' || fe === 'parameters' || fe === 'this' || fe === 'rest') &&
											Be === 0
									) ||
										T.match(
											re,
											(ie, fe) => fe === 'typeAnnotation',
											(ie, fe) => fe === 'typeAnnotation',
											(ie, fe, Be) =>
												W(ie) &&
												(fe === 'params' ||
													fe === 'parameters' ||
													fe === 'this' ||
													fe === 'rest') &&
												Be === 0
										) ||
										(!ee &&
											T.match(
												(ie) => ie.type === 'ObjectPattern',
												(ie) =>
													ie.type === 'AssignmentExpression' || ie.type === 'VariableDeclarator'
											))
										? $e
										: l($e, { shouldBreak: ee })
								}
								E.exports = { printObject: $ }
							}
						}),
						By = le({
							'src/language-js/print/flow.js'(d, E) {
								'use strict'
								ge()
								var c = Ia(),
									{ printDanglingComments: D } = Sr(),
									{ printString: g, printNumber: l } = wn(),
									{
										builders: { hardline: p, softline: f, group: y, indent: x }
									} = dn(),
									{
										getParentExportDeclaration: _,
										isFunctionNotation: w,
										isGetterOrSetter: C,
										rawText: v,
										shouldPrintComma: b
									} = er(),
									{ locStart: k, locEnd: q } = Qr(),
									{ replaceTextEndOfLine: G } = _a(),
									{ printClass: O } = Ba(),
									{
										printOpaqueType: U,
										printTypeAlias: j,
										printIntersectionType: H,
										printUnionType: W,
										printFunctionType: re,
										printTupleType: A,
										printIndexedAccessType: $
									} = Qu(),
									{ printInterface: T } = J1(),
									{ printTypeParameter: R, printTypeParameters: m } = Yu(),
									{ printExportDeclaration: S, printExportAllDeclaration: L } = z1(),
									{ printArrayItems: P } = ka(),
									{ printObject: M } = Dp(),
									{ printPropertyKey: V } = Oa(),
									{ printOptionalToken: J, printTypeAnnotation: Z, printRestSpread: ne } = hi()
								function ee(z, ye, te) {
									let X = z.getValue(),
										De = ye.semi ? ';' : '',
										Fe = []
									switch (X.type) {
										case 'DeclareClass':
											return ce(z, O(z, ye, te))
										case 'DeclareFunction':
											return ce(z, [
												'function ',
												te('id'),
												X.predicate ? ' ' : '',
												te('predicate'),
												De
											])
										case 'DeclareModule':
											return ce(z, ['module ', te('id'), ' ', te('body')])
										case 'DeclareModuleExports':
											return ce(z, ['module.exports', ': ', te('typeAnnotation'), De])
										case 'DeclareVariable':
											return ce(z, ['var ', te('id'), De])
										case 'DeclareOpaqueType':
											return ce(z, U(z, ye, te))
										case 'DeclareInterface':
											return ce(z, T(z, ye, te))
										case 'DeclareTypeAlias':
											return ce(z, j(z, ye, te))
										case 'DeclareExportDeclaration':
											return ce(z, S(z, ye, te))
										case 'DeclareExportAllDeclaration':
											return ce(z, L(z, ye, te))
										case 'OpaqueType':
											return U(z, ye, te)
										case 'TypeAlias':
											return j(z, ye, te)
										case 'IntersectionTypeAnnotation':
											return H(z, ye, te)
										case 'UnionTypeAnnotation':
											return W(z, ye, te)
										case 'FunctionTypeAnnotation':
											return re(z, ye, te)
										case 'TupleTypeAnnotation':
											return A(z, ye, te)
										case 'GenericTypeAnnotation':
											return [te('id'), m(z, ye, te, 'typeParameters')]
										case 'IndexedAccessType':
										case 'OptionalIndexedAccessType':
											return $(z, ye, te)
										case 'TypeAnnotation':
											return te('typeAnnotation')
										case 'TypeParameter':
											return R(z, ye, te)
										case 'TypeofTypeAnnotation':
											return ['typeof ', te('argument')]
										case 'ExistsTypeAnnotation':
											return '*'
										case 'EmptyTypeAnnotation':
											return 'empty'
										case 'MixedTypeAnnotation':
											return 'mixed'
										case 'ArrayTypeAnnotation':
											return [te('elementType'), '[]']
										case 'BooleanLiteralTypeAnnotation':
											return String(X.value)
										case 'EnumDeclaration':
											return ['enum ', te('id'), ' ', te('body')]
										case 'EnumBooleanBody':
										case 'EnumNumberBody':
										case 'EnumStringBody':
										case 'EnumSymbolBody': {
											if (X.type === 'EnumSymbolBody' || X.explicitType) {
												let ve = null
												switch (X.type) {
													case 'EnumBooleanBody':
														ve = 'boolean'
														break
													case 'EnumNumberBody':
														ve = 'number'
														break
													case 'EnumStringBody':
														ve = 'string'
														break
													case 'EnumSymbolBody':
														ve = 'symbol'
														break
												}
												Fe.push('of ', ve, ' ')
											}
											if (X.members.length === 0 && !X.hasUnknownMembers)
												Fe.push(y(['{', D(z, ye), f, '}']))
											else {
												let ve =
													X.members.length > 0
														? [p, P(z, ye, 'members', te), X.hasUnknownMembers || b(ye) ? ',' : '']
														: []
												Fe.push(
													y([
														'{',
														x([...ve, ...(X.hasUnknownMembers ? [p, '...'] : [])]),
														D(z, ye, !0),
														p,
														'}'
													])
												)
											}
											return Fe
										}
										case 'EnumBooleanMember':
										case 'EnumNumberMember':
										case 'EnumStringMember':
											return [
												te('id'),
												' = ',
												typeof X.init == 'object' ? te('init') : String(X.init)
											]
										case 'EnumDefaultedMember':
											return te('id')
										case 'FunctionTypeParam': {
											let ve = X.name ? te('name') : z.getParentNode().this === X ? 'this' : ''
											return [ve, J(z), ve ? ': ' : '', te('typeAnnotation')]
										}
										case 'InterfaceDeclaration':
										case 'InterfaceTypeAnnotation':
											return T(z, ye, te)
										case 'ClassImplements':
										case 'InterfaceExtends':
											return [te('id'), te('typeParameters')]
										case 'NullableTypeAnnotation':
											return ['?', te('typeAnnotation')]
										case 'Variance': {
											let { kind: ve } = X
											return c.ok(ve === 'plus' || ve === 'minus'), ve === 'plus' ? '+' : '-'
										}
										case 'ObjectTypeCallProperty':
											return X.static && Fe.push('static '), Fe.push(te('value')), Fe
										case 'ObjectTypeIndexer':
											return [
												X.static ? 'static ' : '',
												X.variance ? te('variance') : '',
												'[',
												te('id'),
												X.id ? ': ' : '',
												te('key'),
												']: ',
												te('value')
											]
										case 'ObjectTypeProperty': {
											let ve = ''
											return (
												X.proto ? (ve = 'proto ') : X.static && (ve = 'static '),
												[
													ve,
													C(X) ? X.kind + ' ' : '',
													X.variance ? te('variance') : '',
													V(z, ye, te),
													J(z),
													w(X) ? '' : ': ',
													te('value')
												]
											)
										}
										case 'ObjectTypeAnnotation':
											return M(z, ye, te)
										case 'ObjectTypeInternalSlot':
											return [
												X.static ? 'static ' : '',
												'[[',
												te('id'),
												']]',
												J(z),
												X.method ? '' : ': ',
												te('value')
											]
										case 'ObjectTypeSpreadProperty':
											return ne(z, ye, te)
										case 'QualifiedTypeofIdentifier':
										case 'QualifiedTypeIdentifier':
											return [te('qualification'), '.', te('id')]
										case 'StringLiteralTypeAnnotation':
											return G(g(v(X), ye))
										case 'NumberLiteralTypeAnnotation':
											c.strictEqual(typeof X.value, 'number')
										case 'BigIntLiteralTypeAnnotation':
											return X.extra ? l(X.extra.raw) : l(X.raw)
										case 'TypeCastExpression':
											return ['(', te('expression'), Z(z, ye, te), ')']
										case 'TypeParameterDeclaration':
										case 'TypeParameterInstantiation': {
											let ve = m(z, ye, te, 'params')
											if (ye.parser === 'flow') {
												let $e = k(X),
													ie = q(X),
													fe = ye.originalText.lastIndexOf('/*', $e),
													Be = ye.originalText.indexOf('*/', ie)
												if (fe !== -1 && Be !== -1) {
													let Me = ye.originalText.slice(fe + 2, Be).trim()
													if (Me.startsWith('::') && !Me.includes('/*') && !Me.includes('*/'))
														return ['/*:: ', ve, ' */']
												}
											}
											return ve
										}
										case 'InferredPredicate':
											return '%checks'
										case 'DeclaredPredicate':
											return ['%checks(', te('value'), ')']
										case 'AnyTypeAnnotation':
											return 'any'
										case 'BooleanTypeAnnotation':
											return 'boolean'
										case 'BigIntTypeAnnotation':
											return 'bigint'
										case 'NullLiteralTypeAnnotation':
											return 'null'
										case 'NumberTypeAnnotation':
											return 'number'
										case 'SymbolTypeAnnotation':
											return 'symbol'
										case 'StringTypeAnnotation':
											return 'string'
										case 'VoidTypeAnnotation':
											return 'void'
										case 'ThisTypeAnnotation':
											return 'this'
										case 'Node':
										case 'Printable':
										case 'SourceLocation':
										case 'Position':
										case 'Statement':
										case 'Function':
										case 'Pattern':
										case 'Expression':
										case 'Declaration':
										case 'Specifier':
										case 'NamedSpecifier':
										case 'Comment':
										case 'MemberTypeAnnotation':
										case 'Type':
											throw new Error('unprintable type: ' + JSON.stringify(X.type))
									}
								}
								function ce(z, ye) {
									let te = _(z)
									return te
										? (c.strictEqual(te.type, 'DeclareExportDeclaration'), ye)
										: ['declare ', ye]
								}
								E.exports = { printFlow: ee }
							}
						}),
						Py = le({
							'src/language-js/utils/is-ts-keyword-type.js'(d, E) {
								'use strict'
								ge()
								function c(D) {
									let { type: g } = D
									return g.startsWith('TS') && g.endsWith('Keyword')
								}
								E.exports = c
							}
						}),
						Q1 = le({
							'src/language-js/print/ternary.js'(d, E) {
								'use strict'
								ge()
								var { hasNewlineInRange: c } = wn(),
									{
										isJsxNode: D,
										getComments: g,
										isCallExpression: l,
										isMemberExpression: p,
										isTSTypeExpression: f
									} = er(),
									{ locStart: y, locEnd: x } = Qr(),
									_ = js(),
									{
										builders: {
											line: w,
											softline: C,
											group: v,
											indent: b,
											align: k,
											ifBreak: q,
											dedent: G,
											breakParent: O
										}
									} = dn()
								function U(A) {
									let $ = [A]
									for (let T = 0; T < $.length; T++) {
										let R = $[T]
										for (let m of ['test', 'consequent', 'alternate']) {
											let S = R[m]
											if (D(S)) return !0
											S.type === 'ConditionalExpression' && $.push(S)
										}
									}
									return !1
								}
								function j(A, $, T) {
									let R = A.getValue(),
										m = R.type === 'ConditionalExpression',
										S = m ? 'alternate' : 'falseType',
										L = A.getParentNode(),
										P = m ? T('test') : [T('checkType'), ' ', 'extends', ' ', T('extendsType')]
									return L.type === R.type && L[S] === R ? k(2, P) : P
								}
								var H = new Map([
									['AssignmentExpression', 'right'],
									['VariableDeclarator', 'init'],
									['ReturnStatement', 'argument'],
									['ThrowStatement', 'argument'],
									['UnaryExpression', 'argument'],
									['YieldExpression', 'argument']
								])
								function W(A) {
									let $ = A.getValue()
									if ($.type !== 'ConditionalExpression') return !1
									let T,
										R = $
									for (let m = 0; !T; m++) {
										let S = A.getParentNode(m)
										if (
											(l(S) && S.callee === R) ||
											(p(S) && S.object === R) ||
											(S.type === 'TSNonNullExpression' && S.expression === R)
										) {
											R = S
											continue
										}
										;(S.type === 'NewExpression' && S.callee === R) || (f(S) && S.expression === R)
											? ((T = A.getParentNode(m + 1)), (R = S))
											: (T = S)
									}
									return R === $ ? !1 : T[H.get(T.type)] === R
								}
								function re(A, $, T) {
									let R = A.getValue(),
										m = R.type === 'ConditionalExpression',
										S = m ? 'consequent' : 'trueType',
										L = m ? 'alternate' : 'falseType',
										P = m ? ['test'] : ['checkType', 'extendsType'],
										M = R[S],
										V = R[L],
										J = [],
										Z = !1,
										ne = A.getParentNode(),
										ee = ne.type === R.type && P.some((Be) => ne[Be] === R),
										ce = ne.type === R.type && !ee,
										z,
										ye,
										te = 0
									do (ye = z || R), (z = A.getParentNode(te)), te++
									while (z && z.type === R.type && P.every((Be) => z[Be] !== ye))
									let X = z || ne,
										De = ye
									if (m && (D(R[P[0]]) || D(M) || D(V) || U(De))) {
										;(Z = !0), (ce = !0)
										let Be = (Dt) => [q('('), b([C, Dt]), C, q(')')],
											Me = (Dt) =>
												Dt.type === 'NullLiteral' ||
												(Dt.type === 'Literal' && Dt.value === null) ||
												(Dt.type === 'Identifier' && Dt.name === 'undefined')
										J.push(
											' ? ',
											Me(M) ? T(S) : Be(T(S)),
											' : ',
											V.type === R.type || Me(V) ? T(L) : Be(T(L))
										)
									} else {
										let Be = [
											w,
											'? ',
											M.type === R.type ? q('', '(') : '',
											k(2, T(S)),
											M.type === R.type ? q('', ')') : '',
											w,
											': ',
											V.type === R.type ? T(L) : k(2, T(L))
										]
										J.push(
											ne.type !== R.type || ne[L] === R || ee
												? Be
												: $.useTabs
												? G(b(Be))
												: k(Math.max(0, $.tabWidth - 2), Be)
										)
									}
									let Fe = [...P.map((Be) => g(R[Be])), g(M), g(V)]
											.flat()
											.some((Be) => _(Be) && c($.originalText, y(Be), x(Be))),
										ve = (Be) => (ne === X ? v(Be, { shouldBreak: Fe }) : Fe ? [Be, O] : Be),
										$e =
											!Z &&
											(p(ne) || (ne.type === 'NGPipeExpression' && ne.left === R)) &&
											!ne.computed,
										ie = W(A),
										fe = ve([j(A, $, T), ce ? J : b(J), m && $e && !ie ? C : ''])
									return ee || ie ? v([b([C, fe]), C]) : fe
								}
								E.exports = { printTernary: re }
							}
						}),
						Y1 = le({
							'src/language-js/print/statement.js'(d, E) {
								'use strict'
								ge()
								var {
										builders: { hardline: c }
									} = dn(),
									D = vo(),
									{
										getLeftSidePathName: g,
										hasNakedLeftSide: l,
										isJsxNode: p,
										isTheOnlyJsxElementInMarkdown: f,
										hasComment: y,
										CommentCheckFlags: x,
										isNextLineEmpty: _
									} = er(),
									{ shouldPrintParamsWithoutParens: w } = Xu()
								function C(j, H, W, re) {
									let A = j.getValue(),
										$ = [],
										T = A.type === 'ClassBody',
										R = v(A[re])
									return (
										j.each((m, S, L) => {
											let P = m.getValue()
											if (P.type === 'EmptyStatement') return
											let M = W()
											!H.semi && !T && !f(H, m) && b(m, H)
												? y(P, x.Leading)
													? $.push(W([], { needsSemi: !0 }))
													: $.push(';', M)
												: $.push(M),
												!H.semi && T && O(P) && U(P, L[S + 1]) && $.push(';'),
												P !== R && ($.push(c), _(P, H) && $.push(c))
										}, re),
										$
									)
								}
								function v(j) {
									for (let H = j.length - 1; H >= 0; H--) {
										let W = j[H]
										if (W.type !== 'EmptyStatement') return W
									}
								}
								function b(j, H) {
									return j.getNode().type !== 'ExpressionStatement'
										? !1
										: j.call((W) => k(W, H), 'expression')
								}
								function k(j, H) {
									let W = j.getValue()
									switch (W.type) {
										case 'ParenthesizedExpression':
										case 'TypeCastExpression':
										case 'ArrayExpression':
										case 'ArrayPattern':
										case 'TemplateLiteral':
										case 'TemplateElement':
										case 'RegExpLiteral':
											return !0
										case 'ArrowFunctionExpression': {
											if (!w(j, H)) return !0
											break
										}
										case 'UnaryExpression': {
											let { prefix: re, operator: A } = W
											if (re && (A === '+' || A === '-')) return !0
											break
										}
										case 'BindExpression': {
											if (!W.object) return !0
											break
										}
										case 'Literal': {
											if (W.regex) return !0
											break
										}
										default:
											if (p(W)) return !0
									}
									return D(j, H) ? !0 : l(W) ? j.call((re) => k(re, H), ...g(j, W)) : !1
								}
								function q(j, H, W) {
									return C(j, H, W, 'body')
								}
								function G(j, H, W) {
									return C(j, H, W, 'consequent')
								}
								var O = (j) => {
									let { type: H } = j
									return (
										H === 'ClassProperty' ||
										H === 'PropertyDefinition' ||
										H === 'ClassPrivateProperty' ||
										H === 'ClassAccessorProperty' ||
										H === 'AccessorProperty' ||
										H === 'TSAbstractPropertyDefinition' ||
										H === 'TSAbstractAccessorProperty'
									)
								}
								function U(j, H) {
									let { type: W, name: re } = j.key
									if (
										!j.computed &&
										W === 'Identifier' &&
										(re === 'static' || re === 'get' || re === 'set' || re === 'accessor') &&
										!j.value &&
										!j.typeAnnotation
									)
										return !0
									if (!H || H.static || H.accessibility) return !1
									if (!H.computed) {
										let A = H.key && H.key.name
										if (A === 'in' || A === 'instanceof') return !0
									}
									if (O(H) && H.variance && !H.static && !H.declare) return !0
									switch (H.type) {
										case 'ClassProperty':
										case 'PropertyDefinition':
										case 'TSAbstractPropertyDefinition':
											return H.computed
										case 'MethodDefinition':
										case 'TSAbstractMethodDefinition':
										case 'ClassMethod':
										case 'ClassPrivateMethod': {
											if (
												(H.value ? H.value.async : H.async) ||
												H.kind === 'get' ||
												H.kind === 'set'
											)
												return !1
											let A = H.value ? H.value.generator : H.generator
											return !!(H.computed || A)
										}
										case 'TSIndexSignature':
											return !0
									}
									return !1
								}
								E.exports = { printBody: q, printSwitchCaseConsequent: G }
							}
						}),
						X1 = le({
							'src/language-js/print/block.js'(d, E) {
								'use strict'
								ge()
								var { printDanglingComments: c } = Sr(),
									{ isNonEmptyArray: D } = wn(),
									{
										builders: { hardline: g, indent: l }
									} = dn(),
									{ hasComment: p, CommentCheckFlags: f, isNextLineEmpty: y } = er(),
									{ printHardlineAfterHeritage: x } = Ba(),
									{ printBody: _ } = Y1()
								function w(v, b, k) {
									let q = v.getValue(),
										G = []
									if (
										(q.type === 'StaticBlock' && G.push('static '),
										q.type === 'ClassBody' && D(q.body))
									) {
										let U = v.getParentNode()
										G.push(x(U))
									}
									G.push('{')
									let O = C(v, b, k)
									if (O) G.push(l([g, O]), g)
									else {
										let U = v.getParentNode(),
											j = v.getParentNode(1)
										U.type === 'ArrowFunctionExpression' ||
											U.type === 'FunctionExpression' ||
											U.type === 'FunctionDeclaration' ||
											U.type === 'ObjectMethod' ||
											U.type === 'ClassMethod' ||
											U.type === 'ClassPrivateMethod' ||
											U.type === 'ForStatement' ||
											U.type === 'WhileStatement' ||
											U.type === 'DoWhileStatement' ||
											U.type === 'DoExpression' ||
											(U.type === 'CatchClause' && !j.finalizer) ||
											U.type === 'TSModuleDeclaration' ||
											U.type === 'TSDeclareFunction' ||
											q.type === 'StaticBlock' ||
											q.type === 'ClassBody' ||
											G.push(g)
									}
									return G.push('}'), G
								}
								function C(v, b, k) {
									let q = v.getValue(),
										G = D(q.directives),
										O = q.body.some((H) => H.type !== 'EmptyStatement'),
										U = p(q, f.Dangling)
									if (!G && !O && !U) return ''
									let j = []
									if (
										(G &&
											v.each((H, W, re) => {
												j.push(k()),
													(W < re.length - 1 || O || U) &&
														(j.push(g), y(H.getValue(), b) && j.push(g))
											}, 'directives'),
										O && j.push(_(v, b, k)),
										U && j.push(c(v, b, !0)),
										q.type === 'Program')
									) {
										let H = v.getParentNode()
										;(!H || H.type !== 'ModuleExpression') && j.push(g)
									}
									return j
								}
								E.exports = { printBlock: w, printBlockBody: C }
							}
						}),
						My = le({
							'src/language-js/print/typescript.js'(d, E) {
								'use strict'
								ge()
								var { printDanglingComments: c } = Sr(),
									{ hasNewlineInRange: D } = wn(),
									{
										builders: {
											join: g,
											line: l,
											hardline: p,
											softline: f,
											group: y,
											indent: x,
											conditionalGroup: _,
											ifBreak: w
										}
									} = dn(),
									{
										isStringLiteral: C,
										getTypeScriptMappedTypeModifier: v,
										shouldPrintComma: b,
										isCallExpression: k,
										isMemberExpression: q
									} = er(),
									G = Py(),
									{ locStart: O, locEnd: U } = Qr(),
									{ printOptionalToken: j, printTypeScriptModifiers: H } = hi(),
									{ printTernary: W } = Q1(),
									{ printFunctionParameters: re, shouldGroupFunctionParameters: A } = zu(),
									{ printTemplateLiteral: $ } = Eo(),
									{ printArrayItems: T } = ka(),
									{ printObject: R } = Dp(),
									{ printClassProperty: m, printClassMethod: S } = Ba(),
									{ printTypeParameter: L, printTypeParameters: P } = Yu(),
									{ printPropertyKey: M } = Oa(),
									{ printFunction: V, printMethodInternal: J } = Xu(),
									{ printInterface: Z } = J1(),
									{ printBlock: ne } = X1(),
									{
										printTypeAlias: ee,
										printIntersectionType: ce,
										printUnionType: z,
										printFunctionType: ye,
										printTupleType: te,
										printIndexedAccessType: X,
										printJSDocType: De
									} = Qu()
								function Fe(ve, $e, ie) {
									let fe = ve.getValue()
									if (!fe.type.startsWith('TS')) return
									if (G(fe)) return fe.type.slice(2, -7).toLowerCase()
									let Be = $e.semi ? ';' : '',
										Me = []
									switch (fe.type) {
										case 'TSThisType':
											return 'this'
										case 'TSTypeAssertion': {
											let Dt = !(
													fe.expression.type === 'ArrayExpression' ||
													fe.expression.type === 'ObjectExpression'
												),
												me = y(['<', x([f, ie('typeAnnotation')]), f, '>']),
												ae = [w('('), x([f, ie('expression')]), f, w(')')]
											return Dt
												? _([
														[me, ie('expression')],
														[me, y(ae, { shouldBreak: !0 })],
														[me, ie('expression')]
												  ])
												: y([me, ie('expression')])
										}
										case 'TSDeclareFunction':
											return V(ve, ie, $e)
										case 'TSExportAssignment':
											return ['export = ', ie('expression'), Be]
										case 'TSModuleBlock':
											return ne(ve, $e, ie)
										case 'TSInterfaceBody':
										case 'TSTypeLiteral':
											return R(ve, $e, ie)
										case 'TSTypeAliasDeclaration':
											return ee(ve, $e, ie)
										case 'TSQualifiedName':
											return g('.', [ie('left'), ie('right')])
										case 'TSAbstractMethodDefinition':
										case 'TSDeclareMethod':
											return S(ve, $e, ie)
										case 'TSAbstractAccessorProperty':
										case 'TSAbstractPropertyDefinition':
											return m(ve, $e, ie)
										case 'TSInterfaceHeritage':
										case 'TSExpressionWithTypeArguments':
											return (
												Me.push(ie('expression')),
												fe.typeParameters && Me.push(ie('typeParameters')),
												Me
											)
										case 'TSTemplateLiteralType':
											return $(ve, ie, $e)
										case 'TSNamedTupleMember':
											return [ie('label'), fe.optional ? '?' : '', ': ', ie('elementType')]
										case 'TSRestType':
											return ['...', ie('typeAnnotation')]
										case 'TSOptionalType':
											return [ie('typeAnnotation'), '?']
										case 'TSInterfaceDeclaration':
											return Z(ve, $e, ie)
										case 'TSClassImplements':
											return [ie('expression'), ie('typeParameters')]
										case 'TSTypeParameterDeclaration':
										case 'TSTypeParameterInstantiation':
											return P(ve, $e, ie, 'params')
										case 'TSTypeParameter':
											return L(ve, $e, ie)
										case 'TSSatisfiesExpression':
										case 'TSAsExpression': {
											let Dt = fe.type === 'TSAsExpression' ? 'as' : 'satisfies'
											Me.push(ie('expression'), ` ${Dt} `, ie('typeAnnotation'))
											let me = ve.getParentNode()
											return (k(me) && me.callee === fe) || (q(me) && me.object === fe)
												? y([x([f, ...Me]), f])
												: Me
										}
										case 'TSArrayType':
											return [ie('elementType'), '[]']
										case 'TSPropertySignature':
											return (
												fe.readonly && Me.push('readonly '),
												Me.push(M(ve, $e, ie), j(ve)),
												fe.typeAnnotation && Me.push(': ', ie('typeAnnotation')),
												fe.initializer && Me.push(' = ', ie('initializer')),
												Me
											)
										case 'TSParameterProperty':
											return (
												fe.accessibility && Me.push(fe.accessibility + ' '),
												fe.export && Me.push('export '),
												fe.static && Me.push('static '),
												fe.override && Me.push('override '),
												fe.readonly && Me.push('readonly '),
												Me.push(ie('parameter')),
												Me
											)
										case 'TSTypeQuery':
											return ['typeof ', ie('exprName'), ie('typeParameters')]
										case 'TSIndexSignature': {
											let Dt = ve.getParentNode(),
												me = fe.parameters.length > 1 ? w(b($e) ? ',' : '') : '',
												ae = y([x([f, g([', ', f], ve.map(ie, 'parameters'))]), me, f])
											return [
												fe.export ? 'export ' : '',
												fe.accessibility ? [fe.accessibility, ' '] : '',
												fe.static ? 'static ' : '',
												fe.readonly ? 'readonly ' : '',
												fe.declare ? 'declare ' : '',
												'[',
												fe.parameters ? ae : '',
												fe.typeAnnotation ? ']: ' : ']',
												fe.typeAnnotation ? ie('typeAnnotation') : '',
												Dt.type === 'ClassBody' ? Be : ''
											]
										}
										case 'TSTypePredicate':
											return [
												fe.asserts ? 'asserts ' : '',
												ie('parameterName'),
												fe.typeAnnotation ? [' is ', ie('typeAnnotation')] : ''
											]
										case 'TSNonNullExpression':
											return [ie('expression'), '!']
										case 'TSImportType':
											return [
												fe.isTypeOf ? 'typeof ' : '',
												'import(',
												ie(fe.parameter ? 'parameter' : 'argument'),
												')',
												fe.qualifier ? ['.', ie('qualifier')] : '',
												P(ve, $e, ie, 'typeParameters')
											]
										case 'TSLiteralType':
											return ie('literal')
										case 'TSIndexedAccessType':
											return X(ve, $e, ie)
										case 'TSConstructSignatureDeclaration':
										case 'TSCallSignatureDeclaration':
										case 'TSConstructorType': {
											if (
												(fe.type === 'TSConstructorType' && fe.abstract && Me.push('abstract '),
												fe.type !== 'TSCallSignatureDeclaration' && Me.push('new '),
												Me.push(y(re(ve, ie, $e, !1, !0))),
												fe.returnType || fe.typeAnnotation)
											) {
												let Dt = fe.type === 'TSConstructorType'
												Me.push(Dt ? ' => ' : ': ', ie('returnType'), ie('typeAnnotation'))
											}
											return Me
										}
										case 'TSTypeOperator':
											return [fe.operator, ' ', ie('typeAnnotation')]
										case 'TSMappedType': {
											let Dt = D($e.originalText, O(fe), U(fe))
											return y(
												[
													'{',
													x([
														$e.bracketSpacing ? l : f,
														ie('typeParameter'),
														fe.optional ? v(fe.optional, '?') : '',
														fe.typeAnnotation ? ': ' : '',
														ie('typeAnnotation'),
														w(Be)
													]),
													c(ve, $e, !0),
													$e.bracketSpacing ? l : f,
													'}'
												],
												{ shouldBreak: Dt }
											)
										}
										case 'TSMethodSignature': {
											let Dt = fe.kind && fe.kind !== 'method' ? `${fe.kind} ` : ''
											Me.push(
												fe.accessibility ? [fe.accessibility, ' '] : '',
												Dt,
												fe.export ? 'export ' : '',
												fe.static ? 'static ' : '',
												fe.readonly ? 'readonly ' : '',
												fe.abstract ? 'abstract ' : '',
												fe.declare ? 'declare ' : '',
												fe.computed ? '[' : '',
												ie('key'),
												fe.computed ? ']' : '',
												j(ve)
											)
											let me = re(ve, ie, $e, !1, !0),
												ae = fe.returnType ? 'returnType' : 'typeAnnotation',
												xe = fe[ae],
												Ce = xe ? ie(ae) : '',
												Ge = A(fe, Ce)
											return Me.push(Ge ? y(me) : me), xe && Me.push(': ', y(Ce)), y(Me)
										}
										case 'TSNamespaceExportDeclaration':
											return (
												Me.push('export as namespace ', ie('id')), $e.semi && Me.push(';'), y(Me)
											)
										case 'TSEnumDeclaration':
											return (
												fe.declare && Me.push('declare '),
												fe.modifiers && Me.push(H(ve, $e, ie)),
												fe.const && Me.push('const '),
												Me.push('enum ', ie('id'), ' '),
												fe.members.length === 0
													? Me.push(y(['{', c(ve, $e), f, '}']))
													: Me.push(
															y([
																'{',
																x([p, T(ve, $e, 'members', ie), b($e, 'es5') ? ',' : '']),
																c(ve, $e, !0),
																p,
																'}'
															])
													  ),
												Me
											)
										case 'TSEnumMember':
											return (
												fe.computed ? Me.push('[', ie('id'), ']') : Me.push(ie('id')),
												fe.initializer && Me.push(' = ', ie('initializer')),
												Me
											)
										case 'TSImportEqualsDeclaration':
											return (
												fe.isExport && Me.push('export '),
												Me.push('import '),
												fe.importKind && fe.importKind !== 'value' && Me.push(fe.importKind, ' '),
												Me.push(ie('id'), ' = ', ie('moduleReference')),
												$e.semi && Me.push(';'),
												y(Me)
											)
										case 'TSExternalModuleReference':
											return ['require(', ie('expression'), ')']
										case 'TSModuleDeclaration': {
											let Dt = ve.getParentNode(),
												me = C(fe.id),
												ae = Dt.type === 'TSModuleDeclaration',
												xe = fe.body && fe.body.type === 'TSModuleDeclaration'
											if (ae) Me.push('.')
											else {
												fe.declare && Me.push('declare '), Me.push(H(ve, $e, ie))
												let Ce = $e.originalText.slice(O(fe), O(fe.id))
												;(fe.id.type === 'Identifier' &&
													fe.id.name === 'global' &&
													!/namespace|module/.test(Ce)) ||
													Me.push(
														me || /(?:^|\s)module(?:\s|$)/.test(Ce) ? 'module ' : 'namespace '
													)
											}
											return (
												Me.push(ie('id')),
												xe
													? Me.push(ie('body'))
													: fe.body
													? Me.push(' ', y(ie('body')))
													: Me.push(Be),
												Me
											)
										}
										case 'TSConditionalType':
											return W(ve, $e, ie)
										case 'TSInferType':
											return ['infer', ' ', ie('typeParameter')]
										case 'TSIntersectionType':
											return ce(ve, $e, ie)
										case 'TSUnionType':
											return z(ve, $e, ie)
										case 'TSFunctionType':
											return ye(ve, $e, ie)
										case 'TSTupleType':
											return te(ve, $e, ie)
										case 'TSTypeReference':
											return [ie('typeName'), P(ve, $e, ie, 'typeParameters')]
										case 'TSTypeAnnotation':
											return ie('typeAnnotation')
										case 'TSEmptyBodyFunctionExpression':
											return J(ve, $e, ie)
										case 'TSJSDocAllType':
											return '*'
										case 'TSJSDocUnknownType':
											return '?'
										case 'TSJSDocNullableType':
											return De(ve, ie, '?')
										case 'TSJSDocNonNullableType':
											return De(ve, ie, '!')
										case 'TSInstantiationExpression':
											return [ie('expression'), ie('typeParameters')]
										default:
											throw new Error(`Unknown TypeScript node type: ${JSON.stringify(fe.type)}.`)
									}
								}
								E.exports = { printTypescript: Fe }
							}
						}),
						jy = le({
							'src/language-js/print/comment.js'(d, E) {
								'use strict'
								ge()
								var { hasNewline: c } = wn(),
									{
										builders: { join: D, hardline: g },
										utils: { replaceTextEndOfLine: l }
									} = dn(),
									{ isLineComment: p } = er(),
									{ locStart: f, locEnd: y } = Qr(),
									x = js()
								function _(v, b) {
									let k = v.getValue()
									if (p(k)) return b.originalText.slice(f(k), y(k)).trimEnd()
									if (x(k)) {
										if (w(k)) {
											let O = C(k)
											return k.trailing && !c(b.originalText, f(k), { backwards: !0 }) ? [g, O] : O
										}
										let q = y(k),
											G = b.originalText.slice(q - 3, q) === '*-/'
										return ['/*', l(k.value), G ? '*-/' : '*/']
									}
									throw new Error('Not a comment: ' + JSON.stringify(k))
								}
								function w(v) {
									let b = `*${v.value}*`.split(`
`)
									return b.length > 1 && b.every((k) => k.trim()[0] === '*')
								}
								function C(v) {
									let b = v.value.split(`
`)
									return [
										'/*',
										D(
											g,
											b.map((k, q) =>
												q === 0 ? k.trimEnd() : ' ' + (q < b.length - 1 ? k.trim() : k.trimStart())
											)
										),
										'*/'
									]
								}
								E.exports = { printComment: _ }
							}
						}),
						$y = le({
							'src/language-js/print/literal.js'(d, E) {
								'use strict'
								ge()
								var { printString: c, printNumber: D } = wn(),
									{ replaceTextEndOfLine: g } = _a(),
									{ printDirective: l } = hi()
								function p(_, w) {
									let C = _.getNode()
									switch (C.type) {
										case 'RegExpLiteral':
											return x(C)
										case 'BigIntLiteral':
											return y(C.bigint || C.extra.raw)
										case 'NumericLiteral':
											return D(C.extra.raw)
										case 'StringLiteral':
											return g(c(C.extra.raw, w))
										case 'NullLiteral':
											return 'null'
										case 'BooleanLiteral':
											return String(C.value)
										case 'DecimalLiteral':
											return D(C.value) + 'm'
										case 'Literal': {
											if (C.regex) return x(C.regex)
											if (C.bigint) return y(C.raw)
											if (C.decimal) return D(C.decimal) + 'm'
											let { value: v } = C
											return typeof v == 'number'
												? D(C.raw)
												: typeof v == 'string'
												? f(_)
													? l(C.raw, w)
													: g(c(C.raw, w))
												: String(v)
										}
									}
								}
								function f(_) {
									if (_.getName() !== 'expression') return
									let w = _.getParentNode()
									return w.type === 'ExpressionStatement' && w.directive
								}
								function y(_) {
									return _.toLowerCase()
								}
								function x(_) {
									let { pattern: w, flags: C } = _
									return (C = [...C].sort().join('')), `/${w}/${C}`
								}
								E.exports = { printLiteral: p }
							}
						}),
						Vy = le({
							'src/language-js/printer-estree.js'(d, E) {
								'use strict'
								ge()
								var { printDanglingComments: c } = Sr(),
									{ hasNewline: D } = wn(),
									{
										builders: { join: g, line: l, hardline: p, softline: f, group: y, indent: x },
										utils: { replaceTextEndOfLine: _ }
									} = dn(),
									w = by(),
									C = Ty(),
									{ insertPragma: v } = V1(),
									b = U1(),
									k = vo(),
									q = q1(),
									{
										hasFlowShorthandAnnotationComment: G,
										hasComment: O,
										CommentCheckFlags: U,
										isTheOnlyJsxElementInMarkdown: j,
										isLineComment: H,
										isNextLineEmpty: W,
										needsHardlineAfterDanglingComment: re,
										hasIgnoreComment: A,
										isCallExpression: $,
										isMemberExpression: T,
										markerForIfWithoutBlockAndSameLineComment: R
									} = er(),
									{ locStart: m, locEnd: S } = Qr(),
									L = js(),
									{ printHtmlBinding: P, isVueEventBindingExpression: M } = Iy(),
									{ printAngular: V } = ky(),
									{ printJsx: J, hasJsxIgnoreComment: Z } = Ry(),
									{ printFlow: ne } = By(),
									{ printTypescript: ee } = My(),
									{
										printOptionalToken: ce,
										printBindExpressionCallee: z,
										printTypeAnnotation: ye,
										adjustClause: te,
										printRestSpread: X,
										printDefiniteToken: De,
										printDirective: Fe
									} = hi(),
									{
										printImportDeclaration: ve,
										printExportDeclaration: $e,
										printExportAllDeclaration: ie,
										printModuleSpecifier: fe
									} = z1(),
									{ printTernary: Be } = Q1(),
									{ printTemplateLiteral: Me } = Eo(),
									{ printArray: Dt } = ka(),
									{ printObject: me } = Dp(),
									{ printClass: ae, printClassMethod: xe, printClassProperty: Ce } = Ba(),
									{ printProperty: Ge } = Oa(),
									{
										printFunction: nt,
										printArrowFunction: ot,
										printMethod: Ut,
										printReturnStatement: vn,
										printThrowStatement: Dn
									} = Xu(),
									{ printCallExpression: Vt } = H1(),
									{ printVariableDeclarator: tn, printAssignmentExpression: Ie } = Ra(),
									{ printBinaryishExpression: se } = mp(),
									{ printSwitchCaseConsequent: je } = Y1(),
									{ printMemberExpression: he } = W1(),
									{ printBlock: Oe, printBlockBody: wt } = X1(),
									{ printComment: mt } = jy(),
									{ printLiteral: Ue } = $y(),
									{ printDecorators: B } = gp()
								function pe(pt, jt, at, ar) {
									let Rt = _e(pt, jt, at, ar)
									if (!Rt) return ''
									let ir = pt.getValue(),
										{ type: It } = ir
									if (
										It === 'ClassMethod' ||
										It === 'ClassPrivateMethod' ||
										It === 'ClassProperty' ||
										It === 'ClassAccessorProperty' ||
										It === 'AccessorProperty' ||
										It === 'TSAbstractAccessorProperty' ||
										It === 'PropertyDefinition' ||
										It === 'TSAbstractPropertyDefinition' ||
										It === 'ClassPrivateProperty' ||
										It === 'MethodDefinition' ||
										It === 'TSAbstractMethodDefinition' ||
										It === 'TSDeclareMethod'
									)
										return Rt
									let an = [Rt],
										yn = B(pt, jt, at),
										Qn = ir.type === 'ClassExpression' && yn
									if (yn && ((an = [...yn, Rt]), !Qn)) return y(an)
									if (!k(pt, jt))
										return (
											ar && ar.needsSemi && an.unshift(';'),
											an.length === 1 && an[0] === Rt ? Rt : an
										)
									if (
										(Qn && (an = [x([l, ...an])]),
										an.unshift('('),
										ar && ar.needsSemi && an.unshift(';'),
										G(ir))
									) {
										let [Pt] = ir.trailingComments
										an.push(' /*', Pt.value.trimStart(), '*/'), (Pt.printed = !0)
									}
									return Qn && an.push(l), an.push(')'), an
								}
								function _e(pt, jt, at, ar) {
									let Rt = pt.getValue(),
										ir = jt.semi ? ';' : ''
									if (!Rt) return ''
									if (typeof Rt == 'string') return Rt
									for (let an of [Ue, P, V, J, ne, ee]) {
										let yn = an(pt, jt, at)
										if (typeof yn < 'u') return yn
									}
									let It = []
									switch (Rt.type) {
										case 'JsExpressionRoot':
											return at('node')
										case 'JsonRoot':
											return [at('node'), p]
										case 'File':
											return (
												Rt.program &&
													Rt.program.interpreter &&
													It.push(at(['program', 'interpreter'])),
												It.push(at('program')),
												It
											)
										case 'Program':
											return wt(pt, jt, at)
										case 'EmptyStatement':
											return ''
										case 'ExpressionStatement': {
											if (
												jt.parser === '__vue_event_binding' ||
												jt.parser === '__vue_ts_event_binding'
											) {
												let yn = pt.getParentNode()
												if (yn.type === 'Program' && yn.body.length === 1 && yn.body[0] === Rt)
													return [at('expression'), M(Rt.expression) ? ';' : '']
											}
											let an = c(pt, jt, !0, (yn) => {
												let { marker: Qn } = yn
												return Qn === R
											})
											return [at('expression'), j(jt, pt) ? '' : ir, an ? [' ', an] : '']
										}
										case 'ParenthesizedExpression':
											return !O(Rt.expression) &&
												(Rt.expression.type === 'ObjectExpression' ||
													Rt.expression.type === 'ArrayExpression')
												? ['(', at('expression'), ')']
												: y(['(', x([f, at('expression')]), f, ')'])
										case 'AssignmentExpression':
											return Ie(pt, jt, at)
										case 'VariableDeclarator':
											return tn(pt, jt, at)
										case 'BinaryExpression':
										case 'LogicalExpression':
											return se(pt, jt, at)
										case 'AssignmentPattern':
											return [at('left'), ' = ', at('right')]
										case 'OptionalMemberExpression':
										case 'MemberExpression':
											return he(pt, jt, at)
										case 'MetaProperty':
											return [at('meta'), '.', at('property')]
										case 'BindExpression':
											return (
												Rt.object && It.push(at('object')), It.push(y(x([f, z(pt, jt, at)]))), It
											)
										case 'Identifier':
											return [Rt.name, ce(pt), De(pt), ye(pt, jt, at)]
										case 'V8IntrinsicIdentifier':
											return ['%', Rt.name]
										case 'SpreadElement':
										case 'SpreadElementPattern':
										case 'SpreadProperty':
										case 'SpreadPropertyPattern':
										case 'RestElement':
											return X(pt, jt, at)
										case 'FunctionDeclaration':
										case 'FunctionExpression':
											return nt(pt, at, jt, ar)
										case 'ArrowFunctionExpression':
											return ot(pt, jt, at, ar)
										case 'YieldExpression':
											return (
												It.push('yield'),
												Rt.delegate && It.push('*'),
												Rt.argument && It.push(' ', at('argument')),
												It
											)
										case 'AwaitExpression': {
											if ((It.push('await'), Rt.argument)) {
												It.push(' ', at('argument'))
												let an = pt.getParentNode()
												if (($(an) && an.callee === Rt) || (T(an) && an.object === Rt)) {
													It = [x([f, ...It]), f]
													let yn = pt.findAncestor(
														(Qn) => Qn.type === 'AwaitExpression' || Qn.type === 'BlockStatement'
													)
													if (!yn || yn.type !== 'AwaitExpression') return y(It)
												}
											}
											return It
										}
										case 'ExportDefaultDeclaration':
										case 'ExportNamedDeclaration':
											return $e(pt, jt, at)
										case 'ExportAllDeclaration':
											return ie(pt, jt, at)
										case 'ImportDeclaration':
											return ve(pt, jt, at)
										case 'ImportSpecifier':
										case 'ExportSpecifier':
										case 'ImportNamespaceSpecifier':
										case 'ExportNamespaceSpecifier':
										case 'ImportDefaultSpecifier':
										case 'ExportDefaultSpecifier':
											return fe(pt, jt, at)
										case 'ImportAttribute':
											return [at('key'), ': ', at('value')]
										case 'Import':
											return 'import'
										case 'BlockStatement':
										case 'StaticBlock':
										case 'ClassBody':
											return Oe(pt, jt, at)
										case 'ThrowStatement':
											return Dn(pt, jt, at)
										case 'ReturnStatement':
											return vn(pt, jt, at)
										case 'NewExpression':
										case 'ImportExpression':
										case 'OptionalCallExpression':
										case 'CallExpression':
											return Vt(pt, jt, at)
										case 'ObjectExpression':
										case 'ObjectPattern':
										case 'RecordExpression':
											return me(pt, jt, at)
										case 'ObjectProperty':
										case 'Property':
											return Rt.method || Rt.kind === 'get' || Rt.kind === 'set'
												? Ut(pt, jt, at)
												: Ge(pt, jt, at)
										case 'ObjectMethod':
											return Ut(pt, jt, at)
										case 'Decorator':
											return ['@', at('expression')]
										case 'ArrayExpression':
										case 'ArrayPattern':
										case 'TupleExpression':
											return Dt(pt, jt, at)
										case 'SequenceExpression': {
											let an = pt.getParentNode(0)
											if (an.type === 'ExpressionStatement' || an.type === 'ForStatement') {
												let yn = []
												return (
													pt.each((Qn, Pt) => {
														Pt === 0 ? yn.push(at()) : yn.push(',', x([l, at()]))
													}, 'expressions'),
													y(yn)
												)
											}
											return y(g([',', l], pt.map(at, 'expressions')))
										}
										case 'ThisExpression':
											return 'this'
										case 'Super':
											return 'super'
										case 'Directive':
											return [at('value'), ir]
										case 'DirectiveLiteral':
											return Fe(Rt.extra.raw, jt)
										case 'UnaryExpression':
											return (
												It.push(Rt.operator),
												/[a-z]$/.test(Rt.operator) && It.push(' '),
												O(Rt.argument)
													? It.push(y(['(', x([f, at('argument')]), f, ')']))
													: It.push(at('argument')),
												It
											)
										case 'UpdateExpression':
											return It.push(at('argument'), Rt.operator), Rt.prefix && It.reverse(), It
										case 'ConditionalExpression':
											return Be(pt, jt, at)
										case 'VariableDeclaration': {
											let an = pt.map(at, 'declarations'),
												yn = pt.getParentNode(),
												Qn =
													yn.type === 'ForStatement' ||
													yn.type === 'ForInStatement' ||
													yn.type === 'ForOfStatement',
												Pt = Rt.declarations.some((ln) => ln.init),
												mn
											return (
												an.length === 1 && !O(Rt.declarations[0])
													? (mn = an[0])
													: an.length > 0 && (mn = x(an[0])),
												(It = [
													Rt.declare ? 'declare ' : '',
													Rt.kind,
													mn ? [' ', mn] : '',
													x(an.slice(1).map((ln) => [',', Pt && !Qn ? p : l, ln]))
												]),
												(Qn && yn.body !== Rt) || It.push(ir),
												y(It)
											)
										}
										case 'WithStatement':
											return y(['with (', at('object'), ')', te(Rt.body, at('body'))])
										case 'IfStatement': {
											let an = te(Rt.consequent, at('consequent')),
												yn = y(['if (', y([x([f, at('test')]), f]), ')', an])
											if ((It.push(yn), Rt.alternate)) {
												let Qn = O(Rt.consequent, U.Trailing | U.Line) || re(Rt),
													Pt = Rt.consequent.type === 'BlockStatement' && !Qn
												It.push(Pt ? ' ' : p),
													O(Rt, U.Dangling) && It.push(c(pt, jt, !0), Qn ? p : ' '),
													It.push(
														'else',
														y(
															te(Rt.alternate, at('alternate'), Rt.alternate.type === 'IfStatement')
														)
													)
											}
											return It
										}
										case 'ForStatement': {
											let an = te(Rt.body, at('body')),
												yn = c(pt, jt, !0),
												Qn = yn ? [yn, f] : ''
											return !Rt.init && !Rt.test && !Rt.update
												? [Qn, y(['for (;;)', an])]
												: [
														Qn,
														y([
															'for (',
															y([x([f, at('init'), ';', l, at('test'), ';', l, at('update')]), f]),
															')',
															an
														])
												  ]
										}
										case 'WhileStatement':
											return y([
												'while (',
												y([x([f, at('test')]), f]),
												')',
												te(Rt.body, at('body'))
											])
										case 'ForInStatement':
											return y([
												'for (',
												at('left'),
												' in ',
												at('right'),
												')',
												te(Rt.body, at('body'))
											])
										case 'ForOfStatement':
											return y([
												'for',
												Rt.await ? ' await' : '',
												' (',
												at('left'),
												' of ',
												at('right'),
												')',
												te(Rt.body, at('body'))
											])
										case 'DoWhileStatement': {
											let an = te(Rt.body, at('body'))
											return (
												(It = [y(['do', an])]),
												Rt.body.type === 'BlockStatement' ? It.push(' ') : It.push(p),
												It.push('while (', y([x([f, at('test')]), f]), ')', ir),
												It
											)
										}
										case 'DoExpression':
											return [Rt.async ? 'async ' : '', 'do ', at('body')]
										case 'BreakStatement':
											return (
												It.push('break'), Rt.label && It.push(' ', at('label')), It.push(ir), It
											)
										case 'ContinueStatement':
											return (
												It.push('continue'), Rt.label && It.push(' ', at('label')), It.push(ir), It
											)
										case 'LabeledStatement':
											return Rt.body.type === 'EmptyStatement'
												? [at('label'), ':;']
												: [at('label'), ': ', at('body')]
										case 'TryStatement':
											return [
												'try ',
												at('block'),
												Rt.handler ? [' ', at('handler')] : '',
												Rt.finalizer ? [' finally ', at('finalizer')] : ''
											]
										case 'CatchClause':
											if (Rt.param) {
												let an = O(
														Rt.param,
														(Qn) =>
															!L(Qn) ||
															(Qn.leading && D(jt.originalText, S(Qn))) ||
															(Qn.trailing && D(jt.originalText, m(Qn), { backwards: !0 }))
													),
													yn = at('param')
												return [
													'catch ',
													an ? ['(', x([f, yn]), f, ') '] : ['(', yn, ') '],
													at('body')
												]
											}
											return ['catch ', at('body')]
										case 'SwitchStatement':
											return [
												y(['switch (', x([f, at('discriminant')]), f, ')']),
												' {',
												Rt.cases.length > 0
													? x([
															p,
															g(
																p,
																pt.map((an, yn, Qn) => {
																	let Pt = an.getValue()
																	return [at(), yn !== Qn.length - 1 && W(Pt, jt) ? p : '']
																}, 'cases')
															)
													  ])
													: '',
												p,
												'}'
											]
										case 'SwitchCase': {
											Rt.test ? It.push('case ', at('test'), ':') : It.push('default:'),
												O(Rt, U.Dangling) && It.push(' ', c(pt, jt, !0))
											let an = Rt.consequent.filter((yn) => yn.type !== 'EmptyStatement')
											if (an.length > 0) {
												let yn = je(pt, jt, at)
												It.push(
													an.length === 1 && an[0].type === 'BlockStatement'
														? [' ', yn]
														: x([p, yn])
												)
											}
											return It
										}
										case 'DebuggerStatement':
											return ['debugger', ir]
										case 'ClassDeclaration':
										case 'ClassExpression':
											return ae(pt, jt, at)
										case 'ClassMethod':
										case 'ClassPrivateMethod':
										case 'MethodDefinition':
											return xe(pt, jt, at)
										case 'ClassProperty':
										case 'PropertyDefinition':
										case 'ClassPrivateProperty':
										case 'ClassAccessorProperty':
										case 'AccessorProperty':
											return Ce(pt, jt, at)
										case 'TemplateElement':
											return _(Rt.value.raw)
										case 'TemplateLiteral':
											return Me(pt, at, jt)
										case 'TaggedTemplateExpression':
											return [at('tag'), at('typeParameters'), at('quasi')]
										case 'PrivateIdentifier':
											return ['#', at('name')]
										case 'PrivateName':
											return ['#', at('id')]
										case 'InterpreterDirective':
											return It.push('#!', Rt.value, p), W(Rt, jt) && It.push(p), It
										case 'TopicReference':
											return '%'
										case 'ArgumentPlaceholder':
											return '?'
										case 'ModuleExpression': {
											It.push('module {')
											let an = at('body')
											return an && It.push(x([p, an]), p), It.push('}'), It
										}
										default:
											throw new Error('unknown type: ' + JSON.stringify(Rt.type))
									}
								}
								function st(pt) {
									return (
										pt.type &&
										!L(pt) &&
										!H(pt) &&
										pt.type !== 'EmptyStatement' &&
										pt.type !== 'TemplateElement' &&
										pt.type !== 'Import' &&
										pt.type !== 'TSEmptyBodyFunctionExpression'
									)
								}
								E.exports = {
									preprocess: q,
									print: pe,
									embed: w,
									insertPragma: v,
									massageAstNode: C,
									hasPrettierIgnore(pt) {
										return A(pt) || Z(pt)
									},
									willPrintOwnComments: b.willPrintOwnComments,
									canAttachComment: st,
									printComment: mt,
									isBlockComment: L,
									handleComments: {
										avoidAstMutation: !0,
										ownLine: b.handleOwnLineComment,
										endOfLine: b.handleEndOfLineComment,
										remaining: b.handleRemainingComment
									},
									getCommentChildNodes: b.getCommentChildNodes
								}
							}
						}),
						Uy = le({
							'src/language-js/printer-estree-json.js'(d, E) {
								'use strict'
								ge()
								var {
										builders: { hardline: c, indent: D, join: g }
									} = dn(),
									l = q1()
								function p(_, w, C) {
									let v = _.getValue()
									switch (v.type) {
										case 'JsonRoot':
											return [C('node'), c]
										case 'ArrayExpression': {
											if (v.elements.length === 0) return '[]'
											let b = _.map(() => (_.getValue() === null ? 'null' : C()), 'elements')
											return ['[', D([c, g([',', c], b)]), c, ']']
										}
										case 'ObjectExpression':
											return v.properties.length === 0
												? '{}'
												: ['{', D([c, g([',', c], _.map(C, 'properties'))]), c, '}']
										case 'ObjectProperty':
											return [C('key'), ': ', C('value')]
										case 'UnaryExpression':
											return [v.operator === '+' ? '' : v.operator, C('argument')]
										case 'NullLiteral':
											return 'null'
										case 'BooleanLiteral':
											return v.value ? 'true' : 'false'
										case 'StringLiteral':
											return JSON.stringify(v.value)
										case 'NumericLiteral':
											return f(_) ? JSON.stringify(String(v.value)) : JSON.stringify(v.value)
										case 'Identifier':
											return f(_) ? JSON.stringify(v.name) : v.name
										case 'TemplateLiteral':
											return C(['quasis', 0])
										case 'TemplateElement':
											return JSON.stringify(v.value.cooked)
										default:
											throw new Error('unknown type: ' + JSON.stringify(v.type))
									}
								}
								function f(_) {
									return _.getName() === 'key' && _.getParentNode().type === 'ObjectProperty'
								}
								var y = new Set([
									'start',
									'end',
									'extra',
									'loc',
									'comments',
									'leadingComments',
									'trailingComments',
									'innerComments',
									'errors',
									'range',
									'tokens'
								])
								function x(_, w) {
									let { type: C } = _
									if (C === 'ObjectProperty') {
										let { key: v } = _
										v.type === 'Identifier'
											? (w.key = { type: 'StringLiteral', value: v.name })
											: v.type === 'NumericLiteral' &&
											  (w.key = { type: 'StringLiteral', value: String(v.value) })
										return
									}
									if (C === 'UnaryExpression' && _.operator === '+') return w.argument
									if (C === 'ArrayExpression') {
										for (let [v, b] of _.elements.entries())
											b === null && w.elements.splice(v, 0, { type: 'NullLiteral' })
										return
									}
									if (C === 'TemplateLiteral')
										return { type: 'StringLiteral', value: _.quasis[0].value.cooked }
								}
								;(x.ignoredProperties = y),
									(E.exports = { preprocess: l, print: p, massageAstNode: x })
							}
						}),
						xo = le({
							'src/common/common-options.js'(d, E) {
								'use strict'
								ge()
								var c = 'Common'
								E.exports = {
									bracketSpacing: {
										since: '0.0.0',
										category: c,
										type: 'boolean',
										default: !0,
										description: 'Print spaces between brackets.',
										oppositeDescription: 'Do not print spaces between brackets.'
									},
									singleQuote: {
										since: '0.0.0',
										category: c,
										type: 'boolean',
										default: !1,
										description: 'Use single quotes instead of double quotes.'
									},
									proseWrap: {
										since: '1.8.2',
										category: c,
										type: 'choice',
										default: [
											{ since: '1.8.2', value: !0 },
											{ since: '1.9.0', value: 'preserve' }
										],
										description: 'How to wrap prose.',
										choices: [
											{
												since: '1.9.0',
												value: 'always',
												description: 'Wrap prose if it exceeds the print width.'
											},
											{ since: '1.9.0', value: 'never', description: 'Do not wrap prose.' },
											{ since: '1.9.0', value: 'preserve', description: 'Wrap prose as-is.' }
										]
									},
									bracketSameLine: {
										since: '2.4.0',
										category: c,
										type: 'boolean',
										default: !1,
										description: 'Put > of opening tags on the last line instead of on a new line.'
									},
									singleAttributePerLine: {
										since: '2.6.0',
										category: c,
										type: 'boolean',
										default: !1,
										description: 'Enforce single attribute per line in HTML, Vue and JSX.'
									}
								}
							}
						}),
						qy = le({
							'src/language-js/options.js'(d, E) {
								'use strict'
								ge()
								var c = xo(),
									D = 'JavaScript'
								E.exports = {
									arrowParens: {
										since: '1.9.0',
										category: D,
										type: 'choice',
										default: [
											{ since: '1.9.0', value: 'avoid' },
											{ since: '2.0.0', value: 'always' }
										],
										description: 'Include parentheses around a sole arrow function parameter.',
										choices: [
											{
												value: 'always',
												description: 'Always include parens. Example: `(x) => x`'
											},
											{
												value: 'avoid',
												description: 'Omit parens when possible. Example: `x => x`'
											}
										]
									},
									bracketSameLine: c.bracketSameLine,
									bracketSpacing: c.bracketSpacing,
									jsxBracketSameLine: {
										since: '0.17.0',
										category: D,
										type: 'boolean',
										description: 'Put > on the last line instead of at a new line.',
										deprecated: '2.4.0'
									},
									semi: {
										since: '1.0.0',
										category: D,
										type: 'boolean',
										default: !0,
										description: 'Print semicolons.',
										oppositeDescription:
											'Do not print semicolons, except at the beginning of lines which may need them.'
									},
									singleQuote: c.singleQuote,
									jsxSingleQuote: {
										since: '1.15.0',
										category: D,
										type: 'boolean',
										default: !1,
										description: 'Use single quotes in JSX.'
									},
									quoteProps: {
										since: '1.17.0',
										category: D,
										type: 'choice',
										default: 'as-needed',
										description: 'Change when properties in objects are quoted.',
										choices: [
											{
												value: 'as-needed',
												description: 'Only add quotes around object properties where required.'
											},
											{
												value: 'consistent',
												description:
													'If at least one property in an object requires quotes, quote all properties.'
											},
											{
												value: 'preserve',
												description: 'Respect the input use of quotes in object properties.'
											}
										]
									},
									trailingComma: {
										since: '0.0.0',
										category: D,
										type: 'choice',
										default: [
											{ since: '0.0.0', value: !1 },
											{ since: '0.19.0', value: 'none' },
											{ since: '2.0.0', value: 'es5' }
										],
										description: 'Print trailing commas wherever possible when multi-line.',
										choices: [
											{
												value: 'es5',
												description: 'Trailing commas where valid in ES5 (objects, arrays, etc.)'
											},
											{ value: 'none', description: 'No trailing commas.' },
											{
												value: 'all',
												description:
													'Trailing commas wherever possible (including function arguments).'
											}
										]
									},
									singleAttributePerLine: c.singleAttributePerLine
								}
							}
						}),
						Gy = le({
							'src/language-js/parse/parsers.js'() {
								ge()
							}
						}),
						yp = le({
							'node_modules/linguist-languages/data/JavaScript.json'(d, E) {
								E.exports = {
									name: 'JavaScript',
									type: 'programming',
									tmScope: 'source.js',
									aceMode: 'javascript',
									codemirrorMode: 'javascript',
									codemirrorMimeType: 'text/javascript',
									color: '#f1e05a',
									aliases: ['js', 'node'],
									extensions: [
										'.js',
										'._js',
										'.bones',
										'.cjs',
										'.es',
										'.es6',
										'.frag',
										'.gs',
										'.jake',
										'.javascript',
										'.jsb',
										'.jscad',
										'.jsfl',
										'.jslib',
										'.jsm',
										'.jspre',
										'.jss',
										'.jsx',
										'.mjs',
										'.njs',
										'.pac',
										'.sjs',
										'.ssjs',
										'.xsjs',
										'.xsjslib'
									],
									filenames: ['Jakefile'],
									interpreters: [
										'chakra',
										'd8',
										'gjs',
										'js',
										'node',
										'nodejs',
										'qjs',
										'rhino',
										'v8',
										'v8-shell'
									],
									languageId: 183
								}
							}
						}),
						Wy = le({
							'node_modules/linguist-languages/data/TypeScript.json'(d, E) {
								E.exports = {
									name: 'TypeScript',
									type: 'programming',
									color: '#3178c6',
									aliases: ['ts'],
									interpreters: ['deno', 'ts-node'],
									extensions: ['.ts', '.cts', '.mts'],
									tmScope: 'source.ts',
									aceMode: 'typescript',
									codemirrorMode: 'javascript',
									codemirrorMimeType: 'application/typescript',
									languageId: 378
								}
							}
						}),
						Hy = le({
							'node_modules/linguist-languages/data/TSX.json'(d, E) {
								E.exports = {
									name: 'TSX',
									type: 'programming',
									color: '#3178c6',
									group: 'TypeScript',
									extensions: ['.tsx'],
									tmScope: 'source.tsx',
									aceMode: 'javascript',
									codemirrorMode: 'jsx',
									codemirrorMimeType: 'text/jsx',
									languageId: 94901924
								}
							}
						}),
						K1 = le({
							'node_modules/linguist-languages/data/JSON.json'(d, E) {
								E.exports = {
									name: 'JSON',
									type: 'data',
									color: '#292929',
									tmScope: 'source.json',
									aceMode: 'json',
									codemirrorMode: 'javascript',
									codemirrorMimeType: 'application/json',
									aliases: ['geojson', 'jsonl', 'topojson'],
									extensions: [
										'.json',
										'.4DForm',
										'.4DProject',
										'.avsc',
										'.geojson',
										'.gltf',
										'.har',
										'.ice',
										'.JSON-tmLanguage',
										'.jsonl',
										'.mcmeta',
										'.tfstate',
										'.tfstate.backup',
										'.topojson',
										'.webapp',
										'.webmanifest',
										'.yy',
										'.yyp'
									],
									filenames: [
										'.arcconfig',
										'.auto-changelog',
										'.c8rc',
										'.htmlhintrc',
										'.imgbotconfig',
										'.nycrc',
										'.tern-config',
										'.tern-project',
										'.watchmanconfig',
										'Pipfile.lock',
										'composer.lock',
										'mcmod.info'
									],
									languageId: 174
								}
							}
						}),
						Jy = le({
							'node_modules/linguist-languages/data/JSON with Comments.json'(d, E) {
								E.exports = {
									name: 'JSON with Comments',
									type: 'data',
									color: '#292929',
									group: 'JSON',
									tmScope: 'source.js',
									aceMode: 'javascript',
									codemirrorMode: 'javascript',
									codemirrorMimeType: 'text/javascript',
									aliases: ['jsonc'],
									extensions: [
										'.jsonc',
										'.code-snippets',
										'.sublime-build',
										'.sublime-commands',
										'.sublime-completions',
										'.sublime-keymap',
										'.sublime-macro',
										'.sublime-menu',
										'.sublime-mousemap',
										'.sublime-project',
										'.sublime-settings',
										'.sublime-theme',
										'.sublime-workspace',
										'.sublime_metrics',
										'.sublime_session'
									],
									filenames: [
										'.babelrc',
										'.devcontainer.json',
										'.eslintrc.json',
										'.jscsrc',
										'.jshintrc',
										'.jslintrc',
										'api-extractor.json',
										'devcontainer.json',
										'jsconfig.json',
										'language-configuration.json',
										'tsconfig.json',
										'tslint.json'
									],
									languageId: 423
								}
							}
						}),
						zy = le({
							'node_modules/linguist-languages/data/JSON5.json'(d, E) {
								E.exports = {
									name: 'JSON5',
									type: 'data',
									color: '#267CB9',
									extensions: ['.json5'],
									tmScope: 'source.js',
									aceMode: 'javascript',
									codemirrorMode: 'javascript',
									codemirrorMimeType: 'application/json',
									languageId: 175
								}
							}
						}),
						Qy = le({
							'src/language-js/index.js'(d, E) {
								'use strict'
								ge()
								var c = Ms(),
									D = Vy(),
									g = Uy(),
									l = qy(),
									p = Gy(),
									f = [
										c(yp(), (x) => ({
											since: '0.0.0',
											parsers: [
												'babel',
												'acorn',
												'espree',
												'meriyah',
												'babel-flow',
												'babel-ts',
												'flow',
												'typescript'
											],
											vscodeLanguageIds: ['javascript', 'mongo'],
											interpreters: [...x.interpreters, 'zx'],
											extensions: [...x.extensions.filter((_) => _ !== '.jsx'), '.wxs']
										})),
										c(yp(), () => ({
											name: 'Flow',
											since: '0.0.0',
											parsers: ['flow', 'babel-flow'],
											vscodeLanguageIds: ['javascript'],
											aliases: [],
											filenames: [],
											extensions: ['.js.flow']
										})),
										c(yp(), () => ({
											name: 'JSX',
											since: '0.0.0',
											parsers: [
												'babel',
												'babel-flow',
												'babel-ts',
												'flow',
												'typescript',
												'espree',
												'meriyah'
											],
											vscodeLanguageIds: ['javascriptreact'],
											aliases: void 0,
											filenames: void 0,
											extensions: ['.jsx'],
											group: 'JavaScript',
											interpreters: void 0,
											tmScope: 'source.js.jsx',
											aceMode: 'javascript',
											codemirrorMode: 'jsx',
											codemirrorMimeType: 'text/jsx',
											color: void 0
										})),
										c(Wy(), () => ({
											since: '1.4.0',
											parsers: ['typescript', 'babel-ts'],
											vscodeLanguageIds: ['typescript']
										})),
										c(Hy(), () => ({
											since: '1.4.0',
											parsers: ['typescript', 'babel-ts'],
											vscodeLanguageIds: ['typescriptreact']
										})),
										c(K1(), () => ({
											name: 'JSON.stringify',
											since: '1.13.0',
											parsers: ['json-stringify'],
											vscodeLanguageIds: ['json'],
											extensions: ['.importmap'],
											filenames: ['package.json', 'package-lock.json', 'composer.json']
										})),
										c(K1(), (x) => ({
											since: '1.5.0',
											parsers: ['json'],
											vscodeLanguageIds: ['json'],
											extensions: x.extensions.filter((_) => _ !== '.jsonl')
										})),
										c(Jy(), (x) => ({
											since: '1.5.0',
											parsers: ['json'],
											vscodeLanguageIds: ['jsonc'],
											filenames: [...x.filenames, '.eslintrc', '.swcrc']
										})),
										c(zy(), () => ({
											since: '1.13.0',
											parsers: ['json5'],
											vscodeLanguageIds: ['json5']
										}))
									],
									y = { estree: D, 'estree-json': g }
								E.exports = { languages: f, options: l, printers: y, parsers: p }
							}
						}),
						Yy = le({
							'src/language-css/clean.js'(d, E) {
								'use strict'
								ge()
								var { isFrontMatterNode: c } = wn(),
									D = Ur(),
									g = new Set([
										'raw',
										'raws',
										'sourceIndex',
										'source',
										'before',
										'after',
										'trailingComma'
									])
								function l(f, y, x) {
									if (
										(c(f) && f.lang === 'yaml' && delete y.value,
										f.type === 'css-comment' &&
											x.type === 'css-root' &&
											x.nodes.length > 0 &&
											(((x.nodes[0] === f || (c(x.nodes[0]) && x.nodes[1] === f)) &&
												(delete y.text, /^\*\s*@(?:format|prettier)\s*$/.test(f.text))) ||
												(x.type === 'css-root' && D(x.nodes) === f)))
									)
										return null
									if (
										(f.type === 'value-root' && delete y.text,
										(f.type === 'media-query' ||
											f.type === 'media-query-list' ||
											f.type === 'media-feature-expression') &&
											delete y.value,
										f.type === 'css-rule' && delete y.params,
										f.type === 'selector-combinator' && (y.value = y.value.replace(/\s+/g, ' ')),
										f.type === 'media-feature' && (y.value = y.value.replace(/ /g, '')),
										((f.type === 'value-word' &&
											((f.isColor && f.isHex) ||
												['initial', 'inherit', 'unset', 'revert'].includes(
													y.value.replace().toLowerCase()
												))) ||
											f.type === 'media-feature' ||
											f.type === 'selector-root-invalid' ||
											f.type === 'selector-pseudo') &&
											(y.value = y.value.toLowerCase()),
										f.type === 'css-decl' && (y.prop = y.prop.toLowerCase()),
										(f.type === 'css-atrule' || f.type === 'css-import') &&
											(y.name = y.name.toLowerCase()),
										f.type === 'value-number' && (y.unit = y.unit.toLowerCase()),
										(f.type === 'media-feature' ||
											f.type === 'media-keyword' ||
											f.type === 'media-type' ||
											f.type === 'media-unknown' ||
											f.type === 'media-url' ||
											f.type === 'media-value' ||
											f.type === 'selector-attribute' ||
											f.type === 'selector-string' ||
											f.type === 'selector-class' ||
											f.type === 'selector-combinator' ||
											f.type === 'value-string') &&
											y.value &&
											(y.value = p(y.value)),
										f.type === 'selector-attribute' &&
											((y.attribute = y.attribute.trim()),
											y.namespace &&
												typeof y.namespace == 'string' &&
												((y.namespace = y.namespace.trim()),
												y.namespace.length === 0 && (y.namespace = !0)),
											y.value &&
												((y.value = y.value.trim().replace(/^["']|["']$/g, '')), delete y.quoted)),
										(f.type === 'media-value' ||
											f.type === 'media-type' ||
											f.type === 'value-number' ||
											f.type === 'selector-root-invalid' ||
											f.type === 'selector-class' ||
											f.type === 'selector-combinator' ||
											f.type === 'selector-tag') &&
											y.value &&
											(y.value = y.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (_, w, C) => {
												let v = Number(w)
												return Number.isNaN(v) ? _ : v + C.toLowerCase()
											})),
										f.type === 'selector-tag')
									) {
										let _ = f.value.toLowerCase()
										;['from', 'to'].includes(_) && (y.value = _)
									}
									if (
										(f.type === 'css-atrule' &&
											f.name.toLowerCase() === 'supports' &&
											delete y.value,
										f.type === 'selector-unknown' && delete y.value,
										f.type === 'value-comma_group')
									) {
										let _ = f.groups.findIndex((w) => w.type === 'value-number' && w.unit === '...')
										_ !== -1 &&
											((y.groups[_].unit = ''),
											y.groups.splice(_ + 1, 0, {
												type: 'value-word',
												value: '...',
												isColor: !1,
												isHex: !1
											}))
									}
									if (
										f.type === 'value-comma_group' &&
										f.groups.some(
											(_) =>
												(_.type === 'value-atword' && _.value.endsWith('[')) ||
												(_.type === 'value-word' && _.value.startsWith(']'))
										)
									)
										return {
											type: 'value-atword',
											value: f.groups.map((_) => _.value).join(''),
											group: { open: null, close: null, groups: [], type: 'value-paren_group' }
										}
								}
								l.ignoredProperties = g
								function p(f) {
									return f.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, '$1')
								}
								E.exports = l
							}
						}),
						Ep = le({
							'src/utils/front-matter/print.js'(d, E) {
								'use strict'
								ge()
								var {
									builders: { hardline: c, markAsRoot: D }
								} = dn()
								function g(l, p) {
									if (l.lang === 'yaml') {
										let f = l.value.trim(),
											y = f ? p(f, { parser: 'yaml' }, { stripTrailingHardline: !0 }) : ''
										return D([l.startDelimiter, c, y, y ? c : '', l.endDelimiter])
									}
								}
								E.exports = g
							}
						}),
						Xy = le({
							'src/language-css/embed.js'(d, E) {
								'use strict'
								ge()
								var {
										builders: { hardline: c }
									} = dn(),
									D = Ep()
								function g(l, p, f) {
									let y = l.getValue()
									if (y.type === 'front-matter') {
										let x = D(y, f)
										return x ? [x, c] : ''
									}
								}
								E.exports = g
							}
						}),
						Z1 = le({
							'src/utils/front-matter/parse.js'(d, E) {
								'use strict'
								ge()
								var c = new RegExp(
									'^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)',
									's'
								)
								function D(g) {
									let l = g.match(c)
									if (!l) return { content: g }
									let { startDelimiter: p, language: f, value: y = '', endDelimiter: x } = l.groups,
										_ = f.trim() || 'yaml'
									if ((p === '+++' && (_ = 'toml'), _ !== 'yaml' && p !== x)) return { content: g }
									let [w] = l
									return {
										frontMatter: {
											type: 'front-matter',
											lang: _,
											value: y,
											startDelimiter: p,
											endDelimiter: x,
											raw: w.replace(/\n$/, '')
										},
										content: w.replace(/[^\n]/g, ' ') + g.slice(w.length)
									}
								}
								E.exports = D
							}
						}),
						Ky = le({
							'src/language-css/pragma.js'(d, E) {
								'use strict'
								ge()
								var c = V1(),
									D = Z1()
								function g(p) {
									return c.hasPragma(D(p).content)
								}
								function l(p) {
									let { frontMatter: f, content: y } = D(p)
									return (
										(f
											? f.raw +
											  `

`
											: '') + c.insertPragma(y)
									)
								}
								E.exports = { hasPragma: g, insertPragma: l }
							}
						}),
						Zy = le({
							'src/language-css/utils/index.js'(d, E) {
								'use strict'
								ge()
								var c = new Set([
									'red',
									'green',
									'blue',
									'alpha',
									'a',
									'rgb',
									'hue',
									'h',
									'saturation',
									's',
									'lightness',
									'l',
									'whiteness',
									'w',
									'blackness',
									'b',
									'tint',
									'shade',
									'blend',
									'blenda',
									'contrast',
									'hsl',
									'hsla',
									'hwb',
									'hwba'
								])
								function D(me, ae) {
									let xe = Array.isArray(ae) ? ae : [ae],
										Ce = -1,
										Ge
									for (; (Ge = me.getParentNode(++Ce)); ) if (xe.includes(Ge.type)) return Ce
									return -1
								}
								function g(me, ae) {
									let xe = D(me, ae)
									return xe === -1 ? null : me.getParentNode(xe)
								}
								function l(me) {
									var ae
									let xe = g(me, 'css-decl')
									return xe == null || (ae = xe.prop) === null || ae === void 0
										? void 0
										: ae.toLowerCase()
								}
								var p = new Set(['initial', 'inherit', 'unset', 'revert'])
								function f(me) {
									return p.has(me.toLowerCase())
								}
								function y(me, ae) {
									let xe = g(me, 'css-atrule')
									return (
										xe?.name &&
										xe.name.toLowerCase().endsWith('keyframes') &&
										['from', 'to'].includes(ae.toLowerCase())
									)
								}
								function x(me) {
									return me.includes('$') ||
										me.includes('@') ||
										me.includes('#') ||
										me.startsWith('%') ||
										me.startsWith('--') ||
										me.startsWith(':--') ||
										(me.includes('(') && me.includes(')'))
										? me
										: me.toLowerCase()
								}
								function _(me, ae) {
									var xe
									let Ce = g(me, 'value-func')
									return (
										(Ce == null || (xe = Ce.value) === null || xe === void 0
											? void 0
											: xe.toLowerCase()) === ae
									)
								}
								function w(me) {
									var ae
									let xe = g(me, 'css-rule'),
										Ce =
											xe == null || (ae = xe.raws) === null || ae === void 0 ? void 0 : ae.selector
									return Ce && (Ce.startsWith(':import') || Ce.startsWith(':export'))
								}
								function C(me, ae) {
									let xe = Array.isArray(ae) ? ae : [ae],
										Ce = g(me, 'css-atrule')
									return Ce && xe.includes(Ce.name.toLowerCase())
								}
								function v(me) {
									let ae = me.getValue(),
										xe = g(me, 'css-atrule')
									return (
										xe?.name === 'import' && ae.groups[0].value === 'url' && ae.groups.length === 2
									)
								}
								function b(me) {
									return me.type === 'value-func' && me.value.toLowerCase() === 'url'
								}
								function k(me, ae) {
									var xe
									let Ce = (xe = me.getParentNode()) === null || xe === void 0 ? void 0 : xe.nodes
									return Ce && Ce.indexOf(ae) === Ce.length - 1
								}
								function q(me) {
									let { selector: ae } = me
									return ae
										? (typeof ae == 'string' && /^@.+:.*$/.test(ae)) ||
												(ae.value && /^@.+:.*$/.test(ae.value))
										: !1
								}
								function G(me) {
									return me.type === 'value-word' && ['from', 'through', 'end'].includes(me.value)
								}
								function O(me) {
									return me.type === 'value-word' && ['and', 'or', 'not'].includes(me.value)
								}
								function U(me) {
									return me.type === 'value-word' && me.value === 'in'
								}
								function j(me) {
									return me.type === 'value-operator' && me.value === '*'
								}
								function H(me) {
									return me.type === 'value-operator' && me.value === '/'
								}
								function W(me) {
									return me.type === 'value-operator' && me.value === '+'
								}
								function re(me) {
									return me.type === 'value-operator' && me.value === '-'
								}
								function A(me) {
									return me.type === 'value-operator' && me.value === '%'
								}
								function $(me) {
									return j(me) || H(me) || W(me) || re(me) || A(me)
								}
								function T(me) {
									return me.type === 'value-word' && ['==', '!='].includes(me.value)
								}
								function R(me) {
									return me.type === 'value-word' && ['<', '>', '<=', '>='].includes(me.value)
								}
								function m(me) {
									return (
										me.type === 'css-atrule' &&
										['if', 'else', 'for', 'each', 'while'].includes(me.name)
									)
								}
								function S(me) {
									var ae
									return (
										((ae = me.raws) === null || ae === void 0 ? void 0 : ae.params) &&
										/^\(\s*\)$/.test(me.raws.params)
									)
								}
								function L(me) {
									return me.name.startsWith('prettier-placeholder')
								}
								function P(me) {
									return me.prop.startsWith('@prettier-placeholder')
								}
								function M(me, ae) {
									return (
										me.value === '$$' &&
										me.type === 'value-func' &&
										ae?.type === 'value-word' &&
										!ae.raws.before
									)
								}
								function V(me) {
									var ae, xe
									return (
										((ae = me.value) === null || ae === void 0 ? void 0 : ae.type) ===
											'value-root' &&
										((xe = me.value.group) === null || xe === void 0 ? void 0 : xe.type) ===
											'value-value' &&
										me.prop.toLowerCase() === 'composes'
									)
								}
								function J(me) {
									var ae, xe, Ce
									return (
										((ae = me.value) === null ||
										ae === void 0 ||
										(xe = ae.group) === null ||
										xe === void 0 ||
										(Ce = xe.group) === null ||
										Ce === void 0
											? void 0
											: Ce.type) === 'value-paren_group' &&
										me.value.group.group.open !== null &&
										me.value.group.group.close !== null
									)
								}
								function Z(me) {
									var ae
									return ((ae = me.raws) === null || ae === void 0 ? void 0 : ae.before) === ''
								}
								function ne(me) {
									var ae, xe
									return (
										me.type === 'value-comma_group' &&
										((ae = me.groups) === null ||
										ae === void 0 ||
										(xe = ae[1]) === null ||
										xe === void 0
											? void 0
											: xe.type) === 'value-colon'
									)
								}
								function ee(me) {
									var ae
									return (
										me.type === 'value-paren_group' &&
										((ae = me.groups) === null || ae === void 0 ? void 0 : ae[0]) &&
										ne(me.groups[0])
									)
								}
								function ce(me) {
									var ae
									let xe = me.getValue()
									if (xe.groups.length === 0) return !1
									let Ce = me.getParentNode(1)
									if (!ee(xe) && !(Ce && ee(Ce))) return !1
									let Ge = g(me, 'css-decl')
									return !!(
										(Ge != null &&
											(ae = Ge.prop) !== null &&
											ae !== void 0 &&
											ae.startsWith('$')) ||
										ee(Ce) ||
										Ce.type === 'value-func'
									)
								}
								function z(me) {
									return me.type === 'value-comment' && me.inline
								}
								function ye(me) {
									return me.type === 'value-word' && me.value === '#'
								}
								function te(me) {
									return me.type === 'value-word' && me.value === '{'
								}
								function X(me) {
									return me.type === 'value-word' && me.value === '}'
								}
								function De(me) {
									return ['value-word', 'value-atword'].includes(me.type)
								}
								function Fe(me) {
									return me?.type === 'value-colon'
								}
								function ve(me, ae) {
									if (!ne(ae)) return !1
									let { groups: xe } = ae,
										Ce = xe.indexOf(me)
									return Ce === -1 ? !1 : Fe(xe[Ce + 1])
								}
								function $e(me) {
									return me.value && ['not', 'and', 'or'].includes(me.value.toLowerCase())
								}
								function ie(me) {
									return me.type !== 'value-func' ? !1 : c.has(me.value.toLowerCase())
								}
								function fe(me) {
									return /\/\//.test(me.split(/[\n\r]/).pop())
								}
								function Be(me) {
									return me?.type === 'value-atword' && me.value.startsWith('prettier-placeholder-')
								}
								function Me(me, ae) {
									var xe, Ce
									if (
										((xe = me.open) === null || xe === void 0 ? void 0 : xe.value) !== '(' ||
										((Ce = me.close) === null || Ce === void 0 ? void 0 : Ce.value) !== ')' ||
										me.groups.some((Ge) => Ge.type !== 'value-comma_group')
									)
										return !1
									if (ae.type === 'value-comma_group') {
										let Ge = ae.groups.indexOf(me) - 1,
											nt = ae.groups[Ge]
										if (nt?.type === 'value-word' && nt.value === 'with') return !0
									}
									return !1
								}
								function Dt(me) {
									var ae, xe
									return (
										me.type === 'value-paren_group' &&
										((ae = me.open) === null || ae === void 0 ? void 0 : ae.value) === '(' &&
										((xe = me.close) === null || xe === void 0 ? void 0 : xe.value) === ')'
									)
								}
								E.exports = {
									getAncestorCounter: D,
									getAncestorNode: g,
									getPropOfDeclNode: l,
									maybeToLowerCase: x,
									insideValueFunctionNode: _,
									insideICSSRuleNode: w,
									insideAtRuleNode: C,
									insideURLFunctionInImportAtRuleNode: v,
									isKeyframeAtRuleKeywords: y,
									isWideKeywords: f,
									isLastNode: k,
									isSCSSControlDirectiveNode: m,
									isDetachedRulesetDeclarationNode: q,
									isRelationalOperatorNode: R,
									isEqualityOperatorNode: T,
									isMultiplicationNode: j,
									isDivisionNode: H,
									isAdditionNode: W,
									isSubtractionNode: re,
									isModuloNode: A,
									isMathOperatorNode: $,
									isEachKeywordNode: U,
									isForKeywordNode: G,
									isURLFunctionNode: b,
									isIfElseKeywordNode: O,
									hasComposesNode: V,
									hasParensAroundNode: J,
									hasEmptyRawBefore: Z,
									isDetachedRulesetCallNode: S,
									isTemplatePlaceholderNode: L,
									isTemplatePropNode: P,
									isPostcssSimpleVarNode: M,
									isKeyValuePairNode: ne,
									isKeyValuePairInParenGroupNode: ee,
									isKeyInValuePairNode: ve,
									isSCSSMapItemNode: ce,
									isInlineValueCommentNode: z,
									isHashNode: ye,
									isLeftCurlyBraceNode: te,
									isRightCurlyBraceNode: X,
									isWordNode: De,
									isColonNode: Fe,
									isMediaAndSupportsKeywords: $e,
									isColorAdjusterFuncNode: ie,
									lastLineHasInlineComment: fe,
									isAtWordPlaceholderNode: Be,
									isConfigurationNode: Me,
									isParenGroupNode: Dt
								}
							}
						}),
						eE = le({
							'src/utils/line-column-to-index.js'(d, E) {
								'use strict'
								ge(),
									(E.exports = function (c, D) {
										let g = 0
										for (let l = 0; l < c.line - 1; ++l)
											g =
												D.indexOf(
													`
`,
													g
												) + 1
										return g + c.column
									})
							}
						}),
						tE = le({
							'src/language-css/loc.js'(d, E) {
								'use strict'
								ge()
								var { skipEverythingButNewLine: c } = Vu(),
									D = Ur(),
									g = eE()
								function l(v, b) {
									return typeof v.sourceIndex == 'number'
										? v.sourceIndex
										: v.source
										? g(v.source.start, b) - 1
										: null
								}
								function p(v, b) {
									if (v.type === 'css-comment' && v.inline) return c(b, v.source.startOffset)
									let k = v.nodes && D(v.nodes)
									return (
										k && v.source && !v.source.end && (v = k),
										v.source && v.source.end ? g(v.source.end, b) : null
									)
								}
								function f(v, b) {
									v.source && ((v.source.startOffset = l(v, b)), (v.source.endOffset = p(v, b)))
									for (let k in v) {
										let q = v[k]
										k === 'source' ||
											!q ||
											typeof q != 'object' ||
											(q.type === 'value-root' || q.type === 'value-unknown'
												? y(q, x(v), q.text || q.value)
												: f(q, b))
									}
								}
								function y(v, b, k) {
									v.source &&
										((v.source.startOffset = l(v, k) + b), (v.source.endOffset = p(v, k) + b))
									for (let q in v) {
										let G = v[q]
										q === 'source' || !G || typeof G != 'object' || y(G, b, k)
									}
								}
								function x(v) {
									let b = v.source.startOffset
									return (
										typeof v.prop == 'string' && (b += v.prop.length),
										v.type === 'css-atrule' &&
											typeof v.name == 'string' &&
											(b += 1 + v.name.length + v.raws.afterName.match(/^\s*:?\s*/)[0].length),
										v.type !== 'css-atrule' &&
											v.raws &&
											typeof v.raws.between == 'string' &&
											(b += v.raws.between.length),
										b
									)
								}
								function _(v) {
									let b = 'initial',
										k = 'initial',
										q,
										G = !1,
										O = []
									for (let U = 0; U < v.length; U++) {
										let j = v[U]
										switch (b) {
											case 'initial':
												if (j === "'") {
													b = 'single-quotes'
													continue
												}
												if (j === '"') {
													b = 'double-quotes'
													continue
												}
												if (
													(j === 'u' || j === 'U') &&
													v.slice(U, U + 4).toLowerCase() === 'url('
												) {
													;(b = 'url'), (U += 3)
													continue
												}
												if (j === '*' && v[U - 1] === '/') {
													b = 'comment-block'
													continue
												}
												if (j === '/' && v[U - 1] === '/') {
													;(b = 'comment-inline'), (q = U - 1)
													continue
												}
												continue
											case 'single-quotes':
												if (
													(j === "'" && v[U - 1] !== '\\' && ((b = k), (k = 'initial')),
													j ===
														`
` || j === '\r')
												)
													return v
												continue
											case 'double-quotes':
												if (
													(j === '"' && v[U - 1] !== '\\' && ((b = k), (k = 'initial')),
													j ===
														`
` || j === '\r')
												)
													return v
												continue
											case 'url':
												if (
													(j === ')' && (b = 'initial'),
													j ===
														`
` || j === '\r')
												)
													return v
												if (j === "'") {
													;(b = 'single-quotes'), (k = 'url')
													continue
												}
												if (j === '"') {
													;(b = 'double-quotes'), (k = 'url')
													continue
												}
												continue
											case 'comment-block':
												j === '/' && v[U - 1] === '*' && (b = 'initial')
												continue
											case 'comment-inline':
												;(j === '"' || j === "'" || j === '*') && (G = !0),
													(j ===
														`
` ||
														j === '\r') &&
														(G && O.push([q, U]), (b = 'initial'), (G = !1))
												continue
										}
									}
									for (let [U, j] of O)
										v = v.slice(0, U) + v.slice(U, j).replace(/["'*]/g, ' ') + v.slice(j)
									return v
								}
								function w(v) {
									return v.source.startOffset
								}
								function C(v) {
									return v.source.endOffset
								}
								E.exports = {
									locStart: w,
									locEnd: C,
									calculateLoc: f,
									replaceQuotesInInlineComments: _
								}
							}
						}),
						nE = le({
							'src/language-css/utils/is-less-parser.js'(d, E) {
								'use strict'
								ge()
								function c(D) {
									return D.parser === 'css' || D.parser === 'less'
								}
								E.exports = c
							}
						}),
						rE = le({
							'src/language-css/utils/is-scss.js'(d, E) {
								'use strict'
								ge()
								function c(D, g) {
									return D === 'less' || D === 'scss'
										? D === 'scss'
										: /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(g)
								}
								E.exports = c
							}
						}),
						iE = le({
							'src/language-css/utils/css-units.evaluate.js'(d, E) {
								E.exports = {
									em: 'em',
									rem: 'rem',
									ex: 'ex',
									rex: 'rex',
									cap: 'cap',
									rcap: 'rcap',
									ch: 'ch',
									rch: 'rch',
									ic: 'ic',
									ric: 'ric',
									lh: 'lh',
									rlh: 'rlh',
									vw: 'vw',
									svw: 'svw',
									lvw: 'lvw',
									dvw: 'dvw',
									vh: 'vh',
									svh: 'svh',
									lvh: 'lvh',
									dvh: 'dvh',
									vi: 'vi',
									svi: 'svi',
									lvi: 'lvi',
									dvi: 'dvi',
									vb: 'vb',
									svb: 'svb',
									lvb: 'lvb',
									dvb: 'dvb',
									vmin: 'vmin',
									svmin: 'svmin',
									lvmin: 'lvmin',
									dvmin: 'dvmin',
									vmax: 'vmax',
									svmax: 'svmax',
									lvmax: 'lvmax',
									dvmax: 'dvmax',
									cm: 'cm',
									mm: 'mm',
									q: 'Q',
									in: 'in',
									pt: 'pt',
									pc: 'pc',
									px: 'px',
									deg: 'deg',
									grad: 'grad',
									rad: 'rad',
									turn: 'turn',
									s: 's',
									ms: 'ms',
									hz: 'Hz',
									khz: 'kHz',
									dpi: 'dpi',
									dpcm: 'dpcm',
									dppx: 'dppx',
									x: 'x'
								}
							}
						}),
						sE = le({
							'src/language-css/utils/print-unit.js'(d, E) {
								'use strict'
								ge()
								var c = iE()
								function D(g) {
									let l = g.toLowerCase()
									return Object.prototype.hasOwnProperty.call(c, l) ? c[l] : g
								}
								E.exports = D
							}
						}),
						oE = le({
							'src/language-css/printer-postcss.js'(d, E) {
								'use strict'
								ge()
								var c = Ur(),
									{
										printNumber: D,
										printString: g,
										hasNewline: l,
										isFrontMatterNode: p,
										isNextLineEmpty: f,
										isNonEmptyArray: y
									} = wn(),
									{
										builders: {
											join: x,
											line: _,
											hardline: w,
											softline: C,
											group: v,
											fill: b,
											indent: k,
											dedent: q,
											ifBreak: G,
											breakParent: O
										},
										utils: { removeLines: U, getDocParts: j }
									} = dn(),
									H = Yy(),
									W = Xy(),
									{ insertPragma: re } = Ky(),
									{
										getAncestorNode: A,
										getPropOfDeclNode: $,
										maybeToLowerCase: T,
										insideValueFunctionNode: R,
										insideICSSRuleNode: m,
										insideAtRuleNode: S,
										insideURLFunctionInImportAtRuleNode: L,
										isKeyframeAtRuleKeywords: P,
										isWideKeywords: M,
										isLastNode: V,
										isSCSSControlDirectiveNode: J,
										isDetachedRulesetDeclarationNode: Z,
										isRelationalOperatorNode: ne,
										isEqualityOperatorNode: ee,
										isMultiplicationNode: ce,
										isDivisionNode: z,
										isAdditionNode: ye,
										isSubtractionNode: te,
										isMathOperatorNode: X,
										isEachKeywordNode: De,
										isForKeywordNode: Fe,
										isURLFunctionNode: ve,
										isIfElseKeywordNode: $e,
										hasComposesNode: ie,
										hasParensAroundNode: fe,
										hasEmptyRawBefore: Be,
										isKeyValuePairNode: Me,
										isKeyInValuePairNode: Dt,
										isDetachedRulesetCallNode: me,
										isTemplatePlaceholderNode: ae,
										isTemplatePropNode: xe,
										isPostcssSimpleVarNode: Ce,
										isSCSSMapItemNode: Ge,
										isInlineValueCommentNode: nt,
										isHashNode: ot,
										isLeftCurlyBraceNode: Ut,
										isRightCurlyBraceNode: vn,
										isWordNode: Dn,
										isColonNode: Vt,
										isMediaAndSupportsKeywords: tn,
										isColorAdjusterFuncNode: Ie,
										lastLineHasInlineComment: se,
										isAtWordPlaceholderNode: je,
										isConfigurationNode: he,
										isParenGroupNode: Oe
									} = Zy(),
									{ locStart: wt, locEnd: mt } = tE(),
									Ue = nE(),
									B = rE(),
									pe = sE()
								function _e(Pt) {
									return Pt.trailingComma === 'es5' || Pt.trailingComma === 'all'
								}
								function st(Pt, mn, ln) {
									let ke = Pt.getValue()
									if (!ke) return ''
									if (typeof ke == 'string') return ke
									switch (ke.type) {
										case 'front-matter':
											return [ke.raw, w]
										case 'css-root': {
											let Sn = pt(Pt, mn, ln),
												_n = ke.raws.after.trim()
											return (
												_n.startsWith(';') && (_n = _n.slice(1).trim()),
												[Sn, _n ? ` ${_n}` : '', j(Sn).length > 0 ? w : '']
											)
										}
										case 'css-comment': {
											let Sn = ke.inline || ke.raws.inline,
												_n = mn.originalText.slice(wt(ke), mt(ke))
											return Sn ? _n.trimEnd() : _n
										}
										case 'css-rule':
											return [
												ln('selector'),
												ke.important ? ' !important' : '',
												ke.nodes
													? [
															ke.selector &&
															ke.selector.type === 'selector-unknown' &&
															se(ke.selector.value)
																? _
																: ' ',
															'{',
															ke.nodes.length > 0 ? k([w, pt(Pt, mn, ln)]) : '',
															w,
															'}',
															Z(ke) ? ';' : ''
													  ]
													: ';'
											]
										case 'css-decl': {
											let Sn = Pt.getParentNode(),
												{ between: _n } = ke.raws,
												Kn = _n.trim(),
												gi = Kn === ':',
												Y = ie(ke) ? U(ln('value')) : ln('value')
											return (
												!gi && se(Kn) && (Y = k([w, q(Y)])),
												[
													ke.raws.before.replace(/[\s;]/g, ''),
													(Sn.type === 'css-atrule' && Sn.variable) || m(Pt) ? ke.prop : T(ke.prop),
													Kn.startsWith('//') ? ' ' : '',
													Kn,
													ke.extend ? '' : ' ',
													Ue(mn) && ke.extend && ke.selector
														? ['extend(', ln('selector'), ')']
														: '',
													Y,
													ke.raws.important
														? ke.raws.important.replace(/\s*!\s*important/i, ' !important')
														: ke.important
														? ' !important'
														: '',
													ke.raws.scssDefault
														? ke.raws.scssDefault.replace(/\s*!default/i, ' !default')
														: ke.scssDefault
														? ' !default'
														: '',
													ke.raws.scssGlobal
														? ke.raws.scssGlobal.replace(/\s*!global/i, ' !global')
														: ke.scssGlobal
														? ' !global'
														: '',
													ke.nodes
														? [' {', k([C, pt(Pt, mn, ln)]), C, '}']
														: xe(ke) && !Sn.raws.semicolon && mn.originalText[mt(ke) - 1] !== ';'
														? ''
														: mn.__isHTMLStyleAttribute && V(Pt, ke)
														? G(';')
														: ';'
												]
											)
										}
										case 'css-atrule': {
											let Sn = Pt.getParentNode(),
												_n = ae(ke) && !Sn.raws.semicolon && mn.originalText[mt(ke) - 1] !== ';'
											if (Ue(mn)) {
												if (ke.mixin)
													return [ln('selector'), ke.important ? ' !important' : '', _n ? '' : ';']
												if (ke.function) return [ke.name, ln('params'), _n ? '' : ';']
												if (ke.variable)
													return [
														'@',
														ke.name,
														': ',
														ke.value ? ln('value') : '',
														ke.raws.between.trim() ? ke.raws.between.trim() + ' ' : '',
														ke.nodes
															? ['{', k([ke.nodes.length > 0 ? C : '', pt(Pt, mn, ln)]), C, '}']
															: '',
														_n ? '' : ';'
													]
											}
											return [
												'@',
												me(ke) || ke.name.endsWith(':') ? ke.name : T(ke.name),
												ke.params
													? [
															me(ke)
																? ''
																: ae(ke)
																? ke.raws.afterName === ''
																	? ''
																	: ke.name.endsWith(':')
																	? ' '
																	: /^\s*\n\s*\n/.test(ke.raws.afterName)
																	? [w, w]
																	: /^\s*\n/.test(ke.raws.afterName)
																	? w
																	: ' '
																: ' ',
															ln('params')
													  ]
													: '',
												ke.selector ? k([' ', ln('selector')]) : '',
												ke.value
													? v([' ', ln('value'), J(ke) ? (fe(ke) ? ' ' : _) : ''])
													: ke.name === 'else'
													? ' '
													: '',
												ke.nodes
													? [
															J(ke)
																? ''
																: (ke.selector &&
																		!ke.selector.nodes &&
																		typeof ke.selector.value == 'string' &&
																		se(ke.selector.value)) ||
																  (!ke.selector && typeof ke.params == 'string' && se(ke.params))
																? _
																: ' ',
															'{',
															k([ke.nodes.length > 0 ? C : '', pt(Pt, mn, ln)]),
															C,
															'}'
													  ]
													: _n
													? ''
													: ';'
											]
										}
										case 'media-query-list': {
											let Sn = []
											return (
												Pt.each((_n) => {
													let Kn = _n.getValue()
													;(Kn.type === 'media-query' && Kn.value === '') || Sn.push(ln())
												}, 'nodes'),
												v(k(x(_, Sn)))
											)
										}
										case 'media-query':
											return [x(' ', Pt.map(ln, 'nodes')), V(Pt, ke) ? '' : ',']
										case 'media-type':
											return yn(It(ke.value, mn))
										case 'media-feature-expression':
											return ke.nodes ? ['(', ...Pt.map(ln, 'nodes'), ')'] : ke.value
										case 'media-feature':
											return T(It(ke.value.replace(/ +/g, ' '), mn))
										case 'media-colon':
											return [ke.value, ' ']
										case 'media-value':
											return yn(It(ke.value, mn))
										case 'media-keyword':
											return It(ke.value, mn)
										case 'media-url':
											return It(ke.value.replace(/^url\(\s+/gi, 'url(').replace(/\s+\)$/g, ')'), mn)
										case 'media-unknown':
											return ke.value
										case 'selector-root':
											return v([
												S(Pt, 'custom-selector') ? [A(Pt, 'css-atrule').customSelector, _] : '',
												x(
													[',', S(Pt, ['extend', 'custom-selector', 'nest']) ? _ : w],
													Pt.map(ln, 'nodes')
												)
											])
										case 'selector-selector':
											return v(k(Pt.map(ln, 'nodes')))
										case 'selector-comment':
											return ke.value
										case 'selector-string':
											return It(ke.value, mn)
										case 'selector-tag': {
											let Sn = Pt.getParentNode(),
												_n = Sn && Sn.nodes.indexOf(ke),
												Kn = _n && Sn.nodes[_n - 1]
											return [
												ke.namespace ? [ke.namespace === !0 ? '' : ke.namespace.trim(), '|'] : '',
												Kn.type === 'selector-nesting'
													? ke.value
													: yn(P(Pt, ke.value) ? ke.value.toLowerCase() : ke.value)
											]
										}
										case 'selector-id':
											return ['#', ke.value]
										case 'selector-class':
											return ['.', yn(It(ke.value, mn))]
										case 'selector-attribute': {
											var mi
											return [
												'[',
												ke.namespace ? [ke.namespace === !0 ? '' : ke.namespace.trim(), '|'] : '',
												ke.attribute.trim(),
												(mi = ke.operator) !== null && mi !== void 0 ? mi : '',
												ke.value ? an(It(ke.value.trim(), mn), mn) : '',
												ke.insensitive ? ' i' : '',
												']'
											]
										}
										case 'selector-combinator': {
											if (
												ke.value === '+' ||
												ke.value === '>' ||
												ke.value === '~' ||
												ke.value === '>>>'
											) {
												let Kn = Pt.getParentNode()
												return [
													Kn.type === 'selector-selector' && Kn.nodes[0] === ke ? '' : _,
													ke.value,
													V(Pt, ke) ? '' : ' '
												]
											}
											let Sn = ke.value.trim().startsWith('(') ? _ : '',
												_n = yn(It(ke.value.trim(), mn)) || _
											return [Sn, _n]
										}
										case 'selector-universal':
											return [
												ke.namespace ? [ke.namespace === !0 ? '' : ke.namespace.trim(), '|'] : '',
												ke.value
											]
										case 'selector-pseudo':
											return [
												T(ke.value),
												y(ke.nodes)
													? v(['(', k([C, x([',', _], Pt.map(ln, 'nodes'))]), C, ')'])
													: ''
											]
										case 'selector-nesting':
											return ke.value
										case 'selector-unknown': {
											let Sn = A(Pt, 'css-rule')
											if (Sn && Sn.isSCSSNesterProperty) return yn(It(T(ke.value), mn))
											let _n = Pt.getParentNode()
											if (_n.raws && _n.raws.selector) {
												let gi = wt(_n),
													Y = gi + _n.raws.selector.length
												return mn.originalText.slice(gi, Y).trim()
											}
											let Kn = Pt.getParentNode(1)
											if (
												_n.type === 'value-paren_group' &&
												Kn &&
												Kn.type === 'value-func' &&
												Kn.value === 'selector'
											) {
												let gi = mt(_n.open) + 1,
													Y = wt(_n.close),
													We = mn.originalText.slice(gi, Y).trim()
												return se(We) ? [O, We] : We
											}
											return ke.value
										}
										case 'value-value':
										case 'value-root':
											return ln('group')
										case 'value-comment':
											return mn.originalText.slice(wt(ke), mt(ke))
										case 'value-comma_group': {
											let Sn = Pt.getParentNode(),
												_n = Pt.getParentNode(1),
												Kn = $(Pt),
												gi =
													Kn &&
													Sn.type === 'value-value' &&
													(Kn === 'grid' || Kn.startsWith('grid-template')),
												Y = A(Pt, 'css-atrule'),
												We = Y && J(Y),
												Zt = ke.groups.some((Di) => nt(Di)),
												Ln = Pt.map(ln, 'groups'),
												In = [],
												oi = R(Pt, 'url'),
												pr = !1,
												Wr = !1
											for (let Di = 0; Di < ke.groups.length; ++Di) {
												var qr
												In.push(Ln[Di])
												let Nr = ke.groups[Di - 1],
													cn = ke.groups[Di],
													Tn = ke.groups[Di + 1],
													Zu = ke.groups[Di + 2]
												if (oi) {
													;((Tn && ye(Tn)) || ye(cn)) && In.push(' ')
													continue
												}
												if (
													(S(Pt, 'forward') &&
														cn.type === 'value-word' &&
														cn.value &&
														Nr !== void 0 &&
														Nr.type === 'value-word' &&
														Nr.value === 'as' &&
														Tn.type === 'value-operator' &&
														Tn.value === '*') ||
													!Tn ||
													(cn.type === 'value-word' && cn.value.endsWith('-') && je(Tn))
												)
													continue
												if (cn.type === 'value-string' && cn.quoted) {
													let Cp = cn.value.lastIndexOf('#{'),
														Sp = cn.value.lastIndexOf('}')
													Cp !== -1 && Sp !== -1
														? (pr = Cp > Sp)
														: Cp !== -1
														? (pr = !0)
														: Sp !== -1 && (pr = !1)
												}
												if (
													pr ||
													Vt(cn) ||
													Vt(Tn) ||
													(cn.type === 'value-atword' &&
														(cn.value === '' || cn.value.endsWith('['))) ||
													(Tn.type === 'value-word' && Tn.value.startsWith(']')) ||
													cn.value === '~' ||
													(cn.value &&
														cn.value.includes('\\') &&
														Tn &&
														Tn.type !== 'value-comment') ||
													(Nr &&
														Nr.value &&
														Nr.value.indexOf('\\') === Nr.value.length - 1 &&
														cn.type === 'value-operator' &&
														cn.value === '/') ||
													cn.value === '\\' ||
													Ce(cn, Tn) ||
													ot(cn) ||
													Ut(cn) ||
													vn(Tn) ||
													(Ut(Tn) && Be(Tn)) ||
													(vn(cn) && Be(Tn)) ||
													(cn.value === '--' && ot(Tn))
												)
													continue
												let Ap = X(cn),
													o0 = X(Tn)
												if (
													(((Ap && ot(Tn)) || (o0 && vn(cn))) && Be(Tn)) ||
													(!Nr && z(cn)) ||
													(R(Pt, 'calc') && (ye(cn) || ye(Tn) || te(cn) || te(Tn)) && Be(Tn))
												)
													continue
												let x4 =
														(ye(cn) || te(cn)) &&
														Di === 0 &&
														(Tn.type === 'value-number' || Tn.isHex) &&
														_n &&
														Ie(_n) &&
														!Be(Tn),
													a0 =
														(Zu && Zu.type === 'value-func') ||
														(Zu && Dn(Zu)) ||
														cn.type === 'value-func' ||
														Dn(cn),
													u0 =
														Tn.type === 'value-func' ||
														Dn(Tn) ||
														(Nr && Nr.type === 'value-func') ||
														(Nr && Dn(Nr))
												if (
													!(
														!(ce(Tn) || ce(cn)) &&
														!R(Pt, 'calc') &&
														!x4 &&
														((z(Tn) && !a0) ||
															(z(cn) && !u0) ||
															(ye(Tn) && !a0) ||
															(ye(cn) && !u0) ||
															te(Tn) ||
															te(cn)) &&
														(Be(Tn) || (Ap && (!Nr || (Nr && X(Nr)))))
													) &&
													!(
														(mn.parser === 'scss' || mn.parser === 'less') &&
														Ap &&
														cn.value === '-' &&
														Oe(Tn) &&
														mt(cn) === wt(Tn.open) &&
														Tn.open.value === '('
													)
												) {
													if (nt(cn)) {
														if (Sn.type === 'value-paren_group') {
															In.push(q(w))
															continue
														}
														In.push(w)
														continue
													}
													if (We && (ee(Tn) || ne(Tn) || $e(Tn) || De(cn) || Fe(cn))) {
														In.push(' ')
														continue
													}
													if (Y && Y.name.toLowerCase() === 'namespace') {
														In.push(' ')
														continue
													}
													if (gi) {
														cn.source && Tn.source && cn.source.start.line !== Tn.source.start.line
															? (In.push(w), (Wr = !0))
															: In.push(' ')
														continue
													}
													if (o0) {
														In.push(' ')
														continue
													}
													if (
														!(Tn && Tn.value === '...') &&
														!(je(cn) && je(Tn) && mt(cn) === wt(Tn))
													) {
														if (je(cn) && Oe(Tn) && mt(cn) === wt(Tn.open)) {
															In.push(C)
															continue
														}
														if (cn.value === 'with' && Oe(Tn)) {
															In.push(' ')
															continue
														}
														;((qr = cn.value) !== null &&
															qr !== void 0 &&
															qr.endsWith('#') &&
															Tn.value === '{' &&
															Oe(Tn.group)) ||
															In.push(_)
													}
												}
											}
											return (
												Zt && In.push(O),
												Wr && In.unshift(w),
												We ? v(k(In)) : L(Pt) ? v(b(In)) : v(k(b(In)))
											)
										}
										case 'value-paren_group': {
											let Sn = Pt.getParentNode()
											if (
												Sn &&
												ve(Sn) &&
												(ke.groups.length === 1 ||
													(ke.groups.length > 0 &&
														ke.groups[0].type === 'value-comma_group' &&
														ke.groups[0].groups.length > 0 &&
														ke.groups[0].groups[0].type === 'value-word' &&
														ke.groups[0].groups[0].value.startsWith('data:')))
											)
												return [
													ke.open ? ln('open') : '',
													x(',', Pt.map(ln, 'groups')),
													ke.close ? ln('close') : ''
												]
											if (!ke.open) {
												let oi = Pt.map(ln, 'groups'),
													pr = []
												for (let Wr = 0; Wr < oi.length; Wr++)
													Wr !== 0 && pr.push([',', _]), pr.push(oi[Wr])
												return v(k(b(pr)))
											}
											let _n = Ge(Pt),
												Kn = c(ke.groups),
												gi = Kn && Kn.type === 'value-comment',
												Y = Dt(ke, Sn),
												We = he(ke, Sn),
												Zt = We || (_n && !Y),
												Ln = We || Y,
												In = v(
													[
														ke.open ? ln('open') : '',
														k([
															C,
															x(
																[_],
																Pt.map((oi, pr) => {
																	let Wr = oi.getValue(),
																		Di = pr === ke.groups.length - 1,
																		Nr = [ln(), Di ? '' : ',']
																	if (
																		Me(Wr) &&
																		Wr.type === 'value-comma_group' &&
																		Wr.groups &&
																		Wr.groups[0].type !== 'value-paren_group' &&
																		Wr.groups[2] &&
																		Wr.groups[2].type === 'value-paren_group'
																	) {
																		let cn = j(Nr[0].contents.contents)
																		;(cn[1] = v(cn[1])), (Nr = [v(q(Nr))])
																	}
																	if (!Di && Wr.type === 'value-comma_group' && y(Wr.groups)) {
																		let cn = c(Wr.groups)
																		!cn.source && cn.close && (cn = cn.close),
																			cn.source && f(mn.originalText, cn, mt) && Nr.push(w)
																	}
																	return Nr
																}, 'groups')
															)
														]),
														G(!gi && B(mn.parser, mn.originalText) && _n && _e(mn) ? ',' : ''),
														C,
														ke.close ? ln('close') : ''
													],
													{ shouldBreak: Zt }
												)
											return Ln ? q(In) : In
										}
										case 'value-func':
											return [ke.value, S(Pt, 'supports') && tn(ke) ? ' ' : '', ln('group')]
										case 'value-paren':
											return ke.value
										case 'value-number':
											return [Qn(ke.value), pe(ke.unit)]
										case 'value-operator':
											return ke.value
										case 'value-word':
											return (ke.isColor && ke.isHex) || M(ke.value)
												? ke.value.toLowerCase()
												: ke.value
										case 'value-colon': {
											let Sn = Pt.getParentNode(),
												_n = Sn && Sn.groups.indexOf(ke),
												Kn = _n && Sn.groups[_n - 1]
											return [
												ke.value,
												(Kn && typeof Kn.value == 'string' && c(Kn.value) === '\\') || R(Pt, 'url')
													? ''
													: _
											]
										}
										case 'value-comma':
											return [ke.value, ' ']
										case 'value-string':
											return g(ke.raws.quote + ke.value + ke.raws.quote, mn)
										case 'value-atword':
											return ['@', ke.value]
										case 'value-unicode-range':
											return ke.value
										case 'value-unknown':
											return ke.value
										default:
											throw new Error(`Unknown postcss type ${JSON.stringify(ke.type)}`)
									}
								}
								function pt(Pt, mn, ln) {
									let ke = []
									return (
										Pt.each((mi, qr, Sn) => {
											let _n = Sn[qr - 1]
											if (_n && _n.type === 'css-comment' && _n.text.trim() === 'prettier-ignore') {
												let Kn = mi.getValue()
												ke.push(mn.originalText.slice(wt(Kn), mt(Kn)))
											} else ke.push(ln())
											qr !== Sn.length - 1 &&
												((Sn[qr + 1].type === 'css-comment' &&
													!l(mn.originalText, wt(Sn[qr + 1]), { backwards: !0 }) &&
													!p(Sn[qr])) ||
												(Sn[qr + 1].type === 'css-atrule' &&
													Sn[qr + 1].name === 'else' &&
													Sn[qr].type !== 'css-comment')
													? ke.push(' ')
													: (ke.push(mn.__isHTMLStyleAttribute ? _ : w),
													  f(mn.originalText, mi.getValue(), mt) && !p(Sn[qr]) && ke.push(w)))
										}, 'nodes'),
										ke
									)
								}
								var jt = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs,
									at = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g,
									ar = /[A-Za-z]+/g,
									Rt = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g,
									ir = new RegExp(jt.source + `|(${Rt.source})?(${at.source})(${ar.source})?`, 'g')
								function It(Pt, mn) {
									return Pt.replace(jt, (ln) => g(ln, mn))
								}
								function an(Pt, mn) {
									let ln = mn.singleQuote ? "'" : '"'
									return Pt.includes('"') || Pt.includes("'") ? Pt : ln + Pt + ln
								}
								function yn(Pt) {
									return Pt.replace(ir, (mn, ln, ke, mi, qr) =>
										!ke && mi ? Qn(mi) + T(qr || '') : mn
									)
								}
								function Qn(Pt) {
									return D(Pt).replace(/\.0(?=$|e)/, '')
								}
								E.exports = { print: st, embed: W, insertPragma: re, massageAstNode: H }
							}
						}),
						aE = le({
							'src/language-css/options.js'(d, E) {
								'use strict'
								ge()
								var c = xo()
								E.exports = { singleQuote: c.singleQuote }
							}
						}),
						uE = le({
							'src/language-css/parsers.js'() {
								ge()
							}
						}),
						lE = le({
							'node_modules/linguist-languages/data/CSS.json'(d, E) {
								E.exports = {
									name: 'CSS',
									type: 'markup',
									tmScope: 'source.css',
									aceMode: 'css',
									codemirrorMode: 'css',
									codemirrorMimeType: 'text/css',
									color: '#563d7c',
									extensions: ['.css'],
									languageId: 50
								}
							}
						}),
						cE = le({
							'node_modules/linguist-languages/data/PostCSS.json'(d, E) {
								E.exports = {
									name: 'PostCSS',
									type: 'markup',
									color: '#dc3a0c',
									tmScope: 'source.postcss',
									group: 'CSS',
									extensions: ['.pcss', '.postcss'],
									aceMode: 'text',
									languageId: 262764437
								}
							}
						}),
						pE = le({
							'node_modules/linguist-languages/data/Less.json'(d, E) {
								E.exports = {
									name: 'Less',
									type: 'markup',
									color: '#1d365d',
									aliases: ['less-css'],
									extensions: ['.less'],
									tmScope: 'source.css.less',
									aceMode: 'less',
									codemirrorMode: 'css',
									codemirrorMimeType: 'text/css',
									languageId: 198
								}
							}
						}),
						fE = le({
							'node_modules/linguist-languages/data/SCSS.json'(d, E) {
								E.exports = {
									name: 'SCSS',
									type: 'markup',
									color: '#c6538c',
									tmScope: 'source.css.scss',
									aceMode: 'scss',
									codemirrorMode: 'css',
									codemirrorMimeType: 'text/x-scss',
									extensions: ['.scss'],
									languageId: 329
								}
							}
						}),
						dE = le({
							'src/language-css/index.js'(d, E) {
								'use strict'
								ge()
								var c = Ms(),
									D = oE(),
									g = aE(),
									l = uE(),
									p = [
										c(lE(), (y) => ({
											since: '1.4.0',
											parsers: ['css'],
											vscodeLanguageIds: ['css'],
											extensions: [...y.extensions, '.wxss']
										})),
										c(cE(), () => ({
											since: '1.4.0',
											parsers: ['css'],
											vscodeLanguageIds: ['postcss']
										})),
										c(pE(), () => ({
											since: '1.4.0',
											parsers: ['less'],
											vscodeLanguageIds: ['less']
										})),
										c(fE(), () => ({
											since: '1.4.0',
											parsers: ['scss'],
											vscodeLanguageIds: ['scss']
										}))
									],
									f = { postcss: D }
								E.exports = { languages: p, options: g, printers: f, parsers: l }
							}
						}),
						hE = le({
							'src/language-handlebars/loc.js'(d, E) {
								'use strict'
								ge()
								function c(g) {
									return g.loc.start.offset
								}
								function D(g) {
									return g.loc.end.offset
								}
								E.exports = { locStart: c, locEnd: D }
							}
						}),
						mE = le({
							'src/language-handlebars/clean.js'(d, E) {
								'use strict'
								ge()
								function c(D, g) {
									if (D.type === 'TextNode') {
										let l = D.chars.trim()
										if (!l) return null
										g.chars = l.replace(/[\t\n\f\r ]+/g, ' ')
									}
									D.type === 'AttrNode' && D.name.toLowerCase() === 'class' && delete g.value
								}
								;(c.ignoredProperties = new Set(['loc', 'selfClosing'])), (E.exports = c)
							}
						}),
						gE = le({
							'src/language-handlebars/html-void-elements.evaluate.js'(d, E) {
								E.exports = [
									'area',
									'base',
									'br',
									'col',
									'command',
									'embed',
									'hr',
									'img',
									'input',
									'keygen',
									'link',
									'meta',
									'param',
									'source',
									'track',
									'wbr'
								]
							}
						}),
						DE = le({
							'src/language-handlebars/utils.js'(d, E) {
								'use strict'
								ge()
								var c = Ur(),
									D = gE()
								function g(j) {
									let H = j.getValue(),
										W = j.getParentNode(0)
									return !!(
										(C(j, ['ElementNode']) && c(W.children) === H) ||
										(C(j, ['Block']) && c(W.body) === H)
									)
								}
								function l(j) {
									return j.toUpperCase() === j
								}
								function p(j) {
									return (
										w(j, ['ElementNode']) &&
										typeof j.tag == 'string' &&
										!j.tag.startsWith(':') &&
										(l(j.tag[0]) || j.tag.includes('.'))
									)
								}
								var f = new Set(D)
								function y(j) {
									return f.has(j.toLowerCase()) && !l(j[0])
								}
								function x(j) {
									return j.selfClosing === !0 || y(j.tag) || (p(j) && j.children.every((H) => _(H)))
								}
								function _(j) {
									return w(j, ['TextNode']) && !/\S/.test(j.chars)
								}
								function w(j, H) {
									return j && H.includes(j.type)
								}
								function C(j, H) {
									let W = j.getParentNode(0)
									return w(W, H)
								}
								function v(j, H) {
									let W = q(j)
									return w(W, H)
								}
								function b(j, H) {
									let W = G(j)
									return w(W, H)
								}
								function k(j, H) {
									var W, re, A, $
									let T = j.getValue(),
										R = (W = j.getParentNode(0)) !== null && W !== void 0 ? W : {},
										m =
											(re =
												(A = ($ = R.children) !== null && $ !== void 0 ? $ : R.body) !== null &&
												A !== void 0
													? A
													: R.parts) !== null && re !== void 0
												? re
												: [],
										S = m.indexOf(T)
									return S !== -1 && m[S + H]
								}
								function q(j) {
									let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1
									return k(j, -H)
								}
								function G(j) {
									return k(j, 1)
								}
								function O(j) {
									return (
										w(j, ['MustacheCommentStatement']) &&
										typeof j.value == 'string' &&
										j.value.trim() === 'prettier-ignore'
									)
								}
								function U(j) {
									let H = j.getValue(),
										W = q(j, 2)
									return O(H) || O(W)
								}
								E.exports = {
									getNextNode: G,
									getPreviousNode: q,
									hasPrettierIgnore: U,
									isLastNodeOfSiblings: g,
									isNextNodeOfSomeType: b,
									isNodeOfSomeType: w,
									isParentOfSomeType: C,
									isPreviousNodeOfSomeType: v,
									isVoid: x,
									isWhitespaceNode: _
								}
							}
						}),
						yE = le({
							'src/language-handlebars/printer-glimmer.js'(d, E) {
								'use strict'
								ge()
								var {
										builders: {
											dedent: c,
											fill: D,
											group: g,
											hardline: l,
											ifBreak: p,
											indent: f,
											join: y,
											line: x,
											softline: _
										},
										utils: { getDocParts: w, replaceTextEndOfLine: C }
									} = dn(),
									{ getPreferredQuote: v, isNonEmptyArray: b } = wn(),
									{ locStart: k, locEnd: q } = hE(),
									G = mE(),
									{
										getNextNode: O,
										getPreviousNode: U,
										hasPrettierIgnore: j,
										isLastNodeOfSiblings: H,
										isNextNodeOfSomeType: W,
										isNodeOfSomeType: re,
										isParentOfSomeType: A,
										isPreviousNodeOfSomeType: $,
										isVoid: T,
										isWhitespaceNode: R
									} = DE(),
									m = 2
								function S(se, je, he) {
									let Oe = se.getValue()
									if (!Oe) return ''
									if (j(se)) return je.originalText.slice(k(Oe), q(Oe))
									let wt = je.singleQuote ? "'" : '"'
									switch (Oe.type) {
										case 'Block':
										case 'Program':
										case 'Template':
											return g(se.map(he, 'body'))
										case 'ElementNode': {
											let mt = g(P(se, he)),
												Ue =
													je.htmlWhitespaceSensitivity === 'ignore' && W(se, ['ElementNode'])
														? _
														: ''
											if (T(Oe)) return [mt, Ue]
											let B = ['</', Oe.tag, '>']
											return Oe.children.length === 0
												? [mt, f(B), Ue]
												: je.htmlWhitespaceSensitivity === 'ignore'
												? [mt, f(M(se, je, he)), l, f(B), Ue]
												: [mt, f(g(M(se, je, he))), f(B), Ue]
										}
										case 'BlockStatement': {
											let mt = se.getParentNode(1)
											return mt &&
												mt.inverse &&
												mt.inverse.body.length === 1 &&
												mt.inverse.body[0] === Oe &&
												mt.inverse.body[0].path.parts[0] === mt.path.parts[0]
												? [
														Fe(se, he, mt.inverse.body[0].path.parts[0]),
														Be(se, he, je),
														Me(se, he, je)
												  ]
												: [X(se, he), g([Be(se, he, je), Me(se, he, je), ve(se, he, je)])]
										}
										case 'ElementModifierStatement':
											return g(['{{', Dn(se, he), '}}'])
										case 'MustacheStatement':
											return g([J(Oe), Dn(se, he), Z(Oe)])
										case 'SubExpression':
											return g(['(', vn(se, he), _, ')'])
										case 'AttrNode': {
											let mt = Oe.value.type === 'TextNode'
											if (mt && Oe.value.chars === '' && k(Oe.value) === q(Oe.value)) return Oe.name
											let Ue = mt
													? v(Oe.value.chars, wt).quote
													: Oe.value.type === 'ConcatStatement'
													? v(
															Oe.value.parts
																.filter((pe) => pe.type === 'TextNode')
																.map((pe) => pe.chars)
																.join(''),
															wt
													  ).quote
													: '',
												B = he('value')
											return [Oe.name, '=', Ue, Oe.name === 'class' && Ue ? g(f(B)) : B, Ue]
										}
										case 'ConcatStatement':
											return se.map(he, 'parts')
										case 'Hash':
											return y(x, se.map(he, 'pairs'))
										case 'HashPair':
											return [Oe.key, '=', he('value')]
										case 'TextNode': {
											let mt = Oe.chars.replace(/{{/g, '\\{{'),
												Ue = ae(se)
											if (Ue) {
												if (Ue === 'class') {
													let Rt = mt.trim().split(/\s+/).join(' '),
														ir = !1,
														It = !1
													return (
														A(se, ['ConcatStatement']) &&
															($(se, ['MustacheStatement']) && /^\s/.test(mt) && (ir = !0),
															W(se, ['MustacheStatement']) &&
																/\s$/.test(mt) &&
																Rt !== '' &&
																(It = !0)),
														[ir ? x : '', Rt, It ? x : '']
													)
												}
												return C(mt)
											}
											let B = /^[\t\n\f\r ]*$/.test(mt),
												pe = !U(se),
												_e = !O(se)
											if (je.htmlWhitespaceSensitivity !== 'ignore') {
												let Rt = /^[\t\n\f\r ]*/,
													ir = /[\t\n\f\r ]*$/,
													It = _e && A(se, ['Template']),
													an = pe && A(se, ['Template'])
												if (B) {
													if (an || It) return ''
													let ln = [x],
														ke = xe(mt)
													return ke && (ln = nt(ke)), H(se) && (ln = ln.map((mi) => c(mi))), ln
												}
												let [yn] = mt.match(Rt),
													[Qn] = mt.match(ir),
													Pt = []
												if (yn) {
													Pt = [x]
													let ln = xe(yn)
													ln && (Pt = nt(ln)), (mt = mt.replace(Rt, ''))
												}
												let mn = []
												if (Qn) {
													if (!It) {
														mn = [x]
														let ln = xe(Qn)
														ln && (mn = nt(ln)), H(se) && (mn = mn.map((ke) => c(ke)))
													}
													mt = mt.replace(ir, '')
												}
												return [...Pt, D(Dt(mt)), ...mn]
											}
											let st = xe(mt),
												pt = Ce(mt),
												jt = Ge(mt)
											if ((pe || _e) && B && A(se, ['Block', 'ElementNode', 'Template'])) return ''
											B && st
												? ((pt = Math.min(st, m)), (jt = 0))
												: (W(se, ['BlockStatement', 'ElementNode']) && (jt = Math.max(jt, 1)),
												  $(se, ['BlockStatement', 'ElementNode']) && (pt = Math.max(pt, 1)))
											let at = '',
												ar = ''
											return (
												jt === 0 && W(se, ['MustacheStatement']) && (ar = ' '),
												pt === 0 && $(se, ['MustacheStatement']) && (at = ' '),
												pe && ((pt = 0), (at = '')),
												_e && ((jt = 0), (ar = '')),
												(mt = mt.replace(/^[\t\n\f\r ]+/g, at).replace(/[\t\n\f\r ]+$/, ar)),
												[...nt(pt), D(Dt(mt)), ...nt(jt)]
											)
										}
										case 'MustacheCommentStatement': {
											let mt = k(Oe),
												Ue = q(Oe),
												B = je.originalText.charAt(mt + 2) === '~',
												pe = je.originalText.charAt(Ue - 3) === '~',
												_e = Oe.value.includes('}}') ? '--' : ''
											return ['{{', B ? '~' : '', '!', _e, Oe.value, _e, pe ? '~' : '', '}}']
										}
										case 'PathExpression':
											return Oe.original
										case 'BooleanLiteral':
											return String(Oe.value)
										case 'CommentStatement':
											return ['<!--', Oe.value, '-->']
										case 'StringLiteral': {
											if (Ut(se)) {
												let mt = je.singleQuote ? '"' : "'"
												return ot(Oe.value, mt)
											}
											return ot(Oe.value, wt)
										}
										case 'NumberLiteral':
											return String(Oe.value)
										case 'UndefinedLiteral':
											return 'undefined'
										case 'NullLiteral':
											return 'null'
										default:
											throw new Error('unknown glimmer type: ' + JSON.stringify(Oe.type))
									}
								}
								function L(se, je) {
									return k(se) - k(je)
								}
								function P(se, je) {
									let he = se.getValue(),
										Oe = ['attributes', 'modifiers', 'comments'].filter((mt) => b(he[mt])),
										wt = Oe.flatMap((mt) => he[mt]).sort(L)
									for (let mt of Oe)
										se.each((Ue) => {
											let B = wt.indexOf(Ue.getValue())
											wt.splice(B, 1, [x, je()])
										}, mt)
									return b(he.blockParams) && wt.push(x, Ie(he)), ['<', he.tag, f(wt), V(he)]
								}
								function M(se, je, he) {
									let Oe = se.getValue().children.every((wt) => R(wt))
									return je.htmlWhitespaceSensitivity === 'ignore' && Oe
										? ''
										: se.map((wt, mt) => {
												let Ue = he()
												return mt === 0 && je.htmlWhitespaceSensitivity === 'ignore' ? [_, Ue] : Ue
										  }, 'children')
								}
								function V(se) {
									return T(se) ? p([_, '/>'], [' />', _]) : p([_, '>'], '>')
								}
								function J(se) {
									let je = se.escaped === !1 ? '{{{' : '{{',
										he = se.strip && se.strip.open ? '~' : ''
									return [je, he]
								}
								function Z(se) {
									let je = se.escaped === !1 ? '}}}' : '}}'
									return [se.strip && se.strip.close ? '~' : '', je]
								}
								function ne(se) {
									let je = J(se),
										he = se.openStrip.open ? '~' : ''
									return [je, he, '#']
								}
								function ee(se) {
									let je = Z(se)
									return [se.openStrip.close ? '~' : '', je]
								}
								function ce(se) {
									let je = J(se),
										he = se.closeStrip.open ? '~' : ''
									return [je, he, '/']
								}
								function z(se) {
									let je = Z(se)
									return [se.closeStrip.close ? '~' : '', je]
								}
								function ye(se) {
									let je = J(se),
										he = se.inverseStrip.open ? '~' : ''
									return [je, he]
								}
								function te(se) {
									let je = Z(se)
									return [se.inverseStrip.close ? '~' : '', je]
								}
								function X(se, je) {
									let he = se.getValue(),
										Oe = [],
										wt = tn(se, je)
									return (
										wt && Oe.push(g(wt)),
										b(he.program.blockParams) && Oe.push(Ie(he.program)),
										g([ne(he), Vt(se, je), Oe.length > 0 ? f([x, y(x, Oe)]) : '', _, ee(he)])
									)
								}
								function De(se, je) {
									return [
										je.htmlWhitespaceSensitivity === 'ignore' ? l : '',
										ye(se),
										'else',
										te(se)
									]
								}
								function Fe(se, je, he) {
									let Oe = se.getValue(),
										wt = se.getParentNode(1)
									return g([
										ye(wt),
										['else', ' ', he],
										f([
											x,
											g(tn(se, je)),
											...(b(Oe.program.blockParams) ? [x, Ie(Oe.program)] : [])
										]),
										_,
										te(wt)
									])
								}
								function ve(se, je, he) {
									let Oe = se.getValue()
									return he.htmlWhitespaceSensitivity === 'ignore'
										? [$e(Oe) ? _ : l, ce(Oe), je('path'), z(Oe)]
										: [ce(Oe), je('path'), z(Oe)]
								}
								function $e(se) {
									return re(se, ['BlockStatement']) && se.program.body.every((je) => R(je))
								}
								function ie(se) {
									return (
										fe(se) &&
										se.inverse.body.length === 1 &&
										re(se.inverse.body[0], ['BlockStatement']) &&
										se.inverse.body[0].path.parts[0] === se.path.parts[0]
									)
								}
								function fe(se) {
									return re(se, ['BlockStatement']) && se.inverse
								}
								function Be(se, je, he) {
									let Oe = se.getValue()
									if ($e(Oe)) return ''
									let wt = je('program')
									return he.htmlWhitespaceSensitivity === 'ignore' ? f([l, wt]) : f(wt)
								}
								function Me(se, je, he) {
									let Oe = se.getValue(),
										wt = je('inverse'),
										mt = he.htmlWhitespaceSensitivity === 'ignore' ? [l, wt] : wt
									return ie(Oe) ? mt : fe(Oe) ? [De(Oe, he), f(mt)] : ''
								}
								function Dt(se) {
									return w(y(x, me(se)))
								}
								function me(se) {
									return se.split(/[\t\n\f\r ]+/)
								}
								function ae(se) {
									for (let je = 0; je < 2; je++) {
										let he = se.getParentNode(je)
										if (he && he.type === 'AttrNode') return he.name.toLowerCase()
									}
								}
								function xe(se) {
									return (
										(se = typeof se == 'string' ? se : ''),
										se.split(`
`).length - 1
									)
								}
								function Ce(se) {
									se = typeof se == 'string' ? se : ''
									let je = (se.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || ''
									return xe(je)
								}
								function Ge(se) {
									se = typeof se == 'string' ? se : ''
									let je = (se.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || ''
									return xe(je)
								}
								function nt() {
									let se = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0
									return Array.from({ length: Math.min(se, m) }).fill(l)
								}
								function ot(se, je) {
									let { quote: he, regex: Oe } = v(se, je)
									return [he, se.replace(Oe, `\\${he}`), he]
								}
								function Ut(se) {
									let je = 0,
										he = se.getParentNode(je)
									for (; he && re(he, ['SubExpression']); ) je++, (he = se.getParentNode(je))
									return !!(
										he &&
										re(se.getParentNode(je + 1), ['ConcatStatement']) &&
										re(se.getParentNode(je + 2), ['AttrNode'])
									)
								}
								function vn(se, je) {
									let he = Vt(se, je),
										Oe = tn(se, je)
									return Oe ? f([he, x, g(Oe)]) : he
								}
								function Dn(se, je) {
									let he = Vt(se, je),
										Oe = tn(se, je)
									return Oe ? [f([he, x, Oe]), _] : he
								}
								function Vt(se, je) {
									return je('path')
								}
								function tn(se, je) {
									let he = se.getValue(),
										Oe = []
									if (he.params.length > 0) {
										let wt = se.map(je, 'params')
										Oe.push(...wt)
									}
									if (he.hash && he.hash.pairs.length > 0) {
										let wt = je('hash')
										Oe.push(wt)
									}
									return Oe.length === 0 ? '' : y(x, Oe)
								}
								function Ie(se) {
									return ['as |', se.blockParams.join(' '), '|']
								}
								E.exports = { print: S, massageAstNode: G }
							}
						}),
						EE = le({
							'src/language-handlebars/parsers.js'() {
								ge()
							}
						}),
						vE = le({
							'node_modules/linguist-languages/data/Handlebars.json'(d, E) {
								E.exports = {
									name: 'Handlebars',
									type: 'markup',
									color: '#f7931e',
									aliases: ['hbs', 'htmlbars'],
									extensions: ['.handlebars', '.hbs'],
									tmScope: 'text.html.handlebars',
									aceMode: 'handlebars',
									languageId: 155
								}
							}
						}),
						xE = le({
							'src/language-handlebars/index.js'(d, E) {
								'use strict'
								ge()
								var c = Ms(),
									D = yE(),
									g = EE(),
									l = [
										c(vE(), () => ({
											since: '2.3.0',
											parsers: ['glimmer'],
											vscodeLanguageIds: ['handlebars']
										}))
									],
									p = { glimmer: D }
								E.exports = { languages: l, printers: p, parsers: g }
							}
						}),
						bE = le({
							'src/language-graphql/pragma.js'(d, E) {
								'use strict'
								ge()
								function c(g) {
									return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(g)
								}
								function D(g) {
									return (
										`# @format

` + g
									)
								}
								E.exports = { hasPragma: c, insertPragma: D }
							}
						}),
						TE = le({
							'src/language-graphql/loc.js'(d, E) {
								'use strict'
								ge()
								function c(g) {
									return typeof g.start == 'number' ? g.start : g.loc && g.loc.start
								}
								function D(g) {
									return typeof g.end == 'number' ? g.end : g.loc && g.loc.end
								}
								E.exports = { locStart: c, locEnd: D }
							}
						}),
						AE = le({
							'src/language-graphql/printer-graphql.js'(d, E) {
								'use strict'
								ge()
								var {
										builders: {
											join: c,
											hardline: D,
											line: g,
											softline: l,
											group: p,
											indent: f,
											ifBreak: y
										}
									} = dn(),
									{ isNextLineEmpty: x, isNonEmptyArray: _ } = wn(),
									{ insertPragma: w } = bE(),
									{ locStart: C, locEnd: v } = TE()
								function b(W, re, A) {
									let $ = W.getValue()
									if (!$) return ''
									if (typeof $ == 'string') return $
									switch ($.kind) {
										case 'Document': {
											let T = []
											return (
												W.each((R, m, S) => {
													T.push(A()),
														m !== S.length - 1 &&
															(T.push(D), x(re.originalText, R.getValue(), v) && T.push(D))
												}, 'definitions'),
												[...T, D]
											)
										}
										case 'OperationDefinition': {
											let T = re.originalText[C($)] !== '{',
												R = !!$.name
											return [
												T ? $.operation : '',
												T && R ? [' ', A('name')] : '',
												T && !R && _($.variableDefinitions) ? ' ' : '',
												_($.variableDefinitions)
													? p([
															'(',
															f([l, c([y('', ', '), l], W.map(A, 'variableDefinitions'))]),
															l,
															')'
													  ])
													: '',
												k(W, A, $),
												$.selectionSet ? (!T && !R ? '' : ' ') : '',
												A('selectionSet')
											]
										}
										case 'FragmentDefinition':
											return [
												'fragment ',
												A('name'),
												_($.variableDefinitions)
													? p([
															'(',
															f([l, c([y('', ', '), l], W.map(A, 'variableDefinitions'))]),
															l,
															')'
													  ])
													: '',
												' on ',
												A('typeCondition'),
												k(W, A, $),
												' ',
												A('selectionSet')
											]
										case 'SelectionSet':
											return ['{', f([D, c(D, q(W, re, A, 'selections'))]), D, '}']
										case 'Field':
											return p([
												$.alias ? [A('alias'), ': '] : '',
												A('name'),
												$.arguments.length > 0
													? p(['(', f([l, c([y('', ', '), l], q(W, re, A, 'arguments'))]), l, ')'])
													: '',
												k(W, A, $),
												$.selectionSet ? ' ' : '',
												A('selectionSet')
											])
										case 'Name':
											return $.value
										case 'StringValue': {
											if ($.block) {
												let T = $.value.replace(/"""/g, '\\$&').split(`
`)
												return (
													T.length === 1 && (T[0] = T[0].trim()),
													T.every((R) => R === '') && (T.length = 0),
													c(D, ['"""', ...T, '"""'])
												)
											}
											return ['"', $.value.replace(/["\\]/g, '\\$&').replace(/\n/g, '\\n'), '"']
										}
										case 'IntValue':
										case 'FloatValue':
										case 'EnumValue':
											return $.value
										case 'BooleanValue':
											return $.value ? 'true' : 'false'
										case 'NullValue':
											return 'null'
										case 'Variable':
											return ['$', A('name')]
										case 'ListValue':
											return p(['[', f([l, c([y('', ', '), l], W.map(A, 'values'))]), l, ']'])
										case 'ObjectValue':
											return p([
												'{',
												re.bracketSpacing && $.fields.length > 0 ? ' ' : '',
												f([l, c([y('', ', '), l], W.map(A, 'fields'))]),
												l,
												y('', re.bracketSpacing && $.fields.length > 0 ? ' ' : ''),
												'}'
											])
										case 'ObjectField':
										case 'Argument':
											return [A('name'), ': ', A('value')]
										case 'Directive':
											return [
												'@',
												A('name'),
												$.arguments.length > 0
													? p(['(', f([l, c([y('', ', '), l], q(W, re, A, 'arguments'))]), l, ')'])
													: ''
											]
										case 'NamedType':
											return A('name')
										case 'VariableDefinition':
											return [
												A('variable'),
												': ',
												A('type'),
												$.defaultValue ? [' = ', A('defaultValue')] : '',
												k(W, A, $)
											]
										case 'ObjectTypeExtension':
										case 'ObjectTypeDefinition':
											return [
												A('description'),
												$.description ? D : '',
												$.kind === 'ObjectTypeExtension' ? 'extend ' : '',
												'type ',
												A('name'),
												$.interfaces.length > 0 ? [' implements ', ...U(W, re, A)] : '',
												k(W, A, $),
												$.fields.length > 0
													? [' {', f([D, c(D, q(W, re, A, 'fields'))]), D, '}']
													: ''
											]
										case 'FieldDefinition':
											return [
												A('description'),
												$.description ? D : '',
												A('name'),
												$.arguments.length > 0
													? p(['(', f([l, c([y('', ', '), l], q(W, re, A, 'arguments'))]), l, ')'])
													: '',
												': ',
												A('type'),
												k(W, A, $)
											]
										case 'DirectiveDefinition':
											return [
												A('description'),
												$.description ? D : '',
												'directive ',
												'@',
												A('name'),
												$.arguments.length > 0
													? p(['(', f([l, c([y('', ', '), l], q(W, re, A, 'arguments'))]), l, ')'])
													: '',
												$.repeatable ? ' repeatable' : '',
												' on ',
												c(' | ', W.map(A, 'locations'))
											]
										case 'EnumTypeExtension':
										case 'EnumTypeDefinition':
											return [
												A('description'),
												$.description ? D : '',
												$.kind === 'EnumTypeExtension' ? 'extend ' : '',
												'enum ',
												A('name'),
												k(W, A, $),
												$.values.length > 0
													? [' {', f([D, c(D, q(W, re, A, 'values'))]), D, '}']
													: ''
											]
										case 'EnumValueDefinition':
											return [A('description'), $.description ? D : '', A('name'), k(W, A, $)]
										case 'InputValueDefinition':
											return [
												A('description'),
												$.description ? ($.description.block ? D : g) : '',
												A('name'),
												': ',
												A('type'),
												$.defaultValue ? [' = ', A('defaultValue')] : '',
												k(W, A, $)
											]
										case 'InputObjectTypeExtension':
										case 'InputObjectTypeDefinition':
											return [
												A('description'),
												$.description ? D : '',
												$.kind === 'InputObjectTypeExtension' ? 'extend ' : '',
												'input ',
												A('name'),
												k(W, A, $),
												$.fields.length > 0
													? [' {', f([D, c(D, q(W, re, A, 'fields'))]), D, '}']
													: ''
											]
										case 'SchemaExtension':
											return [
												'extend schema',
												k(W, A, $),
												...($.operationTypes.length > 0
													? [' {', f([D, c(D, q(W, re, A, 'operationTypes'))]), D, '}']
													: [])
											]
										case 'SchemaDefinition':
											return [
												A('description'),
												$.description ? D : '',
												'schema',
												k(W, A, $),
												' {',
												$.operationTypes.length > 0
													? f([D, c(D, q(W, re, A, 'operationTypes'))])
													: '',
												D,
												'}'
											]
										case 'OperationTypeDefinition':
											return [A('operation'), ': ', A('type')]
										case 'InterfaceTypeExtension':
										case 'InterfaceTypeDefinition':
											return [
												A('description'),
												$.description ? D : '',
												$.kind === 'InterfaceTypeExtension' ? 'extend ' : '',
												'interface ',
												A('name'),
												$.interfaces.length > 0 ? [' implements ', ...U(W, re, A)] : '',
												k(W, A, $),
												$.fields.length > 0
													? [' {', f([D, c(D, q(W, re, A, 'fields'))]), D, '}']
													: ''
											]
										case 'FragmentSpread':
											return ['...', A('name'), k(W, A, $)]
										case 'InlineFragment':
											return [
												'...',
												$.typeCondition ? [' on ', A('typeCondition')] : '',
												k(W, A, $),
												' ',
												A('selectionSet')
											]
										case 'UnionTypeExtension':
										case 'UnionTypeDefinition':
											return p([
												A('description'),
												$.description ? D : '',
												p([
													$.kind === 'UnionTypeExtension' ? 'extend ' : '',
													'union ',
													A('name'),
													k(W, A, $),
													$.types.length > 0
														? [' =', y('', ' '), f([y([g, '  ']), c([g, '| '], W.map(A, 'types'))])]
														: ''
												])
											])
										case 'ScalarTypeExtension':
										case 'ScalarTypeDefinition':
											return [
												A('description'),
												$.description ? D : '',
												$.kind === 'ScalarTypeExtension' ? 'extend ' : '',
												'scalar ',
												A('name'),
												k(W, A, $)
											]
										case 'NonNullType':
											return [A('type'), '!']
										case 'ListType':
											return ['[', A('type'), ']']
										default:
											throw new Error('unknown graphql type: ' + JSON.stringify($.kind))
									}
								}
								function k(W, re, A) {
									if (A.directives.length === 0) return ''
									let $ = c(g, W.map(re, 'directives'))
									return A.kind === 'FragmentDefinition' || A.kind === 'OperationDefinition'
										? p([g, $])
										: [' ', p(f([l, $]))]
								}
								function q(W, re, A, $) {
									return W.map((T, R, m) => {
										let S = A()
										return R < m.length - 1 && x(re.originalText, T.getValue(), v) ? [S, D] : S
									}, $)
								}
								function G(W) {
									return W.kind && W.kind !== 'Comment'
								}
								function O(W) {
									let re = W.getValue()
									if (re.kind === 'Comment') return '#' + re.value.trimEnd()
									throw new Error('Not a comment: ' + JSON.stringify(re))
								}
								function U(W, re, A) {
									let $ = W.getNode(),
										T = [],
										{ interfaces: R } = $,
										m = W.map((S) => A(S), 'interfaces')
									for (let S = 0; S < R.length; S++) {
										let L = R[S]
										T.push(m[S])
										let P = R[S + 1]
										if (P) {
											let M = re.originalText.slice(L.loc.end, P.loc.start),
												V = M.includes('#'),
												J = M.replace(/#.*/g, '').trim()
											T.push(J === ',' ? ',' : ' &', V ? g : ' ')
										}
									}
									return T
								}
								function j(W, re) {
									W.kind === 'StringValue' &&
										W.block &&
										!W.value.includes(`
`) &&
										(re.value = re.value.trim())
								}
								j.ignoredProperties = new Set(['loc', 'comments'])
								function H(W) {
									var re
									let A = W.getValue()
									return A == null || (re = A.comments) === null || re === void 0
										? void 0
										: re.some(($) => $.value.trim() === 'prettier-ignore')
								}
								E.exports = {
									print: b,
									massageAstNode: j,
									hasPrettierIgnore: H,
									insertPragma: w,
									printComment: O,
									canAttachComment: G
								}
							}
						}),
						CE = le({
							'src/language-graphql/options.js'(d, E) {
								'use strict'
								ge()
								var c = xo()
								E.exports = { bracketSpacing: c.bracketSpacing }
							}
						}),
						SE = le({
							'src/language-graphql/parsers.js'() {
								ge()
							}
						}),
						NE = le({
							'node_modules/linguist-languages/data/GraphQL.json'(d, E) {
								E.exports = {
									name: 'GraphQL',
									type: 'data',
									color: '#e10098',
									extensions: ['.graphql', '.gql', '.graphqls'],
									tmScope: 'source.graphql',
									aceMode: 'text',
									languageId: 139
								}
							}
						}),
						FE = le({
							'src/language-graphql/index.js'(d, E) {
								'use strict'
								ge()
								var c = Ms(),
									D = AE(),
									g = CE(),
									l = SE(),
									p = [
										c(NE(), () => ({
											since: '1.5.0',
											parsers: ['graphql'],
											vscodeLanguageIds: ['graphql']
										}))
									],
									f = { graphql: D }
								E.exports = { languages: p, options: g, printers: f, parsers: l }
							}
						}),
						e0 = le({
							'node_modules/collapse-white-space/index.js'(d, E) {
								'use strict'
								ge(), (E.exports = c)
								function c(D) {
									return String(D).replace(/\s+/g, ' ')
								}
							}
						}),
						t0 = le({
							'src/language-markdown/loc.js'(d, E) {
								'use strict'
								ge()
								function c(g) {
									return g.position.start.offset
								}
								function D(g) {
									return g.position.end.offset
								}
								E.exports = { locStart: c, locEnd: D }
							}
						}),
						_E = le({
							'src/language-markdown/constants.evaluate.js'(d, E) {
								E.exports = {
									cjkPattern:
										'(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?',
									kPattern:
										'[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]',
									punctuationPattern:
										'[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]'
								}
							}
						}),
						vp = le({
							'src/language-markdown/utils.js'(d, E) {
								'use strict'
								ge()
								var { getLast: c } = wn(),
									{ locStart: D, locEnd: g } = t0(),
									{ cjkPattern: l, kPattern: p, punctuationPattern: f } = _E(),
									y = [
										'liquidNode',
										'inlineCode',
										'emphasis',
										'esComment',
										'strong',
										'delete',
										'wikiLink',
										'link',
										'linkReference',
										'image',
										'imageReference',
										'footnote',
										'footnoteReference',
										'sentence',
										'whitespace',
										'word',
										'break',
										'inlineMath'
									],
									x = [...y, 'tableCell', 'paragraph', 'heading'],
									_ = new RegExp(p),
									w = new RegExp(f)
								function C(O, U) {
									let j = 'non-cjk',
										H = 'cj-letter',
										W = 'k-letter',
										re = 'cjk-punctuation',
										A = [],
										$ = (
											U.proseWrap === 'preserve'
												? O
												: O.replace(
														new RegExp(
															`(${l})
(${l})`,
															'g'
														),
														'$1$2'
												  )
										).split(/([\t\n ]+)/)
									for (let [R, m] of $.entries()) {
										if (R % 2 === 1) {
											A.push({
												type: 'whitespace',
												value: /\n/.test(m)
													? `
`
													: ' '
											})
											continue
										}
										if ((R === 0 || R === $.length - 1) && m === '') continue
										let S = m.split(new RegExp(`(${l})`))
										for (let [L, P] of S.entries())
											if (!((L === 0 || L === S.length - 1) && P === '')) {
												if (L % 2 === 0) {
													P !== '' &&
														T({
															type: 'word',
															value: P,
															kind: j,
															hasLeadingPunctuation: w.test(P[0]),
															hasTrailingPunctuation: w.test(c(P))
														})
													continue
												}
												T(
													w.test(P)
														? {
																type: 'word',
																value: P,
																kind: re,
																hasLeadingPunctuation: !0,
																hasTrailingPunctuation: !0
														  }
														: {
																type: 'word',
																value: P,
																kind: _.test(P) ? W : H,
																hasLeadingPunctuation: !1,
																hasTrailingPunctuation: !1
														  }
												)
											}
									}
									return A
									function T(R) {
										let m = c(A)
										m &&
											m.type === 'word' &&
											((m.kind === j && R.kind === H && !m.hasTrailingPunctuation) ||
											(m.kind === H && R.kind === j && !R.hasLeadingPunctuation)
												? A.push({ type: 'whitespace', value: ' ' })
												: !S(j, re) &&
												  ![m.value, R.value].some((L) => /\u3000/.test(L)) &&
												  A.push({ type: 'whitespace', value: '' })),
											A.push(R)
										function S(L, P) {
											return (m.kind === L && R.kind === P) || (m.kind === P && R.kind === L)
										}
									}
								}
								function v(O, U) {
									let [, j, H, W] = U.slice(O.position.start.offset, O.position.end.offset).match(
										/^\s*(\d+)(\.|\))(\s*)/
									)
									return { numberText: j, marker: H, leadingSpaces: W }
								}
								function b(O, U) {
									if (!O.ordered || O.children.length < 2) return !1
									let j = Number(v(O.children[0], U.originalText).numberText),
										H = Number(v(O.children[1], U.originalText).numberText)
									if (j === 0 && O.children.length > 2) {
										let W = Number(v(O.children[2], U.originalText).numberText)
										return H === 1 && W === 1
									}
									return H === 1
								}
								function k(O, U) {
									let { value: j } = O
									return O.position.end.offset === U.length &&
										j.endsWith(`
`) &&
										U.endsWith(`
`)
										? j.slice(0, -1)
										: j
								}
								function q(O, U) {
									return (function j(H, W, re) {
										let A = Object.assign({}, U(H, W, re))
										return (
											A.children && (A.children = A.children.map(($, T) => j($, T, [A, ...re]))), A
										)
									})(O, null, [])
								}
								function G(O) {
									if (O?.type !== 'link' || O.children.length !== 1) return !1
									let [U] = O.children
									return D(O) === D(U) && g(O) === g(U)
								}
								E.exports = {
									mapAst: q,
									splitText: C,
									punctuationPattern: f,
									getFencedCodeBlockValue: k,
									getOrderedListItemInfo: v,
									hasGitDiffFriendlyOrderedList: b,
									INLINE_NODE_TYPES: y,
									INLINE_NODE_WRAPPER_TYPES: x,
									isAutolink: G
								}
							}
						}),
						wE = le({
							'src/language-markdown/embed.js'(d, E) {
								'use strict'
								ge()
								var { inferParserByLanguage: c, getMaxContinuousCount: D } = wn(),
									{
										builders: { hardline: g, markAsRoot: l },
										utils: { replaceEndOfLine: p }
									} = dn(),
									f = Ep(),
									{ getFencedCodeBlockValue: y } = vp()
								function x(_, w, C, v) {
									let b = _.getValue()
									if (b.type === 'code' && b.lang !== null) {
										let k = c(b.lang, v)
										if (k) {
											let q = v.__inJsTemplate ? '~' : '`',
												G = q.repeat(Math.max(3, D(b.value, q) + 1)),
												O = { parser: k }
											b.lang === 'tsx' && (O.filepath = 'dummy.tsx')
											let U = C(y(b, v.originalText), O, { stripTrailingHardline: !0 })
											return l([G, b.lang, b.meta ? ' ' + b.meta : '', g, p(U), g, G])
										}
									}
									switch (b.type) {
										case 'front-matter':
											return f(b, C)
										case 'importExport':
											return [C(b.value, { parser: 'babel' }, { stripTrailingHardline: !0 }), g]
										case 'jsx':
											return C(
												`<$>${b.value}</$>`,
												{ parser: '__js_expression', rootMarker: 'mdx' },
												{ stripTrailingHardline: !0 }
											)
									}
									return null
								}
								E.exports = x
							}
						}),
						n0 = le({
							'src/language-markdown/pragma.js'(d, E) {
								'use strict'
								ge()
								var c = Z1(),
									D = ['format', 'prettier']
								function g(l) {
									let p = `@(${D.join('|')})`,
										f = new RegExp(
											[
												`<!--\\s*${p}\\s*-->`,
												`{\\s*\\/\\*\\s*${p}\\s*\\*\\/\\s*}`,
												`<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${p}[^\\S
]*($|
)[\\s\\S]*
.*-->`
											].join('|'),
											'm'
										),
										y = l.match(f)
									return y?.index === 0
								}
								E.exports = {
									startWithPragma: g,
									hasPragma: (l) => g(c(l).content.trimStart()),
									insertPragma: (l) => {
										let p = c(l),
											f = `<!-- @${D[0]} -->`
										return p.frontMatter
											? `${p.frontMatter.raw}

${f}

${p.content}`
											: `${f}

${p.content}`
									}
								}
							}
						}),
						LE = le({
							'src/language-markdown/print-preprocess.js'(d, E) {
								'use strict'
								ge()
								var c = Ur(),
									{ getOrderedListItemInfo: D, mapAst: g, splitText: l } = vp(),
									p = /^.$/su
								function f(G, O) {
									return (
										(G = _(G, O)),
										(G = v(G)),
										(G = x(G, O)),
										(G = k(G, O)),
										(G = q(G, O)),
										(G = b(G, O)),
										(G = y(G)),
										(G = w(G)),
										G
									)
								}
								function y(G) {
									return g(G, (O) =>
										O.type !== 'import' && O.type !== 'export'
											? O
											: Object.assign(Object.assign({}, O), {}, { type: 'importExport' })
									)
								}
								function x(G, O) {
									return g(G, (U) =>
										U.type !== 'inlineCode' || O.proseWrap === 'preserve'
											? U
											: Object.assign(
													Object.assign({}, U),
													{},
													{ value: U.value.replace(/\s+/g, ' ') }
											  )
									)
								}
								function _(G, O) {
									return g(G, (U) =>
										U.type !== 'text' ||
										U.value === '*' ||
										U.value === '_' ||
										!p.test(U.value) ||
										U.position.end.offset - U.position.start.offset === U.value.length
											? U
											: Object.assign(
													Object.assign({}, U),
													{},
													{
														value: O.originalText.slice(
															U.position.start.offset,
															U.position.end.offset
														)
													}
											  )
									)
								}
								function w(G) {
									return C(
										G,
										(O, U) => O.type === 'importExport' && U.type === 'importExport',
										(O, U) => ({
											type: 'importExport',
											value:
												O.value +
												`

` +
												U.value,
											position: { start: O.position.start, end: U.position.end }
										})
									)
								}
								function C(G, O, U) {
									return g(G, (j) => {
										if (!j.children) return j
										let H = j.children.reduce((W, re) => {
											let A = c(W)
											return A && O(A, re) ? W.splice(-1, 1, U(A, re)) : W.push(re), W
										}, [])
										return Object.assign(Object.assign({}, j), {}, { children: H })
									})
								}
								function v(G) {
									return C(
										G,
										(O, U) => O.type === 'text' && U.type === 'text',
										(O, U) => ({
											type: 'text',
											value: O.value + U.value,
											position: { start: O.position.start, end: U.position.end }
										})
									)
								}
								function b(G, O) {
									return g(G, (U, j, H) => {
										let [W] = H
										if (U.type !== 'text') return U
										let { value: re } = U
										return (
											W.type === 'paragraph' &&
												(j === 0 && (re = re.trimStart()),
												j === W.children.length - 1 && (re = re.trimEnd())),
											{ type: 'sentence', position: U.position, children: l(re, O) }
										)
									})
								}
								function k(G, O) {
									return g(G, (U, j, H) => {
										if (U.type === 'code') {
											let W = /^\n?(?: {4,}|\t)/.test(
												O.originalText.slice(U.position.start.offset, U.position.end.offset)
											)
											if (((U.isIndented = W), W))
												for (let re = 0; re < H.length; re++) {
													let A = H[re]
													if (A.hasIndentedCodeblock) break
													A.type === 'list' && (A.hasIndentedCodeblock = !0)
												}
										}
										return U
									})
								}
								function q(G, O) {
									return g(G, (H, W, re) => {
										if (H.type === 'list' && H.children.length > 0) {
											for (let A = 0; A < re.length; A++) {
												let $ = re[A]
												if ($.type === 'list' && !$.isAligned) return (H.isAligned = !1), H
											}
											H.isAligned = j(H)
										}
										return H
									})
									function U(H) {
										return H.children.length === 0 ? -1 : H.children[0].position.start.column - 1
									}
									function j(H) {
										if (!H.ordered) return !0
										let [W, re] = H.children
										if (D(W, O.originalText).leadingSpaces.length > 1) return !0
										let A = U(W)
										if (A === -1) return !1
										if (H.children.length === 1) return A % O.tabWidth === 0
										let $ = U(re)
										return A !== $
											? !1
											: A % O.tabWidth === 0
											? !0
											: D(re, O.originalText).leadingSpaces.length > 1
									}
								}
								E.exports = f
							}
						}),
						IE = le({
							'src/language-markdown/clean.js'(d, E) {
								'use strict'
								ge()
								var c = e0(),
									{ isFrontMatterNode: D } = wn(),
									{ startWithPragma: g } = n0(),
									l = new Set(['position', 'raw'])
								function p(f, y, x) {
									if (
										((f.type === 'front-matter' ||
											f.type === 'code' ||
											f.type === 'yaml' ||
											f.type === 'import' ||
											f.type === 'export' ||
											f.type === 'jsx') &&
											delete y.value,
										f.type === 'list' && delete y.isAligned,
										(f.type === 'list' || f.type === 'listItem') &&
											(delete y.spread, delete y.loose),
										f.type === 'text' ||
											(f.type === 'inlineCode' && (y.value = f.value.replace(/[\t\n ]+/g, ' ')),
											f.type === 'wikiLink' && (y.value = f.value.trim().replace(/[\t\n]+/g, ' ')),
											(f.type === 'definition' ||
												f.type === 'linkReference' ||
												f.type === 'imageReference') &&
												(y.label = c(f.label)),
											(f.type === 'definition' || f.type === 'link' || f.type === 'image') &&
												f.title &&
												(y.title = f.title.replace(/\\(["')])/g, '$1')),
											x &&
												x.type === 'root' &&
												x.children.length > 0 &&
												(x.children[0] === f || (D(x.children[0]) && x.children[1] === f)) &&
												f.type === 'html' &&
												g(f.value)))
									)
										return null
								}
								;(p.ignoredProperties = l), (E.exports = p)
							}
						}),
						kE = le({
							'src/language-markdown/printer-markdown.js'(d, E) {
								'use strict'
								ge()
								var c = e0(),
									{
										getLast: D,
										getMinNotPresentContinuousCount: g,
										getMaxContinuousCount: l,
										getStringWidth: p,
										isNonEmptyArray: f
									} = wn(),
									{
										builders: {
											breakParent: y,
											join: x,
											line: _,
											literalline: w,
											markAsRoot: C,
											hardline: v,
											softline: b,
											ifBreak: k,
											fill: q,
											align: G,
											indent: O,
											group: U,
											hardlineWithoutBreakParent: j
										},
										utils: { normalizeDoc: H, replaceTextEndOfLine: W },
										printer: { printDocToString: re }
									} = dn(),
									A = wE(),
									{ insertPragma: $ } = n0(),
									{ locStart: T, locEnd: R } = t0(),
									m = LE(),
									S = IE(),
									{
										getFencedCodeBlockValue: L,
										hasGitDiffFriendlyOrderedList: P,
										splitText: M,
										punctuationPattern: V,
										INLINE_NODE_TYPES: J,
										INLINE_NODE_WRAPPER_TYPES: Z,
										isAutolink: ne
									} = vp(),
									ee = new Set(['importExport']),
									ce = ['heading', 'tableCell', 'link', 'wikiLink'],
									z = new Set(['listItem', 'definition', 'footnoteDefinition'])
								function ye(Ie, se, je) {
									let he = Ie.getValue()
									if (nt(Ie))
										return M(
											se.originalText.slice(he.position.start.offset, he.position.end.offset),
											se
										).map((Oe) =>
											Oe.type === 'word' ? Oe.value : Oe.value === '' ? '' : ie(Ie, Oe.value, se)
										)
									switch (he.type) {
										case 'front-matter':
											return se.originalText.slice(he.position.start.offset, he.position.end.offset)
										case 'root':
											return he.children.length === 0
												? ''
												: [H(Be(Ie, se, je)), ee.has(me(he).type) ? '' : v]
										case 'paragraph':
											return Me(Ie, se, je, { postprocessor: q })
										case 'sentence':
											return Me(Ie, se, je)
										case 'word': {
											let Oe = he.value
													.replace(/\*/g, '\\$&')
													.replace(
														new RegExp([`(^|${V})(_+)`, `(_+)(${V}|$)`].join('|'), 'g'),
														(Ue, B, pe, _e, st) =>
															(pe ? `${B}${pe}` : `${_e}${st}`).replace(/_/g, '\\_')
													),
												wt = (Ue, B, pe) => Ue.type === 'sentence' && pe === 0,
												mt = (Ue, B, pe) => ne(Ue.children[pe - 1])
											return (
												Oe !== he.value &&
													(Ie.match(void 0, wt, mt) ||
														Ie.match(
															void 0,
															wt,
															(Ue, B, pe) => Ue.type === 'emphasis' && pe === 0,
															mt
														)) &&
													(Oe = Oe.replace(/^(\\?[*_])+/, (Ue) => Ue.replace(/\\/g, ''))),
												Oe
											)
										}
										case 'whitespace': {
											let Oe = Ie.getParentNode(),
												wt = Oe.children.indexOf(he),
												mt = Oe.children[wt + 1],
												Ue =
													mt && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(mt.value)
														? 'never'
														: se.proseWrap
											return ie(Ie, he.value, { proseWrap: Ue })
										}
										case 'emphasis': {
											let Oe
											if (ne(he.children[0])) Oe = se.originalText[he.position.start.offset]
											else {
												let wt = Ie.getParentNode(),
													mt = wt.children.indexOf(he),
													Ue = wt.children[mt - 1],
													B = wt.children[mt + 1]
												Oe =
													(Ue &&
														Ue.type === 'sentence' &&
														Ue.children.length > 0 &&
														D(Ue.children).type === 'word' &&
														!D(Ue.children).hasTrailingPunctuation) ||
													(B &&
														B.type === 'sentence' &&
														B.children.length > 0 &&
														B.children[0].type === 'word' &&
														!B.children[0].hasLeadingPunctuation) ||
													$e(Ie, 'emphasis')
														? '*'
														: '_'
											}
											return [Oe, Me(Ie, se, je), Oe]
										}
										case 'strong':
											return ['**', Me(Ie, se, je), '**']
										case 'delete':
											return ['~~', Me(Ie, se, je), '~~']
										case 'inlineCode': {
											let Oe = g(he.value, '`'),
												wt = '`'.repeat(Oe || 1),
												mt = Oe && !/^\s/.test(he.value) ? ' ' : ''
											return [wt, mt, he.value, mt, wt]
										}
										case 'wikiLink': {
											let Oe = ''
											return (
												se.proseWrap === 'preserve'
													? (Oe = he.value)
													: (Oe = he.value.replace(/[\t\n]+/g, ' ')),
												['[[', Oe, ']]']
											)
										}
										case 'link':
											switch (se.originalText[he.position.start.offset]) {
												case '<': {
													let Oe = 'mailto:'
													return [
														'<',
														he.url.startsWith(Oe) &&
														se.originalText.slice(
															he.position.start.offset + 1,
															he.position.start.offset + 1 + Oe.length
														) !== Oe
															? he.url.slice(Oe.length)
															: he.url,
														'>'
													]
												}
												case '[':
													return ['[', Me(Ie, se, je), '](', ot(he.url, ')'), Ut(he.title, se), ')']
												default:
													return se.originalText.slice(
														he.position.start.offset,
														he.position.end.offset
													)
											}
										case 'image':
											return ['![', he.alt || '', '](', ot(he.url, ')'), Ut(he.title, se), ')']
										case 'blockquote':
											return ['> ', G('> ', Me(Ie, se, je))]
										case 'heading':
											return ['#'.repeat(he.depth) + ' ', Me(Ie, se, je)]
										case 'code': {
											if (he.isIndented) {
												let mt = ' '.repeat(4)
												return G(mt, [mt, ...W(he.value, v)])
											}
											let Oe = se.__inJsTemplate ? '~' : '`',
												wt = Oe.repeat(Math.max(3, l(he.value, Oe) + 1))
											return [
												wt,
												he.lang || '',
												he.meta ? ' ' + he.meta : '',
												v,
												...W(L(he, se.originalText), v),
												v,
												wt
											]
										}
										case 'html': {
											let Oe = Ie.getParentNode(),
												wt =
													Oe.type === 'root' && D(Oe.children) === he
														? he.value.trimEnd()
														: he.value,
												mt = /^<!--.*-->$/s.test(wt)
											return W(wt, mt ? v : C(w))
										}
										case 'list': {
											let Oe = De(he, Ie.getParentNode()),
												wt = P(he, se)
											return Me(Ie, se, je, {
												processor: (mt, Ue) => {
													let B = _e(),
														pe = mt.getValue()
													if (
														pe.children.length === 2 &&
														pe.children[1].type === 'html' &&
														pe.children[0].position.start.column !==
															pe.children[1].position.start.column
													)
														return [B, te(mt, se, je, B)]
													return [B, G(' '.repeat(B.length), te(mt, se, je, B))]
													function _e() {
														let st = he.ordered
															? (Ue === 0 ? he.start : wt ? 1 : he.start + Ue) +
															  (Oe % 2 === 0 ? '. ' : ') ')
															: Oe % 2 === 0
															? '- '
															: '* '
														return he.isAligned || he.hasIndentedCodeblock ? X(st, se) : st
													}
												}
											})
										}
										case 'thematicBreak': {
											let Oe = ve(Ie, 'list')
											return Oe === -1
												? '---'
												: De(Ie.getParentNode(Oe), Ie.getParentNode(Oe + 1)) % 2 === 0
												? '***'
												: '---'
										}
										case 'linkReference':
											return [
												'[',
												Me(Ie, se, je),
												']',
												he.referenceType === 'full'
													? Vt(he)
													: he.referenceType === 'collapsed'
													? '[]'
													: ''
											]
										case 'imageReference':
											switch (he.referenceType) {
												case 'full':
													return ['![', he.alt || '', ']', Vt(he)]
												default:
													return ['![', he.alt, ']', he.referenceType === 'collapsed' ? '[]' : '']
											}
										case 'definition': {
											let Oe = se.proseWrap === 'always' ? _ : ' '
											return U([
												Vt(he),
												':',
												O([Oe, ot(he.url), he.title === null ? '' : [Oe, Ut(he.title, se, !1)]])
											])
										}
										case 'footnote':
											return ['[^', Me(Ie, se, je), ']']
										case 'footnoteReference':
											return tn(he)
										case 'footnoteDefinition': {
											let Oe = Ie.getParentNode().children[Ie.getName() + 1],
												wt =
													he.children.length === 1 &&
													he.children[0].type === 'paragraph' &&
													(se.proseWrap === 'never' ||
														(se.proseWrap === 'preserve' &&
															he.children[0].position.start.line ===
																he.children[0].position.end.line))
											return [
												tn(he),
												': ',
												wt
													? Me(Ie, se, je)
													: U([
															G(
																' '.repeat(4),
																Me(Ie, se, je, {
																	processor: (mt, Ue) => (Ue === 0 ? U([b, je()]) : je())
																})
															),
															Oe && Oe.type === 'footnoteDefinition' ? b : ''
													  ])
											]
										}
										case 'table':
											return fe(Ie, se, je)
										case 'tableCell':
											return Me(Ie, se, je)
										case 'break':
											return /\s/.test(se.originalText[he.position.start.offset])
												? ['  ', C(w)]
												: ['\\', v]
										case 'liquidNode':
											return W(he.value, v)
										case 'importExport':
											return [he.value, v]
										case 'esComment':
											return ['{/* ', he.value, ' */}']
										case 'jsx':
											return he.value
										case 'math':
											return ['$$', v, he.value ? [...W(he.value, v), v] : '', '$$']
										case 'inlineMath':
											return se.originalText.slice(T(he), R(he))
										case 'tableRow':
										case 'listItem':
										default:
											throw new Error(`Unknown markdown type ${JSON.stringify(he.type)}`)
									}
								}
								function te(Ie, se, je, he) {
									let Oe = Ie.getValue(),
										wt = Oe.checked === null ? '' : Oe.checked ? '[x] ' : '[ ] '
									return [
										wt,
										Me(Ie, se, je, {
											processor: (mt, Ue) => {
												if (Ue === 0 && mt.getValue().type !== 'list')
													return G(' '.repeat(wt.length), je())
												let B = ' '.repeat(vn(se.tabWidth - he.length, 0, 3))
												return [B, G(B, je())]
											}
										})
									]
								}
								function X(Ie, se) {
									let je = he()
									return Ie + ' '.repeat(je >= 4 ? 0 : je)
									function he() {
										let Oe = Ie.length % se.tabWidth
										return Oe === 0 ? 0 : se.tabWidth - Oe
									}
								}
								function De(Ie, se) {
									return Fe(Ie, se, (je) => je.ordered === Ie.ordered)
								}
								function Fe(Ie, se, je) {
									let he = -1
									for (let Oe of se.children)
										if ((Oe.type === Ie.type && je(Oe) ? he++ : (he = -1), Oe === Ie)) return he
								}
								function ve(Ie, se) {
									let je = Array.isArray(se) ? se : [se],
										he = -1,
										Oe
									for (; (Oe = Ie.getParentNode(++he)); ) if (je.includes(Oe.type)) return he
									return -1
								}
								function $e(Ie, se) {
									let je = ve(Ie, se)
									return je === -1 ? null : Ie.getParentNode(je)
								}
								function ie(Ie, se, je) {
									if (
										je.proseWrap === 'preserve' &&
										se ===
											`
`
									)
										return v
									let he = je.proseWrap === 'always' && !$e(Ie, ce)
									return se !== '' ? (he ? _ : ' ') : he ? b : ''
								}
								function fe(Ie, se, je) {
									let he = Ie.getValue(),
										Oe = [],
										wt = Ie.map(
											(st) =>
												st.map((pt, jt) => {
													let at = re(je(), se).formatted,
														ar = p(at)
													return (Oe[jt] = Math.max(Oe[jt] || 3, ar)), { text: at, width: ar }
												}, 'children'),
											'children'
										),
										mt = B(!1)
									if (se.proseWrap !== 'never') return [y, mt]
									let Ue = B(!0)
									return [y, U(k(Ue, mt))]
									function B(st) {
										let pt = [_e(wt[0], st), pe(st)]
										return (
											wt.length > 1 &&
												pt.push(
													x(
														j,
														wt.slice(1).map((jt) => _e(jt, st))
													)
												),
											x(j, pt)
										)
									}
									function pe(st) {
										return `| ${Oe.map((pt, jt) => {
											let at = he.align[jt],
												ar = at === 'center' || at === 'left' ? ':' : '-',
												Rt = at === 'center' || at === 'right' ? ':' : '-',
												ir = st ? '-' : '-'.repeat(pt - 2)
											return `${ar}${ir}${Rt}`
										}).join(' | ')} |`
									}
									function _e(st, pt) {
										return `| ${st
											.map((jt, at) => {
												let { text: ar, width: Rt } = jt
												if (pt) return ar
												let ir = Oe[at] - Rt,
													It = he.align[at],
													an = 0
												It === 'right' ? (an = ir) : It === 'center' && (an = Math.floor(ir / 2))
												let yn = ir - an
												return `${' '.repeat(an)}${ar}${' '.repeat(yn)}`
											})
											.join(' | ')} |`
									}
								}
								function Be(Ie, se, je) {
									let he = [],
										Oe = null,
										{ children: wt } = Ie.getValue()
									for (let [mt, Ue] of wt.entries())
										switch (ae(Ue)) {
											case 'start':
												Oe === null && (Oe = { index: mt, offset: Ue.position.end.offset })
												break
											case 'end':
												Oe !== null &&
													(he.push({
														start: Oe,
														end: { index: mt, offset: Ue.position.start.offset }
													}),
													(Oe = null))
												break
											default:
												break
										}
									return Me(Ie, se, je, {
										processor: (mt, Ue) => {
											if (he.length > 0) {
												let B = he[0]
												if (Ue === B.start.index)
													return [
														Dt(wt[B.start.index]),
														se.originalText.slice(B.start.offset, B.end.offset),
														Dt(wt[B.end.index])
													]
												if (B.start.index < Ue && Ue < B.end.index) return !1
												if (Ue === B.end.index) return he.shift(), !1
											}
											return je()
										}
									})
								}
								function Me(Ie, se, je) {
									let he = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {},
										{ postprocessor: Oe } = he,
										wt = he.processor || (() => je()),
										mt = Ie.getValue(),
										Ue = [],
										B
									return (
										Ie.each((pe, _e) => {
											let st = pe.getValue(),
												pt = wt(pe, _e)
											if (pt !== !1) {
												let jt = { parts: Ue, prevNode: B, parentNode: mt, options: se }
												xe(st, jt) &&
													(Ue.push(v),
													(B && ee.has(B.type)) || ((Ce(st, jt) || Ge(st, jt)) && Ue.push(v)),
													Ge(st, jt) && Ue.push(v)),
													Ue.push(pt),
													(B = st)
											}
										}, 'children'),
										Oe ? Oe(Ue) : Ue
									)
								}
								function Dt(Ie) {
									if (Ie.type === 'html') return Ie.value
									if (
										Ie.type === 'paragraph' &&
										Array.isArray(Ie.children) &&
										Ie.children.length === 1 &&
										Ie.children[0].type === 'esComment'
									)
										return ['{/* ', Ie.children[0].value, ' */}']
								}
								function me(Ie) {
									let se = Ie
									for (; f(se.children); ) se = D(se.children)
									return se
								}
								function ae(Ie) {
									let se
									if (Ie.type === 'html')
										se = Ie.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/)
									else {
										let je
										Ie.type === 'esComment'
											? (je = Ie)
											: Ie.type === 'paragraph' &&
											  Ie.children.length === 1 &&
											  Ie.children[0].type === 'esComment' &&
											  (je = Ie.children[0]),
											je && (se = je.value.match(/^prettier-ignore(?:-(start|end))?$/))
									}
									return se ? se[1] || 'next' : !1
								}
								function xe(Ie, se) {
									let je = se.parts.length === 0,
										he = J.includes(Ie.type),
										Oe = Ie.type === 'html' && Z.includes(se.parentNode.type)
									return !je && !he && !Oe
								}
								function Ce(Ie, se) {
									var je, he, Oe
									let wt = (se.prevNode && se.prevNode.type) === Ie.type && z.has(Ie.type),
										mt = se.parentNode.type === 'listItem' && !se.parentNode.loose,
										Ue =
											((je = se.prevNode) === null || je === void 0 ? void 0 : je.type) ===
												'listItem' && se.prevNode.loose,
										B = ae(se.prevNode) === 'next',
										pe =
											Ie.type === 'html' &&
											((he = se.prevNode) === null || he === void 0 ? void 0 : he.type) ===
												'html' &&
											se.prevNode.position.end.line + 1 === Ie.position.start.line,
										_e =
											Ie.type === 'html' &&
											se.parentNode.type === 'listItem' &&
											((Oe = se.prevNode) === null || Oe === void 0 ? void 0 : Oe.type) ===
												'paragraph' &&
											se.prevNode.position.end.line + 1 === Ie.position.start.line
									return Ue || !(wt || mt || B || pe || _e)
								}
								function Ge(Ie, se) {
									let je = se.prevNode && se.prevNode.type === 'list',
										he = Ie.type === 'code' && Ie.isIndented
									return je && he
								}
								function nt(Ie) {
									let se = $e(Ie, ['linkReference', 'imageReference'])
									return se && (se.type !== 'linkReference' || se.referenceType !== 'full')
								}
								function ot(Ie) {
									let se = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
										je = [' ', ...(Array.isArray(se) ? se : [se])]
									return new RegExp(je.map((he) => `\\${he}`).join('|')).test(Ie) ? `<${Ie}>` : Ie
								}
								function Ut(Ie, se) {
									let je = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0
									if (!Ie) return ''
									if (je) return ' ' + Ut(Ie, se, !1)
									if (
										((Ie = Ie.replace(/\\(["')])/g, '$1')),
										Ie.includes('"') && Ie.includes("'") && !Ie.includes(')'))
									)
										return `(${Ie})`
									let he = Ie.split("'").length - 1,
										Oe = Ie.split('"').length - 1,
										wt = he > Oe ? '"' : Oe > he || se.singleQuote ? "'" : '"'
									return (
										(Ie = Ie.replace(/\\/, '\\\\')),
										(Ie = Ie.replace(new RegExp(`(${wt})`, 'g'), '\\$1')),
										`${wt}${Ie}${wt}`
									)
								}
								function vn(Ie, se, je) {
									return Ie < se ? se : Ie > je ? je : Ie
								}
								function Dn(Ie) {
									let se = Number(Ie.getName())
									if (se === 0) return !1
									let je = Ie.getParentNode().children[se - 1]
									return ae(je) === 'next'
								}
								function Vt(Ie) {
									return `[${c(Ie.label)}]`
								}
								function tn(Ie) {
									return `[^${Ie.label}]`
								}
								E.exports = {
									preprocess: m,
									print: ye,
									embed: A,
									massageAstNode: S,
									hasPrettierIgnore: Dn,
									insertPragma: $
								}
							}
						}),
						RE = le({
							'src/language-markdown/options.js'(d, E) {
								'use strict'
								ge()
								var c = xo()
								E.exports = { proseWrap: c.proseWrap, singleQuote: c.singleQuote }
							}
						}),
						OE = le({
							'src/language-markdown/parsers.js'() {
								ge()
							}
						}),
						r0 = le({
							'node_modules/linguist-languages/data/Markdown.json'(d, E) {
								E.exports = {
									name: 'Markdown',
									type: 'prose',
									color: '#083fa1',
									aliases: ['pandoc'],
									aceMode: 'markdown',
									codemirrorMode: 'gfm',
									codemirrorMimeType: 'text/x-gfm',
									wrap: !0,
									extensions: [
										'.md',
										'.livemd',
										'.markdown',
										'.mdown',
										'.mdwn',
										'.mdx',
										'.mkd',
										'.mkdn',
										'.mkdown',
										'.ronn',
										'.scd',
										'.workbook'
									],
									filenames: ['contents.lr'],
									tmScope: 'source.gfm',
									languageId: 222
								}
							}
						}),
						BE = le({
							'src/language-markdown/index.js'(d, E) {
								'use strict'
								ge()
								var c = Ms(),
									D = kE(),
									g = RE(),
									l = OE(),
									p = [
										c(r0(), (y) => ({
											since: '1.8.0',
											parsers: ['markdown'],
											vscodeLanguageIds: ['markdown'],
											filenames: [...y.filenames, 'README'],
											extensions: y.extensions.filter((x) => x !== '.mdx')
										})),
										c(r0(), () => ({
											name: 'MDX',
											since: '1.15.0',
											parsers: ['mdx'],
											vscodeLanguageIds: ['mdx'],
											filenames: [],
											extensions: ['.mdx']
										}))
									],
									f = { mdast: D }
								E.exports = { languages: p, options: g, printers: f, parsers: l }
							}
						}),
						PE = le({
							'src/language-html/clean.js'(d, E) {
								'use strict'
								ge()
								var { isFrontMatterNode: c } = wn(),
									D = new Set([
										'sourceSpan',
										'startSourceSpan',
										'endSourceSpan',
										'nameSpan',
										'valueSpan'
									])
								function g(l, p) {
									if (
										l.type === 'text' ||
										l.type === 'comment' ||
										c(l) ||
										l.type === 'yaml' ||
										l.type === 'toml'
									)
										return null
									l.type === 'attribute' && delete p.value, l.type === 'docType' && delete p.value
								}
								;(g.ignoredProperties = D), (E.exports = g)
							}
						}),
						ME = le({
							'src/language-html/constants.evaluate.js'(d, E) {
								E.exports = {
									CSS_DISPLAY_TAGS: {
										area: 'none',
										base: 'none',
										basefont: 'none',
										datalist: 'none',
										head: 'none',
										link: 'none',
										meta: 'none',
										noembed: 'none',
										noframes: 'none',
										param: 'block',
										rp: 'none',
										script: 'block',
										source: 'block',
										style: 'none',
										template: 'inline',
										track: 'block',
										title: 'none',
										html: 'block',
										body: 'block',
										address: 'block',
										blockquote: 'block',
										center: 'block',
										div: 'block',
										figure: 'block',
										figcaption: 'block',
										footer: 'block',
										form: 'block',
										header: 'block',
										hr: 'block',
										legend: 'block',
										listing: 'block',
										main: 'block',
										p: 'block',
										plaintext: 'block',
										pre: 'block',
										xmp: 'block',
										slot: 'contents',
										ruby: 'ruby',
										rt: 'ruby-text',
										article: 'block',
										aside: 'block',
										h1: 'block',
										h2: 'block',
										h3: 'block',
										h4: 'block',
										h5: 'block',
										h6: 'block',
										hgroup: 'block',
										nav: 'block',
										section: 'block',
										dir: 'block',
										dd: 'block',
										dl: 'block',
										dt: 'block',
										ol: 'block',
										ul: 'block',
										li: 'list-item',
										table: 'table',
										caption: 'table-caption',
										colgroup: 'table-column-group',
										col: 'table-column',
										thead: 'table-header-group',
										tbody: 'table-row-group',
										tfoot: 'table-footer-group',
										tr: 'table-row',
										td: 'table-cell',
										th: 'table-cell',
										fieldset: 'block',
										button: 'inline-block',
										details: 'block',
										summary: 'block',
										dialog: 'block',
										meter: 'inline-block',
										progress: 'inline-block',
										object: 'inline-block',
										video: 'inline-block',
										audio: 'inline-block',
										select: 'inline-block',
										option: 'block',
										optgroup: 'block'
									},
									CSS_DISPLAY_DEFAULT: 'inline',
									CSS_WHITE_SPACE_TAGS: {
										listing: 'pre',
										plaintext: 'pre',
										pre: 'pre',
										xmp: 'pre',
										nobr: 'nowrap',
										table: 'initial',
										textarea: 'pre-wrap'
									},
									CSS_WHITE_SPACE_DEFAULT: 'normal'
								}
							}
						}),
						jE = le({
							'src/language-html/utils/is-unknown-namespace.js'(d, E) {
								'use strict'
								ge()
								function c(D) {
									return (
										D.type === 'element' &&
										!D.hasExplicitNamespace &&
										!['html', 'svg'].includes(D.namespace)
									)
								}
								E.exports = c
							}
						}),
						bo = le({
							'src/language-html/utils/index.js'(d, E) {
								'use strict'
								ge()
								var { inferParserByLanguage: c, isFrontMatterNode: D } = wn(),
									{
										builders: { line: g, hardline: l, join: p },
										utils: { getDocParts: f, replaceTextEndOfLine: y }
									} = dn(),
									{
										CSS_DISPLAY_TAGS: x,
										CSS_DISPLAY_DEFAULT: _,
										CSS_WHITE_SPACE_TAGS: w,
										CSS_WHITE_SPACE_DEFAULT: C
									} = ME(),
									v = jE(),
									b = new Set([
										'	',
										`
`,
										'\f',
										'\r',
										' '
									]),
									k = (B) => B.replace(/^[\t\n\f\r ]+/, ''),
									q = (B) => B.replace(/[\t\n\f\r ]+$/, ''),
									G = (B) => k(q(B)),
									O = (B) => B.replace(/^[\t\f\r ]*\n/g, ''),
									U = (B) => O(q(B)),
									j = (B) => B.split(/[\t\n\f\r ]+/),
									H = (B) => B.match(/^[\t\n\f\r ]*/)[0],
									W = (B) => {
										let [, pe, _e, st] = B.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s)
										return { leadingWhitespace: pe, trailingWhitespace: st, text: _e }
									},
									re = (B) => /[\t\n\f\r ]/.test(B)
								function A(B, pe) {
									return !!(
										(B.type === 'ieConditionalComment' &&
											B.lastChild &&
											!B.lastChild.isSelfClosing &&
											!B.lastChild.endSourceSpan) ||
										(B.type === 'ieConditionalComment' && !B.complete) ||
										(Ce(B) &&
											B.children.some((_e) => _e.type !== 'text' && _e.type !== 'interpolation')) ||
										(he(B, pe) && !m(B) && B.type !== 'interpolation')
									)
								}
								function $(B) {
									return B.type === 'attribute' || !B.parent || !B.prev ? !1 : T(B.prev)
								}
								function T(B) {
									return B.type === 'comment' && B.value.trim() === 'prettier-ignore'
								}
								function R(B) {
									return B.type === 'text' || B.type === 'comment'
								}
								function m(B) {
									return (
										B.type === 'element' &&
										(B.fullName === 'script' ||
											B.fullName === 'style' ||
											B.fullName === 'svg:style' ||
											(v(B) && (B.name === 'script' || B.name === 'style')))
									)
								}
								function S(B) {
									return B.children && !m(B)
								}
								function L(B) {
									return m(B) || B.type === 'interpolation' || P(B)
								}
								function P(B) {
									return Ut(B).startsWith('pre')
								}
								function M(B, pe) {
									let _e = st()
									if (
										_e &&
										!B.prev &&
										B.parent &&
										B.parent.tagDefinition &&
										B.parent.tagDefinition.ignoreFirstLf
									)
										return B.type === 'interpolation'
									return _e
									function st() {
										return D(B)
											? !1
											: (B.type === 'text' || B.type === 'interpolation') &&
											  B.prev &&
											  (B.prev.type === 'text' || B.prev.type === 'interpolation')
											? !0
											: !B.parent || B.parent.cssDisplay === 'none'
											? !1
											: Ce(B.parent)
											? !0
											: !(
													(!B.prev &&
														(B.parent.type === 'root' ||
															(Ce(B) && B.parent) ||
															m(B.parent) ||
															se(B.parent, pe) ||
															!Me(B.parent.cssDisplay))) ||
													(B.prev && !ae(B.prev.cssDisplay))
											  )
									}
								}
								function V(B, pe) {
									return D(B)
										? !1
										: (B.type === 'text' || B.type === 'interpolation') &&
										  B.next &&
										  (B.next.type === 'text' || B.next.type === 'interpolation')
										? !0
										: !B.parent || B.parent.cssDisplay === 'none'
										? !1
										: Ce(B.parent)
										? !0
										: !(
												(!B.next &&
													(B.parent.type === 'root' ||
														(Ce(B) && B.parent) ||
														m(B.parent) ||
														se(B.parent, pe) ||
														!Dt(B.parent.cssDisplay))) ||
												(B.next && !me(B.next.cssDisplay))
										  )
								}
								function J(B) {
									return xe(B.cssDisplay) && !m(B)
								}
								function Z(B) {
									return (
										D(B) ||
										(B.next &&
											B.sourceSpan.end &&
											B.sourceSpan.end.line + 1 < B.next.sourceSpan.start.line)
									)
								}
								function ne(B) {
									return (
										ee(B) ||
										(B.type === 'element' &&
											B.children.length > 0 &&
											(['body', 'script', 'style'].includes(B.name) ||
												B.children.some((pe) => ve(pe)))) ||
										(B.firstChild &&
											B.firstChild === B.lastChild &&
											B.firstChild.type !== 'text' &&
											te(B.firstChild) &&
											(!B.lastChild.isTrailingSpaceSensitive || X(B.lastChild)))
									)
								}
								function ee(B) {
									return (
										B.type === 'element' &&
										B.children.length > 0 &&
										(['html', 'head', 'ul', 'ol', 'select'].includes(B.name) ||
											(B.cssDisplay.startsWith('table') && B.cssDisplay !== 'table-cell'))
									)
								}
								function ce(B) {
									return De(B) || (B.prev && z(B.prev)) || ye(B)
								}
								function z(B) {
									return De(B) || (B.type === 'element' && B.fullName === 'br') || ye(B)
								}
								function ye(B) {
									return te(B) && X(B)
								}
								function te(B) {
									return (
										B.hasLeadingSpaces &&
										(B.prev
											? B.prev.sourceSpan.end.line < B.sourceSpan.start.line
											: B.parent.type === 'root' ||
											  B.parent.startSourceSpan.end.line < B.sourceSpan.start.line)
									)
								}
								function X(B) {
									return (
										B.hasTrailingSpaces &&
										(B.next
											? B.next.sourceSpan.start.line > B.sourceSpan.end.line
											: B.parent.type === 'root' ||
											  (B.parent.endSourceSpan &&
													B.parent.endSourceSpan.start.line > B.sourceSpan.end.line))
									)
								}
								function De(B) {
									switch (B.type) {
										case 'ieConditionalComment':
										case 'comment':
										case 'directive':
											return !0
										case 'element':
											return ['script', 'select'].includes(B.name)
									}
									return !1
								}
								function Fe(B) {
									return B.lastChild ? Fe(B.lastChild) : B
								}
								function ve(B) {
									return B.children && B.children.some((pe) => pe.type !== 'text')
								}
								function $e(B) {
									let { type: pe, lang: _e } = B.attrMap
									if (
										pe === 'module' ||
										pe === 'text/javascript' ||
										pe === 'text/babel' ||
										pe === 'application/javascript' ||
										_e === 'jsx'
									)
										return 'babel'
									if (pe === 'application/x-typescript' || _e === 'ts' || _e === 'tsx')
										return 'typescript'
									if (pe === 'text/markdown') return 'markdown'
									if (pe === 'text/html') return 'html'
									if (
										(pe && (pe.endsWith('json') || pe.endsWith('importmap'))) ||
										pe === 'speculationrules'
									)
										return 'json'
									if (pe === 'text/x-handlebars-template') return 'glimmer'
								}
								function ie(B, pe) {
									let { lang: _e } = B.attrMap
									if (!_e || _e === 'postcss' || _e === 'css') return 'css'
									if (_e === 'scss') return 'scss'
									if (_e === 'less') return 'less'
									if (_e === 'stylus') return c('stylus', pe)
								}
								function fe(B, pe) {
									if (B.name === 'script' && !B.attrMap.src)
										return !B.attrMap.lang && !B.attrMap.type ? 'babel' : $e(B)
									if (B.name === 'style') return ie(B, pe)
									if (pe && he(B, pe))
										return $e(B) || (!('src' in B.attrMap) && c(B.attrMap.lang, pe))
								}
								function Be(B) {
									return B === 'block' || B === 'list-item' || B.startsWith('table')
								}
								function Me(B) {
									return !Be(B) && B !== 'inline-block'
								}
								function Dt(B) {
									return !Be(B) && B !== 'inline-block'
								}
								function me(B) {
									return !Be(B)
								}
								function ae(B) {
									return !Be(B)
								}
								function xe(B) {
									return !Be(B) && B !== 'inline-block'
								}
								function Ce(B) {
									return Ut(B).startsWith('pre')
								}
								function Ge(B, pe) {
									let _e = 0
									for (let st = B.stack.length - 1; st >= 0; st--) {
										let pt = B.stack[st]
										pt && typeof pt == 'object' && !Array.isArray(pt) && pe(pt) && _e++
									}
									return _e
								}
								function nt(B, pe) {
									let _e = B
									for (; _e; ) {
										if (pe(_e)) return !0
										_e = _e.parent
									}
									return !1
								}
								function ot(B, pe) {
									if (B.prev && B.prev.type === 'comment') {
										let st = B.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/)
										if (st) return st[1]
									}
									let _e = !1
									if (B.type === 'element' && B.namespace === 'svg')
										if (nt(B, (st) => st.fullName === 'svg:foreignObject')) _e = !0
										else return B.name === 'svg' ? 'inline-block' : 'block'
									switch (pe.htmlWhitespaceSensitivity) {
										case 'strict':
											return 'inline'
										case 'ignore':
											return 'block'
										default:
											return pe.parser === 'vue' && B.parent && B.parent.type === 'root'
												? 'block'
												: (B.type === 'element' && (!B.namespace || _e || v(B)) && x[B.name]) || _
									}
								}
								function Ut(B) {
									return (B.type === 'element' && (!B.namespace || v(B)) && w[B.name]) || C
								}
								function vn(B) {
									let pe = Number.POSITIVE_INFINITY
									for (let _e of B.split(`
`)) {
										if (_e.length === 0) continue
										if (!b.has(_e[0])) return 0
										let st = H(_e).length
										_e.length !== st && st < pe && (pe = st)
									}
									return pe === Number.POSITIVE_INFINITY ? 0 : pe
								}
								function Dn(B) {
									let pe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : vn(B)
									return pe === 0
										? B
										: B.split(
												`
`
										  ).map((_e) => _e.slice(pe)).join(`
`)
								}
								function Vt(B, pe) {
									let _e = 0
									for (let st = 0; st < B.length; st++) B[st] === pe && _e++
									return _e
								}
								function tn(B) {
									return B.replace(/&apos;/g, "'").replace(/&quot;/g, '"')
								}
								var Ie = new Set(['template', 'style', 'script'])
								function se(B, pe) {
									return je(B, pe) && !Ie.has(B.fullName)
								}
								function je(B, pe) {
									return (
										pe.parser === 'vue' &&
										B.type === 'element' &&
										B.parent.type === 'root' &&
										B.fullName.toLowerCase() !== 'html'
									)
								}
								function he(B, pe) {
									return je(B, pe) && (se(B, pe) || (B.attrMap.lang && B.attrMap.lang !== 'html'))
								}
								function Oe(B) {
									let pe = B.fullName
									return (
										pe.charAt(0) === '#' ||
										pe === 'slot-scope' ||
										pe === 'v-slot' ||
										pe.startsWith('v-slot:')
									)
								}
								function wt(B, pe) {
									let _e = B.parent
									if (!je(_e, pe)) return !1
									let st = _e.fullName,
										pt = B.fullName
									return (st === 'script' && pt === 'setup') || (st === 'style' && pt === 'vars')
								}
								function mt(B) {
									let pe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : B.value
									return B.parent.isWhitespaceSensitive
										? B.parent.isIndentationSensitive
											? y(pe)
											: y(Dn(U(pe)), l)
										: f(p(g, j(pe)))
								}
								function Ue(B, pe) {
									return je(B, pe) && B.name === 'script'
								}
								E.exports = {
									htmlTrim: G,
									htmlTrimPreserveIndentation: U,
									hasHtmlWhitespace: re,
									getLeadingAndTrailingHtmlWhitespace: W,
									canHaveInterpolation: S,
									countChars: Vt,
									countParents: Ge,
									dedentString: Dn,
									forceBreakChildren: ee,
									forceBreakContent: ne,
									forceNextEmptyLine: Z,
									getLastDescendant: Fe,
									getNodeCssStyleDisplay: ot,
									getNodeCssStyleWhiteSpace: Ut,
									hasPrettierIgnore: $,
									inferScriptParser: fe,
									isVueCustomBlock: se,
									isVueNonHtmlBlock: he,
									isVueScriptTag: Ue,
									isVueSlotAttribute: Oe,
									isVueSfcBindingsAttribute: wt,
									isVueSfcBlock: je,
									isDanglingSpaceSensitiveNode: J,
									isIndentationSensitiveNode: P,
									isLeadingSpaceSensitiveNode: M,
									isPreLikeNode: Ce,
									isScriptLikeTag: m,
									isTextLikeNode: R,
									isTrailingSpaceSensitiveNode: V,
									isWhitespaceSensitiveNode: L,
									isUnknownNamespace: v,
									preferHardlineAsLeadingSpaces: ce,
									preferHardlineAsTrailingSpaces: z,
									shouldPreserveContent: A,
									unescapeQuoteEntities: tn,
									getTextValueParts: mt
								}
							}
						}),
						$E = le({
							'node_modules/angular-html-parser/lib/compiler/src/chars.js'(d) {
								'use strict'
								ge(),
									Object.defineProperty(d, '__esModule', { value: !0 }),
									(d.$EOF = 0),
									(d.$BSPACE = 8),
									(d.$TAB = 9),
									(d.$LF = 10),
									(d.$VTAB = 11),
									(d.$FF = 12),
									(d.$CR = 13),
									(d.$SPACE = 32),
									(d.$BANG = 33),
									(d.$DQ = 34),
									(d.$HASH = 35),
									(d.$$ = 36),
									(d.$PERCENT = 37),
									(d.$AMPERSAND = 38),
									(d.$SQ = 39),
									(d.$LPAREN = 40),
									(d.$RPAREN = 41),
									(d.$STAR = 42),
									(d.$PLUS = 43),
									(d.$COMMA = 44),
									(d.$MINUS = 45),
									(d.$PERIOD = 46),
									(d.$SLASH = 47),
									(d.$COLON = 58),
									(d.$SEMICOLON = 59),
									(d.$LT = 60),
									(d.$EQ = 61),
									(d.$GT = 62),
									(d.$QUESTION = 63),
									(d.$0 = 48),
									(d.$7 = 55),
									(d.$9 = 57),
									(d.$A = 65),
									(d.$E = 69),
									(d.$F = 70),
									(d.$X = 88),
									(d.$Z = 90),
									(d.$LBRACKET = 91),
									(d.$BACKSLASH = 92),
									(d.$RBRACKET = 93),
									(d.$CARET = 94),
									(d.$_ = 95),
									(d.$a = 97),
									(d.$b = 98),
									(d.$e = 101),
									(d.$f = 102),
									(d.$n = 110),
									(d.$r = 114),
									(d.$t = 116),
									(d.$u = 117),
									(d.$v = 118),
									(d.$x = 120),
									(d.$z = 122),
									(d.$LBRACE = 123),
									(d.$BAR = 124),
									(d.$RBRACE = 125),
									(d.$NBSP = 160),
									(d.$PIPE = 124),
									(d.$TILDA = 126),
									(d.$AT = 64),
									(d.$BT = 96)
								function E(f) {
									return (f >= d.$TAB && f <= d.$SPACE) || f == d.$NBSP
								}
								d.isWhitespace = E
								function c(f) {
									return d.$0 <= f && f <= d.$9
								}
								d.isDigit = c
								function D(f) {
									return (f >= d.$a && f <= d.$z) || (f >= d.$A && f <= d.$Z)
								}
								d.isAsciiLetter = D
								function g(f) {
									return (f >= d.$a && f <= d.$f) || (f >= d.$A && f <= d.$F) || c(f)
								}
								d.isAsciiHexDigit = g
								function l(f) {
									return f === d.$LF || f === d.$CR
								}
								d.isNewLine = l
								function p(f) {
									return d.$0 <= f && f <= d.$7
								}
								d.isOctalDigit = p
							}
						}),
						VE = le({
							'node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = class {
									constructor(D, g, l) {
										;(this.filePath = D), (this.name = g), (this.members = l)
									}
									assertNoMembers() {
										if (this.members.length)
											throw new Error(
												`Illegal state: symbol without members expected, but got ${JSON.stringify(
													this
												)}.`
											)
									}
								}
								d.StaticSymbol = E
								var c = class {
									constructor() {
										this.cache = new Map()
									}
									get(D, g, l) {
										l = l || []
										let p = l.length ? `.${l.join('.')}` : '',
											f = `"${D}".${g}${p}`,
											y = this.cache.get(f)
										return y || ((y = new E(D, g, l)), this.cache.set(f, y)), y
									}
								}
								d.StaticSymbolCache = c
							}
						}),
						UE = le({
							'node_modules/angular-html-parser/lib/compiler/src/util.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = /-+([a-z0-9])/g
								function c(m) {
									return m.replace(E, function () {
										for (var S = arguments.length, L = new Array(S), P = 0; P < S; P++)
											L[P] = arguments[P]
										return L[1].toUpperCase()
									})
								}
								d.dashCaseToCamelCase = c
								function D(m, S) {
									return l(m, ':', S)
								}
								d.splitAtColon = D
								function g(m, S) {
									return l(m, '.', S)
								}
								d.splitAtPeriod = g
								function l(m, S, L) {
									let P = m.indexOf(S)
									return P == -1 ? L : [m.slice(0, P).trim(), m.slice(P + 1).trim()]
								}
								function p(m, S, L) {
									return Array.isArray(m)
										? S.visitArray(m, L)
										: O(m)
										? S.visitStringMap(m, L)
										: m == null ||
										  typeof m == 'string' ||
										  typeof m == 'number' ||
										  typeof m == 'boolean'
										? S.visitPrimitive(m, L)
										: S.visitOther(m, L)
								}
								d.visitValue = p
								function f(m) {
									return m != null
								}
								d.isDefined = f
								function y(m) {
									return m === void 0 ? null : m
								}
								d.noUndefined = y
								var x = class {
									visitArray(m, S) {
										return m.map((L) => p(L, this, S))
									}
									visitStringMap(m, S) {
										let L = {}
										return (
											Object.keys(m).forEach((P) => {
												L[P] = p(m[P], this, S)
											}),
											L
										)
									}
									visitPrimitive(m, S) {
										return m
									}
									visitOther(m, S) {
										return m
									}
								}
								;(d.ValueTransformer = x),
									(d.SyncAsync = {
										assertSync: (m) => {
											if (W(m)) throw new Error('Illegal state: value cannot be a promise')
											return m
										},
										then: (m, S) => (W(m) ? m.then(S) : S(m)),
										all: (m) => (m.some(W) ? Promise.all(m) : m)
									})
								function _(m) {
									throw new Error(`Internal Error: ${m}`)
								}
								d.error = _
								function w(m, S) {
									let L = Error(m)
									return (L[C] = !0), S && (L[v] = S), L
								}
								d.syntaxError = w
								var C = 'ngSyntaxError',
									v = 'ngParseErrors'
								function b(m) {
									return m[C]
								}
								d.isSyntaxError = b
								function k(m) {
									return m[v] || []
								}
								d.getParseErrors = k
								function q(m) {
									return m.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1')
								}
								d.escapeRegExp = q
								var G = Object.getPrototypeOf({})
								function O(m) {
									return typeof m == 'object' && m !== null && Object.getPrototypeOf(m) === G
								}
								function U(m) {
									let S = ''
									for (let L = 0; L < m.length; L++) {
										let P = m.charCodeAt(L)
										if (P >= 55296 && P <= 56319 && m.length > L + 1) {
											let M = m.charCodeAt(L + 1)
											M >= 56320 &&
												M <= 57343 &&
												(L++, (P = ((P - 55296) << 10) + M - 56320 + 65536))
										}
										P <= 127
											? (S += String.fromCharCode(P))
											: P <= 2047
											? (S += String.fromCharCode(((P >> 6) & 31) | 192, (P & 63) | 128))
											: P <= 65535
											? (S += String.fromCharCode(
													(P >> 12) | 224,
													((P >> 6) & 63) | 128,
													(P & 63) | 128
											  ))
											: P <= 2097151 &&
											  (S += String.fromCharCode(
													((P >> 18) & 7) | 240,
													((P >> 12) & 63) | 128,
													((P >> 6) & 63) | 128,
													(P & 63) | 128
											  ))
									}
									return S
								}
								d.utf8Encode = U
								function j(m) {
									if (typeof m == 'string') return m
									if (m instanceof Array) return '[' + m.map(j).join(', ') + ']'
									if (m == null) return '' + m
									if (m.overriddenName) return `${m.overriddenName}`
									if (m.name) return `${m.name}`
									if (!m.toString) return 'object'
									let S = m.toString()
									if (S == null) return '' + S
									let L = S.indexOf(`
`)
									return L === -1 ? S : S.substring(0, L)
								}
								d.stringify = j
								function H(m) {
									return typeof m == 'function' && m.hasOwnProperty('__forward_ref__') ? m() : m
								}
								d.resolveForwardRef = H
								function W(m) {
									return !!m && typeof m.then == 'function'
								}
								d.isPromise = W
								var re = class {
									constructor(m) {
										this.full = m
										let S = m.split('.')
										;(this.major = S[0]), (this.minor = S[1]), (this.patch = S.slice(2).join('.'))
									}
								}
								d.Version = re
								var A = typeof window < 'u' && window,
									$ =
										typeof self < 'u' &&
										typeof WorkerGlobalScope < 'u' &&
										self instanceof WorkerGlobalScope &&
										self,
									T = typeof globalThis < 'u' && globalThis,
									R = T || A || $
								d.global = R
							}
						}),
						qE = le({
							'node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = VE(),
									c = UE(),
									D = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/
								function g(L) {
									return L.replace(/\W/g, '_')
								}
								d.sanitizeIdentifier = g
								var l = 0
								function p(L) {
									if (!L || !L.reference) return null
									let P = L.reference
									if (P instanceof E.StaticSymbol) return P.name
									if (P.__anonymousType) return P.__anonymousType
									let M = c.stringify(P)
									return (
										M.indexOf('(') >= 0
											? ((M = `anonymous_${l++}`), (P.__anonymousType = M))
											: (M = g(M)),
										M
									)
								}
								d.identifierName = p
								function f(L) {
									let P = L.reference
									return P instanceof E.StaticSymbol ? P.filePath : `./${c.stringify(P)}`
								}
								d.identifierModuleUrl = f
								function y(L, P) {
									return `View_${p({ reference: L })}_${P}`
								}
								d.viewClassName = y
								function x(L) {
									return `RenderType_${p({ reference: L })}`
								}
								d.rendererTypeName = x
								function _(L) {
									return `HostView_${p({ reference: L })}`
								}
								d.hostViewClassName = _
								function w(L) {
									return `${p({ reference: L })}NgFactory`
								}
								d.componentFactoryName = w
								var C
								;(function (L) {
									;(L[(L.Pipe = 0)] = 'Pipe'),
										(L[(L.Directive = 1)] = 'Directive'),
										(L[(L.NgModule = 2)] = 'NgModule'),
										(L[(L.Injectable = 3)] = 'Injectable')
								})((C = d.CompileSummaryKind || (d.CompileSummaryKind = {})))
								function v(L) {
									return L.value != null ? g(L.value) : p(L.identifier)
								}
								d.tokenName = v
								function b(L) {
									return L.identifier != null ? L.identifier.reference : L.value
								}
								d.tokenReference = b
								var k = class {
									constructor() {
										let {
											moduleUrl: L,
											styles: P,
											styleUrls: M
										} = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
										;(this.moduleUrl = L || null), (this.styles = W(P)), (this.styleUrls = W(M))
									}
								}
								d.CompileStylesheetMetadata = k
								var q = class {
									constructor(L) {
										let {
											encapsulation: P,
											template: M,
											templateUrl: V,
											htmlAst: J,
											styles: Z,
											styleUrls: ne,
											externalStylesheets: ee,
											animations: ce,
											ngContentSelectors: z,
											interpolation: ye,
											isInline: te,
											preserveWhitespaces: X
										} = L
										if (
											((this.encapsulation = P),
											(this.template = M),
											(this.templateUrl = V),
											(this.htmlAst = J),
											(this.styles = W(Z)),
											(this.styleUrls = W(ne)),
											(this.externalStylesheets = W(ee)),
											(this.animations = ce ? A(ce) : []),
											(this.ngContentSelectors = z || []),
											ye && ye.length != 2)
										)
											throw new Error("'interpolation' should have a start and an end symbol.")
										;(this.interpolation = ye), (this.isInline = te), (this.preserveWhitespaces = X)
									}
									toSummary() {
										return {
											ngContentSelectors: this.ngContentSelectors,
											encapsulation: this.encapsulation,
											styles: this.styles,
											animations: this.animations
										}
									}
								}
								d.CompileTemplateMetadata = q
								var G = class {
									static create(L) {
										let {
												isHost: P,
												type: M,
												isComponent: V,
												selector: J,
												exportAs: Z,
												changeDetection: ne,
												inputs: ee,
												outputs: ce,
												host: z,
												providers: ye,
												viewProviders: te,
												queries: X,
												guards: De,
												viewQueries: Fe,
												entryComponents: ve,
												template: $e,
												componentViewType: ie,
												rendererType: fe,
												componentFactory: Be
											} = L,
											Me = {},
											Dt = {},
											me = {}
										z != null &&
											Object.keys(z).forEach((Ce) => {
												let Ge = z[Ce],
													nt = Ce.match(D)
												nt === null
													? (me[Ce] = Ge)
													: nt[1] != null
													? (Dt[nt[1]] = Ge)
													: nt[2] != null && (Me[nt[2]] = Ge)
											})
										let ae = {}
										ee?.forEach((Ce) => {
											let Ge = c.splitAtColon(Ce, [Ce, Ce])
											ae[Ge[0]] = Ge[1]
										})
										let xe = {}
										return (
											ce?.forEach((Ce) => {
												let Ge = c.splitAtColon(Ce, [Ce, Ce])
												xe[Ge[0]] = Ge[1]
											}),
											new G({
												isHost: P,
												type: M,
												isComponent: !!V,
												selector: J,
												exportAs: Z,
												changeDetection: ne,
												inputs: ae,
												outputs: xe,
												hostListeners: Me,
												hostProperties: Dt,
												hostAttributes: me,
												providers: ye,
												viewProviders: te,
												queries: X,
												guards: De,
												viewQueries: Fe,
												entryComponents: ve,
												template: $e,
												componentViewType: ie,
												rendererType: fe,
												componentFactory: Be
											})
										)
									}
									constructor(L) {
										let {
											isHost: P,
											type: M,
											isComponent: V,
											selector: J,
											exportAs: Z,
											changeDetection: ne,
											inputs: ee,
											outputs: ce,
											hostListeners: z,
											hostProperties: ye,
											hostAttributes: te,
											providers: X,
											viewProviders: De,
											queries: Fe,
											guards: ve,
											viewQueries: $e,
											entryComponents: ie,
											template: fe,
											componentViewType: Be,
											rendererType: Me,
											componentFactory: Dt
										} = L
										;(this.isHost = !!P),
											(this.type = M),
											(this.isComponent = V),
											(this.selector = J),
											(this.exportAs = Z),
											(this.changeDetection = ne),
											(this.inputs = ee),
											(this.outputs = ce),
											(this.hostListeners = z),
											(this.hostProperties = ye),
											(this.hostAttributes = te),
											(this.providers = W(X)),
											(this.viewProviders = W(De)),
											(this.queries = W(Fe)),
											(this.guards = ve),
											(this.viewQueries = W($e)),
											(this.entryComponents = W(ie)),
											(this.template = fe),
											(this.componentViewType = Be),
											(this.rendererType = Me),
											(this.componentFactory = Dt)
									}
									toSummary() {
										return {
											summaryKind: C.Directive,
											type: this.type,
											isComponent: this.isComponent,
											selector: this.selector,
											exportAs: this.exportAs,
											inputs: this.inputs,
											outputs: this.outputs,
											hostListeners: this.hostListeners,
											hostProperties: this.hostProperties,
											hostAttributes: this.hostAttributes,
											providers: this.providers,
											viewProviders: this.viewProviders,
											queries: this.queries,
											guards: this.guards,
											viewQueries: this.viewQueries,
											entryComponents: this.entryComponents,
											changeDetection: this.changeDetection,
											template: this.template && this.template.toSummary(),
											componentViewType: this.componentViewType,
											rendererType: this.rendererType,
											componentFactory: this.componentFactory
										}
									}
								}
								d.CompileDirectiveMetadata = G
								var O = class {
									constructor(L) {
										let { type: P, name: M, pure: V } = L
										;(this.type = P), (this.name = M), (this.pure = !!V)
									}
									toSummary() {
										return {
											summaryKind: C.Pipe,
											type: this.type,
											name: this.name,
											pure: this.pure
										}
									}
								}
								d.CompilePipeMetadata = O
								var U = class {}
								d.CompileShallowModuleMetadata = U
								var j = class {
									constructor(L) {
										let {
											type: P,
											providers: M,
											declaredDirectives: V,
											exportedDirectives: J,
											declaredPipes: Z,
											exportedPipes: ne,
											entryComponents: ee,
											bootstrapComponents: ce,
											importedModules: z,
											exportedModules: ye,
											schemas: te,
											transitiveModule: X,
											id: De
										} = L
										;(this.type = P || null),
											(this.declaredDirectives = W(V)),
											(this.exportedDirectives = W(J)),
											(this.declaredPipes = W(Z)),
											(this.exportedPipes = W(ne)),
											(this.providers = W(M)),
											(this.entryComponents = W(ee)),
											(this.bootstrapComponents = W(ce)),
											(this.importedModules = W(z)),
											(this.exportedModules = W(ye)),
											(this.schemas = W(te)),
											(this.id = De || null),
											(this.transitiveModule = X || null)
									}
									toSummary() {
										let L = this.transitiveModule
										return {
											summaryKind: C.NgModule,
											type: this.type,
											entryComponents: L.entryComponents,
											providers: L.providers,
											modules: L.modules,
											exportedDirectives: L.exportedDirectives,
											exportedPipes: L.exportedPipes
										}
									}
								}
								d.CompileNgModuleMetadata = j
								var H = class {
									constructor() {
										;(this.directivesSet = new Set()),
											(this.directives = []),
											(this.exportedDirectivesSet = new Set()),
											(this.exportedDirectives = []),
											(this.pipesSet = new Set()),
											(this.pipes = []),
											(this.exportedPipesSet = new Set()),
											(this.exportedPipes = []),
											(this.modulesSet = new Set()),
											(this.modules = []),
											(this.entryComponentsSet = new Set()),
											(this.entryComponents = []),
											(this.providers = [])
									}
									addProvider(L, P) {
										this.providers.push({ provider: L, module: P })
									}
									addDirective(L) {
										this.directivesSet.has(L.reference) ||
											(this.directivesSet.add(L.reference), this.directives.push(L))
									}
									addExportedDirective(L) {
										this.exportedDirectivesSet.has(L.reference) ||
											(this.exportedDirectivesSet.add(L.reference), this.exportedDirectives.push(L))
									}
									addPipe(L) {
										this.pipesSet.has(L.reference) ||
											(this.pipesSet.add(L.reference), this.pipes.push(L))
									}
									addExportedPipe(L) {
										this.exportedPipesSet.has(L.reference) ||
											(this.exportedPipesSet.add(L.reference), this.exportedPipes.push(L))
									}
									addModule(L) {
										this.modulesSet.has(L.reference) ||
											(this.modulesSet.add(L.reference), this.modules.push(L))
									}
									addEntryComponent(L) {
										this.entryComponentsSet.has(L.componentType) ||
											(this.entryComponentsSet.add(L.componentType), this.entryComponents.push(L))
									}
								}
								d.TransitiveCompileNgModuleMetadata = H
								function W(L) {
									return L || []
								}
								var re = class {
									constructor(L, P) {
										let {
											useClass: M,
											useValue: V,
											useExisting: J,
											useFactory: Z,
											deps: ne,
											multi: ee
										} = P
										;(this.token = L),
											(this.useClass = M || null),
											(this.useValue = V),
											(this.useExisting = J),
											(this.useFactory = Z || null),
											(this.dependencies = ne || null),
											(this.multi = !!ee)
									}
								}
								d.ProviderMeta = re
								function A(L) {
									return L.reduce((P, M) => {
										let V = Array.isArray(M) ? A(M) : M
										return P.concat(V)
									}, [])
								}
								d.flatten = A
								function $(L) {
									return L.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, 'ng:///')
								}
								function T(L, P, M) {
									let V
									return (
										M.isInline
											? P.type.reference instanceof E.StaticSymbol
												? (V = `${P.type.reference.filePath}.${P.type.reference.name}.html`)
												: (V = `${p(L)}/${p(P.type)}.html`)
											: (V = M.templateUrl),
										P.type.reference instanceof E.StaticSymbol ? V : $(V)
									)
								}
								d.templateSourceUrl = T
								function R(L, P) {
									let M = L.moduleUrl.split(/\/\\/g),
										V = M[M.length - 1]
									return $(`css/${P}${V}.ngstyle.js`)
								}
								d.sharedStylesheetJitUrl = R
								function m(L) {
									return $(`${p(L.type)}/module.ngfactory.js`)
								}
								d.ngModuleJitUrl = m
								function S(L, P) {
									return $(`${p(L)}/${p(P.type)}.ngfactory.js`)
								}
								d.templateJitUrl = S
							}
						}),
						GE = le({
							'node_modules/angular-html-parser/lib/compiler/src/parse_util.js'(d) {
								'use strict'
								ge(), Object.defineProperty(d, '__esModule', { value: !0 })
								var E = $E(),
									c = qE(),
									D = class {
										constructor(_, w, C, v) {
											;(this.file = _), (this.offset = w), (this.line = C), (this.col = v)
										}
										toString() {
											return this.offset != null
												? `${this.file.url}@${this.line}:${this.col}`
												: this.file.url
										}
										moveBy(_) {
											let w = this.file.content,
												C = w.length,
												v = this.offset,
												b = this.line,
												k = this.col
											for (; v > 0 && _ < 0; )
												if ((v--, _++, w.charCodeAt(v) == E.$LF)) {
													b--
													let q = w.substr(0, v - 1).lastIndexOf(String.fromCharCode(E.$LF))
													k = q > 0 ? v - q : v
												} else k--
											for (; v < C && _ > 0; ) {
												let q = w.charCodeAt(v)
												v++, _--, q == E.$LF ? (b++, (k = 0)) : k++
											}
											return new D(this.file, v, b, k)
										}
										getContext(_, w) {
											let C = this.file.content,
												v = this.offset
											if (v != null) {
												v > C.length - 1 && (v = C.length - 1)
												let b = v,
													k = 0,
													q = 0
												for (
													;
													k < _ &&
													v > 0 &&
													(v--,
													k++,
													!(
														C[v] ==
															`
` && ++q == w
													));

												);
												for (
													k = 0, q = 0;
													k < _ &&
													b < C.length - 1 &&
													(b++,
													k++,
													!(
														C[b] ==
															`
` && ++q == w
													));

												);
												return {
													before: C.substring(v, this.offset),
													after: C.substring(this.offset, b + 1)
												}
											}
											return null
										}
									}
								d.ParseLocation = D
								var g = class {
									constructor(_, w) {
										;(this.content = _), (this.url = w)
									}
								}
								d.ParseSourceFile = g
								var l = class {
									constructor(_, w) {
										let C = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null
										;(this.start = _), (this.end = w), (this.details = C)
									}
									toString() {
										return this.start.file.content.substring(this.start.offset, this.end.offset)
									}
								}
								;(d.ParseSourceSpan = l),
									(d.EMPTY_PARSE_LOCATION = new D(new g('', ''), 0, 0, 0)),
									(d.EMPTY_SOURCE_SPAN = new l(d.EMPTY_PARSE_LOCATION, d.EMPTY_PARSE_LOCATION))
								var p
								;(function (_) {
									;(_[(_.WARNING = 0)] = 'WARNING'), (_[(_.ERROR = 1)] = 'ERROR')
								})((p = d.ParseErrorLevel || (d.ParseErrorLevel = {})))
								var f = class {
									constructor(_, w) {
										let C = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : p.ERROR
										;(this.span = _), (this.msg = w), (this.level = C)
									}
									contextualMessage() {
										let _ = this.span.start.getContext(100, 3)
										return _
											? `${this.msg} ("${_.before}[${p[this.level]} ->]${_.after}")`
											: this.msg
									}
									toString() {
										let _ = this.span.details ? `, ${this.span.details}` : ''
										return `${this.contextualMessage()}: ${this.span.start}${_}`
									}
								}
								d.ParseError = f
								function y(_, w) {
									let C = c.identifierModuleUrl(w),
										v =
											C != null
												? `in ${_} ${c.identifierName(w)} in ${C}`
												: `in ${_} ${c.identifierName(w)}`,
										b = new g('', v)
									return new l(new D(b, -1, -1, -1), new D(b, -1, -1, -1))
								}
								d.typeSourceSpan = y
								function x(_, w, C) {
									let v = `in ${_} ${w} in ${C}`,
										b = new g('', v)
									return new l(new D(b, -1, -1, -1), new D(b, -1, -1, -1))
								}
								d.r3JitTypeSourceSpan = x
							}
						}),
						WE = le({
							'src/language-html/print-preprocess.js'(d, E) {
								'use strict'
								ge()
								var { ParseSourceSpan: c } = GE(),
									{
										htmlTrim: D,
										getLeadingAndTrailingHtmlWhitespace: g,
										hasHtmlWhitespace: l,
										canHaveInterpolation: p,
										getNodeCssStyleDisplay: f,
										isDanglingSpaceSensitiveNode: y,
										isIndentationSensitiveNode: x,
										isLeadingSpaceSensitiveNode: _,
										isTrailingSpaceSensitiveNode: w,
										isWhitespaceSensitiveNode: C,
										isVueScriptTag: v
									} = bo(),
									b = [q, G, U, H, W, $, re, A, T, j, R]
								function k(m, S) {
									for (let L of b) L(m, S)
									return m
								}
								function q(m) {
									m.walk((S) => {
										if (
											S.type === 'element' &&
											S.tagDefinition.ignoreFirstLf &&
											S.children.length > 0 &&
											S.children[0].type === 'text' &&
											S.children[0].value[0] ===
												`
`
										) {
											let L = S.children[0]
											L.value.length === 1 ? S.removeChild(L) : (L.value = L.value.slice(1))
										}
									})
								}
								function G(m) {
									let S = (L) =>
										L.type === 'element' &&
										L.prev &&
										L.prev.type === 'ieConditionalStartComment' &&
										L.prev.sourceSpan.end.offset === L.startSourceSpan.start.offset &&
										L.firstChild &&
										L.firstChild.type === 'ieConditionalEndComment' &&
										L.firstChild.sourceSpan.start.offset === L.startSourceSpan.end.offset
									m.walk((L) => {
										if (L.children)
											for (let P = 0; P < L.children.length; P++) {
												let M = L.children[P]
												if (!S(M)) continue
												let V = M.prev,
													J = M.firstChild
												L.removeChild(V), P--
												let Z = new c(V.sourceSpan.start, J.sourceSpan.end),
													ne = new c(Z.start, M.sourceSpan.end)
												;(M.condition = V.condition),
													(M.sourceSpan = ne),
													(M.startSourceSpan = Z),
													M.removeChild(J)
											}
									})
								}
								function O(m, S, L) {
									m.walk((P) => {
										if (P.children)
											for (let M = 0; M < P.children.length; M++) {
												let V = P.children[M]
												if (V.type !== 'text' && !S(V)) continue
												V.type !== 'text' && ((V.type = 'text'), (V.value = L(V)))
												let J = V.prev
												!J ||
													J.type !== 'text' ||
													((J.value += V.value),
													(J.sourceSpan = new c(J.sourceSpan.start, V.sourceSpan.end)),
													P.removeChild(V),
													M--)
											}
									})
								}
								function U(m) {
									return O(
										m,
										(S) => S.type === 'cdata',
										(S) => `<![CDATA[${S.value}]]>`
									)
								}
								function j(m) {
									let S = (L) =>
										L.type === 'element' &&
										L.attrs.length === 0 &&
										L.children.length === 1 &&
										L.firstChild.type === 'text' &&
										!l(L.children[0].value) &&
										!L.firstChild.hasLeadingSpaces &&
										!L.firstChild.hasTrailingSpaces &&
										L.isLeadingSpaceSensitive &&
										!L.hasLeadingSpaces &&
										L.isTrailingSpaceSensitive &&
										!L.hasTrailingSpaces &&
										L.prev &&
										L.prev.type === 'text' &&
										L.next &&
										L.next.type === 'text'
									m.walk((L) => {
										if (L.children)
											for (let P = 0; P < L.children.length; P++) {
												let M = L.children[P]
												if (!S(M)) continue
												let V = M.prev,
													J = M.next
												;(V.value +=
													`<${M.rawName}>` + M.firstChild.value + `</${M.rawName}>` + J.value),
													(V.sourceSpan = new c(V.sourceSpan.start, J.sourceSpan.end)),
													(V.isTrailingSpaceSensitive = J.isTrailingSpaceSensitive),
													(V.hasTrailingSpaces = J.hasTrailingSpaces),
													L.removeChild(M),
													P--,
													L.removeChild(J)
											}
									})
								}
								function H(m, S) {
									if (S.parser === 'html') return
									let L = /{{(.+?)}}/s
									m.walk((P) => {
										if (p(P))
											for (let M of P.children) {
												if (M.type !== 'text') continue
												let V = M.sourceSpan.start,
													J = null,
													Z = M.value.split(L)
												for (let ne = 0; ne < Z.length; ne++, V = J) {
													let ee = Z[ne]
													if (ne % 2 === 0) {
														;(J = V.moveBy(ee.length)),
															ee.length > 0 &&
																P.insertChildBefore(M, {
																	type: 'text',
																	value: ee,
																	sourceSpan: new c(V, J)
																})
														continue
													}
													;(J = V.moveBy(ee.length + 4)),
														P.insertChildBefore(M, {
															type: 'interpolation',
															sourceSpan: new c(V, J),
															children:
																ee.length === 0
																	? []
																	: [
																			{
																				type: 'text',
																				value: ee,
																				sourceSpan: new c(V.moveBy(2), J.moveBy(-2))
																			}
																	  ]
														})
												}
												P.removeChild(M)
											}
									})
								}
								function W(m) {
									m.walk((S) => {
										if (!S.children) return
										if (
											S.children.length === 0 ||
											(S.children.length === 1 &&
												S.children[0].type === 'text' &&
												D(S.children[0].value).length === 0)
										) {
											;(S.hasDanglingSpaces = S.children.length > 0), (S.children = [])
											return
										}
										let L = C(S),
											P = x(S)
										if (!L)
											for (let M = 0; M < S.children.length; M++) {
												let V = S.children[M]
												if (V.type !== 'text') continue
												let { leadingWhitespace: J, text: Z, trailingWhitespace: ne } = g(V.value),
													ee = V.prev,
													ce = V.next
												Z
													? ((V.value = Z),
													  (V.sourceSpan = new c(
															V.sourceSpan.start.moveBy(J.length),
															V.sourceSpan.end.moveBy(-ne.length)
													  )),
													  J && (ee && (ee.hasTrailingSpaces = !0), (V.hasLeadingSpaces = !0)),
													  ne && ((V.hasTrailingSpaces = !0), ce && (ce.hasLeadingSpaces = !0)))
													: (S.removeChild(V),
													  M--,
													  (J || ne) &&
															(ee && (ee.hasTrailingSpaces = !0), ce && (ce.hasLeadingSpaces = !0)))
											}
										;(S.isWhitespaceSensitive = L), (S.isIndentationSensitive = P)
									})
								}
								function re(m) {
									m.walk((S) => {
										S.isSelfClosing =
											!S.children ||
											(S.type === 'element' &&
												(S.tagDefinition.isVoid || S.startSourceSpan === S.endSourceSpan))
									})
								}
								function A(m, S) {
									m.walk((L) => {
										L.type === 'element' &&
											(L.hasHtmComponentClosingTag =
												L.endSourceSpan &&
												/^<\s*\/\s*\/\s*>$/.test(
													S.originalText.slice(
														L.endSourceSpan.start.offset,
														L.endSourceSpan.end.offset
													)
												))
									})
								}
								function $(m, S) {
									m.walk((L) => {
										L.cssDisplay = f(L, S)
									})
								}
								function T(m, S) {
									m.walk((L) => {
										let { children: P } = L
										if (P) {
											if (P.length === 0) {
												L.isDanglingSpaceSensitive = y(L)
												return
											}
											for (let M of P)
												(M.isLeadingSpaceSensitive = _(M, S)),
													(M.isTrailingSpaceSensitive = w(M, S))
											for (let M = 0; M < P.length; M++) {
												let V = P[M]
												;(V.isLeadingSpaceSensitive =
													(M === 0 || V.prev.isTrailingSpaceSensitive) &&
													V.isLeadingSpaceSensitive),
													(V.isTrailingSpaceSensitive =
														(M === P.length - 1 || V.next.isLeadingSpaceSensitive) &&
														V.isTrailingSpaceSensitive)
											}
										}
									})
								}
								function R(m, S) {
									if (S.parser === 'vue') {
										let L = m.children.find((M) => v(M, S))
										if (!L) return
										let { lang: P } = L.attrMap
										;(P === 'ts' || P === 'typescript') &&
											(S.__should_parse_vue_template_with_ts = !0)
									}
								}
								E.exports = k
							}
						}),
						HE = le({
							'src/language-html/pragma.js'(d, E) {
								'use strict'
								ge()
								function c(g) {
									return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(g)
								}
								function D(g) {
									return (
										`<!-- @format -->

` + g.replace(/^\s*\n/, '')
									)
								}
								E.exports = { hasPragma: c, insertPragma: D }
							}
						}),
						xp = le({
							'src/language-html/loc.js'(d, E) {
								'use strict'
								ge()
								function c(g) {
									return g.sourceSpan.start.offset
								}
								function D(g) {
									return g.sourceSpan.end.offset
								}
								E.exports = { locStart: c, locEnd: D }
							}
						}),
						Pa = le({
							'src/language-html/print/tag.js'(d, E) {
								'use strict'
								ge()
								var c = Ia(),
									{ isNonEmptyArray: D } = wn(),
									{
										builders: { indent: g, join: l, line: p, softline: f, hardline: y },
										utils: { replaceTextEndOfLine: x }
									} = dn(),
									{ locStart: _, locEnd: w } = xp(),
									{
										isTextLikeNode: C,
										getLastDescendant: v,
										isPreLikeNode: b,
										hasPrettierIgnore: k,
										shouldPreserveContent: q,
										isVueSfcBlock: G
									} = bo()
								function O(z, ye) {
									return [z.isSelfClosing ? '' : U(z, ye), j(z, ye)]
								}
								function U(z, ye) {
									return z.lastChild && m(z.lastChild) ? '' : [H(z, ye), re(z, ye)]
								}
								function j(z, ye) {
									return (z.next ? T(z.next) : R(z.parent)) ? '' : [A(z, ye), W(z, ye)]
								}
								function H(z, ye) {
									return R(z) ? A(z.lastChild, ye) : ''
								}
								function W(z, ye) {
									return m(z) ? re(z.parent, ye) : S(z) ? ee(z.next) : ''
								}
								function re(z, ye) {
									if ((c(!z.isSelfClosing), $(z, ye))) return ''
									switch (z.type) {
										case 'ieConditionalComment':
											return '<!'
										case 'element':
											if (z.hasHtmComponentClosingTag) return '<//'
										default:
											return `</${z.rawName}`
									}
								}
								function A(z, ye) {
									if ($(z, ye)) return ''
									switch (z.type) {
										case 'ieConditionalComment':
										case 'ieConditionalEndComment':
											return '[endif]-->'
										case 'ieConditionalStartComment':
											return ']><!-->'
										case 'interpolation':
											return '}}'
										case 'element':
											if (z.isSelfClosing) return '/>'
										default:
											return '>'
									}
								}
								function $(z, ye) {
									return !z.isSelfClosing && !z.endSourceSpan && (k(z) || q(z.parent, ye))
								}
								function T(z) {
									return (
										z.prev &&
										z.prev.type !== 'docType' &&
										!C(z.prev) &&
										z.isLeadingSpaceSensitive &&
										!z.hasLeadingSpaces
									)
								}
								function R(z) {
									return (
										z.lastChild &&
										z.lastChild.isTrailingSpaceSensitive &&
										!z.lastChild.hasTrailingSpaces &&
										!C(v(z.lastChild)) &&
										!b(z)
									)
								}
								function m(z) {
									return !z.next && !z.hasTrailingSpaces && z.isTrailingSpaceSensitive && C(v(z))
								}
								function S(z) {
									return (
										z.next &&
										!C(z.next) &&
										C(z) &&
										z.isTrailingSpaceSensitive &&
										!z.hasTrailingSpaces
									)
								}
								function L(z) {
									let ye = z.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s)
									return ye ? (ye[1] ? ye[1].split(/\s+/) : !0) : !1
								}
								function P(z) {
									return !z.prev && z.isLeadingSpaceSensitive && !z.hasLeadingSpaces
								}
								function M(z, ye, te) {
									let X = z.getValue()
									if (!D(X.attrs)) return X.isSelfClosing ? ' ' : ''
									let De = X.prev && X.prev.type === 'comment' && L(X.prev.value),
										Fe =
											typeof De == 'boolean'
												? () => De
												: Array.isArray(De)
												? (Be) => De.includes(Be.rawName)
												: () => !1,
										ve = z.map((Be) => {
											let Me = Be.getValue()
											return Fe(Me) ? x(ye.originalText.slice(_(Me), w(Me))) : te()
										}, 'attrs'),
										$e =
											X.type === 'element' &&
											X.fullName === 'script' &&
											X.attrs.length === 1 &&
											X.attrs[0].fullName === 'src' &&
											X.children.length === 0,
										ie = ye.singleAttributePerLine && X.attrs.length > 1 && !G(X, ye) ? y : p,
										fe = [g([$e ? ' ' : p, l(ie, ve)])]
									return (
										(X.firstChild && P(X.firstChild)) || (X.isSelfClosing && R(X.parent)) || $e
											? fe.push(X.isSelfClosing ? ' ' : '')
											: fe.push(
													ye.bracketSameLine
														? X.isSelfClosing
															? ' '
															: ''
														: X.isSelfClosing
														? p
														: f
											  ),
										fe
									)
								}
								function V(z) {
									return z.firstChild && P(z.firstChild) ? '' : ce(z)
								}
								function J(z, ye, te) {
									let X = z.getValue()
									return [Z(X, ye), M(z, ye, te), X.isSelfClosing ? '' : V(X)]
								}
								function Z(z, ye) {
									return z.prev && S(z.prev) ? '' : [ne(z, ye), ee(z)]
								}
								function ne(z, ye) {
									return P(z) ? ce(z.parent) : T(z) ? A(z.prev, ye) : ''
								}
								function ee(z) {
									switch (z.type) {
										case 'ieConditionalComment':
										case 'ieConditionalStartComment':
											return `<!--[if ${z.condition}`
										case 'ieConditionalEndComment':
											return '<!--<!'
										case 'interpolation':
											return '{{'
										case 'docType':
											return '<!DOCTYPE'
										case 'element':
											if (z.condition) return `<!--[if ${z.condition}]><!--><${z.rawName}`
										default:
											return `<${z.rawName}`
									}
								}
								function ce(z) {
									switch ((c(!z.isSelfClosing), z.type)) {
										case 'ieConditionalComment':
											return ']>'
										case 'element':
											if (z.condition) return '><!--<![endif]-->'
										default:
											return '>'
									}
								}
								E.exports = {
									printClosingTag: O,
									printClosingTagStart: U,
									printClosingTagStartMarker: re,
									printClosingTagEndMarker: A,
									printClosingTagSuffix: W,
									printClosingTagEnd: j,
									needsToBorrowLastChildClosingTagEndMarker: R,
									needsToBorrowParentClosingTagStartMarker: m,
									needsToBorrowPrevClosingTagEndMarker: T,
									printOpeningTag: J,
									printOpeningTagStart: Z,
									printOpeningTagPrefix: ne,
									printOpeningTagStartMarker: ee,
									printOpeningTagEndMarker: ce,
									needsToBorrowNextOpeningTagStartMarker: S,
									needsToBorrowParentOpeningTagEndMarker: P
								}
							}
						}),
						JE = le({
							'node_modules/parse-srcset/src/parse-srcset.js'(d, E) {
								ge(),
									(function (c, D) {
										typeof define == 'function' && define.amd
											? define([], D)
											: typeof E == 'object' && E.exports
											? (E.exports = D())
											: (c.parseSrcset = D())
									})(d, function () {
										return function (c, D) {
											var g = (D && D.logger) || console
											function l(re) {
												return (
													re === ' ' ||
													re === '	' ||
													re ===
														`
` ||
													re === '\f' ||
													re === '\r'
												)
											}
											function p(re) {
												var A,
													$ = re.exec(c.substring(U))
												if ($) return (A = $[0]), (U += A.length), A
											}
											for (
												var f = c.length,
													y = /^[ \t\n\r\u000c]+/,
													x = /^[, \t\n\r\u000c]+/,
													_ = /^[^ \t\n\r\u000c]+/,
													w = /[,]+$/,
													C = /^\d+$/,
													v = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/,
													b,
													k,
													q,
													G,
													O,
													U = 0,
													j = [];
												;

											) {
												if ((p(x), U >= f)) return j
												;(b = p(_)),
													(k = []),
													b.slice(-1) === ',' ? ((b = b.replace(w, '')), W()) : H()
											}
											function H() {
												for (p(y), q = '', G = 'in descriptor'; ; ) {
													if (((O = c.charAt(U)), G === 'in descriptor'))
														if (l(O)) q && (k.push(q), (q = ''), (G = 'after descriptor'))
														else if (O === ',') {
															;(U += 1), q && k.push(q), W()
															return
														} else if (O === '(') (q = q + O), (G = 'in parens')
														else if (O === '') {
															q && k.push(q), W()
															return
														} else q = q + O
													else if (G === 'in parens')
														if (O === ')') (q = q + O), (G = 'in descriptor')
														else if (O === '') {
															k.push(q), W()
															return
														} else q = q + O
													else if (G === 'after descriptor' && !l(O))
														if (O === '') {
															W()
															return
														} else (G = 'in descriptor'), (U -= 1)
													U += 1
												}
											}
											function W() {
												var re = !1,
													A,
													$,
													T,
													R,
													m = {},
													S,
													L,
													P,
													M,
													V
												for (R = 0; R < k.length; R++)
													(S = k[R]),
														(L = S[S.length - 1]),
														(P = S.substring(0, S.length - 1)),
														(M = parseInt(P, 10)),
														(V = parseFloat(P)),
														C.test(P) && L === 'w'
															? ((A || $) && (re = !0), M === 0 ? (re = !0) : (A = M))
															: v.test(P) && L === 'x'
															? ((A || $ || T) && (re = !0), V < 0 ? (re = !0) : ($ = V))
															: C.test(P) && L === 'h'
															? ((T || $) && (re = !0), M === 0 ? (re = !0) : (T = M))
															: (re = !0)
												re
													? g &&
													  g.error &&
													  g.error(
															"Invalid srcset descriptor found in '" + c + "' at '" + S + "'."
													  )
													: ((m.url = b), A && (m.w = A), $ && (m.d = $), T && (m.h = T), j.push(m))
											}
										}
									})
							}
						}),
						zE = le({
							'src/language-html/syntax-attribute.js'(d, E) {
								'use strict'
								ge()
								var c = JE(),
									{
										builders: { ifBreak: D, join: g, line: l }
									} = dn()
								function p(y) {
									let x = c(y, {
											logger: {
												error(H) {
													throw new Error(H)
												}
											}
										}),
										_ = x.some((H) => {
											let { w: W } = H
											return W
										}),
										w = x.some((H) => {
											let { h: W } = H
											return W
										}),
										C = x.some((H) => {
											let { d: W } = H
											return W
										})
									if (_ + w + C > 1) throw new Error('Mixed descriptor in srcset is not supported')
									let v = _ ? 'w' : w ? 'h' : 'd',
										b = _ ? 'w' : w ? 'h' : 'x',
										k = (H) => Math.max(...H),
										q = x.map((H) => H.url),
										G = k(q.map((H) => H.length)),
										O = x.map((H) => H[v]).map((H) => (H ? H.toString() : '')),
										U = O.map((H) => {
											let W = H.indexOf('.')
											return W === -1 ? H.length : W
										}),
										j = k(U)
									return g(
										[',', l],
										q.map((H, W) => {
											let re = [H],
												A = O[W]
											if (A) {
												let $ = G - H.length + 1,
													T = j - U[W],
													R = ' '.repeat($ + T)
												re.push(D(R, ' '), A + b)
											}
											return re
										})
									)
								}
								function f(y) {
									return y.trim().split(/\s+/).join(' ')
								}
								E.exports = { printImgSrcset: p, printClassNames: f }
							}
						}),
						QE = le({
							'src/language-html/syntax-vue.js'(d, E) {
								'use strict'
								ge()
								var {
									builders: { group: c }
								} = dn()
								function D(f, y) {
									let { left: x, operator: _, right: w } = g(f)
									return [
										c(y(`function _(${x}) {}`, { parser: 'babel', __isVueForBindingLeft: !0 })),
										' ',
										_,
										' ',
										y(w, { parser: '__js_expression' }, { stripTrailingHardline: !0 })
									]
								}
								function g(f) {
									let y = /(.*?)\s+(in|of)\s+(.*)/s,
										x = /,([^,\]}]*)(?:,([^,\]}]*))?$/,
										_ = /^\(|\)$/g,
										w = f.match(y)
									if (!w) return
									let C = {}
									if (((C.for = w[3].trim()), !C.for)) return
									let v = w[1].trim().replace(_, ''),
										b = v.match(x)
									b
										? ((C.alias = v.replace(x, '')),
										  (C.iterator1 = b[1].trim()),
										  b[2] && (C.iterator2 = b[2].trim()))
										: (C.alias = v)
									let k = [C.alias, C.iterator1, C.iterator2]
									if (!k.some((q, G) => !q && (G === 0 || k.slice(G + 1).some(Boolean))))
										return { left: k.filter(Boolean).join(','), operator: w[2], right: C.for }
								}
								function l(f, y) {
									return y(`function _(${f}) {}`, { parser: 'babel', __isVueBindings: !0 })
								}
								function p(f) {
									let y = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/,
										x =
											/^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/,
										_ = f.trim()
									return y.test(_) || x.test(_)
								}
								E.exports = { isVueEventBindingExpression: p, printVueFor: D, printVueBindings: l }
							}
						}),
						i0 = le({
							'src/language-html/get-node-content.js'(d, E) {
								'use strict'
								ge()
								var {
									needsToBorrowParentClosingTagStartMarker: c,
									printClosingTagStartMarker: D,
									needsToBorrowLastChildClosingTagEndMarker: g,
									printClosingTagEndMarker: l,
									needsToBorrowParentOpeningTagEndMarker: p,
									printOpeningTagEndMarker: f
								} = Pa()
								function y(x, _) {
									let w = x.startSourceSpan.end.offset
									x.firstChild && p(x.firstChild) && (w -= f(x).length)
									let C = x.endSourceSpan.start.offset
									return (
										x.lastChild && c(x.lastChild)
											? (C += D(x, _).length)
											: g(x) && (C -= l(x.lastChild, _).length),
										_.originalText.slice(w, C)
									)
								}
								E.exports = y
							}
						}),
						YE = le({
							'src/language-html/embed.js'(d, E) {
								'use strict'
								ge()
								var {
										builders: {
											breakParent: c,
											group: D,
											hardline: g,
											indent: l,
											line: p,
											fill: f,
											softline: y
										},
										utils: { mapDoc: x, replaceTextEndOfLine: _ }
									} = dn(),
									w = Ep(),
									{
										printClosingTag: C,
										printClosingTagSuffix: v,
										needsToBorrowPrevClosingTagEndMarker: b,
										printOpeningTagPrefix: k,
										printOpeningTag: q
									} = Pa(),
									{ printImgSrcset: G, printClassNames: O } = zE(),
									{ printVueFor: U, printVueBindings: j, isVueEventBindingExpression: H } = QE(),
									{
										isScriptLikeTag: W,
										isVueNonHtmlBlock: re,
										inferScriptParser: A,
										htmlTrimPreserveIndentation: $,
										dedentString: T,
										unescapeQuoteEntities: R,
										isVueSlotAttribute: m,
										isVueSfcBindingsAttribute: S,
										getTextValueParts: L
									} = bo(),
									P = i0()
								function M(J, Z, ne) {
									let ee = (ve) => new RegExp(ve.join('|')).test(J.fullName),
										ce = () => R(J.value),
										z = !1,
										ye = (ve, $e) => {
											let ie =
												ve.type === 'NGRoot'
													? ve.node.type === 'NGMicrosyntax' &&
													  ve.node.body.length === 1 &&
													  ve.node.body[0].type === 'NGMicrosyntaxExpression'
														? ve.node.body[0].expression
														: ve.node
													: ve.type === 'JsExpressionRoot'
													? ve.node
													: ve
											ie &&
												(ie.type === 'ObjectExpression' ||
													ie.type === 'ArrayExpression' ||
													($e.parser === '__vue_expression' &&
														(ie.type === 'TemplateLiteral' || ie.type === 'StringLiteral'))) &&
												(z = !0)
										},
										te = (ve) => D(ve),
										X = function (ve) {
											let $e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
											return D([l([y, ve]), $e ? y : ''])
										},
										De = (ve) => (z ? te(ve) : X(ve)),
										Fe = (ve, $e) =>
											Z(ve, Object.assign({ __onHtmlBindingRoot: ye, __embeddedInHtml: !0 }, $e))
									if (
										J.fullName === 'srcset' &&
										(J.parent.fullName === 'img' || J.parent.fullName === 'source')
									)
										return X(G(ce()))
									if (J.fullName === 'class' && !ne.parentParser) {
										let ve = ce()
										if (!ve.includes('{{')) return O(ve)
									}
									if (J.fullName === 'style' && !ne.parentParser) {
										let ve = ce()
										if (!ve.includes('{{'))
											return X(Fe(ve, { parser: 'css', __isHTMLStyleAttribute: !0 }))
									}
									if (ne.parser === 'vue') {
										if (J.fullName === 'v-for') return U(ce(), Fe)
										if (m(J) || S(J, ne)) return j(ce(), Fe)
										let ve = ['^@', '^v-on:'],
											$e = ['^:', '^v-bind:'],
											ie = ['^v-']
										if (ee(ve)) {
											let fe = ce(),
												Be = H(fe)
													? '__js_expression'
													: ne.__should_parse_vue_template_with_ts
													? '__vue_ts_event_binding'
													: '__vue_event_binding'
											return De(Fe(fe, { parser: Be }))
										}
										if (ee($e)) return De(Fe(ce(), { parser: '__vue_expression' }))
										if (ee(ie)) return De(Fe(ce(), { parser: '__js_expression' }))
									}
									if (ne.parser === 'angular') {
										let ve = (me, ae) =>
												Fe(me, Object.assign(Object.assign({}, ae), {}, { trailingComma: 'none' })),
											$e = ['^\\*'],
											ie = ['^\\(.+\\)$', '^on-'],
											fe = ['^\\[.+\\]$', '^bind(on)?-', '^ng-(if|show|hide|class|style)$'],
											Be = ['^i18n(-.+)?$']
										if (ee(ie)) return De(ve(ce(), { parser: '__ng_action' }))
										if (ee(fe)) return De(ve(ce(), { parser: '__ng_binding' }))
										if (ee(Be)) {
											let me = ce().trim()
											return X(f(L(J, me)), !me.includes('@@'))
										}
										if (ee($e)) return De(ve(ce(), { parser: '__ng_directive' }))
										let Me = /{{(.+?)}}/s,
											Dt = ce()
										if (Me.test(Dt)) {
											let me = []
											for (let [ae, xe] of Dt.split(Me).entries())
												if (ae % 2 === 0) me.push(_(xe))
												else
													try {
														me.push(
															D([
																'{{',
																l([
																	p,
																	ve(xe, {
																		parser: '__ng_interpolation',
																		__isInHtmlInterpolation: !0
																	})
																]),
																p,
																'}}'
															])
														)
													} catch {
														me.push('{{', _(xe), '}}')
													}
											return D(me)
										}
									}
									return null
								}
								function V(J, Z, ne, ee) {
									let ce = J.getValue()
									switch (ce.type) {
										case 'element': {
											if (W(ce) || ce.type === 'interpolation') return
											if (!ce.isSelfClosing && re(ce, ee)) {
												let z = A(ce, ee)
												if (!z) return
												let ye = P(ce, ee),
													te = /^\s*$/.test(ye),
													X = ''
												return (
													te ||
														((X = ne(
															$(ye),
															{ parser: z, __embeddedInHtml: !0 },
															{ stripTrailingHardline: !0 }
														)),
														(te = X === '')),
													[
														k(ce, ee),
														D(q(J, ee, Z)),
														te ? '' : g,
														X,
														te ? '' : g,
														C(ce, ee),
														v(ce, ee)
													]
												)
											}
											break
										}
										case 'text': {
											if (W(ce.parent)) {
												let z = A(ce.parent, ee)
												if (z) {
													let ye =
															z === 'markdown' ? T(ce.value.replace(/^[^\S\n]*\n/, '')) : ce.value,
														te = { parser: z, __embeddedInHtml: !0 }
													if (ee.parser === 'html' && z === 'babel') {
														let X = 'script',
															{ attrMap: De } = ce.parent
														De &&
															(De.type === 'module' ||
																(De.type === 'text/babel' && De['data-type'] === 'module')) &&
															(X = 'module'),
															(te.__babelSourceType = X)
													}
													return [
														c,
														k(ce, ee),
														ne(ye, te, { stripTrailingHardline: !0 }),
														v(ce, ee)
													]
												}
											} else if (ce.parent.type === 'interpolation') {
												let z = { __isInHtmlInterpolation: !0, __embeddedInHtml: !0 }
												return (
													ee.parser === 'angular'
														? ((z.parser = '__ng_interpolation'), (z.trailingComma = 'none'))
														: ee.parser === 'vue'
														? (z.parser = ee.__should_parse_vue_template_with_ts
																? '__vue_ts_expression'
																: '__vue_expression')
														: (z.parser = '__js_expression'),
													[
														l([p, ne(ce.value, z, { stripTrailingHardline: !0 })]),
														ce.parent.next && b(ce.parent.next) ? ' ' : p
													]
												)
											}
											break
										}
										case 'attribute': {
											if (!ce.value) break
											if (
												/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(
													ee.originalText.slice(ce.valueSpan.start.offset, ce.valueSpan.end.offset)
												)
											)
												return [ce.rawName, '=', ce.value]
											if (
												ee.parser === 'lwc' &&
												/^{.*}$/s.test(
													ee.originalText.slice(ce.valueSpan.start.offset, ce.valueSpan.end.offset)
												)
											)
												return [ce.rawName, '=', ce.value]
											let z = M(
												ce,
												(ye, te) =>
													ne(
														ye,
														Object.assign({ __isInHtmlAttribute: !0, __embeddedInHtml: !0 }, te),
														{ stripTrailingHardline: !0 }
													),
												ee
											)
											if (z)
												return [
													ce.rawName,
													'="',
													D(
														x(z, (ye) => (typeof ye == 'string' ? ye.replace(/"/g, '&quot;') : ye))
													),
													'"'
												]
											break
										}
										case 'front-matter':
											return w(ce, ne)
									}
								}
								E.exports = V
							}
						}),
						s0 = le({
							'src/language-html/print/children.js'(d, E) {
								'use strict'
								ge()
								var {
										builders: {
											breakParent: c,
											group: D,
											ifBreak: g,
											line: l,
											softline: p,
											hardline: f
										},
										utils: { replaceTextEndOfLine: y }
									} = dn(),
									{ locStart: x, locEnd: _ } = xp(),
									{
										forceBreakChildren: w,
										forceNextEmptyLine: C,
										isTextLikeNode: v,
										hasPrettierIgnore: b,
										preferHardlineAsLeadingSpaces: k
									} = bo(),
									{
										printOpeningTagPrefix: q,
										needsToBorrowNextOpeningTagStartMarker: G,
										printOpeningTagStartMarker: O,
										needsToBorrowPrevClosingTagEndMarker: U,
										printClosingTagEndMarker: j,
										printClosingTagSuffix: H,
										needsToBorrowParentClosingTagStartMarker: W
									} = Pa()
								function re(T, R, m) {
									let S = T.getValue()
									return b(S)
										? [
												q(S, R),
												...y(
													R.originalText.slice(
														x(S) + (S.prev && G(S.prev) ? O(S).length : 0),
														_(S) - (S.next && U(S.next) ? j(S, R).length : 0)
													)
												),
												H(S, R)
										  ]
										: m()
								}
								function A(T, R) {
									return v(T) && v(R)
										? T.isTrailingSpaceSensitive
											? T.hasTrailingSpaces
												? k(R)
													? f
													: l
												: ''
											: k(R)
											? f
											: p
										: (G(T) &&
												(b(R) ||
													R.firstChild ||
													R.isSelfClosing ||
													(R.type === 'element' && R.attrs.length > 0))) ||
										  (T.type === 'element' && T.isSelfClosing && U(R))
										? ''
										: !R.isLeadingSpaceSensitive ||
										  k(R) ||
										  (U(R) &&
												T.lastChild &&
												W(T.lastChild) &&
												T.lastChild.lastChild &&
												W(T.lastChild.lastChild))
										? f
										: R.hasLeadingSpaces
										? l
										: p
								}
								function $(T, R, m) {
									let S = T.getValue()
									if (w(S))
										return [
											c,
											...T.map((P) => {
												let M = P.getValue(),
													V = M.prev ? A(M.prev, M) : ''
												return [V ? [V, C(M.prev) ? f : ''] : '', re(P, R, m)]
											}, 'children')
										]
									let L = S.children.map(() => Symbol(''))
									return T.map((P, M) => {
										let V = P.getValue()
										if (v(V)) {
											if (V.prev && v(V.prev)) {
												let ye = A(V.prev, V)
												if (ye) return C(V.prev) ? [f, f, re(P, R, m)] : [ye, re(P, R, m)]
											}
											return re(P, R, m)
										}
										let J = [],
											Z = [],
											ne = [],
											ee = [],
											ce = V.prev ? A(V.prev, V) : '',
											z = V.next ? A(V, V.next) : ''
										return (
											ce &&
												(C(V.prev)
													? J.push(f, f)
													: ce === f
													? J.push(f)
													: v(V.prev)
													? Z.push(ce)
													: Z.push(g('', p, { groupId: L[M - 1] }))),
											z &&
												(C(V)
													? v(V.next) && ee.push(f, f)
													: z === f
													? v(V.next) && ee.push(f)
													: ne.push(z)),
											[...J, D([...Z, D([re(P, R, m), ...ne], { id: L[M] })]), ...ee]
										)
									}, 'children')
								}
								E.exports = { printChildren: $ }
							}
						}),
						XE = le({
							'src/language-html/print/element.js'(d, E) {
								'use strict'
								ge()
								var {
										builders: {
											breakParent: c,
											dedentToRoot: D,
											group: g,
											ifBreak: l,
											indentIfBreak: p,
											indent: f,
											line: y,
											softline: x
										},
										utils: { replaceTextEndOfLine: _ }
									} = dn(),
									w = i0(),
									{
										shouldPreserveContent: C,
										isScriptLikeTag: v,
										isVueCustomBlock: b,
										countParents: k,
										forceBreakContent: q
									} = bo(),
									{
										printOpeningTagPrefix: G,
										printOpeningTag: O,
										printClosingTagSuffix: U,
										printClosingTag: j,
										needsToBorrowPrevClosingTagEndMarker: H,
										needsToBorrowLastChildClosingTagEndMarker: W
									} = Pa(),
									{ printChildren: re } = s0()
								function A($, T, R) {
									let m = $.getValue()
									if (C(m, T)) return [G(m, T), g(O($, T, R)), ..._(w(m, T)), ...j(m, T), U(m, T)]
									let S =
											m.children.length === 1 &&
											m.firstChild.type === 'interpolation' &&
											m.firstChild.isLeadingSpaceSensitive &&
											!m.firstChild.hasLeadingSpaces &&
											m.lastChild.isTrailingSpaceSensitive &&
											!m.lastChild.hasTrailingSpaces,
										L = Symbol('element-attr-group-id'),
										P = (Z) => g([g(O($, T, R), { id: L }), Z, j(m, T)]),
										M = (Z) =>
											S
												? p(Z, { groupId: L })
												: (v(m) || b(m, T)) &&
												  m.parent.type === 'root' &&
												  T.parser === 'vue' &&
												  !T.vueIndentScriptAndStyle
												? Z
												: f(Z),
										V = () =>
											S
												? l(x, '', { groupId: L })
												: m.firstChild.hasLeadingSpaces && m.firstChild.isLeadingSpaceSensitive
												? y
												: m.firstChild.type === 'text' &&
												  m.isWhitespaceSensitive &&
												  m.isIndentationSensitive
												? D(x)
												: x,
										J = () =>
											(m.next ? H(m.next) : W(m.parent))
												? m.lastChild.hasTrailingSpaces && m.lastChild.isTrailingSpaceSensitive
													? ' '
													: ''
												: S
												? l(x, '', { groupId: L })
												: m.lastChild.hasTrailingSpaces && m.lastChild.isTrailingSpaceSensitive
												? y
												: (m.lastChild.type === 'comment' ||
														(m.lastChild.type === 'text' &&
															m.isWhitespaceSensitive &&
															m.isIndentationSensitive)) &&
												  new RegExp(
														`\\n[\\t ]{${
															T.tabWidth * k($, (Z) => Z.parent && Z.parent.type !== 'root')
														}}$`
												  ).test(m.lastChild.value)
												? ''
												: x
									return m.children.length === 0
										? P(m.hasDanglingSpaces && m.isDanglingSpaceSensitive ? y : '')
										: P([q(m) ? c : '', M([V(), re($, T, R)]), J()])
								}
								E.exports = { printElement: A }
							}
						}),
						KE = le({
							'src/language-html/printer-html.js'(d, E) {
								'use strict'
								ge()
								var {
										builders: { fill: c, group: D, hardline: g, literalline: l },
										utils: { cleanDoc: p, getDocParts: f, isConcat: y, replaceTextEndOfLine: x }
									} = dn(),
									_ = PE(),
									{ countChars: w, unescapeQuoteEntities: C, getTextValueParts: v } = bo(),
									b = WE(),
									{ insertPragma: k } = HE(),
									{ locStart: q, locEnd: G } = xp(),
									O = YE(),
									{
										printClosingTagSuffix: U,
										printClosingTagEnd: j,
										printOpeningTagPrefix: H,
										printOpeningTagStart: W
									} = Pa(),
									{ printElement: re } = XE(),
									{ printChildren: A } = s0()
								function $(T, R, m) {
									let S = T.getValue()
									switch (S.type) {
										case 'front-matter':
											return x(S.raw)
										case 'root':
											return R.__onHtmlRoot && R.__onHtmlRoot(S), [D(A(T, R, m)), g]
										case 'element':
										case 'ieConditionalComment':
											return re(T, R, m)
										case 'ieConditionalStartComment':
										case 'ieConditionalEndComment':
											return [W(S), j(S)]
										case 'interpolation':
											return [W(S, R), ...T.map(m, 'children'), j(S, R)]
										case 'text': {
											if (S.parent.type === 'interpolation') {
												let P = /\n[^\S\n]*$/,
													M = P.test(S.value),
													V = M ? S.value.replace(P, '') : S.value
												return [...x(V), M ? g : '']
											}
											let L = p([H(S, R), ...v(S), U(S, R)])
											return y(L) || L.type === 'fill' ? c(f(L)) : L
										}
										case 'docType':
											return [
												D([W(S, R), ' ', S.value.replace(/^html\b/i, 'html').replace(/\s+/g, ' ')]),
												j(S, R)
											]
										case 'comment':
											return [H(S, R), ...x(R.originalText.slice(q(S), G(S)), l), U(S, R)]
										case 'attribute': {
											if (S.value === null) return S.rawName
											let L = C(S.value),
												P = w(L, "'"),
												M = w(L, '"'),
												V = P < M ? "'" : '"'
											return [
												S.rawName,
												'=',
												V,
												...x(V === '"' ? L.replace(/"/g, '&quot;') : L.replace(/'/g, '&apos;')),
												V
											]
										}
										default:
											throw new Error(`Unexpected node type ${S.type}`)
									}
								}
								E.exports = {
									preprocess: b,
									print: $,
									insertPragma: k,
									massageAstNode: _,
									embed: O
								}
							}
						}),
						ZE = le({
							'src/language-html/options.js'(d, E) {
								'use strict'
								ge()
								var c = xo(),
									D = 'HTML'
								E.exports = {
									bracketSameLine: c.bracketSameLine,
									htmlWhitespaceSensitivity: {
										since: '1.15.0',
										category: D,
										type: 'choice',
										default: 'css',
										description: 'How to handle whitespaces in HTML.',
										choices: [
											{
												value: 'css',
												description: 'Respect the default value of CSS display property.'
											},
											{ value: 'strict', description: 'Whitespaces are considered sensitive.' },
											{ value: 'ignore', description: 'Whitespaces are considered insensitive.' }
										]
									},
									singleAttributePerLine: c.singleAttributePerLine,
									vueIndentScriptAndStyle: {
										since: '1.19.0',
										category: D,
										type: 'boolean',
										default: !1,
										description: 'Indent script and style tags in Vue files.'
									}
								}
							}
						}),
						e4 = le({
							'src/language-html/parsers.js'() {
								ge()
							}
						}),
						bp = le({
							'node_modules/linguist-languages/data/HTML.json'(d, E) {
								E.exports = {
									name: 'HTML',
									type: 'markup',
									tmScope: 'text.html.basic',
									aceMode: 'html',
									codemirrorMode: 'htmlmixed',
									codemirrorMimeType: 'text/html',
									color: '#e34c26',
									aliases: ['xhtml'],
									extensions: ['.html', '.hta', '.htm', '.html.hl', '.inc', '.xht', '.xhtml'],
									languageId: 146
								}
							}
						}),
						t4 = le({
							'node_modules/linguist-languages/data/Vue.json'(d, E) {
								E.exports = {
									name: 'Vue',
									type: 'markup',
									color: '#41b883',
									extensions: ['.vue'],
									tmScope: 'text.html.vue',
									aceMode: 'html',
									languageId: 391
								}
							}
						}),
						n4 = le({
							'src/language-html/index.js'(d, E) {
								'use strict'
								ge()
								var c = Ms(),
									D = KE(),
									g = ZE(),
									l = e4(),
									p = [
										c(bp(), () => ({
											name: 'Angular',
											since: '1.15.0',
											parsers: ['angular'],
											vscodeLanguageIds: ['html'],
											extensions: ['.component.html'],
											filenames: []
										})),
										c(bp(), (y) => ({
											since: '1.15.0',
											parsers: ['html'],
											vscodeLanguageIds: ['html'],
											extensions: [...y.extensions, '.mjml']
										})),
										c(bp(), () => ({
											name: 'Lightning Web Components',
											since: '1.17.0',
											parsers: ['lwc'],
											vscodeLanguageIds: ['html'],
											extensions: [],
											filenames: []
										})),
										c(t4(), () => ({
											since: '1.10.0',
											parsers: ['vue'],
											vscodeLanguageIds: ['vue']
										}))
									],
									f = { html: D }
								E.exports = { languages: p, printers: f, options: g, parsers: l }
							}
						}),
						r4 = le({
							'src/language-yaml/pragma.js'(d, E) {
								'use strict'
								ge()
								function c(l) {
									return /^\s*@(?:prettier|format)\s*$/.test(l)
								}
								function D(l) {
									return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(l)
								}
								function g(l) {
									return `# @format

${l}`
								}
								E.exports = { isPragma: c, hasPragma: D, insertPragma: g }
							}
						}),
						i4 = le({
							'src/language-yaml/loc.js'(d, E) {
								'use strict'
								ge()
								function c(g) {
									return g.position.start.offset
								}
								function D(g) {
									return g.position.end.offset
								}
								E.exports = { locStart: c, locEnd: D }
							}
						}),
						s4 = le({
							'src/language-yaml/embed.js'(d, E) {
								'use strict'
								ge()
								function c(D, g, l, p) {
									if (
										D.getValue().type === 'root' &&
										p.filepath &&
										/(?:[/\\]|^)\.(?:prettier|stylelint|lintstaged)rc$/.test(p.filepath)
									)
										return l(
											p.originalText,
											Object.assign(Object.assign({}, p), {}, { parser: 'json' })
										)
								}
								E.exports = c
							}
						}),
						To = le({
							'src/language-yaml/utils.js'(d, E) {
								'use strict'
								ge()
								var { getLast: c, isNonEmptyArray: D } = wn()
								function g(A, $) {
									let T = 0,
										R = A.stack.length - 1
									for (let m = 0; m < R; m++) {
										let S = A.stack[m]
										l(S) && $(S) && T++
									}
									return T
								}
								function l(A, $) {
									return A && typeof A.type == 'string' && (!$ || $.includes(A.type))
								}
								function p(A, $, T) {
									return $(
										'children' in A
											? Object.assign(
													Object.assign({}, A),
													{},
													{ children: A.children.map((R) => p(R, $, A)) }
											  )
											: A,
										T
									)
								}
								function f(A, $, T) {
									Object.defineProperty(A, $, { get: T, enumerable: !1 })
								}
								function y(A, $) {
									let T = 0,
										R = $.length
									for (let m = A.position.end.offset - 1; m < R; m++) {
										let S = $[m]
										if (
											(S ===
												`
` && T++,
											T === 1 && /\S/.test(S))
										)
											return !1
										if (T === 2) return !0
									}
									return !1
								}
								function x(A) {
									switch (A.getValue().type) {
										case 'tag':
										case 'anchor':
										case 'comment':
											return !1
									}
									let $ = A.stack.length
									for (let T = 1; T < $; T++) {
										let R = A.stack[T],
											m = A.stack[T - 1]
										if (Array.isArray(m) && typeof R == 'number' && R !== m.length - 1) return !1
									}
									return !0
								}
								function _(A) {
									return D(A.children) ? _(c(A.children)) : A
								}
								function w(A) {
									return A.value.trim() === 'prettier-ignore'
								}
								function C(A) {
									let $ = A.getValue()
									if ($.type === 'documentBody') {
										let T = A.getParentNode()
										return U(T.head) && w(c(T.head.endComments))
									}
									return k($) && w(c($.leadingComments))
								}
								function v(A) {
									return !D(A.children) && !b(A)
								}
								function b(A) {
									return k(A) || q(A) || G(A) || O(A) || U(A)
								}
								function k(A) {
									return D(A?.leadingComments)
								}
								function q(A) {
									return D(A?.middleComments)
								}
								function G(A) {
									return A?.indicatorComment
								}
								function O(A) {
									return A?.trailingComment
								}
								function U(A) {
									return D(A?.endComments)
								}
								function j(A) {
									let $ = [],
										T
									for (let R of A.split(/( +)/))
										R !== ' '
											? T === ' '
												? $.push(R)
												: $.push(($.pop() || '') + R)
											: T === void 0 && $.unshift(''),
											(T = R)
									return (
										T === ' ' && $.push(($.pop() || '') + ' '),
										$[0] === '' && ($.shift(), $.unshift(' ' + ($.shift() || ''))),
										$
									)
								}
								function H(A, $, T) {
									let R = $.split(
										`
`
									).map((m, S, L) =>
										S === 0 && S === L.length - 1
											? m
											: S !== 0 && S !== L.length - 1
											? m.trim()
											: S === 0
											? m.trimEnd()
											: m.trimStart()
									)
									return T.proseWrap === 'preserve'
										? R.map((m) => (m.length === 0 ? [] : [m]))
										: R.map((m) => (m.length === 0 ? [] : j(m)))
												.reduce(
													(m, S, L) =>
														L !== 0 &&
														R[L - 1].length > 0 &&
														S.length > 0 &&
														!(A === 'quoteDouble' && c(c(m)).endsWith('\\'))
															? [...m.slice(0, -1), [...c(m), ...S]]
															: [...m, S],
													[]
												)
												.map((m) => (T.proseWrap === 'never' ? [m.join(' ')] : m))
								}
								function W(A, $) {
									let { parentIndent: T, isLastDescendant: R, options: m } = $,
										S =
											A.position.start.line === A.position.end.line
												? ''
												: m.originalText
														.slice(A.position.start.offset, A.position.end.offset)
														.match(/^[^\n]*\n(.*)$/s)[1],
										L
									if (A.indent === null) {
										let V = S.match(/^(?<leadingSpace> *)[^\n\r ]/m)
										L = V ? V.groups.leadingSpace.length : Number.POSITIVE_INFINITY
									} else L = A.indent - 1 + T
									let P = S.split(
										`
`
									).map((V) => V.slice(L))
									if (m.proseWrap === 'preserve' || A.type === 'blockLiteral')
										return M(P.map((V) => (V.length === 0 ? [] : [V])))
									return M(
										P.map((V) => (V.length === 0 ? [] : j(V)))
											.reduce(
												(V, J, Z) =>
													Z !== 0 &&
													P[Z - 1].length > 0 &&
													J.length > 0 &&
													!/^\s/.test(J[0]) &&
													!/^\s|\s$/.test(c(V))
														? [...V.slice(0, -1), [...c(V), ...J]]
														: [...V, J],
												[]
											)
											.map((V) =>
												V.reduce(
													(J, Z) =>
														J.length > 0 && /\s$/.test(c(J))
															? [...J.slice(0, -1), c(J) + ' ' + Z]
															: [...J, Z],
													[]
												)
											)
											.map((V) => (m.proseWrap === 'never' ? [V.join(' ')] : V))
									)
									function M(V) {
										if (A.chomping === 'keep') return c(V).length === 0 ? V.slice(0, -1) : V
										let J = 0
										for (let Z = V.length - 1; Z >= 0 && V[Z].length === 0; Z--) J++
										return J === 0 ? V : J >= 2 && !R ? V.slice(0, -(J - 1)) : V.slice(0, -J)
									}
								}
								function re(A) {
									if (!A) return !0
									switch (A.type) {
										case 'plain':
										case 'quoteDouble':
										case 'quoteSingle':
										case 'alias':
										case 'flowMapping':
										case 'flowSequence':
											return !0
										default:
											return !1
									}
								}
								E.exports = {
									getLast: c,
									getAncestorCount: g,
									isNode: l,
									isEmptyNode: v,
									isInlineNode: re,
									mapNode: p,
									defineShortcut: f,
									isNextLineEmpty: y,
									isLastDescendantNode: x,
									getBlockValueLineContents: W,
									getFlowScalarLineContents: H,
									getLastDescendantNode: _,
									hasPrettierIgnore: C,
									hasLeadingComments: k,
									hasMiddleComments: q,
									hasIndicatorComment: G,
									hasTrailingComment: O,
									hasEndComments: U
								}
							}
						}),
						o4 = le({
							'src/language-yaml/print-preprocess.js'(d, E) {
								'use strict'
								ge()
								var { defineShortcut: c, mapNode: D } = To()
								function g(p) {
									return D(p, l)
								}
								function l(p) {
									switch (p.type) {
										case 'document':
											c(p, 'head', () => p.children[0]), c(p, 'body', () => p.children[1])
											break
										case 'documentBody':
										case 'sequenceItem':
										case 'flowSequenceItem':
										case 'mappingKey':
										case 'mappingValue':
											c(p, 'content', () => p.children[0])
											break
										case 'mappingItem':
										case 'flowMappingItem':
											c(p, 'key', () => p.children[0]), c(p, 'value', () => p.children[1])
											break
									}
									return p
								}
								E.exports = g
							}
						}),
						Ku = le({
							'src/language-yaml/print/misc.js'(d, E) {
								'use strict'
								ge()
								var {
										builders: { softline: c, align: D }
									} = dn(),
									{ hasEndComments: g, isNextLineEmpty: l, isNode: p } = To(),
									f = new WeakMap()
								function y(w, C) {
									let v = w.getValue(),
										b = w.stack[0],
										k
									return (
										f.has(b) ? (k = f.get(b)) : ((k = new Set()), f.set(b, k)),
										!k.has(v.position.end.line) &&
										(k.add(v.position.end.line), l(v, C) && !x(w.getParentNode()))
											? c
											: ''
									)
								}
								function x(w) {
									return (
										g(w) && !p(w, ['documentHead', 'documentBody', 'flowMapping', 'flowSequence'])
									)
								}
								function _(w, C) {
									return D(' '.repeat(w), C)
								}
								E.exports = { alignWithSpaces: _, shouldPrintEndComments: x, printNextEmptyLine: y }
							}
						}),
						a4 = le({
							'src/language-yaml/print/flow-mapping-sequence.js'(d, E) {
								'use strict'
								ge()
								var {
										builders: { ifBreak: c, line: D, softline: g, hardline: l, join: p }
									} = dn(),
									{ isEmptyNode: f, getLast: y, hasEndComments: x } = To(),
									{ printNextEmptyLine: _, alignWithSpaces: w } = Ku()
								function C(b, k, q) {
									let G = b.getValue(),
										O = G.type === 'flowMapping',
										U = O ? '{' : '[',
										j = O ? '}' : ']',
										H = g
									O && G.children.length > 0 && q.bracketSpacing && (H = D)
									let W = y(G.children),
										re = W && W.type === 'flowMappingItem' && f(W.key) && f(W.value)
									return [
										U,
										w(q.tabWidth, [
											H,
											v(b, k, q),
											q.trailingComma === 'none' ? '' : c(','),
											x(G) ? [l, p(l, b.map(k, 'endComments'))] : ''
										]),
										re ? '' : H,
										j
									]
								}
								function v(b, k, q) {
									let G = b.getValue()
									return b.map(
										(O, U) => [
											k(),
											U === G.children.length - 1
												? ''
												: [
														',',
														D,
														G.children[U].position.start.line !==
														G.children[U + 1].position.start.line
															? _(O, q.originalText)
															: ''
												  ]
										],
										'children'
									)
								}
								E.exports = { printFlowMapping: C, printFlowSequence: C }
							}
						}),
						u4 = le({
							'src/language-yaml/print/mapping-item.js'(d, E) {
								'use strict'
								ge()
								var {
										builders: {
											conditionalGroup: c,
											group: D,
											hardline: g,
											ifBreak: l,
											join: p,
											line: f
										}
									} = dn(),
									{
										hasLeadingComments: y,
										hasMiddleComments: x,
										hasTrailingComment: _,
										hasEndComments: w,
										isNode: C,
										isEmptyNode: v,
										isInlineNode: b
									} = To(),
									{ alignWithSpaces: k } = Ku()
								function q(j, H, W, re, A) {
									let { key: $, value: T } = j,
										R = v($),
										m = v(T)
									if (R && m) return ': '
									let S = re('key'),
										L = O(j) ? ' ' : ''
									if (m)
										return j.type === 'flowMappingItem' && H.type === 'flowMapping'
											? S
											: j.type === 'mappingItem' &&
											  G($.content, A) &&
											  !_($.content) &&
											  (!H.tag || H.tag.value !== 'tag:yaml.org,2002:set')
											? [S, L, ':']
											: ['? ', k(2, S)]
									let P = re('value')
									if (R) return [': ', k(2, P)]
									if (y(T) || !b($.content))
										return [
											'? ',
											k(2, S),
											g,
											p(
												'',
												W.map(re, 'value', 'leadingComments').map((ee) => [ee, g])
											),
											': ',
											k(2, P)
										]
									if (
										U($.content) &&
										!y($.content) &&
										!x($.content) &&
										!_($.content) &&
										!w($) &&
										!y(T.content) &&
										!x(T.content) &&
										!w(T) &&
										G(T.content, A)
									)
										return [S, L, ': ', P]
									let M = Symbol('mappingKey'),
										V = D([l('? '), D(k(2, S), { id: M })]),
										J = [g, ': ', k(2, P)],
										Z = [L, ':']
									y(T.content) ||
									(w(T) && T.content && !C(T.content, ['mapping', 'sequence'])) ||
									(H.type === 'mapping' && _($.content) && b(T.content)) ||
									(C(T.content, ['mapping', 'sequence']) &&
										T.content.tag === null &&
										T.content.anchor === null)
										? Z.push(g)
										: T.content && Z.push(f),
										Z.push(P)
									let ne = k(A.tabWidth, Z)
									return G($.content, A) && !y($.content) && !x($.content) && !w($)
										? c([[S, ne]])
										: c([[V, l(J, ne, { groupId: M })]])
								}
								function G(j, H) {
									if (!j) return !0
									switch (j.type) {
										case 'plain':
										case 'quoteSingle':
										case 'quoteDouble':
											break
										case 'alias':
											return !0
										default:
											return !1
									}
									if (H.proseWrap === 'preserve')
										return j.position.start.line === j.position.end.line
									if (
										/\\$/m.test(
											H.originalText.slice(j.position.start.offset, j.position.end.offset)
										)
									)
										return !1
									switch (H.proseWrap) {
										case 'never':
											return !j.value.includes(`
`)
										case 'always':
											return !/[\n ]/.test(j.value)
										default:
											return !1
									}
								}
								function O(j) {
									return j.key.content && j.key.content.type === 'alias'
								}
								function U(j) {
									if (!j) return !0
									switch (j.type) {
										case 'plain':
										case 'quoteDouble':
										case 'quoteSingle':
											return j.position.start.line === j.position.end.line
										case 'alias':
											return !0
										default:
											return !1
									}
								}
								E.exports = q
							}
						}),
						l4 = le({
							'src/language-yaml/print/block.js'(d, E) {
								'use strict'
								ge()
								var {
										builders: {
											dedent: c,
											dedentToRoot: D,
											fill: g,
											hardline: l,
											join: p,
											line: f,
											literalline: y,
											markAsRoot: x
										},
										utils: { getDocParts: _ }
									} = dn(),
									{
										getAncestorCount: w,
										getBlockValueLineContents: C,
										hasIndicatorComment: v,
										isLastDescendantNode: b,
										isNode: k
									} = To(),
									{ alignWithSpaces: q } = Ku()
								function G(O, U, j) {
									let H = O.getValue(),
										W = w(O, (R) => k(R, ['sequence', 'mapping'])),
										re = b(O),
										A = [H.type === 'blockFolded' ? '>' : '|']
									H.indent !== null && A.push(H.indent.toString()),
										H.chomping !== 'clip' && A.push(H.chomping === 'keep' ? '+' : '-'),
										v(H) && A.push(' ', U('indicatorComment'))
									let $ = C(H, { parentIndent: W, isLastDescendant: re, options: j }),
										T = []
									for (let [R, m] of $.entries())
										R === 0 && T.push(l),
											T.push(g(_(p(f, m)))),
											R !== $.length - 1
												? T.push(m.length === 0 ? l : x(y))
												: H.chomping === 'keep' && re && T.push(D(m.length === 0 ? l : y))
									return (
										H.indent === null
											? A.push(c(q(j.tabWidth, T)))
											: A.push(D(q(H.indent - 1 + W, T))),
										A
									)
								}
								E.exports = G
							}
						}),
						c4 = le({
							'src/language-yaml/printer-yaml.js'(d, E) {
								'use strict'
								ge()
								var {
										builders: {
											breakParent: c,
											fill: D,
											group: g,
											hardline: l,
											join: p,
											line: f,
											lineSuffix: y,
											literalline: x
										},
										utils: { getDocParts: _, replaceTextEndOfLine: w }
									} = dn(),
									{ isPreviousLineEmpty: C } = wn(),
									{ insertPragma: v, isPragma: b } = r4(),
									{ locStart: k } = i4(),
									q = s4(),
									{
										getFlowScalarLineContents: G,
										getLastDescendantNode: O,
										hasLeadingComments: U,
										hasMiddleComments: j,
										hasTrailingComment: H,
										hasEndComments: W,
										hasPrettierIgnore: re,
										isLastDescendantNode: A,
										isNode: $,
										isInlineNode: T
									} = To(),
									R = o4(),
									{ alignWithSpaces: m, printNextEmptyLine: S, shouldPrintEndComments: L } = Ku(),
									{ printFlowMapping: P, printFlowSequence: M } = a4(),
									V = u4(),
									J = l4()
								function Z(X, De, Fe) {
									let ve = X.getValue(),
										$e = []
									ve.type !== 'mappingValue' &&
										U(ve) &&
										$e.push([p(l, X.map(Fe, 'leadingComments')), l])
									let { tag: ie, anchor: fe } = ve
									ie && $e.push(Fe('tag')), ie && fe && $e.push(' '), fe && $e.push(Fe('anchor'))
									let Be = ''
									$(ve, [
										'mapping',
										'sequence',
										'comment',
										'directive',
										'mappingItem',
										'sequenceItem'
									]) &&
										!A(X) &&
										(Be = S(X, De.originalText)),
										(ie || fe) &&
											($(ve, ['sequence', 'mapping']) && !j(ve) ? $e.push(l) : $e.push(' ')),
										j(ve) &&
											$e.push([
												ve.middleComments.length === 1 ? '' : l,
												p(l, X.map(Fe, 'middleComments')),
												l
											])
									let Me = X.getParentNode()
									return (
										re(X)
											? $e.push(
													w(
														De.originalText
															.slice(ve.position.start.offset, ve.position.end.offset)
															.trimEnd(),
														x
													)
											  )
											: $e.push(g(ne(ve, Me, X, De, Fe))),
										H(ve) &&
											!$(ve, ['document', 'documentHead']) &&
											$e.push(
												y([
													ve.type === 'mappingValue' && !ve.content ? '' : ' ',
													Me.type === 'mappingKey' && X.getParentNode(2).type === 'mapping' && T(ve)
														? ''
														: c,
													Fe('trailingComment')
												])
											),
										L(ve) &&
											$e.push(
												m(ve.type === 'sequenceItem' ? 2 : 0, [
													l,
													p(
														l,
														X.map(
															(Dt) => [C(De.originalText, Dt.getValue(), k) ? l : '', Fe()],
															'endComments'
														)
													)
												])
											),
										$e.push(Be),
										$e
									)
								}
								function ne(X, De, Fe, ve, $e) {
									switch (X.type) {
										case 'root': {
											let { children: ie } = X,
												fe = []
											Fe.each((Me, Dt) => {
												let me = ie[Dt],
													ae = ie[Dt + 1]
												Dt !== 0 && fe.push(l),
													fe.push($e()),
													ce(me, ae)
														? (fe.push(l, '...'), H(me) && fe.push(' ', $e('trailingComment')))
														: ae && !H(ae.head) && fe.push(l, '---')
											}, 'children')
											let Be = O(X)
											return (
												(!$(Be, ['blockLiteral', 'blockFolded']) || Be.chomping !== 'keep') &&
													fe.push(l),
												fe
											)
										}
										case 'document': {
											let ie = De.children[Fe.getName() + 1],
												fe = []
											return (
												z(X, ie, De, ve) === 'head' &&
													((X.head.children.length > 0 || X.head.endComments.length > 0) &&
														fe.push($e('head')),
													H(X.head)
														? fe.push(['---', ' ', $e(['head', 'trailingComment'])])
														: fe.push('---')),
												ee(X) && fe.push($e('body')),
												p(l, fe)
											)
										}
										case 'documentHead':
											return p(l, [...Fe.map($e, 'children'), ...Fe.map($e, 'endComments')])
										case 'documentBody': {
											let { children: ie, endComments: fe } = X,
												Be = ''
											if (ie.length > 0 && fe.length > 0) {
												let Me = O(X)
												$(Me, ['blockFolded', 'blockLiteral'])
													? Me.chomping !== 'keep' && (Be = [l, l])
													: (Be = l)
											}
											return [p(l, Fe.map($e, 'children')), Be, p(l, Fe.map($e, 'endComments'))]
										}
										case 'directive':
											return ['%', p(' ', [X.name, ...X.parameters])]
										case 'comment':
											return ['#', X.value]
										case 'alias':
											return ['*', X.value]
										case 'tag':
											return ve.originalText.slice(X.position.start.offset, X.position.end.offset)
										case 'anchor':
											return ['&', X.value]
										case 'plain':
											return ye(
												X.type,
												ve.originalText.slice(X.position.start.offset, X.position.end.offset),
												ve
											)
										case 'quoteDouble':
										case 'quoteSingle': {
											let ie = "'",
												fe = '"',
												Be = ve.originalText.slice(
													X.position.start.offset + 1,
													X.position.end.offset - 1
												)
											if (
												(X.type === 'quoteSingle' && Be.includes('\\')) ||
												(X.type === 'quoteDouble' && /\\[^"]/.test(Be))
											) {
												let Dt = X.type === 'quoteDouble' ? fe : ie
												return [Dt, ye(X.type, Be, ve), Dt]
											}
											if (Be.includes(fe))
												return [
													ie,
													ye(
														X.type,
														X.type === 'quoteDouble'
															? Be.replace(/\\"/g, fe).replace(/'/g, ie.repeat(2))
															: Be,
														ve
													),
													ie
												]
											if (Be.includes(ie))
												return [
													fe,
													ye(X.type, X.type === 'quoteSingle' ? Be.replace(/''/g, ie) : Be, ve),
													fe
												]
											let Me = ve.singleQuote ? ie : fe
											return [Me, ye(X.type, Be, ve), Me]
										}
										case 'blockFolded':
										case 'blockLiteral':
											return J(Fe, $e, ve)
										case 'mapping':
										case 'sequence':
											return p(l, Fe.map($e, 'children'))
										case 'sequenceItem':
											return ['- ', m(2, X.content ? $e('content') : '')]
										case 'mappingKey':
										case 'mappingValue':
											return X.content ? $e('content') : ''
										case 'mappingItem':
										case 'flowMappingItem':
											return V(X, De, Fe, $e, ve)
										case 'flowMapping':
											return P(Fe, $e, ve)
										case 'flowSequence':
											return M(Fe, $e, ve)
										case 'flowSequenceItem':
											return $e('content')
										default:
											throw new Error(`Unexpected node type ${X.type}`)
									}
								}
								function ee(X) {
									return X.body.children.length > 0 || W(X.body)
								}
								function ce(X, De) {
									return H(X) || (De && (De.head.children.length > 0 || W(De.head)))
								}
								function z(X, De, Fe, ve) {
									return (Fe.children[0] === X &&
										/---(?:\s|$)/.test(ve.originalText.slice(k(X), k(X) + 4))) ||
										X.head.children.length > 0 ||
										W(X.head) ||
										H(X.head)
										? 'head'
										: ce(X, De)
										? !1
										: De
										? 'root'
										: !1
								}
								function ye(X, De, Fe) {
									let ve = G(X, De, Fe)
									return p(
										l,
										ve.map(($e) => D(_(p(f, $e))))
									)
								}
								function te(X, De) {
									if ($(De))
										switch ((delete De.position, De.type)) {
											case 'comment':
												if (b(De.value)) return null
												break
											case 'quoteDouble':
											case 'quoteSingle':
												De.type = 'quote'
												break
										}
								}
								E.exports = {
									preprocess: R,
									embed: q,
									print: Z,
									massageAstNode: te,
									insertPragma: v
								}
							}
						}),
						p4 = le({
							'src/language-yaml/options.js'(d, E) {
								'use strict'
								ge()
								var c = xo()
								E.exports = {
									bracketSpacing: c.bracketSpacing,
									singleQuote: c.singleQuote,
									proseWrap: c.proseWrap
								}
							}
						}),
						f4 = le({
							'src/language-yaml/parsers.js'() {
								ge()
							}
						}),
						d4 = le({
							'node_modules/linguist-languages/data/YAML.json'(d, E) {
								E.exports = {
									name: 'YAML',
									type: 'data',
									color: '#cb171e',
									tmScope: 'source.yaml',
									aliases: ['yml'],
									extensions: [
										'.yml',
										'.mir',
										'.reek',
										'.rviz',
										'.sublime-syntax',
										'.syntax',
										'.yaml',
										'.yaml-tmlanguage',
										'.yaml.sed',
										'.yml.mysql'
									],
									filenames: [
										'.clang-format',
										'.clang-tidy',
										'.gemrc',
										'CITATION.cff',
										'glide.lock',
										'yarn.lock'
									],
									aceMode: 'yaml',
									codemirrorMode: 'yaml',
									codemirrorMimeType: 'text/x-yaml',
									languageId: 407
								}
							}
						}),
						h4 = le({
							'src/language-yaml/index.js'(d, E) {
								'use strict'
								ge()
								var c = Ms(),
									D = c4(),
									g = p4(),
									l = f4(),
									p = [
										c(d4(), (f) => ({
											since: '1.14.0',
											parsers: ['yaml'],
											vscodeLanguageIds: ['yaml', 'ansible', 'home-assistant'],
											filenames: [
												...f.filenames.filter((y) => y !== 'yarn.lock'),
												'.prettierrc',
												'.stylelintrc',
												'.lintstagedrc'
											]
										}))
									]
								E.exports = { languages: p, printers: { yaml: D }, options: g, parsers: l }
							}
						}),
						m4 = le({
							'src/languages.js'(d, E) {
								'use strict'
								ge(), (E.exports = [Qy(), dE(), xE(), FE(), BE(), n4(), h4()])
							}
						})
					ge()
					var { version: g4 } = ei(),
						Ao = fy(),
						{ getSupportInfo: D4 } = np(),
						y4 = dy(),
						E4 = m4(),
						v4 = dn()
					function $s(d) {
						let E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1
						return function () {
							for (var c = arguments.length, D = new Array(c), g = 0; g < c; g++)
								D[g] = arguments[g]
							let l = D[E] || {},
								p = l.plugins || []
							return (
								(D[E] = Object.assign(
									Object.assign({}, l),
									{},
									{ plugins: [...E4, ...(Array.isArray(p) ? p : Object.values(p))] }
								)),
								d(...D)
							)
						}
					}
					var Tp = $s(Ao.formatWithCursor)
					Le.exports = {
						formatWithCursor: Tp,
						format(d, E) {
							return Tp(d, E).formatted
						},
						check(d, E) {
							let { formatted: c } = Tp(d, E)
							return c === d
						},
						doc: v4,
						getSupportInfo: $s(D4, 0),
						version: g4,
						util: y4,
						__debug: {
							parse: $s(Ao.parse),
							formatAST: $s(Ao.formatAST),
							formatDoc: $s(Ao.formatDoc),
							printToDoc: $s(Ao.printToDoc),
							printDocToString: $s(Ao.printDocToString)
						}
					}
				})
			return nD()
		})
	})
	var X2 = as((Y2, e1) => {
		;(function (e) {
			if (typeof Y2 == 'object' && typeof e1 == 'object') e1.exports = e()
			else if (typeof define == 'function' && define.amd) define(e)
			else {
				var t =
					typeof globalThis < 'u'
						? globalThis
						: typeof global < 'u'
						? global
						: typeof self < 'u'
						? self
						: this || {}
				;(t.prettierPlugins = t.prettierPlugins || {}), (t.prettierPlugins.graphql = e())
			}
		})(function () {
			'use strict'
			var e = (n, r) => () => (r || n((r = { exports: {} }).exports, r), r.exports),
				t = e((n, r) => {
					var i = Object.getOwnPropertyNames,
						s = (He, dt) =>
							function () {
								return He && (dt = (0, He[i(He)[0]])((He = 0))), dt
							},
						o = (He, dt) =>
							function () {
								return dt || (0, He[i(He)[0]])((dt = { exports: {} }).exports, dt), dt.exports
							},
						a = s({ '<define:process>'() {} }),
						u = o({
							'src/common/parser-create-error.js'(He, dt) {
								'use strict'
								a()
								function be(tt, Ee) {
									let xt = new SyntaxError(tt + ' (' + Ee.start.line + ':' + Ee.start.column + ')')
									return (xt.loc = Ee), xt
								}
								dt.exports = be
							}
						}),
						h = o({
							'src/utils/try-combinations.js'(He, dt) {
								'use strict'
								a()
								function be() {
									let tt
									for (var Ee = arguments.length, xt = new Array(Ee), Nt = 0; Nt < Ee; Nt++)
										xt[Nt] = arguments[Nt]
									for (let [en, on] of xt.entries())
										try {
											return { result: on() }
										} catch (Bn) {
											en === 0 && (tt = Bn)
										}
									return { error: tt }
								}
								dt.exports = be
							}
						}),
						N = o({
							'src/language-graphql/pragma.js'(He, dt) {
								'use strict'
								a()
								function be(Ee) {
									return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(Ee)
								}
								function tt(Ee) {
									return (
										`# @format

` + Ee
									)
								}
								dt.exports = { hasPragma: be, insertPragma: tt }
							}
						}),
						I = o({
							'src/language-graphql/loc.js'(He, dt) {
								'use strict'
								a()
								function be(Ee) {
									return typeof Ee.start == 'number' ? Ee.start : Ee.loc && Ee.loc.start
								}
								function tt(Ee) {
									return typeof Ee.end == 'number' ? Ee.end : Ee.loc && Ee.loc.end
								}
								dt.exports = { locStart: be, locEnd: tt }
							}
						}),
						Q = o({
							'node_modules/graphql/jsutils/isObjectLike.js'(He) {
								'use strict'
								a(), Object.defineProperty(He, '__esModule', { value: !0 }), (He.default = be)
								function dt(tt) {
									return (
										typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
											? (dt = function (Ee) {
													return typeof Ee
											  })
											: (dt = function (Ee) {
													return Ee &&
														typeof Symbol == 'function' &&
														Ee.constructor === Symbol &&
														Ee !== Symbol.prototype
														? 'symbol'
														: typeof Ee
											  }),
										dt(tt)
									)
								}
								function be(tt) {
									return dt(tt) == 'object' && tt !== null
								}
							}
						}),
						K = o({
							'node_modules/graphql/polyfills/symbols.js'(He) {
								'use strict'
								a(),
									Object.defineProperty(He, '__esModule', { value: !0 }),
									(He.SYMBOL_TO_STRING_TAG = He.SYMBOL_ASYNC_ITERATOR = He.SYMBOL_ITERATOR = void 0)
								var dt =
									typeof Symbol == 'function' && Symbol.iterator != null
										? Symbol.iterator
										: '@@iterator'
								He.SYMBOL_ITERATOR = dt
								var be =
									typeof Symbol == 'function' && Symbol.asyncIterator != null
										? Symbol.asyncIterator
										: '@@asyncIterator'
								He.SYMBOL_ASYNC_ITERATOR = be
								var tt =
									typeof Symbol == 'function' && Symbol.toStringTag != null
										? Symbol.toStringTag
										: '@@toStringTag'
								He.SYMBOL_TO_STRING_TAG = tt
							}
						}),
						ue = o({
							'node_modules/graphql/language/location.js'(He) {
								'use strict'
								a(), Object.defineProperty(He, '__esModule', { value: !0 }), (He.getLocation = dt)
								function dt(be, tt) {
									for (
										var Ee = /\r\n|[\n\r]/g, xt = 1, Nt = tt + 1, en;
										(en = Ee.exec(be.body)) && en.index < tt;

									)
										(xt += 1), (Nt = tt + 1 - (en.index + en[0].length))
									return { line: xt, column: Nt }
								}
							}
						}),
						de = o({
							'node_modules/graphql/language/printLocation.js'(He) {
								'use strict'
								a(),
									Object.defineProperty(He, '__esModule', { value: !0 }),
									(He.printLocation = be),
									(He.printSourceLocation = tt)
								var dt = ue()
								function be(en) {
									return tt(en.source, (0, dt.getLocation)(en.source, en.start))
								}
								function tt(en, on) {
									var Bn = en.locationOffset.column - 1,
										gn = xt(Bn) + en.body,
										Pn = on.line - 1,
										Gn = en.locationOffset.line - 1,
										Ht = on.line + Gn,
										bn = on.line === 1 ? Bn : 0,
										gt = on.column + bn,
										qe = ''
											.concat(en.name, ':')
											.concat(Ht, ':')
											.concat(
												gt,
												`
`
											),
										Xe = gn.split(/\r\n|[\n\r]/g),
										Mt = Xe[Pn]
									if (Mt.length > 120) {
										for (
											var Ke = Math.floor(gt / 80), Yt = gt % 80, En = [], Gt = 0;
											Gt < Mt.length;
											Gt += 80
										)
											En.push(Mt.slice(Gt, Gt + 80))
										return (
											qe +
											Ee(
												[[''.concat(Ht), En[0]]].concat(
													En.slice(1, Ke + 1).map(function (rn) {
														return ['', rn]
													}),
													[
														[' ', xt(Yt - 1) + '^'],
														['', En[Ke + 1]]
													]
												)
											)
										)
									}
									return (
										qe +
										Ee([
											[''.concat(Ht - 1), Xe[Pn - 1]],
											[''.concat(Ht), Mt],
											['', xt(gt - 1) + '^'],
											[''.concat(Ht + 1), Xe[Pn + 1]]
										])
									)
								}
								function Ee(en) {
									var on = en.filter(function (gn) {
											var Pn = gn[0],
												Gn = gn[1]
											return Gn !== void 0
										}),
										Bn = Math.max.apply(
											Math,
											on.map(function (gn) {
												var Pn = gn[0]
												return Pn.length
											})
										)
									return on.map(function (gn) {
										var Pn = gn[0],
											Gn = gn[1]
										return Nt(Bn, Pn) + (Gn ? ' | ' + Gn : ' |')
									}).join(`
`)
								}
								function xt(en) {
									return Array(en + 1).join(' ')
								}
								function Nt(en, on) {
									return xt(en - on.length) + on
								}
							}
						}),
						Pe = o({
							'node_modules/graphql/error/GraphQLError.js'(He) {
								'use strict'
								a()
								function dt(Gt) {
									return (
										typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
											? (dt = function (rn) {
													return typeof rn
											  })
											: (dt = function (rn) {
													return rn &&
														typeof Symbol == 'function' &&
														rn.constructor === Symbol &&
														rn !== Symbol.prototype
														? 'symbol'
														: typeof rn
											  }),
										dt(Gt)
									)
								}
								Object.defineProperty(He, '__esModule', { value: !0 }),
									(He.printError = En),
									(He.GraphQLError = void 0)
								var be = Nt(Q()),
									tt = K(),
									Ee = ue(),
									xt = de()
								function Nt(Gt) {
									return Gt && Gt.__esModule ? Gt : { default: Gt }
								}
								function en(Gt, rn) {
									if (!(Gt instanceof rn)) throw new TypeError('Cannot call a class as a function')
								}
								function on(Gt, rn) {
									for (var lt = 0; lt < rn.length; lt++) {
										var $t = rn[lt]
										;($t.enumerable = $t.enumerable || !1),
											($t.configurable = !0),
											'value' in $t && ($t.writable = !0),
											Object.defineProperty(Gt, $t.key, $t)
									}
								}
								function Bn(Gt, rn, lt) {
									return rn && on(Gt.prototype, rn), lt && on(Gt, lt), Gt
								}
								function gn(Gt, rn) {
									if (typeof rn != 'function' && rn !== null)
										throw new TypeError('Super expression must either be null or a function')
									;(Gt.prototype = Object.create(rn && rn.prototype, {
										constructor: { value: Gt, writable: !0, configurable: !0 }
									})),
										rn && Mt(Gt, rn)
								}
								function Pn(Gt) {
									var rn = qe()
									return function () {
										var lt = Ke(Gt),
											$t
										if (rn) {
											var Ft = Ke(this).constructor
											$t = Reflect.construct(lt, arguments, Ft)
										} else $t = lt.apply(this, arguments)
										return Gn(this, $t)
									}
								}
								function Gn(Gt, rn) {
									return rn && (dt(rn) === 'object' || typeof rn == 'function') ? rn : Ht(Gt)
								}
								function Ht(Gt) {
									if (Gt === void 0)
										throw new ReferenceError(
											"this hasn't been initialised - super() hasn't been called"
										)
									return Gt
								}
								function bn(Gt) {
									var rn = typeof Map == 'function' ? new Map() : void 0
									return (
										(bn = function (lt) {
											if (lt === null || !Xe(lt)) return lt
											if (typeof lt != 'function')
												throw new TypeError('Super expression must either be null or a function')
											if (typeof rn < 'u') {
												if (rn.has(lt)) return rn.get(lt)
												rn.set(lt, $t)
											}
											function $t() {
												return gt(lt, arguments, Ke(this).constructor)
											}
											return (
												($t.prototype = Object.create(lt.prototype, {
													constructor: { value: $t, enumerable: !1, writable: !0, configurable: !0 }
												})),
												Mt($t, lt)
											)
										}),
										bn(Gt)
									)
								}
								function gt(Gt, rn, lt) {
									return (
										qe()
											? (gt = Reflect.construct)
											: (gt = function ($t, Ft, zt) {
													var kn = [null]
													kn.push.apply(kn, Ft)
													var jr = Function.bind.apply($t, kn),
														di = new jr()
													return zt && Mt(di, zt.prototype), di
											  }),
										gt.apply(null, arguments)
									)
								}
								function qe() {
									if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham)
										return !1
									if (typeof Proxy == 'function') return !0
									try {
										return (
											Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0
										)
									} catch {
										return !1
									}
								}
								function Xe(Gt) {
									return Function.toString.call(Gt).indexOf('[native code]') !== -1
								}
								function Mt(Gt, rn) {
									return (
										(Mt =
											Object.setPrototypeOf ||
											function (lt, $t) {
												return (lt.__proto__ = $t), lt
											}),
										Mt(Gt, rn)
									)
								}
								function Ke(Gt) {
									return (
										(Ke = Object.setPrototypeOf
											? Object.getPrototypeOf
											: function (rn) {
													return rn.__proto__ || Object.getPrototypeOf(rn)
											  }),
										Ke(Gt)
									)
								}
								var Yt = (function (Gt) {
									gn(lt, Gt)
									var rn = Pn(lt)
									function lt($t, Ft, zt, kn, jr, di, Ru) {
										var Ca, Sa, ho, Na, qi
										en(this, lt), (qi = rn.call(this, $t))
										var Gi = Array.isArray(Ft)
												? Ft.length !== 0
													? Ft
													: void 0
												: Ft
												? [Ft]
												: void 0,
											mo = zt
										if (!mo && Gi) {
											var Fa
											mo = (Fa = Gi[0].loc) === null || Fa === void 0 ? void 0 : Fa.source
										}
										var ms = kn
										!ms &&
											Gi &&
											(ms = Gi.reduce(function (ss, gs) {
												return gs.loc && ss.push(gs.loc.start), ss
											}, [])),
											ms && ms.length === 0 && (ms = void 0)
										var go
										kn && zt
											? (go = kn.map(function (ss) {
													return (0, Ee.getLocation)(zt, ss)
											  }))
											: Gi &&
											  (go = Gi.reduce(function (ss, gs) {
													return (
														gs.loc && ss.push((0, Ee.getLocation)(gs.loc.source, gs.loc.start)), ss
													)
											  }, []))
										var Do = Ru
										if (Do == null && di != null) {
											var Ou = di.extensions
											;(0, be.default)(Ou) && (Do = Ou)
										}
										return (
											Object.defineProperties(Ht(qi), {
												name: { value: 'GraphQLError' },
												message: { value: $t, enumerable: !0, writable: !0 },
												locations: {
													value: (Ca = go) !== null && Ca !== void 0 ? Ca : void 0,
													enumerable: go != null
												},
												path: { value: jr ?? void 0, enumerable: jr != null },
												nodes: { value: Gi ?? void 0 },
												source: { value: (Sa = mo) !== null && Sa !== void 0 ? Sa : void 0 },
												positions: { value: (ho = ms) !== null && ho !== void 0 ? ho : void 0 },
												originalError: { value: di },
												extensions: {
													value: (Na = Do) !== null && Na !== void 0 ? Na : void 0,
													enumerable: Do != null
												}
											}),
											di != null && di.stack
												? (Object.defineProperty(Ht(qi), 'stack', {
														value: di.stack,
														writable: !0,
														configurable: !0
												  }),
												  Gn(qi))
												: (Error.captureStackTrace
														? Error.captureStackTrace(Ht(qi), lt)
														: Object.defineProperty(Ht(qi), 'stack', {
																value: Error().stack,
																writable: !0,
																configurable: !0
														  }),
												  qi)
										)
									}
									return (
										Bn(lt, [
											{
												key: 'toString',
												value: function () {
													return En(this)
												}
											},
											{
												key: tt.SYMBOL_TO_STRING_TAG,
												get: function () {
													return 'Object'
												}
											}
										]),
										lt
									)
								})(bn(Error))
								He.GraphQLError = Yt
								function En(Gt) {
									var rn = Gt.message
									if (Gt.nodes)
										for (var lt = 0, $t = Gt.nodes; lt < $t.length; lt++) {
											var Ft = $t[lt]
											Ft.loc &&
												(rn +=
													`

` + (0, xt.printLocation)(Ft.loc))
										}
									else if (Gt.source && Gt.locations)
										for (var zt = 0, kn = Gt.locations; zt < kn.length; zt++) {
											var jr = kn[zt]
											rn +=
												`

` + (0, xt.printSourceLocation)(Gt.source, jr)
										}
									return rn
								}
							}
						}),
						Ze = o({
							'node_modules/graphql/error/syntaxError.js'(He) {
								'use strict'
								a(), Object.defineProperty(He, '__esModule', { value: !0 }), (He.syntaxError = be)
								var dt = Pe()
								function be(tt, Ee, xt) {
									return new dt.GraphQLError('Syntax Error: '.concat(xt), void 0, tt, [Ee])
								}
							}
						}),
						Ae = o({
							'node_modules/graphql/language/kinds.js'(He) {
								'use strict'
								a(), Object.defineProperty(He, '__esModule', { value: !0 }), (He.Kind = void 0)
								var dt = Object.freeze({
									NAME: 'Name',
									DOCUMENT: 'Document',
									OPERATION_DEFINITION: 'OperationDefinition',
									VARIABLE_DEFINITION: 'VariableDefinition',
									SELECTION_SET: 'SelectionSet',
									FIELD: 'Field',
									ARGUMENT: 'Argument',
									FRAGMENT_SPREAD: 'FragmentSpread',
									INLINE_FRAGMENT: 'InlineFragment',
									FRAGMENT_DEFINITION: 'FragmentDefinition',
									VARIABLE: 'Variable',
									INT: 'IntValue',
									FLOAT: 'FloatValue',
									STRING: 'StringValue',
									BOOLEAN: 'BooleanValue',
									NULL: 'NullValue',
									ENUM: 'EnumValue',
									LIST: 'ListValue',
									OBJECT: 'ObjectValue',
									OBJECT_FIELD: 'ObjectField',
									DIRECTIVE: 'Directive',
									NAMED_TYPE: 'NamedType',
									LIST_TYPE: 'ListType',
									NON_NULL_TYPE: 'NonNullType',
									SCHEMA_DEFINITION: 'SchemaDefinition',
									OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',
									SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',
									OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',
									FIELD_DEFINITION: 'FieldDefinition',
									INPUT_VALUE_DEFINITION: 'InputValueDefinition',
									INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',
									UNION_TYPE_DEFINITION: 'UnionTypeDefinition',
									ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',
									ENUM_VALUE_DEFINITION: 'EnumValueDefinition',
									INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',
									DIRECTIVE_DEFINITION: 'DirectiveDefinition',
									SCHEMA_EXTENSION: 'SchemaExtension',
									SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',
									OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',
									INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',
									UNION_TYPE_EXTENSION: 'UnionTypeExtension',
									ENUM_TYPE_EXTENSION: 'EnumTypeExtension',
									INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension'
								})
								He.Kind = dt
							}
						}),
						ze = o({
							'node_modules/graphql/jsutils/invariant.js'(He) {
								'use strict'
								a(), Object.defineProperty(He, '__esModule', { value: !0 }), (He.default = dt)
								function dt(be, tt) {
									var Ee = !!be
									if (!Ee) throw new Error(tt ?? 'Unexpected invariant triggered.')
								}
							}
						}),
						it = o({
							'node_modules/graphql/jsutils/nodejsCustomInspectSymbol.js'(He) {
								'use strict'
								a(), Object.defineProperty(He, '__esModule', { value: !0 }), (He.default = void 0)
								var dt =
										typeof Symbol == 'function' && typeof Symbol.for == 'function'
											? Symbol.for('nodejs.util.inspect.custom')
											: void 0,
									be = dt
								He.default = be
							}
						}),
						Et = o({
							'node_modules/graphql/jsutils/defineInspect.js'(He) {
								'use strict'
								a(), Object.defineProperty(He, '__esModule', { value: !0 }), (He.default = Ee)
								var dt = tt(ze()),
									be = tt(it())
								function tt(xt) {
									return xt && xt.__esModule ? xt : { default: xt }
								}
								function Ee(xt) {
									var Nt = xt.prototype.toJSON
									typeof Nt == 'function' || (0, dt.default)(0),
										(xt.prototype.inspect = Nt),
										be.default && (xt.prototype[be.default] = Nt)
								}
							}
						}),
						_t = o({
							'node_modules/graphql/language/ast.js'(He) {
								'use strict'
								a(),
									Object.defineProperty(He, '__esModule', { value: !0 }),
									(He.isNode = xt),
									(He.Token = He.Location = void 0)
								var dt = be(Et())
								function be(Nt) {
									return Nt && Nt.__esModule ? Nt : { default: Nt }
								}
								var tt = (function () {
									function Nt(on, Bn, gn) {
										;(this.start = on.start),
											(this.end = Bn.end),
											(this.startToken = on),
											(this.endToken = Bn),
											(this.source = gn)
									}
									var en = Nt.prototype
									return (
										(en.toJSON = function () {
											return { start: this.start, end: this.end }
										}),
										Nt
									)
								})()
								;(He.Location = tt), (0, dt.default)(tt)
								var Ee = (function () {
									function Nt(on, Bn, gn, Pn, Gn, Ht, bn) {
										;(this.kind = on),
											(this.start = Bn),
											(this.end = gn),
											(this.line = Pn),
											(this.column = Gn),
											(this.value = bn),
											(this.prev = Ht),
											(this.next = null)
									}
									var en = Nt.prototype
									return (
										(en.toJSON = function () {
											return {
												kind: this.kind,
												value: this.value,
												line: this.line,
												column: this.column
											}
										}),
										Nt
									)
								})()
								;(He.Token = Ee), (0, dt.default)(Ee)
								function xt(Nt) {
									return Nt != null && typeof Nt.kind == 'string'
								}
							}
						}),
						ct = o({
							'node_modules/graphql/language/tokenKind.js'(He) {
								'use strict'
								a(), Object.defineProperty(He, '__esModule', { value: !0 }), (He.TokenKind = void 0)
								var dt = Object.freeze({
									SOF: '<SOF>',
									EOF: '<EOF>',
									BANG: '!',
									DOLLAR: '$',
									AMP: '&',
									PAREN_L: '(',
									PAREN_R: ')',
									SPREAD: '...',
									COLON: ':',
									EQUALS: '=',
									AT: '@',
									BRACKET_L: '[',
									BRACKET_R: ']',
									BRACE_L: '{',
									PIPE: '|',
									BRACE_R: '}',
									NAME: 'Name',
									INT: 'Int',
									FLOAT: 'Float',
									STRING: 'String',
									BLOCK_STRING: 'BlockString',
									COMMENT: 'Comment'
								})
								He.TokenKind = dt
							}
						}),
						St = o({
							'node_modules/graphql/jsutils/inspect.js'(He) {
								'use strict'
								a(), Object.defineProperty(He, '__esModule', { value: !0 }), (He.default = Nt)
								var dt = be(it())
								function be(Ht) {
									return Ht && Ht.__esModule ? Ht : { default: Ht }
								}
								function tt(Ht) {
									return (
										typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
											? (tt = function (bn) {
													return typeof bn
											  })
											: (tt = function (bn) {
													return bn &&
														typeof Symbol == 'function' &&
														bn.constructor === Symbol &&
														bn !== Symbol.prototype
														? 'symbol'
														: typeof bn
											  }),
										tt(Ht)
									)
								}
								var Ee = 10,
									xt = 2
								function Nt(Ht) {
									return en(Ht, [])
								}
								function en(Ht, bn) {
									switch (tt(Ht)) {
										case 'string':
											return JSON.stringify(Ht)
										case 'function':
											return Ht.name ? '[function '.concat(Ht.name, ']') : '[function]'
										case 'object':
											return Ht === null ? 'null' : on(Ht, bn)
										default:
											return String(Ht)
									}
								}
								function on(Ht, bn) {
									if (bn.indexOf(Ht) !== -1) return '[Circular]'
									var gt = [].concat(bn, [Ht]),
										qe = Pn(Ht)
									if (qe !== void 0) {
										var Xe = qe.call(Ht)
										if (Xe !== Ht) return typeof Xe == 'string' ? Xe : en(Xe, gt)
									} else if (Array.isArray(Ht)) return gn(Ht, gt)
									return Bn(Ht, gt)
								}
								function Bn(Ht, bn) {
									var gt = Object.keys(Ht)
									if (gt.length === 0) return '{}'
									if (bn.length > xt) return '[' + Gn(Ht) + ']'
									var qe = gt.map(function (Xe) {
										var Mt = en(Ht[Xe], bn)
										return Xe + ': ' + Mt
									})
									return '{ ' + qe.join(', ') + ' }'
								}
								function gn(Ht, bn) {
									if (Ht.length === 0) return '[]'
									if (bn.length > xt) return '[Array]'
									for (
										var gt = Math.min(Ee, Ht.length), qe = Ht.length - gt, Xe = [], Mt = 0;
										Mt < gt;
										++Mt
									)
										Xe.push(en(Ht[Mt], bn))
									return (
										qe === 1
											? Xe.push('... 1 more item')
											: qe > 1 && Xe.push('... '.concat(qe, ' more items')),
										'[' + Xe.join(', ') + ']'
									)
								}
								function Pn(Ht) {
									var bn = Ht[String(dt.default)]
									if (typeof bn == 'function') return bn
									if (typeof Ht.inspect == 'function') return Ht.inspect
								}
								function Gn(Ht) {
									var bn = Object.prototype.toString
										.call(Ht)
										.replace(/^\[object /, '')
										.replace(/]$/, '')
									if (bn === 'Object' && typeof Ht.constructor == 'function') {
										var gt = Ht.constructor.name
										if (typeof gt == 'string' && gt !== '') return gt
									}
									return bn
								}
							}
						}),
						Je = o({
							'node_modules/graphql/jsutils/devAssert.js'(He) {
								'use strict'
								a(), Object.defineProperty(He, '__esModule', { value: !0 }), (He.default = dt)
								function dt(be, tt) {
									var Ee = !!be
									if (!Ee) throw new Error(tt)
								}
							}
						}),
						Ve = o({
							'node_modules/graphql/jsutils/instanceOf.js'(He) {
								'use strict'
								a(), Object.defineProperty(He, '__esModule', { value: !0 }), (He.default = void 0)
								var dt = be(St())
								function be(Ee) {
									return Ee && Ee.__esModule ? Ee : { default: Ee }
								}
								var tt = function (Ee, xt) {
									return Ee instanceof xt
								}
								He.default = tt
							}
						}),
						Qt = o({
							'node_modules/graphql/language/source.js'(He) {
								'use strict'
								a(),
									Object.defineProperty(He, '__esModule', { value: !0 }),
									(He.isSource = Bn),
									(He.Source = void 0)
								var dt = K(),
									be = xt(St()),
									tt = xt(Je()),
									Ee = xt(Ve())
								function xt(gn) {
									return gn && gn.__esModule ? gn : { default: gn }
								}
								function Nt(gn, Pn) {
									for (var Gn = 0; Gn < Pn.length; Gn++) {
										var Ht = Pn[Gn]
										;(Ht.enumerable = Ht.enumerable || !1),
											(Ht.configurable = !0),
											'value' in Ht && (Ht.writable = !0),
											Object.defineProperty(gn, Ht.key, Ht)
									}
								}
								function en(gn, Pn, Gn) {
									return Pn && Nt(gn.prototype, Pn), Gn && Nt(gn, Gn), gn
								}
								var on = (function () {
									function gn(Pn) {
										var Gn =
												arguments.length > 1 && arguments[1] !== void 0
													? arguments[1]
													: 'GraphQL request',
											Ht =
												arguments.length > 2 && arguments[2] !== void 0
													? arguments[2]
													: { line: 1, column: 1 }
										typeof Pn == 'string' ||
											(0, tt.default)(
												0,
												'Body must be a string. Received: '.concat((0, be.default)(Pn), '.')
											),
											(this.body = Pn),
											(this.name = Gn),
											(this.locationOffset = Ht),
											this.locationOffset.line > 0 ||
												(0, tt.default)(
													0,
													'line in locationOffset is 1-indexed and must be positive.'
												),
											this.locationOffset.column > 0 ||
												(0, tt.default)(
													0,
													'column in locationOffset is 1-indexed and must be positive.'
												)
									}
									return (
										en(gn, [
											{
												key: dt.SYMBOL_TO_STRING_TAG,
												get: function () {
													return 'Source'
												}
											}
										]),
										gn
									)
								})()
								He.Source = on
								function Bn(gn) {
									return (0, Ee.default)(gn, on)
								}
							}
						}),
						qt = o({
							'node_modules/graphql/language/directiveLocation.js'(He) {
								'use strict'
								a(),
									Object.defineProperty(He, '__esModule', { value: !0 }),
									(He.DirectiveLocation = void 0)
								var dt = Object.freeze({
									QUERY: 'QUERY',
									MUTATION: 'MUTATION',
									SUBSCRIPTION: 'SUBSCRIPTION',
									FIELD: 'FIELD',
									FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',
									FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',
									INLINE_FRAGMENT: 'INLINE_FRAGMENT',
									VARIABLE_DEFINITION: 'VARIABLE_DEFINITION',
									SCHEMA: 'SCHEMA',
									SCALAR: 'SCALAR',
									OBJECT: 'OBJECT',
									FIELD_DEFINITION: 'FIELD_DEFINITION',
									ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',
									INTERFACE: 'INTERFACE',
									UNION: 'UNION',
									ENUM: 'ENUM',
									ENUM_VALUE: 'ENUM_VALUE',
									INPUT_OBJECT: 'INPUT_OBJECT',
									INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION'
								})
								He.DirectiveLocation = dt
							}
						}),
						Bt = o({
							'node_modules/graphql/language/blockString.js'(He) {
								'use strict'
								a(),
									Object.defineProperty(He, '__esModule', { value: !0 }),
									(He.dedentBlockStringValue = dt),
									(He.getBlockStringIndentation = tt),
									(He.printBlockString = Ee)
								function dt(xt) {
									var Nt = xt.split(/\r\n|[\n\r]/g),
										en = tt(xt)
									if (en !== 0) for (var on = 1; on < Nt.length; on++) Nt[on] = Nt[on].slice(en)
									for (var Bn = 0; Bn < Nt.length && be(Nt[Bn]); ) ++Bn
									for (var gn = Nt.length; gn > Bn && be(Nt[gn - 1]); ) --gn
									return Nt.slice(Bn, gn).join(`
`)
								}
								function be(xt) {
									for (var Nt = 0; Nt < xt.length; ++Nt)
										if (xt[Nt] !== ' ' && xt[Nt] !== '	') return !1
									return !0
								}
								function tt(xt) {
									for (var Nt, en = !0, on = !0, Bn = 0, gn = null, Pn = 0; Pn < xt.length; ++Pn)
										switch (xt.charCodeAt(Pn)) {
											case 13:
												xt.charCodeAt(Pn + 1) === 10 && ++Pn
											case 10:
												;(en = !1), (on = !0), (Bn = 0)
												break
											case 9:
											case 32:
												++Bn
												break
											default:
												on && !en && (gn === null || Bn < gn) && (gn = Bn), (on = !1)
										}
									return (Nt = gn) !== null && Nt !== void 0 ? Nt : 0
								}
								function Ee(xt) {
									var Nt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : '',
										en = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
										on =
											xt.indexOf(`
`) === -1,
										Bn = xt[0] === ' ' || xt[0] === '	',
										gn = xt[xt.length - 1] === '"',
										Pn = xt[xt.length - 1] === '\\',
										Gn = !on || gn || Pn || en,
										Ht = ''
									return (
										Gn &&
											!(on && Bn) &&
											(Ht +=
												`
` + Nt),
										(Ht += Nt
											? xt.replace(
													/\n/g,
													`
` + Nt
											  )
											: xt),
										Gn &&
											(Ht += `
`),
										'"""' + Ht.replace(/"""/g, '\\"""') + '"""'
									)
								}
							}
						}),
						Te = o({
							'node_modules/graphql/language/lexer.js'(He) {
								'use strict'
								a(),
									Object.defineProperty(He, '__esModule', { value: !0 }),
									(He.isPunctuatorTokenKind = Nt),
									(He.Lexer = void 0)
								var dt = Ze(),
									be = _t(),
									tt = ct(),
									Ee = Bt(),
									xt = (function () {
										function Ke(En) {
											var Gt = new be.Token(tt.TokenKind.SOF, 0, 0, 0, 0, null)
											;(this.source = En),
												(this.lastToken = Gt),
												(this.token = Gt),
												(this.line = 1),
												(this.lineStart = 0)
										}
										var Yt = Ke.prototype
										return (
											(Yt.advance = function () {
												this.lastToken = this.token
												var En = (this.token = this.lookahead())
												return En
											}),
											(Yt.lookahead = function () {
												var En = this.token
												if (En.kind !== tt.TokenKind.EOF)
													do {
														var Gt
														En =
															(Gt = En.next) !== null && Gt !== void 0
																? Gt
																: (En.next = on(this, En))
													} while (En.kind === tt.TokenKind.COMMENT)
												return En
											}),
											Ke
										)
									})()
								He.Lexer = xt
								function Nt(Ke) {
									return (
										Ke === tt.TokenKind.BANG ||
										Ke === tt.TokenKind.DOLLAR ||
										Ke === tt.TokenKind.AMP ||
										Ke === tt.TokenKind.PAREN_L ||
										Ke === tt.TokenKind.PAREN_R ||
										Ke === tt.TokenKind.SPREAD ||
										Ke === tt.TokenKind.COLON ||
										Ke === tt.TokenKind.EQUALS ||
										Ke === tt.TokenKind.AT ||
										Ke === tt.TokenKind.BRACKET_L ||
										Ke === tt.TokenKind.BRACKET_R ||
										Ke === tt.TokenKind.BRACE_L ||
										Ke === tt.TokenKind.PIPE ||
										Ke === tt.TokenKind.BRACE_R
									)
								}
								function en(Ke) {
									return isNaN(Ke)
										? tt.TokenKind.EOF
										: Ke < 127
										? JSON.stringify(String.fromCharCode(Ke))
										: '"\\u'.concat(('00' + Ke.toString(16).toUpperCase()).slice(-4), '"')
								}
								function on(Ke, Yt) {
									for (var En = Ke.source, Gt = En.body, rn = Gt.length, lt = Yt.end; lt < rn; ) {
										var $t = Gt.charCodeAt(lt),
											Ft = Ke.line,
											zt = 1 + lt - Ke.lineStart
										switch ($t) {
											case 65279:
											case 9:
											case 32:
											case 44:
												++lt
												continue
											case 10:
												++lt, ++Ke.line, (Ke.lineStart = lt)
												continue
											case 13:
												Gt.charCodeAt(lt + 1) === 10 ? (lt += 2) : ++lt,
													++Ke.line,
													(Ke.lineStart = lt)
												continue
											case 33:
												return new be.Token(tt.TokenKind.BANG, lt, lt + 1, Ft, zt, Yt)
											case 35:
												return gn(En, lt, Ft, zt, Yt)
											case 36:
												return new be.Token(tt.TokenKind.DOLLAR, lt, lt + 1, Ft, zt, Yt)
											case 38:
												return new be.Token(tt.TokenKind.AMP, lt, lt + 1, Ft, zt, Yt)
											case 40:
												return new be.Token(tt.TokenKind.PAREN_L, lt, lt + 1, Ft, zt, Yt)
											case 41:
												return new be.Token(tt.TokenKind.PAREN_R, lt, lt + 1, Ft, zt, Yt)
											case 46:
												if (Gt.charCodeAt(lt + 1) === 46 && Gt.charCodeAt(lt + 2) === 46)
													return new be.Token(tt.TokenKind.SPREAD, lt, lt + 3, Ft, zt, Yt)
												break
											case 58:
												return new be.Token(tt.TokenKind.COLON, lt, lt + 1, Ft, zt, Yt)
											case 61:
												return new be.Token(tt.TokenKind.EQUALS, lt, lt + 1, Ft, zt, Yt)
											case 64:
												return new be.Token(tt.TokenKind.AT, lt, lt + 1, Ft, zt, Yt)
											case 91:
												return new be.Token(tt.TokenKind.BRACKET_L, lt, lt + 1, Ft, zt, Yt)
											case 93:
												return new be.Token(tt.TokenKind.BRACKET_R, lt, lt + 1, Ft, zt, Yt)
											case 123:
												return new be.Token(tt.TokenKind.BRACE_L, lt, lt + 1, Ft, zt, Yt)
											case 124:
												return new be.Token(tt.TokenKind.PIPE, lt, lt + 1, Ft, zt, Yt)
											case 125:
												return new be.Token(tt.TokenKind.BRACE_R, lt, lt + 1, Ft, zt, Yt)
											case 34:
												return Gt.charCodeAt(lt + 1) === 34 && Gt.charCodeAt(lt + 2) === 34
													? bn(En, lt, Ft, zt, Yt, Ke)
													: Ht(En, lt, Ft, zt, Yt)
											case 45:
											case 48:
											case 49:
											case 50:
											case 51:
											case 52:
											case 53:
											case 54:
											case 55:
											case 56:
											case 57:
												return Pn(En, lt, $t, Ft, zt, Yt)
											case 65:
											case 66:
											case 67:
											case 68:
											case 69:
											case 70:
											case 71:
											case 72:
											case 73:
											case 74:
											case 75:
											case 76:
											case 77:
											case 78:
											case 79:
											case 80:
											case 81:
											case 82:
											case 83:
											case 84:
											case 85:
											case 86:
											case 87:
											case 88:
											case 89:
											case 90:
											case 95:
											case 97:
											case 98:
											case 99:
											case 100:
											case 101:
											case 102:
											case 103:
											case 104:
											case 105:
											case 106:
											case 107:
											case 108:
											case 109:
											case 110:
											case 111:
											case 112:
											case 113:
											case 114:
											case 115:
											case 116:
											case 117:
											case 118:
											case 119:
											case 120:
											case 121:
											case 122:
												return Xe(En, lt, Ft, zt, Yt)
										}
										throw (0, dt.syntaxError)(En, lt, Bn($t))
									}
									var kn = Ke.line,
										jr = 1 + lt - Ke.lineStart
									return new be.Token(tt.TokenKind.EOF, rn, rn, kn, jr, Yt)
								}
								function Bn(Ke) {
									return Ke < 32 && Ke !== 9 && Ke !== 10 && Ke !== 13
										? 'Cannot contain the invalid character '.concat(en(Ke), '.')
										: Ke === 39
										? `Unexpected single quote character ('), did you mean to use a double quote (")?`
										: 'Cannot parse the unexpected character '.concat(en(Ke), '.')
								}
								function gn(Ke, Yt, En, Gt, rn) {
									var lt = Ke.body,
										$t,
										Ft = Yt
									do $t = lt.charCodeAt(++Ft)
									while (!isNaN($t) && ($t > 31 || $t === 9))
									return new be.Token(
										tt.TokenKind.COMMENT,
										Yt,
										Ft,
										En,
										Gt,
										rn,
										lt.slice(Yt + 1, Ft)
									)
								}
								function Pn(Ke, Yt, En, Gt, rn, lt) {
									var $t = Ke.body,
										Ft = En,
										zt = Yt,
										kn = !1
									if ((Ft === 45 && (Ft = $t.charCodeAt(++zt)), Ft === 48)) {
										if (((Ft = $t.charCodeAt(++zt)), Ft >= 48 && Ft <= 57))
											throw (0, dt.syntaxError)(
												Ke,
												zt,
												'Invalid number, unexpected digit after 0: '.concat(en(Ft), '.')
											)
									} else (zt = Gn(Ke, zt, Ft)), (Ft = $t.charCodeAt(zt))
									if (
										(Ft === 46 &&
											((kn = !0),
											(Ft = $t.charCodeAt(++zt)),
											(zt = Gn(Ke, zt, Ft)),
											(Ft = $t.charCodeAt(zt))),
										(Ft === 69 || Ft === 101) &&
											((kn = !0),
											(Ft = $t.charCodeAt(++zt)),
											(Ft === 43 || Ft === 45) && (Ft = $t.charCodeAt(++zt)),
											(zt = Gn(Ke, zt, Ft)),
											(Ft = $t.charCodeAt(zt))),
										Ft === 46 || Mt(Ft))
									)
										throw (0, dt.syntaxError)(
											Ke,
											zt,
											'Invalid number, expected digit but got: '.concat(en(Ft), '.')
										)
									return new be.Token(
										kn ? tt.TokenKind.FLOAT : tt.TokenKind.INT,
										Yt,
										zt,
										Gt,
										rn,
										lt,
										$t.slice(Yt, zt)
									)
								}
								function Gn(Ke, Yt, En) {
									var Gt = Ke.body,
										rn = Yt,
										lt = En
									if (lt >= 48 && lt <= 57) {
										do lt = Gt.charCodeAt(++rn)
										while (lt >= 48 && lt <= 57)
										return rn
									}
									throw (0, dt.syntaxError)(
										Ke,
										rn,
										'Invalid number, expected digit but got: '.concat(en(lt), '.')
									)
								}
								function Ht(Ke, Yt, En, Gt, rn) {
									for (
										var lt = Ke.body, $t = Yt + 1, Ft = $t, zt = 0, kn = '';
										$t < lt.length && !isNaN((zt = lt.charCodeAt($t))) && zt !== 10 && zt !== 13;

									) {
										if (zt === 34)
											return (
												(kn += lt.slice(Ft, $t)),
												new be.Token(tt.TokenKind.STRING, Yt, $t + 1, En, Gt, rn, kn)
											)
										if (zt < 32 && zt !== 9)
											throw (0, dt.syntaxError)(
												Ke,
												$t,
												'Invalid character within String: '.concat(en(zt), '.')
											)
										if ((++$t, zt === 92)) {
											switch (((kn += lt.slice(Ft, $t - 1)), (zt = lt.charCodeAt($t)), zt)) {
												case 34:
													kn += '"'
													break
												case 47:
													kn += '/'
													break
												case 92:
													kn += '\\'
													break
												case 98:
													kn += '\b'
													break
												case 102:
													kn += '\f'
													break
												case 110:
													kn += `
`
													break
												case 114:
													kn += '\r'
													break
												case 116:
													kn += '	'
													break
												case 117: {
													var jr = gt(
														lt.charCodeAt($t + 1),
														lt.charCodeAt($t + 2),
														lt.charCodeAt($t + 3),
														lt.charCodeAt($t + 4)
													)
													if (jr < 0) {
														var di = lt.slice($t + 1, $t + 5)
														throw (0, dt.syntaxError)(
															Ke,
															$t,
															'Invalid character escape sequence: \\u'.concat(di, '.')
														)
													}
													;(kn += String.fromCharCode(jr)), ($t += 4)
													break
												}
												default:
													throw (0, dt.syntaxError)(
														Ke,
														$t,
														'Invalid character escape sequence: \\'.concat(
															String.fromCharCode(zt),
															'.'
														)
													)
											}
											++$t, (Ft = $t)
										}
									}
									throw (0, dt.syntaxError)(Ke, $t, 'Unterminated string.')
								}
								function bn(Ke, Yt, En, Gt, rn, lt) {
									for (
										var $t = Ke.body, Ft = Yt + 3, zt = Ft, kn = 0, jr = '';
										Ft < $t.length && !isNaN((kn = $t.charCodeAt(Ft)));

									) {
										if (kn === 34 && $t.charCodeAt(Ft + 1) === 34 && $t.charCodeAt(Ft + 2) === 34)
											return (
												(jr += $t.slice(zt, Ft)),
												new be.Token(
													tt.TokenKind.BLOCK_STRING,
													Yt,
													Ft + 3,
													En,
													Gt,
													rn,
													(0, Ee.dedentBlockStringValue)(jr)
												)
											)
										if (kn < 32 && kn !== 9 && kn !== 10 && kn !== 13)
											throw (0, dt.syntaxError)(
												Ke,
												Ft,
												'Invalid character within String: '.concat(en(kn), '.')
											)
										kn === 10
											? (++Ft, ++lt.line, (lt.lineStart = Ft))
											: kn === 13
											? ($t.charCodeAt(Ft + 1) === 10 ? (Ft += 2) : ++Ft,
											  ++lt.line,
											  (lt.lineStart = Ft))
											: kn === 92 &&
											  $t.charCodeAt(Ft + 1) === 34 &&
											  $t.charCodeAt(Ft + 2) === 34 &&
											  $t.charCodeAt(Ft + 3) === 34
											? ((jr += $t.slice(zt, Ft) + '"""'), (Ft += 4), (zt = Ft))
											: ++Ft
									}
									throw (0, dt.syntaxError)(Ke, Ft, 'Unterminated string.')
								}
								function gt(Ke, Yt, En, Gt) {
									return (qe(Ke) << 12) | (qe(Yt) << 8) | (qe(En) << 4) | qe(Gt)
								}
								function qe(Ke) {
									return Ke >= 48 && Ke <= 57
										? Ke - 48
										: Ke >= 65 && Ke <= 70
										? Ke - 55
										: Ke >= 97 && Ke <= 102
										? Ke - 87
										: -1
								}
								function Xe(Ke, Yt, En, Gt, rn) {
									for (
										var lt = Ke.body, $t = lt.length, Ft = Yt + 1, zt = 0;
										Ft !== $t &&
										!isNaN((zt = lt.charCodeAt(Ft))) &&
										(zt === 95 ||
											(zt >= 48 && zt <= 57) ||
											(zt >= 65 && zt <= 90) ||
											(zt >= 97 && zt <= 122));

									)
										++Ft
									return new be.Token(tt.TokenKind.NAME, Yt, Ft, En, Gt, rn, lt.slice(Yt, Ft))
								}
								function Mt(Ke) {
									return Ke === 95 || (Ke >= 65 && Ke <= 90) || (Ke >= 97 && Ke <= 122)
								}
							}
						}),
						Ne = o({
							'node_modules/graphql/language/parser.js'(He) {
								'use strict'
								a(),
									Object.defineProperty(He, '__esModule', { value: !0 }),
									(He.parse = on),
									(He.parseValue = Bn),
									(He.parseType = gn),
									(He.Parser = void 0)
								var dt = Ze(),
									be = Ae(),
									tt = _t(),
									Ee = ct(),
									xt = Qt(),
									Nt = qt(),
									en = Te()
								function on(bn, gt) {
									var qe = new Pn(bn, gt)
									return qe.parseDocument()
								}
								function Bn(bn, gt) {
									var qe = new Pn(bn, gt)
									qe.expectToken(Ee.TokenKind.SOF)
									var Xe = qe.parseValueLiteral(!1)
									return qe.expectToken(Ee.TokenKind.EOF), Xe
								}
								function gn(bn, gt) {
									var qe = new Pn(bn, gt)
									qe.expectToken(Ee.TokenKind.SOF)
									var Xe = qe.parseTypeReference()
									return qe.expectToken(Ee.TokenKind.EOF), Xe
								}
								var Pn = (function () {
									function bn(qe, Xe) {
										var Mt = (0, xt.isSource)(qe) ? qe : new xt.Source(qe)
										;(this._lexer = new en.Lexer(Mt)), (this._options = Xe)
									}
									var gt = bn.prototype
									return (
										(gt.parseName = function () {
											var qe = this.expectToken(Ee.TokenKind.NAME)
											return { kind: be.Kind.NAME, value: qe.value, loc: this.loc(qe) }
										}),
										(gt.parseDocument = function () {
											var qe = this._lexer.token
											return {
												kind: be.Kind.DOCUMENT,
												definitions: this.many(
													Ee.TokenKind.SOF,
													this.parseDefinition,
													Ee.TokenKind.EOF
												),
												loc: this.loc(qe)
											}
										}),
										(gt.parseDefinition = function () {
											if (this.peek(Ee.TokenKind.NAME))
												switch (this._lexer.token.value) {
													case 'query':
													case 'mutation':
													case 'subscription':
														return this.parseOperationDefinition()
													case 'fragment':
														return this.parseFragmentDefinition()
													case 'schema':
													case 'scalar':
													case 'type':
													case 'interface':
													case 'union':
													case 'enum':
													case 'input':
													case 'directive':
														return this.parseTypeSystemDefinition()
													case 'extend':
														return this.parseTypeSystemExtension()
												}
											else {
												if (this.peek(Ee.TokenKind.BRACE_L)) return this.parseOperationDefinition()
												if (this.peekDescription()) return this.parseTypeSystemDefinition()
											}
											throw this.unexpected()
										}),
										(gt.parseOperationDefinition = function () {
											var qe = this._lexer.token
											if (this.peek(Ee.TokenKind.BRACE_L))
												return {
													kind: be.Kind.OPERATION_DEFINITION,
													operation: 'query',
													name: void 0,
													variableDefinitions: [],
													directives: [],
													selectionSet: this.parseSelectionSet(),
													loc: this.loc(qe)
												}
											var Xe = this.parseOperationType(),
												Mt
											return (
												this.peek(Ee.TokenKind.NAME) && (Mt = this.parseName()),
												{
													kind: be.Kind.OPERATION_DEFINITION,
													operation: Xe,
													name: Mt,
													variableDefinitions: this.parseVariableDefinitions(),
													directives: this.parseDirectives(!1),
													selectionSet: this.parseSelectionSet(),
													loc: this.loc(qe)
												}
											)
										}),
										(gt.parseOperationType = function () {
											var qe = this.expectToken(Ee.TokenKind.NAME)
											switch (qe.value) {
												case 'query':
													return 'query'
												case 'mutation':
													return 'mutation'
												case 'subscription':
													return 'subscription'
											}
											throw this.unexpected(qe)
										}),
										(gt.parseVariableDefinitions = function () {
											return this.optionalMany(
												Ee.TokenKind.PAREN_L,
												this.parseVariableDefinition,
												Ee.TokenKind.PAREN_R
											)
										}),
										(gt.parseVariableDefinition = function () {
											var qe = this._lexer.token
											return {
												kind: be.Kind.VARIABLE_DEFINITION,
												variable: this.parseVariable(),
												type: (this.expectToken(Ee.TokenKind.COLON), this.parseTypeReference()),
												defaultValue: this.expectOptionalToken(Ee.TokenKind.EQUALS)
													? this.parseValueLiteral(!0)
													: void 0,
												directives: this.parseDirectives(!0),
												loc: this.loc(qe)
											}
										}),
										(gt.parseVariable = function () {
											var qe = this._lexer.token
											return (
												this.expectToken(Ee.TokenKind.DOLLAR),
												{ kind: be.Kind.VARIABLE, name: this.parseName(), loc: this.loc(qe) }
											)
										}),
										(gt.parseSelectionSet = function () {
											var qe = this._lexer.token
											return {
												kind: be.Kind.SELECTION_SET,
												selections: this.many(
													Ee.TokenKind.BRACE_L,
													this.parseSelection,
													Ee.TokenKind.BRACE_R
												),
												loc: this.loc(qe)
											}
										}),
										(gt.parseSelection = function () {
											return this.peek(Ee.TokenKind.SPREAD)
												? this.parseFragment()
												: this.parseField()
										}),
										(gt.parseField = function () {
											var qe = this._lexer.token,
												Xe = this.parseName(),
												Mt,
												Ke
											return (
												this.expectOptionalToken(Ee.TokenKind.COLON)
													? ((Mt = Xe), (Ke = this.parseName()))
													: (Ke = Xe),
												{
													kind: be.Kind.FIELD,
													alias: Mt,
													name: Ke,
													arguments: this.parseArguments(!1),
													directives: this.parseDirectives(!1),
													selectionSet: this.peek(Ee.TokenKind.BRACE_L)
														? this.parseSelectionSet()
														: void 0,
													loc: this.loc(qe)
												}
											)
										}),
										(gt.parseArguments = function (qe) {
											var Xe = qe ? this.parseConstArgument : this.parseArgument
											return this.optionalMany(Ee.TokenKind.PAREN_L, Xe, Ee.TokenKind.PAREN_R)
										}),
										(gt.parseArgument = function () {
											var qe = this._lexer.token,
												Xe = this.parseName()
											return (
												this.expectToken(Ee.TokenKind.COLON),
												{
													kind: be.Kind.ARGUMENT,
													name: Xe,
													value: this.parseValueLiteral(!1),
													loc: this.loc(qe)
												}
											)
										}),
										(gt.parseConstArgument = function () {
											var qe = this._lexer.token
											return {
												kind: be.Kind.ARGUMENT,
												name: this.parseName(),
												value: (this.expectToken(Ee.TokenKind.COLON), this.parseValueLiteral(!0)),
												loc: this.loc(qe)
											}
										}),
										(gt.parseFragment = function () {
											var qe = this._lexer.token
											this.expectToken(Ee.TokenKind.SPREAD)
											var Xe = this.expectOptionalKeyword('on')
											return !Xe && this.peek(Ee.TokenKind.NAME)
												? {
														kind: be.Kind.FRAGMENT_SPREAD,
														name: this.parseFragmentName(),
														directives: this.parseDirectives(!1),
														loc: this.loc(qe)
												  }
												: {
														kind: be.Kind.INLINE_FRAGMENT,
														typeCondition: Xe ? this.parseNamedType() : void 0,
														directives: this.parseDirectives(!1),
														selectionSet: this.parseSelectionSet(),
														loc: this.loc(qe)
												  }
										}),
										(gt.parseFragmentDefinition = function () {
											var qe,
												Xe = this._lexer.token
											return (
												this.expectKeyword('fragment'),
												((qe = this._options) === null || qe === void 0
													? void 0
													: qe.experimentalFragmentVariables) === !0
													? {
															kind: be.Kind.FRAGMENT_DEFINITION,
															name: this.parseFragmentName(),
															variableDefinitions: this.parseVariableDefinitions(),
															typeCondition: (this.expectKeyword('on'), this.parseNamedType()),
															directives: this.parseDirectives(!1),
															selectionSet: this.parseSelectionSet(),
															loc: this.loc(Xe)
													  }
													: {
															kind: be.Kind.FRAGMENT_DEFINITION,
															name: this.parseFragmentName(),
															typeCondition: (this.expectKeyword('on'), this.parseNamedType()),
															directives: this.parseDirectives(!1),
															selectionSet: this.parseSelectionSet(),
															loc: this.loc(Xe)
													  }
											)
										}),
										(gt.parseFragmentName = function () {
											if (this._lexer.token.value === 'on') throw this.unexpected()
											return this.parseName()
										}),
										(gt.parseValueLiteral = function (qe) {
											var Xe = this._lexer.token
											switch (Xe.kind) {
												case Ee.TokenKind.BRACKET_L:
													return this.parseList(qe)
												case Ee.TokenKind.BRACE_L:
													return this.parseObject(qe)
												case Ee.TokenKind.INT:
													return (
														this._lexer.advance(),
														{ kind: be.Kind.INT, value: Xe.value, loc: this.loc(Xe) }
													)
												case Ee.TokenKind.FLOAT:
													return (
														this._lexer.advance(),
														{ kind: be.Kind.FLOAT, value: Xe.value, loc: this.loc(Xe) }
													)
												case Ee.TokenKind.STRING:
												case Ee.TokenKind.BLOCK_STRING:
													return this.parseStringLiteral()
												case Ee.TokenKind.NAME:
													switch ((this._lexer.advance(), Xe.value)) {
														case 'true':
															return { kind: be.Kind.BOOLEAN, value: !0, loc: this.loc(Xe) }
														case 'false':
															return { kind: be.Kind.BOOLEAN, value: !1, loc: this.loc(Xe) }
														case 'null':
															return { kind: be.Kind.NULL, loc: this.loc(Xe) }
														default:
															return { kind: be.Kind.ENUM, value: Xe.value, loc: this.loc(Xe) }
													}
												case Ee.TokenKind.DOLLAR:
													if (!qe) return this.parseVariable()
													break
											}
											throw this.unexpected()
										}),
										(gt.parseStringLiteral = function () {
											var qe = this._lexer.token
											return (
												this._lexer.advance(),
												{
													kind: be.Kind.STRING,
													value: qe.value,
													block: qe.kind === Ee.TokenKind.BLOCK_STRING,
													loc: this.loc(qe)
												}
											)
										}),
										(gt.parseList = function (qe) {
											var Xe = this,
												Mt = this._lexer.token,
												Ke = function () {
													return Xe.parseValueLiteral(qe)
												}
											return {
												kind: be.Kind.LIST,
												values: this.any(Ee.TokenKind.BRACKET_L, Ke, Ee.TokenKind.BRACKET_R),
												loc: this.loc(Mt)
											}
										}),
										(gt.parseObject = function (qe) {
											var Xe = this,
												Mt = this._lexer.token,
												Ke = function () {
													return Xe.parseObjectField(qe)
												}
											return {
												kind: be.Kind.OBJECT,
												fields: this.any(Ee.TokenKind.BRACE_L, Ke, Ee.TokenKind.BRACE_R),
												loc: this.loc(Mt)
											}
										}),
										(gt.parseObjectField = function (qe) {
											var Xe = this._lexer.token,
												Mt = this.parseName()
											return (
												this.expectToken(Ee.TokenKind.COLON),
												{
													kind: be.Kind.OBJECT_FIELD,
													name: Mt,
													value: this.parseValueLiteral(qe),
													loc: this.loc(Xe)
												}
											)
										}),
										(gt.parseDirectives = function (qe) {
											for (var Xe = []; this.peek(Ee.TokenKind.AT); )
												Xe.push(this.parseDirective(qe))
											return Xe
										}),
										(gt.parseDirective = function (qe) {
											var Xe = this._lexer.token
											return (
												this.expectToken(Ee.TokenKind.AT),
												{
													kind: be.Kind.DIRECTIVE,
													name: this.parseName(),
													arguments: this.parseArguments(qe),
													loc: this.loc(Xe)
												}
											)
										}),
										(gt.parseTypeReference = function () {
											var qe = this._lexer.token,
												Xe
											return (
												this.expectOptionalToken(Ee.TokenKind.BRACKET_L)
													? ((Xe = this.parseTypeReference()),
													  this.expectToken(Ee.TokenKind.BRACKET_R),
													  (Xe = { kind: be.Kind.LIST_TYPE, type: Xe, loc: this.loc(qe) }))
													: (Xe = this.parseNamedType()),
												this.expectOptionalToken(Ee.TokenKind.BANG)
													? { kind: be.Kind.NON_NULL_TYPE, type: Xe, loc: this.loc(qe) }
													: Xe
											)
										}),
										(gt.parseNamedType = function () {
											var qe = this._lexer.token
											return { kind: be.Kind.NAMED_TYPE, name: this.parseName(), loc: this.loc(qe) }
										}),
										(gt.parseTypeSystemDefinition = function () {
											var qe = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token
											if (qe.kind === Ee.TokenKind.NAME)
												switch (qe.value) {
													case 'schema':
														return this.parseSchemaDefinition()
													case 'scalar':
														return this.parseScalarTypeDefinition()
													case 'type':
														return this.parseObjectTypeDefinition()
													case 'interface':
														return this.parseInterfaceTypeDefinition()
													case 'union':
														return this.parseUnionTypeDefinition()
													case 'enum':
														return this.parseEnumTypeDefinition()
													case 'input':
														return this.parseInputObjectTypeDefinition()
													case 'directive':
														return this.parseDirectiveDefinition()
												}
											throw this.unexpected(qe)
										}),
										(gt.peekDescription = function () {
											return this.peek(Ee.TokenKind.STRING) || this.peek(Ee.TokenKind.BLOCK_STRING)
										}),
										(gt.parseDescription = function () {
											if (this.peekDescription()) return this.parseStringLiteral()
										}),
										(gt.parseSchemaDefinition = function () {
											var qe = this._lexer.token,
												Xe = this.parseDescription()
											this.expectKeyword('schema')
											var Mt = this.parseDirectives(!0),
												Ke = this.many(
													Ee.TokenKind.BRACE_L,
													this.parseOperationTypeDefinition,
													Ee.TokenKind.BRACE_R
												)
											return {
												kind: be.Kind.SCHEMA_DEFINITION,
												description: Xe,
												directives: Mt,
												operationTypes: Ke,
												loc: this.loc(qe)
											}
										}),
										(gt.parseOperationTypeDefinition = function () {
											var qe = this._lexer.token,
												Xe = this.parseOperationType()
											this.expectToken(Ee.TokenKind.COLON)
											var Mt = this.parseNamedType()
											return {
												kind: be.Kind.OPERATION_TYPE_DEFINITION,
												operation: Xe,
												type: Mt,
												loc: this.loc(qe)
											}
										}),
										(gt.parseScalarTypeDefinition = function () {
											var qe = this._lexer.token,
												Xe = this.parseDescription()
											this.expectKeyword('scalar')
											var Mt = this.parseName(),
												Ke = this.parseDirectives(!0)
											return {
												kind: be.Kind.SCALAR_TYPE_DEFINITION,
												description: Xe,
												name: Mt,
												directives: Ke,
												loc: this.loc(qe)
											}
										}),
										(gt.parseObjectTypeDefinition = function () {
											var qe = this._lexer.token,
												Xe = this.parseDescription()
											this.expectKeyword('type')
											var Mt = this.parseName(),
												Ke = this.parseImplementsInterfaces(),
												Yt = this.parseDirectives(!0),
												En = this.parseFieldsDefinition()
											return {
												kind: be.Kind.OBJECT_TYPE_DEFINITION,
												description: Xe,
												name: Mt,
												interfaces: Ke,
												directives: Yt,
												fields: En,
												loc: this.loc(qe)
											}
										}),
										(gt.parseImplementsInterfaces = function () {
											var qe
											if (!this.expectOptionalKeyword('implements')) return []
											if (
												((qe = this._options) === null || qe === void 0
													? void 0
													: qe.allowLegacySDLImplementsInterfaces) === !0
											) {
												var Xe = []
												this.expectOptionalToken(Ee.TokenKind.AMP)
												do Xe.push(this.parseNamedType())
												while (
													this.expectOptionalToken(Ee.TokenKind.AMP) ||
													this.peek(Ee.TokenKind.NAME)
												)
												return Xe
											}
											return this.delimitedMany(Ee.TokenKind.AMP, this.parseNamedType)
										}),
										(gt.parseFieldsDefinition = function () {
											var qe
											return ((qe = this._options) === null || qe === void 0
												? void 0
												: qe.allowLegacySDLEmptyFields) === !0 &&
												this.peek(Ee.TokenKind.BRACE_L) &&
												this._lexer.lookahead().kind === Ee.TokenKind.BRACE_R
												? (this._lexer.advance(), this._lexer.advance(), [])
												: this.optionalMany(
														Ee.TokenKind.BRACE_L,
														this.parseFieldDefinition,
														Ee.TokenKind.BRACE_R
												  )
										}),
										(gt.parseFieldDefinition = function () {
											var qe = this._lexer.token,
												Xe = this.parseDescription(),
												Mt = this.parseName(),
												Ke = this.parseArgumentDefs()
											this.expectToken(Ee.TokenKind.COLON)
											var Yt = this.parseTypeReference(),
												En = this.parseDirectives(!0)
											return {
												kind: be.Kind.FIELD_DEFINITION,
												description: Xe,
												name: Mt,
												arguments: Ke,
												type: Yt,
												directives: En,
												loc: this.loc(qe)
											}
										}),
										(gt.parseArgumentDefs = function () {
											return this.optionalMany(
												Ee.TokenKind.PAREN_L,
												this.parseInputValueDef,
												Ee.TokenKind.PAREN_R
											)
										}),
										(gt.parseInputValueDef = function () {
											var qe = this._lexer.token,
												Xe = this.parseDescription(),
												Mt = this.parseName()
											this.expectToken(Ee.TokenKind.COLON)
											var Ke = this.parseTypeReference(),
												Yt
											this.expectOptionalToken(Ee.TokenKind.EQUALS) &&
												(Yt = this.parseValueLiteral(!0))
											var En = this.parseDirectives(!0)
											return {
												kind: be.Kind.INPUT_VALUE_DEFINITION,
												description: Xe,
												name: Mt,
												type: Ke,
												defaultValue: Yt,
												directives: En,
												loc: this.loc(qe)
											}
										}),
										(gt.parseInterfaceTypeDefinition = function () {
											var qe = this._lexer.token,
												Xe = this.parseDescription()
											this.expectKeyword('interface')
											var Mt = this.parseName(),
												Ke = this.parseImplementsInterfaces(),
												Yt = this.parseDirectives(!0),
												En = this.parseFieldsDefinition()
											return {
												kind: be.Kind.INTERFACE_TYPE_DEFINITION,
												description: Xe,
												name: Mt,
												interfaces: Ke,
												directives: Yt,
												fields: En,
												loc: this.loc(qe)
											}
										}),
										(gt.parseUnionTypeDefinition = function () {
											var qe = this._lexer.token,
												Xe = this.parseDescription()
											this.expectKeyword('union')
											var Mt = this.parseName(),
												Ke = this.parseDirectives(!0),
												Yt = this.parseUnionMemberTypes()
											return {
												kind: be.Kind.UNION_TYPE_DEFINITION,
												description: Xe,
												name: Mt,
												directives: Ke,
												types: Yt,
												loc: this.loc(qe)
											}
										}),
										(gt.parseUnionMemberTypes = function () {
											return this.expectOptionalToken(Ee.TokenKind.EQUALS)
												? this.delimitedMany(Ee.TokenKind.PIPE, this.parseNamedType)
												: []
										}),
										(gt.parseEnumTypeDefinition = function () {
											var qe = this._lexer.token,
												Xe = this.parseDescription()
											this.expectKeyword('enum')
											var Mt = this.parseName(),
												Ke = this.parseDirectives(!0),
												Yt = this.parseEnumValuesDefinition()
											return {
												kind: be.Kind.ENUM_TYPE_DEFINITION,
												description: Xe,
												name: Mt,
												directives: Ke,
												values: Yt,
												loc: this.loc(qe)
											}
										}),
										(gt.parseEnumValuesDefinition = function () {
											return this.optionalMany(
												Ee.TokenKind.BRACE_L,
												this.parseEnumValueDefinition,
												Ee.TokenKind.BRACE_R
											)
										}),
										(gt.parseEnumValueDefinition = function () {
											var qe = this._lexer.token,
												Xe = this.parseDescription(),
												Mt = this.parseName(),
												Ke = this.parseDirectives(!0)
											return {
												kind: be.Kind.ENUM_VALUE_DEFINITION,
												description: Xe,
												name: Mt,
												directives: Ke,
												loc: this.loc(qe)
											}
										}),
										(gt.parseInputObjectTypeDefinition = function () {
											var qe = this._lexer.token,
												Xe = this.parseDescription()
											this.expectKeyword('input')
											var Mt = this.parseName(),
												Ke = this.parseDirectives(!0),
												Yt = this.parseInputFieldsDefinition()
											return {
												kind: be.Kind.INPUT_OBJECT_TYPE_DEFINITION,
												description: Xe,
												name: Mt,
												directives: Ke,
												fields: Yt,
												loc: this.loc(qe)
											}
										}),
										(gt.parseInputFieldsDefinition = function () {
											return this.optionalMany(
												Ee.TokenKind.BRACE_L,
												this.parseInputValueDef,
												Ee.TokenKind.BRACE_R
											)
										}),
										(gt.parseTypeSystemExtension = function () {
											var qe = this._lexer.lookahead()
											if (qe.kind === Ee.TokenKind.NAME)
												switch (qe.value) {
													case 'schema':
														return this.parseSchemaExtension()
													case 'scalar':
														return this.parseScalarTypeExtension()
													case 'type':
														return this.parseObjectTypeExtension()
													case 'interface':
														return this.parseInterfaceTypeExtension()
													case 'union':
														return this.parseUnionTypeExtension()
													case 'enum':
														return this.parseEnumTypeExtension()
													case 'input':
														return this.parseInputObjectTypeExtension()
												}
											throw this.unexpected(qe)
										}),
										(gt.parseSchemaExtension = function () {
											var qe = this._lexer.token
											this.expectKeyword('extend'), this.expectKeyword('schema')
											var Xe = this.parseDirectives(!0),
												Mt = this.optionalMany(
													Ee.TokenKind.BRACE_L,
													this.parseOperationTypeDefinition,
													Ee.TokenKind.BRACE_R
												)
											if (Xe.length === 0 && Mt.length === 0) throw this.unexpected()
											return {
												kind: be.Kind.SCHEMA_EXTENSION,
												directives: Xe,
												operationTypes: Mt,
												loc: this.loc(qe)
											}
										}),
										(gt.parseScalarTypeExtension = function () {
											var qe = this._lexer.token
											this.expectKeyword('extend'), this.expectKeyword('scalar')
											var Xe = this.parseName(),
												Mt = this.parseDirectives(!0)
											if (Mt.length === 0) throw this.unexpected()
											return {
												kind: be.Kind.SCALAR_TYPE_EXTENSION,
												name: Xe,
												directives: Mt,
												loc: this.loc(qe)
											}
										}),
										(gt.parseObjectTypeExtension = function () {
											var qe = this._lexer.token
											this.expectKeyword('extend'), this.expectKeyword('type')
											var Xe = this.parseName(),
												Mt = this.parseImplementsInterfaces(),
												Ke = this.parseDirectives(!0),
												Yt = this.parseFieldsDefinition()
											if (Mt.length === 0 && Ke.length === 0 && Yt.length === 0)
												throw this.unexpected()
											return {
												kind: be.Kind.OBJECT_TYPE_EXTENSION,
												name: Xe,
												interfaces: Mt,
												directives: Ke,
												fields: Yt,
												loc: this.loc(qe)
											}
										}),
										(gt.parseInterfaceTypeExtension = function () {
											var qe = this._lexer.token
											this.expectKeyword('extend'), this.expectKeyword('interface')
											var Xe = this.parseName(),
												Mt = this.parseImplementsInterfaces(),
												Ke = this.parseDirectives(!0),
												Yt = this.parseFieldsDefinition()
											if (Mt.length === 0 && Ke.length === 0 && Yt.length === 0)
												throw this.unexpected()
											return {
												kind: be.Kind.INTERFACE_TYPE_EXTENSION,
												name: Xe,
												interfaces: Mt,
												directives: Ke,
												fields: Yt,
												loc: this.loc(qe)
											}
										}),
										(gt.parseUnionTypeExtension = function () {
											var qe = this._lexer.token
											this.expectKeyword('extend'), this.expectKeyword('union')
											var Xe = this.parseName(),
												Mt = this.parseDirectives(!0),
												Ke = this.parseUnionMemberTypes()
											if (Mt.length === 0 && Ke.length === 0) throw this.unexpected()
											return {
												kind: be.Kind.UNION_TYPE_EXTENSION,
												name: Xe,
												directives: Mt,
												types: Ke,
												loc: this.loc(qe)
											}
										}),
										(gt.parseEnumTypeExtension = function () {
											var qe = this._lexer.token
											this.expectKeyword('extend'), this.expectKeyword('enum')
											var Xe = this.parseName(),
												Mt = this.parseDirectives(!0),
												Ke = this.parseEnumValuesDefinition()
											if (Mt.length === 0 && Ke.length === 0) throw this.unexpected()
											return {
												kind: be.Kind.ENUM_TYPE_EXTENSION,
												name: Xe,
												directives: Mt,
												values: Ke,
												loc: this.loc(qe)
											}
										}),
										(gt.parseInputObjectTypeExtension = function () {
											var qe = this._lexer.token
											this.expectKeyword('extend'), this.expectKeyword('input')
											var Xe = this.parseName(),
												Mt = this.parseDirectives(!0),
												Ke = this.parseInputFieldsDefinition()
											if (Mt.length === 0 && Ke.length === 0) throw this.unexpected()
											return {
												kind: be.Kind.INPUT_OBJECT_TYPE_EXTENSION,
												name: Xe,
												directives: Mt,
												fields: Ke,
												loc: this.loc(qe)
											}
										}),
										(gt.parseDirectiveDefinition = function () {
											var qe = this._lexer.token,
												Xe = this.parseDescription()
											this.expectKeyword('directive'), this.expectToken(Ee.TokenKind.AT)
											var Mt = this.parseName(),
												Ke = this.parseArgumentDefs(),
												Yt = this.expectOptionalKeyword('repeatable')
											this.expectKeyword('on')
											var En = this.parseDirectiveLocations()
											return {
												kind: be.Kind.DIRECTIVE_DEFINITION,
												description: Xe,
												name: Mt,
												arguments: Ke,
												repeatable: Yt,
												locations: En,
												loc: this.loc(qe)
											}
										}),
										(gt.parseDirectiveLocations = function () {
											return this.delimitedMany(Ee.TokenKind.PIPE, this.parseDirectiveLocation)
										}),
										(gt.parseDirectiveLocation = function () {
											var qe = this._lexer.token,
												Xe = this.parseName()
											if (Nt.DirectiveLocation[Xe.value] !== void 0) return Xe
											throw this.unexpected(qe)
										}),
										(gt.loc = function (qe) {
											var Xe
											if (
												((Xe = this._options) === null || Xe === void 0
													? void 0
													: Xe.noLocation) !== !0
											)
												return new tt.Location(qe, this._lexer.lastToken, this._lexer.source)
										}),
										(gt.peek = function (qe) {
											return this._lexer.token.kind === qe
										}),
										(gt.expectToken = function (qe) {
											var Xe = this._lexer.token
											if (Xe.kind === qe) return this._lexer.advance(), Xe
											throw (0, dt.syntaxError)(
												this._lexer.source,
												Xe.start,
												'Expected '.concat(Ht(qe), ', found ').concat(Gn(Xe), '.')
											)
										}),
										(gt.expectOptionalToken = function (qe) {
											var Xe = this._lexer.token
											if (Xe.kind === qe) return this._lexer.advance(), Xe
										}),
										(gt.expectKeyword = function (qe) {
											var Xe = this._lexer.token
											if (Xe.kind === Ee.TokenKind.NAME && Xe.value === qe) this._lexer.advance()
											else
												throw (0, dt.syntaxError)(
													this._lexer.source,
													Xe.start,
													'Expected "'.concat(qe, '", found ').concat(Gn(Xe), '.')
												)
										}),
										(gt.expectOptionalKeyword = function (qe) {
											var Xe = this._lexer.token
											return Xe.kind === Ee.TokenKind.NAME && Xe.value === qe
												? (this._lexer.advance(), !0)
												: !1
										}),
										(gt.unexpected = function (qe) {
											var Xe = qe ?? this._lexer.token
											return (0, dt.syntaxError)(
												this._lexer.source,
												Xe.start,
												'Unexpected '.concat(Gn(Xe), '.')
											)
										}),
										(gt.any = function (qe, Xe, Mt) {
											this.expectToken(qe)
											for (var Ke = []; !this.expectOptionalToken(Mt); ) Ke.push(Xe.call(this))
											return Ke
										}),
										(gt.optionalMany = function (qe, Xe, Mt) {
											if (this.expectOptionalToken(qe)) {
												var Ke = []
												do Ke.push(Xe.call(this))
												while (!this.expectOptionalToken(Mt))
												return Ke
											}
											return []
										}),
										(gt.many = function (qe, Xe, Mt) {
											this.expectToken(qe)
											var Ke = []
											do Ke.push(Xe.call(this))
											while (!this.expectOptionalToken(Mt))
											return Ke
										}),
										(gt.delimitedMany = function (qe, Xe) {
											this.expectOptionalToken(qe)
											var Mt = []
											do Mt.push(Xe.call(this))
											while (this.expectOptionalToken(qe))
											return Mt
										}),
										bn
									)
								})()
								He.Parser = Pn
								function Gn(bn) {
									var gt = bn.value
									return Ht(bn.kind) + (gt != null ? ' "'.concat(gt, '"') : '')
								}
								function Ht(bn) {
									return (0, en.isPunctuatorTokenKind)(bn) ? '"'.concat(bn, '"') : bn
								}
							}
						})
					a()
					var Lt = u(),
						Ct = h(),
						{ hasPragma: pn } = N(),
						{ locStart: xn, locEnd: zn } = I()
					function rr(He) {
						let dt = [],
							{ startToken: be } = He.loc,
							{ next: tt } = be
						for (; tt.kind !== '<EOF>'; )
							tt.kind === 'Comment' && (Object.assign(tt, { column: tt.column - 1 }), dt.push(tt)),
								(tt = tt.next)
						return dt
					}
					function rt(He) {
						if (He && typeof He == 'object') {
							delete He.startToken, delete He.endToken, delete He.prev, delete He.next
							for (let dt in He) rt(He[dt])
						}
						return He
					}
					var Wt = { allowLegacySDLImplementsInterfaces: !1, experimentalFragmentVariables: !0 }
					function Ot(He) {
						let { GraphQLError: dt } = Pe()
						if (He instanceof dt) {
							let {
								message: be,
								locations: [tt]
							} = He
							return Lt(be, { start: tt })
						}
						return He
					}
					function vt(He) {
						let { parse: dt } = Ne(),
							{ result: be, error: tt } = Ct(
								() => dt(He, Object.assign({}, Wt)),
								() =>
									dt(
										He,
										Object.assign(
											Object.assign({}, Wt),
											{},
											{ allowLegacySDLImplementsInterfaces: !0 }
										)
									)
							)
						if (!be) throw Ot(tt)
						return (be.comments = rr(be)), rt(be), be
					}
					r.exports = {
						parsers: {
							graphql: { parse: vt, astFormat: 'graphql', hasPragma: pn, locStart: xn, locEnd: zn }
						}
					}
				})
			return t()
		})
	})
	var Np = class {
			constructor() {
				;(this.listeners = []),
					(this.unexpectedErrorHandler = function (t) {
						setTimeout(() => {
							throw t.stack
								? Ma.isErrorNoTelemetry(t)
									? new Ma(
											t.message +
												`

` +
												t.stack
									  )
									: new Error(
											t.message +
												`

` +
												t.stack
									  )
								: t
						}, 0)
					})
			}
			addListener(t) {
				return (
					this.listeners.push(t),
					() => {
						this._removeListener(t)
					}
				)
			}
			emit(t) {
				this.listeners.forEach((n) => {
					n(t)
				})
			}
			_removeListener(t) {
				this.listeners.splice(this.listeners.indexOf(t), 1)
			}
			setUnexpectedErrorHandler(t) {
				this.unexpectedErrorHandler = t
			}
			getUnexpectedErrorHandler() {
				return this.unexpectedErrorHandler
			}
			onUnexpectedError(t) {
				this.unexpectedErrorHandler(t), this.emit(t)
			}
			onUnexpectedExternalError(t) {
				this.unexpectedErrorHandler(t)
			}
		},
		F4 = new Np()
	function nl(e) {
		_4(e) || F4.onUnexpectedError(e)
	}
	function _p(e) {
		if (e instanceof Error) {
			let { name: t, message: n } = e,
				r = e.stacktrace || e.stack
			return { $isError: !0, name: t, message: n, stack: r, noTelemetry: Ma.isErrorNoTelemetry(e) }
		}
		return e
	}
	var Fp = 'Canceled'
	function _4(e) {
		return e instanceof tl ? !0 : e instanceof Error && e.name === Fp && e.message === Fp
	}
	var tl = class extends Error {
		constructor() {
			super(Fp), (this.name = this.message)
		}
	}
	var Ma = class e extends Error {
			constructor(t) {
				super(t), (this.name = 'CodeExpectedError')
			}
			static fromError(t) {
				if (t instanceof e) return t
				let n = new e()
				return (n.message = t.message), (n.stack = t.stack), n
			}
			static isErrorNoTelemetry(t) {
				return t.name === 'CodeExpectedError'
			}
		},
		ai = class e extends Error {
			constructor(t) {
				super(t || 'An unexpected bug occurred.'), Object.setPrototypeOf(this, e.prototype)
			}
		}
	function wp(e) {
		let t = this,
			n = !1,
			r
		return function () {
			return n || ((n = !0), (r = e.apply(t, arguments))), r
		}
	}
	function us(e, t) {
		let n = Vs(e, t)
		return n === -1 ? void 0 : e[n]
	}
	function Vs(e, t, n = 0, r = e.length) {
		let i = n,
			s = r
		for (; i < s; ) {
			let o = Math.floor((i + s) / 2)
			t(e[o]) ? (i = o + 1) : (s = o)
		}
		return i - 1
	}
	function c0(e, t) {
		let n = ja(e, t)
		return n === e.length ? void 0 : e[n]
	}
	function ja(e, t, n = 0, r = e.length) {
		let i = n,
			s = r
		for (; i < s; ) {
			let o = Math.floor((i + s) / 2)
			t(e[o]) ? (s = o) : (i = o + 1)
		}
		return i
	}
	var Co = class e {
		constructor(t) {
			;(this._array = t), (this._findLastMonotonousLastIdx = 0)
		}
		findLastMonotonous(t) {
			if (e.assertInvariants) {
				if (this._prevFindLastPredicate) {
					for (let r of this._array)
						if (this._prevFindLastPredicate(r) && !t(r))
							throw new Error(
								'MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.'
							)
				}
				this._prevFindLastPredicate = t
			}
			let n = Vs(this._array, t, this._findLastMonotonousLastIdx)
			return (this._findLastMonotonousLastIdx = n + 1), n === -1 ? void 0 : this._array[n]
		}
	}
	Co.assertInvariants = !1
	function p0(e, t, n = (r, i) => r === i) {
		if (e === t) return !0
		if (!e || !t || e.length !== t.length) return !1
		for (let r = 0, i = e.length; r < i; r++) if (!n(e[r], t[r])) return !1
		return !0
	}
	function* f0(e, t) {
		let n, r
		for (let i of e) r !== void 0 && t(r, i) ? n.push(i) : (n && (yield n), (n = [i])), (r = i)
		n && (yield n)
	}
	function d0(e, t) {
		for (let n = 0; n <= e.length; n++)
			t(n === 0 ? void 0 : e[n - 1], n === e.length ? void 0 : e[n])
	}
	function h0(e, t) {
		for (let n = 0; n < e.length; n++)
			t(n === 0 ? void 0 : e[n - 1], e[n], n + 1 === e.length ? void 0 : e[n + 1])
	}
	function m0(e, t) {
		for (let n of t) e.push(n)
	}
	var Lp
	;(function (e) {
		function t(s) {
			return s < 0
		}
		e.isLessThan = t
		function n(s) {
			return s <= 0
		}
		e.isLessThanOrEqual = n
		function r(s) {
			return s > 0
		}
		e.isGreaterThan = r
		function i(s) {
			return s === 0
		}
		;(e.isNeitherLessOrGreaterThan = i),
			(e.greaterThan = 1),
			(e.lessThan = -1),
			(e.neitherLessOrGreaterThan = 0)
	})(Lp || (Lp = {}))
	function Us(e, t) {
		return (n, r) => t(e(n), e(r))
	}
	var qs = (e, t) => e - t
	function g0(e) {
		return (t, n) => -e(t, n)
	}
	var rl = class e {
		constructor(t) {
			this.iterate = t
		}
		forEach(t) {
			this.iterate((n) => (t(n), !0))
		}
		toArray() {
			let t = []
			return this.iterate((n) => (t.push(n), !0)), t
		}
		filter(t) {
			return new e((n) => this.iterate((r) => (t(r) ? n(r) : !0)))
		}
		map(t) {
			return new e((n) => this.iterate((r) => n(t(r))))
		}
		some(t) {
			let n = !1
			return this.iterate((r) => ((n = t(r)), !n)), n
		}
		findFirst(t) {
			let n
			return this.iterate((r) => (t(r) ? ((n = r), !1) : !0)), n
		}
		findLast(t) {
			let n
			return this.iterate((r) => (t(r) && (n = r), !0)), n
		}
		findLastMaxBy(t) {
			let n,
				r = !0
			return this.iterate((i) => ((r || Lp.isGreaterThan(t(i, n))) && ((r = !1), (n = i)), !0)), n
		}
	}
	rl.empty = new rl((e) => {})
	function D0(e, t) {
		let n = Object.create(null)
		for (let r of e) {
			let i = t(r),
				s = n[i]
			s || (s = n[i] = []), s.push(r)
		}
		return n
	}
	var y0, E0, v0
	var Ip = class {
		constructor(t, n) {
			;(this.uri = t), (this.value = n)
		}
	}
	function w4(e) {
		return Array.isArray(e)
	}
	var $a = class e {
		constructor(t, n) {
			if (((this[y0] = 'ResourceMap'), t instanceof e))
				(this.map = new Map(t.map)), (this.toKey = n ?? e.defaultToKey)
			else if (w4(t)) {
				;(this.map = new Map()), (this.toKey = n ?? e.defaultToKey)
				for (let [r, i] of t) this.set(r, i)
			} else (this.map = new Map()), (this.toKey = t ?? e.defaultToKey)
		}
		set(t, n) {
			return this.map.set(this.toKey(t), new Ip(t, n)), this
		}
		get(t) {
			return this.map.get(this.toKey(t))?.value
		}
		has(t) {
			return this.map.has(this.toKey(t))
		}
		get size() {
			return this.map.size
		}
		clear() {
			this.map.clear()
		}
		delete(t) {
			return this.map.delete(this.toKey(t))
		}
		forEach(t, n) {
			typeof n < 'u' && (t = t.bind(n))
			for (let [r, i] of this.map) t(i.value, i.uri, this)
		}
		*values() {
			for (let t of this.map.values()) yield t.value
		}
		*keys() {
			for (let t of this.map.values()) yield t.uri
		}
		*entries() {
			for (let t of this.map.values()) yield [t.uri, t.value]
		}
		*[((y0 = Symbol.toStringTag), Symbol.iterator)]() {
			for (let [, t] of this.map) yield [t.uri, t.value]
		}
	}
	$a.defaultToKey = (e) => e.toString()
	var x0 = class {
			constructor(t, n) {
				;(this[E0] = 'ResourceSet'),
					!t || typeof t == 'function'
						? (this._map = new $a(t))
						: ((this._map = new $a(n)), t.forEach(this.add, this))
			}
			get size() {
				return this._map.size
			}
			add(t) {
				return this._map.set(t, t), this
			}
			clear() {
				this._map.clear()
			}
			delete(t) {
				return this._map.delete(t)
			}
			forEach(t, n) {
				this._map.forEach((r, i) => t.call(n, i, i, this))
			}
			has(t) {
				return this._map.has(t)
			}
			entries() {
				return this._map.entries()
			}
			keys() {
				return this._map.keys()
			}
			values() {
				return this._map.keys()
			}
			[((E0 = Symbol.toStringTag), Symbol.iterator)]() {
				return this.keys()
			}
		},
		b0 = class {
			constructor() {
				;(this[v0] = 'LinkedMap'),
					(this._map = new Map()),
					(this._head = void 0),
					(this._tail = void 0),
					(this._size = 0),
					(this._state = 0)
			}
			clear() {
				this._map.clear(),
					(this._head = void 0),
					(this._tail = void 0),
					(this._size = 0),
					this._state++
			}
			isEmpty() {
				return !this._head && !this._tail
			}
			get size() {
				return this._size
			}
			get first() {
				return this._head?.value
			}
			get last() {
				return this._tail?.value
			}
			has(t) {
				return this._map.has(t)
			}
			get(t, n = 0) {
				let r = this._map.get(t)
				if (r) return n !== 0 && this.touch(r, n), r.value
			}
			set(t, n, r = 0) {
				let i = this._map.get(t)
				if (i) (i.value = n), r !== 0 && this.touch(i, r)
				else {
					switch (((i = { key: t, value: n, next: void 0, previous: void 0 }), r)) {
						case 0:
							this.addItemLast(i)
							break
						case 1:
							this.addItemFirst(i)
							break
						case 2:
							this.addItemLast(i)
							break
						default:
							this.addItemLast(i)
							break
					}
					this._map.set(t, i), this._size++
				}
				return this
			}
			delete(t) {
				return !!this.remove(t)
			}
			remove(t) {
				let n = this._map.get(t)
				if (n) return this._map.delete(t), this.removeItem(n), this._size--, n.value
			}
			shift() {
				if (!this._head && !this._tail) return
				if (!this._head || !this._tail) throw new Error('Invalid list')
				let t = this._head
				return this._map.delete(t.key), this.removeItem(t), this._size--, t.value
			}
			forEach(t, n) {
				let r = this._state,
					i = this._head
				for (; i; ) {
					if ((n ? t.bind(n)(i.value, i.key, this) : t(i.value, i.key, this), this._state !== r))
						throw new Error('LinkedMap got modified during iteration.')
					i = i.next
				}
			}
			keys() {
				let t = this,
					n = this._state,
					r = this._head,
					i = {
						[Symbol.iterator]() {
							return i
						},
						next() {
							if (t._state !== n) throw new Error('LinkedMap got modified during iteration.')
							if (r) {
								let s = { value: r.key, done: !1 }
								return (r = r.next), s
							} else return { value: void 0, done: !0 }
						}
					}
				return i
			}
			values() {
				let t = this,
					n = this._state,
					r = this._head,
					i = {
						[Symbol.iterator]() {
							return i
						},
						next() {
							if (t._state !== n) throw new Error('LinkedMap got modified during iteration.')
							if (r) {
								let s = { value: r.value, done: !1 }
								return (r = r.next), s
							} else return { value: void 0, done: !0 }
						}
					}
				return i
			}
			entries() {
				let t = this,
					n = this._state,
					r = this._head,
					i = {
						[Symbol.iterator]() {
							return i
						},
						next() {
							if (t._state !== n) throw new Error('LinkedMap got modified during iteration.')
							if (r) {
								let s = { value: [r.key, r.value], done: !1 }
								return (r = r.next), s
							} else return { value: void 0, done: !0 }
						}
					}
				return i
			}
			[((v0 = Symbol.toStringTag), Symbol.iterator)]() {
				return this.entries()
			}
			trimOld(t) {
				if (t >= this.size) return
				if (t === 0) {
					this.clear()
					return
				}
				let n = this._head,
					r = this.size
				for (; n && r > t; ) this._map.delete(n.key), (n = n.next), r--
				;(this._head = n), (this._size = r), n && (n.previous = void 0), this._state++
			}
			addItemFirst(t) {
				if (!this._head && !this._tail) this._tail = t
				else if (this._head) (t.next = this._head), (this._head.previous = t)
				else throw new Error('Invalid list')
				;(this._head = t), this._state++
			}
			addItemLast(t) {
				if (!this._head && !this._tail) this._head = t
				else if (this._tail) (t.previous = this._tail), (this._tail.next = t)
				else throw new Error('Invalid list')
				;(this._tail = t), this._state++
			}
			removeItem(t) {
				if (t === this._head && t === this._tail) (this._head = void 0), (this._tail = void 0)
				else if (t === this._head) {
					if (!t.next) throw new Error('Invalid list')
					;(t.next.previous = void 0), (this._head = t.next)
				} else if (t === this._tail) {
					if (!t.previous) throw new Error('Invalid list')
					;(t.previous.next = void 0), (this._tail = t.previous)
				} else {
					let n = t.next,
						r = t.previous
					if (!n || !r) throw new Error('Invalid list')
					;(n.previous = r), (r.next = n)
				}
				;(t.next = void 0), (t.previous = void 0), this._state++
			}
			touch(t, n) {
				if (!this._head || !this._tail) throw new Error('Invalid list')
				if (!(n !== 1 && n !== 2)) {
					if (n === 1) {
						if (t === this._head) return
						let r = t.next,
							i = t.previous
						t === this._tail
							? ((i.next = void 0), (this._tail = i))
							: ((r.previous = i), (i.next = r)),
							(t.previous = void 0),
							(t.next = this._head),
							(this._head.previous = t),
							(this._head = t),
							this._state++
					} else if (n === 2) {
						if (t === this._tail) return
						let r = t.next,
							i = t.previous
						t === this._head
							? ((r.previous = void 0), (this._head = r))
							: ((r.previous = i), (i.next = r)),
							(t.next = void 0),
							(t.previous = this._tail),
							(this._tail.next = t),
							(this._tail = t),
							this._state++
					}
				}
			}
			toJSON() {
				let t = []
				return (
					this.forEach((n, r) => {
						t.push([r, n])
					}),
					t
				)
			}
			fromJSON(t) {
				this.clear()
				for (let [n, r] of t) this.set(n, r)
			}
		}
	var So = class {
		constructor() {
			this.map = new Map()
		}
		add(t, n) {
			let r = this.map.get(t)
			r || ((r = new Set()), this.map.set(t, r)), r.add(n)
		}
		delete(t, n) {
			let r = this.map.get(t)
			r && (r.delete(n), r.size === 0 && this.map.delete(t))
		}
		forEach(t, n) {
			let r = this.map.get(t)
			r && r.forEach(n)
		}
		get(t) {
			let n = this.map.get(t)
			return n || new Set()
		}
	}
	var No
	;(function (e) {
		function t(Ae) {
			return Ae && typeof Ae == 'object' && typeof Ae[Symbol.iterator] == 'function'
		}
		e.is = t
		let n = Object.freeze([])
		function r() {
			return n
		}
		e.empty = r
		function* i(Ae) {
			yield Ae
		}
		e.single = i
		function s(Ae) {
			return t(Ae) ? Ae : i(Ae)
		}
		e.wrap = s
		function o(Ae) {
			return Ae || n
		}
		e.from = o
		function* a(Ae) {
			for (let ze = Ae.length - 1; ze >= 0; ze--) yield Ae[ze]
		}
		e.reverse = a
		function u(Ae) {
			return !Ae || Ae[Symbol.iterator]().next().done === !0
		}
		e.isEmpty = u
		function h(Ae) {
			return Ae[Symbol.iterator]().next().value
		}
		e.first = h
		function N(Ae, ze) {
			for (let it of Ae) if (ze(it)) return !0
			return !1
		}
		e.some = N
		function I(Ae, ze) {
			for (let it of Ae) if (ze(it)) return it
		}
		e.find = I
		function* Q(Ae, ze) {
			for (let it of Ae) ze(it) && (yield it)
		}
		e.filter = Q
		function* K(Ae, ze) {
			let it = 0
			for (let Et of Ae) yield ze(Et, it++)
		}
		e.map = K
		function* ue(...Ae) {
			for (let ze of Ae) for (let it of ze) yield it
		}
		e.concat = ue
		function de(Ae, ze, it) {
			let Et = it
			for (let _t of Ae) Et = ze(Et, _t)
			return Et
		}
		e.reduce = de
		function* Pe(Ae, ze, it = Ae.length) {
			for (
				ze < 0 && (ze += Ae.length),
					it < 0 ? (it += Ae.length) : it > Ae.length && (it = Ae.length);
				ze < it;
				ze++
			)
				yield Ae[ze]
		}
		e.slice = Pe
		function Ze(Ae, ze = Number.POSITIVE_INFINITY) {
			let it = []
			if (ze === 0) return [it, Ae]
			let Et = Ae[Symbol.iterator]()
			for (let _t = 0; _t < ze; _t++) {
				let ct = Et.next()
				if (ct.done) return [it, e.empty()]
				it.push(ct.value)
			}
			return [
				it,
				{
					[Symbol.iterator]() {
						return Et
					}
				}
			]
		}
		e.consume = Ze
	})(No || (No = {}))
	var L4 = !1,
		Fo = null,
		kp = class e {
			constructor() {
				this.livingDisposables = new Map()
			}
			getDisposableData(t) {
				let n = this.livingDisposables.get(t)
				return (
					n ||
						((n = { parent: null, source: null, isSingleton: !1, value: t, idx: e.idx++ }),
						this.livingDisposables.set(t, n)),
					n
				)
			}
			trackDisposable(t) {
				let n = this.getDisposableData(t)
				n.source || (n.source = new Error().stack)
			}
			setParent(t, n) {
				let r = this.getDisposableData(t)
				r.parent = n
			}
			markAsDisposed(t) {
				this.livingDisposables.delete(t)
			}
			markAsSingleton(t) {
				this.getDisposableData(t).isSingleton = !0
			}
			getRootParent(t, n) {
				let r = n.get(t)
				if (r) return r
				let i = t.parent ? this.getRootParent(this.getDisposableData(t.parent), n) : t
				return n.set(t, i), i
			}
			getTrackedDisposables() {
				let t = new Map()
				return [...this.livingDisposables.entries()]
					.filter(([, r]) => r.source !== null && !this.getRootParent(r, t).isSingleton)
					.map(([r]) => r)
					.flat()
			}
			computeLeakingDisposables(t = 10, n) {
				let r
				if (n) r = n
				else {
					let u = new Map(),
						h = [...this.livingDisposables.values()].filter(
							(I) => I.source !== null && !this.getRootParent(I, u).isSingleton
						)
					if (h.length === 0) return
					let N = new Set(h.map((I) => I.value))
					if (((r = h.filter((I) => !(I.parent && N.has(I.parent)))), r.length === 0))
						throw new Error('There are cyclic diposable chains!')
				}
				if (!r) return
				function i(u) {
					function h(I, Q) {
						for (
							;
							I.length > 0 && Q.some((K) => (typeof K == 'string' ? K === I[0] : I[0].match(K)));

						)
							I.shift()
					}
					let N = u.source
						.split(
							`
`
						)
						.map((I) => I.trim().replace('at ', ''))
						.filter((I) => I !== '')
					return (
						h(N, [
							'Error',
							/^trackDisposable \(.*\)$/,
							/^DisposableTracker.trackDisposable \(.*\)$/
						]),
						N.reverse()
					)
				}
				let s = new So()
				for (let u of r) {
					let h = i(u)
					for (let N = 0; N <= h.length; N++)
						s.add(
							h.slice(0, N).join(`
`),
							u
						)
				}
				r.sort(Us((u) => u.idx, qs))
				let o = '',
					a = 0
				for (let u of r.slice(0, t)) {
					a++
					let h = i(u),
						N = []
					for (let I = 0; I < h.length; I++) {
						let Q = h[I]
						Q = `(shared with ${
							s.get(
								h.slice(0, I + 1).join(`
`)
							).size
						}/${r.length} leaks) at ${Q}`
						let ue = s.get(
								h.slice(0, I).join(`
`)
							),
							de = D0(
								[...ue].map((Pe) => i(Pe)[I]),
								(Pe) => Pe
							)
						delete de[h[I]]
						for (let [Pe, Ze] of Object.entries(de))
							N.unshift(`    - stacktraces of ${Ze.length} other leaks continue with ${Pe}`)
						N.unshift(Q)
					}
					o += `


==================== Leaking disposable ${a}/${r.length}: ${
						u.value.constructor.name
					} ====================
${N.join(`
`)}
============================================================

`
				}
				return (
					r.length > t &&
						(o += `


... and ${r.length - t} more leaking disposables

`),
					{ leaks: r, details: o }
				)
			}
		}
	kp.idx = 0
	function I4(e) {
		Fo = e
	}
	if (L4) {
		let e = '__is_disposable_tracked__'
		I4(
			new (class {
				trackDisposable(t) {
					let n = new Error('Potentially leaked disposable').stack
					setTimeout(() => {
						t[e] || console.log(n)
					}, 3e3)
				}
				setParent(t, n) {
					if (t && t !== _i.None)
						try {
							t[e] = !0
						} catch {}
				}
				markAsDisposed(t) {
					if (t && t !== _i.None)
						try {
							t[e] = !0
						} catch {}
				}
				markAsSingleton(t) {}
			})()
		)
	}
	function il(e) {
		return Fo?.trackDisposable(e), e
	}
	function sl(e) {
		Fo?.markAsDisposed(e)
	}
	function Rp(e, t) {
		Fo?.setParent(e, t)
	}
	function k4(e, t) {
		if (Fo) for (let n of e) Fo.setParent(n, t)
	}
	function Bp(e) {
		if (No.is(e)) {
			let t = []
			for (let n of e)
				if (n)
					try {
						n.dispose()
					} catch (r) {
						t.push(r)
					}
			if (t.length === 1) throw t[0]
			if (t.length > 1) throw new AggregateError(t, 'Encountered errors while disposing of store')
			return Array.isArray(e) ? [] : e
		} else if (e) return e.dispose(), e
	}
	function T0(...e) {
		let t = vs(() => Bp(e))
		return k4(e, t), t
	}
	function vs(e) {
		let t = il({
			dispose: wp(() => {
				sl(t), e()
			})
		})
		return t
	}
	var Gs = class e {
		constructor() {
			;(this._toDispose = new Set()), (this._isDisposed = !1), il(this)
		}
		dispose() {
			this._isDisposed || (sl(this), (this._isDisposed = !0), this.clear())
		}
		get isDisposed() {
			return this._isDisposed
		}
		clear() {
			if (this._toDispose.size !== 0)
				try {
					Bp(this._toDispose)
				} finally {
					this._toDispose.clear()
				}
		}
		add(t) {
			if (!t) return t
			if (t === this) throw new Error('Cannot register a disposable on itself!')
			return (
				Rp(t, this),
				this._isDisposed
					? e.DISABLE_DISPOSED_WARNING ||
					  console.warn(
							new Error(
								'Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!'
							).stack
					  )
					: this._toDispose.add(t),
				t
			)
		}
		delete(t) {
			if (t) {
				if (t === this) throw new Error('Cannot dispose a disposable on itself!')
				this._toDispose.delete(t), t.dispose()
			}
		}
		deleteAndLeak(t) {
			t && this._toDispose.has(t) && (this._toDispose.delete(t), Rp(t, null))
		}
	}
	Gs.DISABLE_DISPOSED_WARNING = !1
	var _i = class {
		constructor() {
			;(this._store = new Gs()), il(this), Rp(this._store, this)
		}
		dispose() {
			sl(this), this._store.dispose()
		}
		_register(t) {
			if (t === this) throw new Error('Cannot register a disposable on itself!')
			return this._store.add(t)
		}
	}
	_i.None = Object.freeze({ dispose() {} })
	var Op = class {
		constructor() {
			;(this._store = new Map()), (this._isDisposed = !1), il(this)
		}
		dispose() {
			sl(this), (this._isDisposed = !0), this.clearAndDisposeAll()
		}
		clearAndDisposeAll() {
			if (this._store.size)
				try {
					Bp(this._store.values())
				} finally {
					this._store.clear()
				}
		}
		has(t) {
			return this._store.has(t)
		}
		get size() {
			return this._store.size
		}
		get(t) {
			return this._store.get(t)
		}
		set(t, n, r = !1) {
			this._isDisposed &&
				console.warn(
					new Error(
						'Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!'
					).stack
				),
				r || this._store.get(t)?.dispose(),
				this._store.set(t, n)
		}
		deleteAndDispose(t) {
			this._store.get(t)?.dispose(), this._store.delete(t)
		}
		[Symbol.iterator]() {
			return this._store[Symbol.iterator]()
		}
	}
	var ur = class e {
		constructor(t) {
			;(this.element = t), (this.next = e.Undefined), (this.prev = e.Undefined)
		}
	}
	ur.Undefined = new ur(void 0)
	var Va = class {
		constructor() {
			;(this._first = ur.Undefined), (this._last = ur.Undefined), (this._size = 0)
		}
		get size() {
			return this._size
		}
		isEmpty() {
			return this._first === ur.Undefined
		}
		clear() {
			let t = this._first
			for (; t !== ur.Undefined; ) {
				let n = t.next
				;(t.prev = ur.Undefined), (t.next = ur.Undefined), (t = n)
			}
			;(this._first = ur.Undefined), (this._last = ur.Undefined), (this._size = 0)
		}
		unshift(t) {
			return this._insert(t, !1)
		}
		push(t) {
			return this._insert(t, !0)
		}
		_insert(t, n) {
			let r = new ur(t)
			if (this._first === ur.Undefined) (this._first = r), (this._last = r)
			else if (n) {
				let s = this._last
				;(this._last = r), (r.prev = s), (s.next = r)
			} else {
				let s = this._first
				;(this._first = r), (r.next = s), (s.prev = r)
			}
			this._size += 1
			let i = !1
			return () => {
				i || ((i = !0), this._remove(r))
			}
		}
		shift() {
			if (this._first !== ur.Undefined) {
				let t = this._first.element
				return this._remove(this._first), t
			}
		}
		pop() {
			if (this._last !== ur.Undefined) {
				let t = this._last.element
				return this._remove(this._last), t
			}
		}
		_remove(t) {
			if (t.prev !== ur.Undefined && t.next !== ur.Undefined) {
				let n = t.prev
				;(n.next = t.next), (t.next.prev = n)
			} else
				t.prev === ur.Undefined && t.next === ur.Undefined
					? ((this._first = ur.Undefined), (this._last = ur.Undefined))
					: t.next === ur.Undefined
					? ((this._last = this._last.prev), (this._last.next = ur.Undefined))
					: t.prev === ur.Undefined &&
					  ((this._first = this._first.next), (this._first.prev = ur.Undefined))
			this._size -= 1
		}
		*[Symbol.iterator]() {
			let t = this._first
			for (; t !== ur.Undefined; ) yield t.element, (t = t.next)
		}
	}
	var R4 = globalThis.performance && typeof globalThis.performance.now == 'function',
		_o = class e {
			static create(t) {
				return new e(t)
			}
			constructor(t) {
				;(this._now =
					R4 && t === !1 ? Date.now : globalThis.performance.now.bind(globalThis.performance)),
					(this._startTime = this._now()),
					(this._stopTime = -1)
			}
			stop() {
				this._stopTime = this._now()
			}
			reset() {
				;(this._startTime = this._now()), (this._stopTime = -1)
			}
			elapsed() {
				return this._stopTime !== -1
					? this._stopTime - this._startTime
					: this._now() - this._startTime
			}
		}
	var A0 = !1,
		O4 = !1,
		ol
	;(function (e) {
		e.None = () => _i.None
		function t(Bt) {
			if (O4) {
				let { onDidAddListener: Te } = Bt,
					Ne = qa.create(),
					Lt = 0
				Bt.onDidAddListener = () => {
					++Lt === 2 &&
						(console.warn(
							'snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here'
						),
						Ne.print()),
						Te?.()
				}
			}
		}
		function n(Bt, Te) {
			return Q(Bt, () => {}, 0, void 0, !0, void 0, Te)
		}
		e.defer = n
		function r(Bt) {
			return (Te, Ne = null, Lt) => {
				let Ct = !1,
					pn
				return (
					(pn = Bt(
						(xn) => {
							if (!Ct) return pn ? pn.dispose() : (Ct = !0), Te.call(Ne, xn)
						},
						null,
						Lt
					)),
					Ct && pn.dispose(),
					pn
				)
			}
		}
		e.once = r
		function i(Bt, Te, Ne) {
			return N((Lt, Ct = null, pn) => Bt((xn) => Lt.call(Ct, Te(xn)), null, pn), Ne)
		}
		e.map = i
		function s(Bt, Te, Ne) {
			return N(
				(Lt, Ct = null, pn) =>
					Bt(
						(xn) => {
							Te(xn), Lt.call(Ct, xn)
						},
						null,
						pn
					),
				Ne
			)
		}
		e.forEach = s
		function o(Bt, Te, Ne) {
			return N((Lt, Ct = null, pn) => Bt((xn) => Te(xn) && Lt.call(Ct, xn), null, pn), Ne)
		}
		e.filter = o
		function a(Bt) {
			return Bt
		}
		e.signal = a
		function u(...Bt) {
			return (Te, Ne = null, Lt) => {
				let Ct = T0(...Bt.map((pn) => pn((xn) => Te.call(Ne, xn))))
				return I(Ct, Lt)
			}
		}
		e.any = u
		function h(Bt, Te, Ne, Lt) {
			let Ct = Ne
			return i(Bt, (pn) => ((Ct = Te(Ct, pn)), Ct), Lt)
		}
		e.reduce = h
		function N(Bt, Te) {
			let Ne,
				Lt = {
					onWillAddFirstListener() {
						Ne = Bt(Ct.fire, Ct)
					},
					onDidRemoveLastListener() {
						Ne?.dispose()
					}
				}
			Te || t(Lt)
			let Ct = new Hr(Lt)
			return Te?.add(Ct), Ct.event
		}
		function I(Bt, Te) {
			return Te instanceof Array ? Te.push(Bt) : Te && Te.add(Bt), Bt
		}
		function Q(Bt, Te, Ne = 100, Lt = !1, Ct = !1, pn, xn) {
			let zn,
				rr,
				rt,
				Wt = 0,
				Ot,
				vt = {
					leakWarningThreshold: pn,
					onWillAddFirstListener() {
						zn = Bt((dt) => {
							Wt++,
								(rr = Te(rr, dt)),
								Lt && !rt && (He.fire(rr), (rr = void 0)),
								(Ot = () => {
									let be = rr
									;(rr = void 0), (rt = void 0), (!Lt || Wt > 1) && He.fire(be), (Wt = 0)
								}),
								typeof Ne == 'number'
									? (clearTimeout(rt), (rt = setTimeout(Ot, Ne)))
									: rt === void 0 && ((rt = 0), queueMicrotask(Ot))
						})
					},
					onWillRemoveListener() {
						Ct && Wt > 0 && Ot?.()
					},
					onDidRemoveLastListener() {
						;(Ot = void 0), zn.dispose()
					}
				}
			xn || t(vt)
			let He = new Hr(vt)
			return xn?.add(He), He.event
		}
		e.debounce = Q
		function K(Bt, Te = 0, Ne) {
			return e.debounce(Bt, (Lt, Ct) => (Lt ? (Lt.push(Ct), Lt) : [Ct]), Te, void 0, !0, void 0, Ne)
		}
		e.accumulate = K
		function ue(Bt, Te = (Lt, Ct) => Lt === Ct, Ne) {
			let Lt = !0,
				Ct
			return o(
				Bt,
				(pn) => {
					let xn = Lt || !Te(pn, Ct)
					return (Lt = !1), (Ct = pn), xn
				},
				Ne
			)
		}
		e.latch = ue
		function de(Bt, Te, Ne) {
			return [e.filter(Bt, Te, Ne), e.filter(Bt, (Lt) => !Te(Lt), Ne)]
		}
		e.split = de
		function Pe(Bt, Te = !1, Ne = [], Lt) {
			let Ct = Ne.slice(),
				pn = Bt((rr) => {
					Ct ? Ct.push(rr) : zn.fire(rr)
				})
			Lt && Lt.add(pn)
			let xn = () => {
					Ct?.forEach((rr) => zn.fire(rr)), (Ct = null)
				},
				zn = new Hr({
					onWillAddFirstListener() {
						pn || ((pn = Bt((rr) => zn.fire(rr))), Lt && Lt.add(pn))
					},
					onDidAddFirstListener() {
						Ct && (Te ? setTimeout(xn) : xn())
					},
					onDidRemoveLastListener() {
						pn && pn.dispose(), (pn = null)
					}
				})
			return Lt && Lt.add(zn), zn.event
		}
		e.buffer = Pe
		function Ze(Bt, Te) {
			return (Lt, Ct, pn) => {
				let xn = Te(new ze())
				return Bt(
					function (zn) {
						let rr = xn.evaluate(zn)
						rr !== Ae && Lt.call(Ct, rr)
					},
					void 0,
					pn
				)
			}
		}
		e.chain = Ze
		let Ae = Symbol('HaltChainable')
		class ze {
			constructor() {
				this.steps = []
			}
			map(Te) {
				return this.steps.push(Te), this
			}
			forEach(Te) {
				return this.steps.push((Ne) => (Te(Ne), Ne)), this
			}
			filter(Te) {
				return this.steps.push((Ne) => (Te(Ne) ? Ne : Ae)), this
			}
			reduce(Te, Ne) {
				let Lt = Ne
				return this.steps.push((Ct) => ((Lt = Te(Lt, Ct)), Lt)), this
			}
			latch(Te = (Ne, Lt) => Ne === Lt) {
				let Ne = !0,
					Lt
				return (
					this.steps.push((Ct) => {
						let pn = Ne || !Te(Ct, Lt)
						return (Ne = !1), (Lt = Ct), pn ? Ct : Ae
					}),
					this
				)
			}
			evaluate(Te) {
				for (let Ne of this.steps) if (((Te = Ne(Te)), Te === Ae)) break
				return Te
			}
		}
		function it(Bt, Te, Ne = (Lt) => Lt) {
			let Lt = (...zn) => xn.fire(Ne(...zn)),
				Ct = () => Bt.on(Te, Lt),
				pn = () => Bt.removeListener(Te, Lt),
				xn = new Hr({ onWillAddFirstListener: Ct, onDidRemoveLastListener: pn })
			return xn.event
		}
		e.fromNodeEventEmitter = it
		function Et(Bt, Te, Ne = (Lt) => Lt) {
			let Lt = (...zn) => xn.fire(Ne(...zn)),
				Ct = () => Bt.addEventListener(Te, Lt),
				pn = () => Bt.removeEventListener(Te, Lt),
				xn = new Hr({ onWillAddFirstListener: Ct, onDidRemoveLastListener: pn })
			return xn.event
		}
		e.fromDOMEventEmitter = Et
		function _t(Bt) {
			return new Promise((Te) => r(Bt)(Te))
		}
		e.toPromise = _t
		function ct(Bt) {
			let Te = new Hr()
			return (
				Bt.then(
					(Ne) => {
						Te.fire(Ne)
					},
					() => {
						Te.fire(void 0)
					}
				).finally(() => {
					Te.dispose()
				}),
				Te.event
			)
		}
		e.fromPromise = ct
		function St(Bt, Te) {
			return Te(void 0), Bt((Ne) => Te(Ne))
		}
		e.runAndSubscribe = St
		function Je(Bt, Te) {
			let Ne = null
			function Lt(pn) {
				Ne?.dispose(), (Ne = new Gs()), Te(pn, Ne)
			}
			Lt(void 0)
			let Ct = Bt((pn) => Lt(pn))
			return vs(() => {
				Ct.dispose(), Ne?.dispose()
			})
		}
		e.runAndSubscribeWithStore = Je
		class Ve {
			constructor(Te, Ne) {
				;(this._observable = Te), (this._counter = 0), (this._hasChanged = !1)
				let Lt = {
					onWillAddFirstListener: () => {
						Te.addObserver(this)
					},
					onDidRemoveLastListener: () => {
						Te.removeObserver(this)
					}
				}
				Ne || t(Lt), (this.emitter = new Hr(Lt)), Ne && Ne.add(this.emitter)
			}
			beginUpdate(Te) {
				this._counter++
			}
			handlePossibleChange(Te) {}
			handleChange(Te, Ne) {
				this._hasChanged = !0
			}
			endUpdate(Te) {
				this._counter--,
					this._counter === 0 &&
						(this._observable.reportChanges(),
						this._hasChanged &&
							((this._hasChanged = !1), this.emitter.fire(this._observable.get())))
			}
		}
		function Qt(Bt, Te) {
			return new Ve(Bt, Te).emitter.event
		}
		e.fromObservable = Qt
		function qt(Bt) {
			return (Te) => {
				let Ne = 0,
					Lt = !1,
					Ct = {
						beginUpdate() {
							Ne++
						},
						endUpdate() {
							Ne--, Ne === 0 && (Bt.reportChanges(), Lt && ((Lt = !1), Te()))
						},
						handlePossibleChange() {},
						handleChange() {
							Lt = !0
						}
					}
				return (
					Bt.addObserver(Ct),
					Bt.reportChanges(),
					{
						dispose() {
							Bt.removeObserver(Ct)
						}
					}
				)
			}
		}
		e.fromObservableLight = qt
	})(ol || (ol = {}))
	var Ua = class e {
		constructor(t) {
			;(this.listenerCount = 0),
				(this.invocationCount = 0),
				(this.elapsedOverall = 0),
				(this.durations = []),
				(this.name = `${t}_${e._idPool++}`),
				e.all.add(this)
		}
		start(t) {
			;(this._stopWatch = new _o()), (this.listenerCount = t)
		}
		stop() {
			if (this._stopWatch) {
				let t = this._stopWatch.elapsed()
				this.durations.push(t),
					(this.elapsedOverall += t),
					(this.invocationCount += 1),
					(this._stopWatch = void 0)
			}
		}
	}
	Ua.all = new Set()
	Ua._idPool = 0
	var C0 = -1
	var Pp = class {
			constructor(t, n = Math.random().toString(18).slice(2, 5)) {
				;(this.threshold = t), (this.name = n), (this._warnCountdown = 0)
			}
			dispose() {
				this._stacks?.clear()
			}
			check(t, n) {
				let r = this.threshold
				if (r <= 0 || n < r) return
				this._stacks || (this._stacks = new Map())
				let i = this._stacks.get(t.value) || 0
				if (
					(this._stacks.set(t.value, i + 1), (this._warnCountdown -= 1), this._warnCountdown <= 0)
				) {
					this._warnCountdown = r * 0.5
					let s,
						o = 0
					for (let [a, u] of this._stacks) (!s || o < u) && ((s = a), (o = u))
					console.warn(
						`[${this.name}] potential listener LEAK detected, having ${n} listeners already. MOST frequent listener (${o}):`
					),
						console.warn(s)
				}
				return () => {
					let s = this._stacks.get(t.value) || 0
					this._stacks.set(t.value, s - 1)
				}
			}
		},
		qa = class e {
			static create() {
				return new e(new Error().stack ?? '')
			}
			constructor(t) {
				this.value = t
			}
			print() {
				console.warn(
					this.value
						.split(
							`
`
						)
						.slice(2).join(`
`)
				)
			}
		},
		B4 = 0,
		wo = class {
			constructor(t) {
				;(this.value = t), (this.id = B4++)
			}
		},
		P4 = 2,
		M4 = (e, t) => {
			if (e instanceof wo) t(e)
			else
				for (let n = 0; n < e.length; n++) {
					let r = e[n]
					r && t(r)
				}
		},
		Hr = class {
			constructor(t) {
				;(this._size = 0),
					(this._options = t),
					(this._leakageMon =
						C0 > 0 || this._options?.leakWarningThreshold
							? new Pp(this._options?.leakWarningThreshold ?? C0)
							: void 0),
					(this._perfMon = this._options?._profName ? new Ua(this._options._profName) : void 0),
					(this._deliveryQueue = this._options?.deliveryQueue)
			}
			dispose() {
				if (!this._disposed) {
					if (
						((this._disposed = !0),
						this._deliveryQueue?.current === this && this._deliveryQueue.reset(),
						this._listeners)
					) {
						if (A0) {
							let t = this._listeners
							queueMicrotask(() => {
								M4(t, (n) => n.stack?.print())
							})
						}
						;(this._listeners = void 0), (this._size = 0)
					}
					this._options?.onDidRemoveLastListener?.(), this._leakageMon?.dispose()
				}
			}
			get event() {
				return (
					this._event ??
						(this._event = (t, n, r) => {
							if (this._leakageMon && this._size > this._leakageMon.threshold * 3)
								return (
									console.warn(
										`[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far`
									),
									_i.None
								)
							if (this._disposed) return _i.None
							n && (t = t.bind(n))
							let i = new wo(t),
								s,
								o
							this._leakageMon &&
								this._size >= Math.ceil(this._leakageMon.threshold * 0.2) &&
								((i.stack = qa.create()), (s = this._leakageMon.check(i.stack, this._size + 1))),
								A0 && (i.stack = o ?? qa.create()),
								this._listeners
									? this._listeners instanceof wo
										? (this._deliveryQueue ?? (this._deliveryQueue = new Mp()),
										  (this._listeners = [this._listeners, i]))
										: this._listeners.push(i)
									: (this._options?.onWillAddFirstListener?.(this),
									  (this._listeners = i),
									  this._options?.onDidAddFirstListener?.(this)),
								this._size++
							let a = vs(() => {
								s?.(), this._removeListener(i)
							})
							return r instanceof Gs ? r.add(a) : Array.isArray(r) && r.push(a), a
						}),
					this._event
				)
			}
			_removeListener(t) {
				if ((this._options?.onWillRemoveListener?.(this), !this._listeners)) return
				if (this._size === 1) {
					;(this._listeners = void 0),
						this._options?.onDidRemoveLastListener?.(this),
						(this._size = 0)
					return
				}
				let n = this._listeners,
					r = n.indexOf(t)
				if (r === -1)
					throw (
						(console.log('disposed?', this._disposed),
						console.log('size?', this._size),
						console.log('arr?', JSON.stringify(this._listeners)),
						new Error('Attempted to dispose unknown listener'))
					)
				this._size--, (n[r] = void 0)
				let i = this._deliveryQueue.current === this
				if (this._size * P4 <= n.length) {
					let s = 0
					for (let o = 0; o < n.length; o++)
						n[o]
							? (n[s++] = n[o])
							: i &&
							  (this._deliveryQueue.end--, s < this._deliveryQueue.i && this._deliveryQueue.i--)
					n.length = s
				}
			}
			_deliver(t, n) {
				if (!t) return
				let r = this._options?.onListenerError || nl
				if (!r) {
					t.value(n)
					return
				}
				try {
					t.value(n)
				} catch (i) {
					r(i)
				}
			}
			_deliverQueue(t) {
				let n = t.current._listeners
				for (; t.i < t.end; ) this._deliver(n[t.i++], t.value)
				t.reset()
			}
			fire(t) {
				if (
					(this._deliveryQueue?.current &&
						(this._deliverQueue(this._deliveryQueue), this._perfMon?.stop()),
					this._perfMon?.start(this._size),
					this._listeners)
				)
					if (this._listeners instanceof wo) this._deliver(this._listeners, t)
					else {
						let n = this._deliveryQueue
						n.enqueue(this, t, this._listeners.length), this._deliverQueue(n)
					}
				this._perfMon?.stop()
			}
			hasListeners() {
				return this._size > 0
			}
		}
	var Mp = class {
		constructor() {
			;(this.i = -1), (this.end = 0)
		}
		enqueue(t, n, r) {
			;(this.i = 0), (this.end = r), (this.current = t), (this.value = n)
		}
		reset() {
			;(this.i = this.end), (this.current = void 0), (this.value = void 0)
		}
	}
	function S0(e) {
		return typeof e == 'string'
	}
	function j4(e) {
		let t = []
		for (; Object.prototype !== e; )
			(t = t.concat(Object.getOwnPropertyNames(e))), (e = Object.getPrototypeOf(e))
		return t
	}
	function Ga(e) {
		let t = []
		for (let n of j4(e)) typeof e[n] == 'function' && t.push(n)
		return t
	}
	function N0(e, t) {
		let n = (i) =>
				function () {
					let s = Array.prototype.slice.call(arguments, 0)
					return t(i, s)
				},
			r = {}
		for (let i of e) r[i] = n(i)
		return r
	}
	var $4 =
		typeof document < 'u' && document.location && document.location.hash.indexOf('pseudo=true') >= 0
	function V4(e, t) {
		let n
		return (
			t.length === 0
				? (n = e)
				: (n = e.replace(/\{(\d+)\}/g, (r, i) => {
						let s = i[0],
							o = t[s],
							a = r
						return (
							typeof o == 'string'
								? (a = o)
								: (typeof o == 'number' || typeof o == 'boolean' || o === void 0 || o === null) &&
								  (a = String(o)),
							a
						)
				  })),
			$4 && (n = '\uFF3B' + n.replace(/[aouei]/g, '$&$&') + '\uFF3D'),
			n
		)
	}
	var U4,
		q4 = {}
	function sr(e, t, n, ...r) {
		let i = typeof t == 'object' ? t.key : t,
			s = (q4[e] ?? {})[i] ?? n
		return V4(s, r)
	}
	function F0(e) {
		return U4
	}
	var Lo = 'en',
		cl = !1,
		pl = !1,
		ul = !1,
		W4 = !1,
		H4 = !1,
		L0 = !1,
		J4 = !1,
		z4 = !1,
		Q4 = !1,
		Y4 = !1,
		al,
		ll = Lo,
		_0 = Lo,
		X4,
		ls,
		wi = typeof self == 'object' ? self : typeof global == 'object' ? global : {},
		yi
	typeof wi.vscode < 'u' && typeof wi.vscode.process < 'u'
		? (yi = wi.vscode.process)
		: typeof process < 'u' && (yi = process)
	var I0 = typeof yi?.versions?.electron == 'string',
		K4 = I0 && yi?.type === 'renderer'
	if (typeof navigator == 'object' && !K4)
		(ls = navigator.userAgent),
			(cl = ls.indexOf('Windows') >= 0),
			(pl = ls.indexOf('Macintosh') >= 0),
			(z4 =
				(ls.indexOf('Macintosh') >= 0 || ls.indexOf('iPad') >= 0 || ls.indexOf('iPhone') >= 0) &&
				!!navigator.maxTouchPoints &&
				navigator.maxTouchPoints > 0),
			(ul = ls.indexOf('Linux') >= 0),
			(Y4 = ls?.indexOf('Mobi') >= 0),
			(L0 = !0),
			(al =
				F0(
					sr(
						'vs/base/common/platform',
						{ key: 'ensureLoaderPluginIsLoaded', comment: ['{Locked}'] },
						'_'
					)
				) || Lo),
			(ll = al),
			(_0 = navigator.language)
	else if (typeof yi == 'object') {
		;(cl = yi.platform === 'win32'),
			(pl = yi.platform === 'darwin'),
			(ul = yi.platform === 'linux'),
			(W4 = ul && !!yi.env.SNAP && !!yi.env.SNAP_REVISION),
			(J4 = I0),
			(Q4 = !!yi.env.CI || !!yi.env.BUILD_ARTIFACTSTAGINGDIRECTORY),
			(al = Lo),
			(ll = Lo)
		let e = yi.env.VSCODE_NLS_CONFIG
		if (e)
			try {
				let t = JSON.parse(e),
					n = t.availableLanguages['*']
				;(al = t.locale), (_0 = t.osLocale), (ll = n || Lo), (X4 = t._translationsConfigFile)
			} catch {}
		H4 = !0
	} else console.error('Unable to resolve platform.')
	var jp = 0
	pl ? (jp = 1) : cl ? (jp = 3) : ul && (jp = 2)
	var Ws = cl,
		k0 = pl
	var y7 = L0 && typeof wi.importScripts == 'function'
	var Wi = ls,
		xs = ll,
		w0
	;(function (e) {
		function t() {
			return xs
		}
		e.value = t
		function n() {
			return xs.length === 2
				? xs === 'en'
				: xs.length >= 3
				? xs[0] === 'e' && xs[1] === 'n' && xs[2] === '-'
				: !1
		}
		e.isDefaultVariant = n
		function r() {
			return xs === 'en'
		}
		e.isDefault = r
	})(w0 || (w0 = {}))
	var Z4 = typeof wi.postMessage == 'function' && !wi.importScripts,
		E7 = (() => {
			if (Z4) {
				let e = []
				wi.addEventListener('message', (n) => {
					if (n.data && n.data.vscodeScheduleAsyncWork)
						for (let r = 0, i = e.length; r < i; r++) {
							let s = e[r]
							if (s.id === n.data.vscodeScheduleAsyncWork) {
								e.splice(r, 1), s.callback()
								return
							}
						}
				})
				let t = 0
				return (n) => {
					let r = ++t
					e.push({ id: r, callback: n }), wi.postMessage({ vscodeScheduleAsyncWork: r }, '*')
				}
			}
			return (e) => setTimeout(e)
		})()
	var ev = !!(Wi && Wi.indexOf('Chrome') >= 0),
		v7 = !!(Wi && Wi.indexOf('Firefox') >= 0),
		x7 = !!(!ev && Wi && Wi.indexOf('Safari') >= 0),
		b7 = !!(Wi && Wi.indexOf('Edg/') >= 0),
		T7 = !!(Wi && Wi.indexOf('Android') >= 0)
	var R0 = Object.freeze(function (e, t) {
			let n = setTimeout(e.bind(t), 0)
			return {
				dispose() {
					clearTimeout(n)
				}
			}
		}),
		fl
	;(function (e) {
		function t(n) {
			return n === e.None || n === e.Cancelled || n instanceof Io
				? !0
				: !n || typeof n != 'object'
				? !1
				: typeof n.isCancellationRequested == 'boolean' &&
				  typeof n.onCancellationRequested == 'function'
		}
		;(e.isCancellationToken = t),
			(e.None = Object.freeze({ isCancellationRequested: !1, onCancellationRequested: ol.None })),
			(e.Cancelled = Object.freeze({ isCancellationRequested: !0, onCancellationRequested: R0 }))
	})(fl || (fl = {}))
	var Io = class {
			constructor() {
				;(this._isCancelled = !1), (this._emitter = null)
			}
			cancel() {
				this._isCancelled ||
					((this._isCancelled = !0), this._emitter && (this._emitter.fire(void 0), this.dispose()))
			}
			get isCancellationRequested() {
				return this._isCancelled
			}
			get onCancellationRequested() {
				return this._isCancelled
					? R0
					: (this._emitter || (this._emitter = new Hr()), this._emitter.event)
			}
			dispose() {
				this._emitter && (this._emitter.dispose(), (this._emitter = null))
			}
		},
		Wa = class {
			constructor(t) {
				;(this._token = void 0),
					(this._parentListener = void 0),
					(this._parentListener = t && t.onCancellationRequested(this.cancel, this))
			}
			get token() {
				return this._token || (this._token = new Io()), this._token
			}
			cancel() {
				this._token
					? this._token instanceof Io && this._token.cancel()
					: (this._token = fl.Cancelled)
			}
			dispose(t = !1) {
				t && this.cancel(),
					this._parentListener?.dispose(),
					this._token ? this._token instanceof Io && this._token.dispose() : (this._token = fl.None)
			}
		}
	var dl = class {
		constructor(t) {
			;(this.fn = t), (this.lastCache = void 0), (this.lastArgKey = void 0)
		}
		get(t) {
			let n = JSON.stringify(t)
			return (
				this.lastArgKey !== n && ((this.lastArgKey = n), (this.lastCache = this.fn(t))),
				this.lastCache
			)
		}
	}
	var Ha = class {
		constructor(t) {
			;(this.executor = t), (this._didRun = !1)
		}
		get hasValue() {
			return this._didRun
		}
		get value() {
			if (!this._didRun)
				try {
					this._value = this.executor()
				} catch (t) {
					this._error = t
				} finally {
					this._didRun = !0
				}
			if (this._error) throw this._error
			return this._value
		}
		get rawValue() {
			return this._value
		}
	}
	var ko
	function O0(e) {
		return e.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, '\\$&')
	}
	function B0(e) {
		return e.split(/\r\n|\r|\n/)
	}
	function P0(e) {
		for (let t = 0, n = e.length; t < n; t++) {
			let r = e.charCodeAt(t)
			if (r !== 32 && r !== 9) return t
		}
		return -1
	}
	function M0(e, t = e.length - 1) {
		for (let n = t; n >= 0; n--) {
			let r = e.charCodeAt(n)
			if (r !== 32 && r !== 9) return n
		}
		return -1
	}
	function Vp(e) {
		return e >= 65 && e <= 90
	}
	function Ro(e) {
		return 55296 <= e && e <= 56319
	}
	function hl(e) {
		return 56320 <= e && e <= 57343
	}
	function Up(e, t) {
		return ((e - 55296) << 10) + (t - 56320) + 65536
	}
	function j0(e, t, n) {
		let r = e.charCodeAt(n)
		if (Ro(r) && n + 1 < t) {
			let i = e.charCodeAt(n + 1)
			if (hl(i)) return Up(r, i)
		}
		return r
	}
	var tv = /^[\t\n\r\x20-\x7E]*$/
	function $0(e) {
		return tv.test(e)
	}
	var I7 = String.fromCharCode(65279)
	var $p = class e {
		static getInstance() {
			return e._INSTANCE || (e._INSTANCE = new e()), e._INSTANCE
		}
		constructor() {
			this._data = nv()
		}
		getGraphemeBreakType(t) {
			if (t < 32) return t === 10 ? 3 : t === 13 ? 2 : 4
			if (t < 127) return 0
			let n = this._data,
				r = n.length / 3,
				i = 1
			for (; i <= r; )
				if (t < n[3 * i]) i = 2 * i
				else if (t > n[3 * i + 1]) i = 2 * i + 1
				else return n[3 * i + 2]
			return 0
		}
	}
	$p._INSTANCE = null
	function nv() {
		return JSON.parse(
			'[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]'
		)
	}
	var Hi = class {
		static getInstance(t) {
			return ko.cache.get(Array.from(t))
		}
		static getLocales() {
			return ko._locales.value
		}
		constructor(t) {
			this.confusableDictionary = t
		}
		isAmbiguous(t) {
			return this.confusableDictionary.has(t)
		}
		getPrimaryConfusable(t) {
			return this.confusableDictionary.get(t)
		}
		getConfusableCodePoints() {
			return new Set(this.confusableDictionary.keys())
		}
	}
	ko = Hi
	Hi.ambiguousCharacterData = new Ha(() =>
		JSON.parse(
			'{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}'
		)
	)
	Hi.cache = new dl((e) => {
		function t(h) {
			let N = new Map()
			for (let I = 0; I < h.length; I += 2) N.set(h[I], h[I + 1])
			return N
		}
		function n(h, N) {
			let I = new Map(h)
			for (let [Q, K] of N) I.set(Q, K)
			return I
		}
		function r(h, N) {
			if (!h) return N
			let I = new Map()
			for (let [Q, K] of h) N.has(Q) && I.set(Q, K)
			return I
		}
		let i = ko.ambiguousCharacterData.value,
			s = e.filter((h) => !h.startsWith('_') && h in i)
		s.length === 0 && (s = ['_default'])
		let o
		for (let h of s) {
			let N = t(i[h])
			o = r(o, N)
		}
		let a = t(i._common),
			u = n(a, o)
		return new ko(u)
	})
	Hi._locales = new Ha(() =>
		Object.keys(ko.ambiguousCharacterData.value).filter((e) => !e.startsWith('_'))
	)
	var Hs = class e {
		static getRawData() {
			return JSON.parse(
				'[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]'
			)
		}
		static getData() {
			return this._data || (this._data = new Set(e.getRawData())), this._data
		}
		static isInvisibleCharacter(t) {
			return e.getData().has(t)
		}
		static get codePoints() {
			return e.getData()
		}
	}
	Hs._data = void 0
	var rv = '$initialize'
	var qp = class {
			constructor(t, n, r, i) {
				;(this.vsWorker = t), (this.req = n), (this.method = r), (this.args = i), (this.type = 0)
			}
		},
		ml = class {
			constructor(t, n, r, i) {
				;(this.vsWorker = t), (this.seq = n), (this.res = r), (this.err = i), (this.type = 1)
			}
		},
		Gp = class {
			constructor(t, n, r, i) {
				;(this.vsWorker = t), (this.req = n), (this.eventName = r), (this.arg = i), (this.type = 2)
			}
		},
		Wp = class {
			constructor(t, n, r) {
				;(this.vsWorker = t), (this.req = n), (this.event = r), (this.type = 3)
			}
		},
		Hp = class {
			constructor(t, n) {
				;(this.vsWorker = t), (this.req = n), (this.type = 4)
			}
		},
		Jp = class {
			constructor(t) {
				;(this._workerId = -1),
					(this._handler = t),
					(this._lastSentReq = 0),
					(this._pendingReplies = Object.create(null)),
					(this._pendingEmitters = new Map()),
					(this._pendingEvents = new Map())
			}
			setWorkerId(t) {
				this._workerId = t
			}
			sendMessage(t, n) {
				let r = String(++this._lastSentReq)
				return new Promise((i, s) => {
					;(this._pendingReplies[r] = { resolve: i, reject: s }),
						this._send(new qp(this._workerId, r, t, n))
				})
			}
			listen(t, n) {
				let r = null,
					i = new Hr({
						onWillAddFirstListener: () => {
							;(r = String(++this._lastSentReq)),
								this._pendingEmitters.set(r, i),
								this._send(new Gp(this._workerId, r, t, n))
						},
						onDidRemoveLastListener: () => {
							this._pendingEmitters.delete(r), this._send(new Hp(this._workerId, r)), (r = null)
						}
					})
				return i.event
			}
			handleMessage(t) {
				!t ||
					!t.vsWorker ||
					(this._workerId !== -1 && t.vsWorker !== this._workerId) ||
					this._handleMessage(t)
			}
			_handleMessage(t) {
				switch (t.type) {
					case 1:
						return this._handleReplyMessage(t)
					case 0:
						return this._handleRequestMessage(t)
					case 2:
						return this._handleSubscribeEventMessage(t)
					case 3:
						return this._handleEventMessage(t)
					case 4:
						return this._handleUnsubscribeEventMessage(t)
				}
			}
			_handleReplyMessage(t) {
				if (!this._pendingReplies[t.seq]) {
					console.warn('Got reply to unknown seq')
					return
				}
				let n = this._pendingReplies[t.seq]
				if ((delete this._pendingReplies[t.seq], t.err)) {
					let r = t.err
					t.err.$isError &&
						((r = new Error()),
						(r.name = t.err.name),
						(r.message = t.err.message),
						(r.stack = t.err.stack)),
						n.reject(r)
					return
				}
				n.resolve(t.res)
			}
			_handleRequestMessage(t) {
				let n = t.req
				this._handler.handleMessage(t.method, t.args).then(
					(i) => {
						this._send(new ml(this._workerId, n, i, void 0))
					},
					(i) => {
						i.detail instanceof Error && (i.detail = _p(i.detail)),
							this._send(new ml(this._workerId, n, void 0, _p(i)))
					}
				)
			}
			_handleSubscribeEventMessage(t) {
				let n = t.req,
					r = this._handler.handleEvent(
						t.eventName,
						t.arg
					)((i) => {
						this._send(new Wp(this._workerId, n, i))
					})
				this._pendingEvents.set(n, r)
			}
			_handleEventMessage(t) {
				if (!this._pendingEmitters.has(t.req)) {
					console.warn('Got event for unknown req')
					return
				}
				this._pendingEmitters.get(t.req).fire(t.event)
			}
			_handleUnsubscribeEventMessage(t) {
				if (!this._pendingEvents.has(t.req)) {
					console.warn('Got unsubscribe for unknown req')
					return
				}
				this._pendingEvents.get(t.req).dispose(), this._pendingEvents.delete(t.req)
			}
			_send(t) {
				let n = []
				if (t.type === 0)
					for (let r = 0; r < t.args.length; r++)
						t.args[r] instanceof ArrayBuffer && n.push(t.args[r])
				else t.type === 1 && t.res instanceof ArrayBuffer && n.push(t.res)
				this._handler.sendMessage(t, n)
			}
		}
	function V0(e) {
		return e[0] === 'o' && e[1] === 'n' && Vp(e.charCodeAt(2))
	}
	function U0(e) {
		return /^onDynamic/.test(e) && Vp(e.charCodeAt(9))
	}
	function iv(e, t, n) {
		let r = (o) =>
				function () {
					let a = Array.prototype.slice.call(arguments, 0)
					return t(o, a)
				},
			i = (o) =>
				function (a) {
					return n(o, a)
				},
			s = {}
		for (let o of e) {
			if (U0(o)) {
				s[o] = i(o)
				continue
			}
			if (V0(o)) {
				s[o] = n(o, void 0)
				continue
			}
			s[o] = r(o)
		}
		return s
	}
	var gl = class {
		constructor(t, n) {
			;(this._requestHandlerFactory = n),
				(this._requestHandler = null),
				(this._protocol = new Jp({
					sendMessage: (r, i) => {
						t(r, i)
					},
					handleMessage: (r, i) => this._handleMessage(r, i),
					handleEvent: (r, i) => this._handleEvent(r, i)
				}))
		}
		onmessage(t) {
			this._protocol.handleMessage(t)
		}
		_handleMessage(t, n) {
			if (t === rv) return this.initialize(n[0], n[1], n[2], n[3])
			if (!this._requestHandler || typeof this._requestHandler[t] != 'function')
				return Promise.reject(new Error('Missing requestHandler or method: ' + t))
			try {
				return Promise.resolve(this._requestHandler[t].apply(this._requestHandler, n))
			} catch (r) {
				return Promise.reject(r)
			}
		}
		_handleEvent(t, n) {
			if (!this._requestHandler) throw new Error('Missing requestHandler')
			if (U0(t)) {
				let r = this._requestHandler[t].call(this._requestHandler, n)
				if (typeof r != 'function')
					throw new Error(`Missing dynamic event ${t} on request handler.`)
				return r
			}
			if (V0(t)) {
				let r = this._requestHandler[t]
				if (typeof r != 'function') throw new Error(`Missing event ${t} on request handler.`)
				return r
			}
			throw new Error(`Malformed event name ${t}`)
		}
		initialize(t, n, r, i) {
			this._protocol.setWorkerId(t)
			let a = iv(
				i,
				(u, h) => this._protocol.sendMessage(u, h),
				(u, h) => this._protocol.listen(u, h)
			)
			return this._requestHandlerFactory
				? ((this._requestHandler = this._requestHandlerFactory(a)),
				  Promise.resolve(Ga(this._requestHandler)))
				: (n &&
						(typeof n.baseUrl < 'u' && delete n.baseUrl,
						typeof n.paths < 'u' && typeof n.paths.vs < 'u' && delete n.paths.vs,
						typeof n.trustedTypesPolicy !== void 0 && delete n.trustedTypesPolicy,
						(n.catchError = !0),
						globalThis.require.config(n)),
				  new Promise((u, h) => {
						let N = globalThis.require
						N(
							[r],
							(I) => {
								if (((this._requestHandler = I.create(a)), !this._requestHandler)) {
									h(new Error('No RequestHandler!'))
									return
								}
								u(Ga(this._requestHandler))
							},
							h
						)
				  }))
		}
	}
	var Ri = class {
		constructor(t, n, r, i) {
			;(this.originalStart = t),
				(this.originalLength = n),
				(this.modifiedStart = r),
				(this.modifiedLength = i)
		}
		getOriginalEnd() {
			return this.originalStart + this.originalLength
		}
		getModifiedEnd() {
			return this.modifiedStart + this.modifiedLength
		}
	}
	function q0(e, t) {
		return ((t << 5) - t + e) | 0
	}
	function W0(e, t) {
		t = q0(149417, t)
		for (let n = 0, r = e.length; n < r; n++) t = q0(e.charCodeAt(n), t)
		return t
	}
	function zp(e, t, n = 32) {
		let r = n - t,
			i = ~((1 << r) - 1)
		return ((e << t) | ((i & e) >>> r)) >>> 0
	}
	function G0(e, t = 0, n = e.byteLength, r = 0) {
		for (let i = 0; i < n; i++) e[t + i] = r
	}
	function sv(e, t, n = '0') {
		for (; e.length < t; ) e = n + e
		return e
	}
	function za(e, t = 32) {
		return e instanceof ArrayBuffer
			? Array.from(new Uint8Array(e))
					.map((n) => n.toString(16).padStart(2, '0'))
					.join('')
			: sv((e >>> 0).toString(16), t / 4)
	}
	var Qp = class e {
		constructor() {
			;(this._h0 = 1732584193),
				(this._h1 = 4023233417),
				(this._h2 = 2562383102),
				(this._h3 = 271733878),
				(this._h4 = 3285377520),
				(this._buff = new Uint8Array(64 + 3)),
				(this._buffDV = new DataView(this._buff.buffer)),
				(this._buffLen = 0),
				(this._totalLen = 0),
				(this._leftoverHighSurrogate = 0),
				(this._finished = !1)
		}
		update(t) {
			let n = t.length
			if (n === 0) return
			let r = this._buff,
				i = this._buffLen,
				s = this._leftoverHighSurrogate,
				o,
				a
			for (s !== 0 ? ((o = s), (a = -1), (s = 0)) : ((o = t.charCodeAt(0)), (a = 0)); ; ) {
				let u = o
				if (Ro(o))
					if (a + 1 < n) {
						let h = t.charCodeAt(a + 1)
						hl(h) ? (a++, (u = Up(o, h))) : (u = 65533)
					} else {
						s = o
						break
					}
				else hl(o) && (u = 65533)
				if (((i = this._push(r, i, u)), a++, a < n)) o = t.charCodeAt(a)
				else break
			}
			;(this._buffLen = i), (this._leftoverHighSurrogate = s)
		}
		_push(t, n, r) {
			return (
				r < 128
					? (t[n++] = r)
					: r < 2048
					? ((t[n++] = 192 | ((r & 1984) >>> 6)), (t[n++] = 128 | ((r & 63) >>> 0)))
					: r < 65536
					? ((t[n++] = 224 | ((r & 61440) >>> 12)),
					  (t[n++] = 128 | ((r & 4032) >>> 6)),
					  (t[n++] = 128 | ((r & 63) >>> 0)))
					: ((t[n++] = 240 | ((r & 1835008) >>> 18)),
					  (t[n++] = 128 | ((r & 258048) >>> 12)),
					  (t[n++] = 128 | ((r & 4032) >>> 6)),
					  (t[n++] = 128 | ((r & 63) >>> 0))),
				n >= 64 &&
					(this._step(),
					(n -= 64),
					(this._totalLen += 64),
					(t[0] = t[64 + 0]),
					(t[1] = t[64 + 1]),
					(t[2] = t[64 + 2])),
				n
			)
		}
		digest() {
			return (
				this._finished ||
					((this._finished = !0),
					this._leftoverHighSurrogate &&
						((this._leftoverHighSurrogate = 0),
						(this._buffLen = this._push(this._buff, this._buffLen, 65533))),
					(this._totalLen += this._buffLen),
					this._wrapUp()),
				za(this._h0) + za(this._h1) + za(this._h2) + za(this._h3) + za(this._h4)
			)
		}
		_wrapUp() {
			;(this._buff[this._buffLen++] = 128),
				G0(this._buff, this._buffLen),
				this._buffLen > 56 && (this._step(), G0(this._buff))
			let t = 8 * this._totalLen
			this._buffDV.setUint32(56, Math.floor(t / 4294967296), !1),
				this._buffDV.setUint32(60, t % 4294967296, !1),
				this._step()
		}
		_step() {
			let t = e._bigBlock32,
				n = this._buffDV
			for (let I = 0; I < 64; I += 4) t.setUint32(I, n.getUint32(I, !1), !1)
			for (let I = 64; I < 320; I += 4)
				t.setUint32(
					I,
					zp(
						t.getUint32(I - 12, !1) ^
							t.getUint32(I - 32, !1) ^
							t.getUint32(I - 56, !1) ^
							t.getUint32(I - 64, !1),
						1
					),
					!1
				)
			let r = this._h0,
				i = this._h1,
				s = this._h2,
				o = this._h3,
				a = this._h4,
				u,
				h,
				N
			for (let I = 0; I < 80; I++)
				I < 20
					? ((u = (i & s) | (~i & o)), (h = 1518500249))
					: I < 40
					? ((u = i ^ s ^ o), (h = 1859775393))
					: I < 60
					? ((u = (i & s) | (i & o) | (s & o)), (h = 2400959708))
					: ((u = i ^ s ^ o), (h = 3395469782)),
					(N = (zp(r, 5) + u + a + h + t.getUint32(I * 4, !1)) & 4294967295),
					(a = o),
					(o = s),
					(s = zp(i, 30)),
					(i = r),
					(r = N)
			;(this._h0 = (this._h0 + r) & 4294967295),
				(this._h1 = (this._h1 + i) & 4294967295),
				(this._h2 = (this._h2 + s) & 4294967295),
				(this._h3 = (this._h3 + o) & 4294967295),
				(this._h4 = (this._h4 + a) & 4294967295)
		}
	}
	Qp._bigBlock32 = new DataView(new ArrayBuffer(320))
	var Dl = class {
		constructor(t) {
			this.source = t
		}
		getElements() {
			let t = this.source,
				n = new Int32Array(t.length)
			for (let r = 0, i = t.length; r < i; r++) n[r] = t.charCodeAt(r)
			return n
		}
	}
	function H0(e, t, n) {
		return new Qa(new Dl(e), new Dl(t)).ComputeDiff(n).changes
	}
	var bs = class {
			static Assert(t, n) {
				if (!t) throw new Error(n)
			}
		},
		Ts = class {
			static Copy(t, n, r, i, s) {
				for (let o = 0; o < s; o++) r[i + o] = t[n + o]
			}
			static Copy2(t, n, r, i, s) {
				for (let o = 0; o < s; o++) r[i + o] = t[n + o]
			}
		},
		yl = class {
			constructor() {
				;(this.m_changes = []),
					(this.m_originalStart = 1073741824),
					(this.m_modifiedStart = 1073741824),
					(this.m_originalCount = 0),
					(this.m_modifiedCount = 0)
			}
			MarkNextChange() {
				;(this.m_originalCount > 0 || this.m_modifiedCount > 0) &&
					this.m_changes.push(
						new Ri(
							this.m_originalStart,
							this.m_originalCount,
							this.m_modifiedStart,
							this.m_modifiedCount
						)
					),
					(this.m_originalCount = 0),
					(this.m_modifiedCount = 0),
					(this.m_originalStart = 1073741824),
					(this.m_modifiedStart = 1073741824)
			}
			AddOriginalElement(t, n) {
				;(this.m_originalStart = Math.min(this.m_originalStart, t)),
					(this.m_modifiedStart = Math.min(this.m_modifiedStart, n)),
					this.m_originalCount++
			}
			AddModifiedElement(t, n) {
				;(this.m_originalStart = Math.min(this.m_originalStart, t)),
					(this.m_modifiedStart = Math.min(this.m_modifiedStart, n)),
					this.m_modifiedCount++
			}
			getChanges() {
				return (
					(this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.MarkNextChange(),
					this.m_changes
				)
			}
			getReverseChanges() {
				return (
					(this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.MarkNextChange(),
					this.m_changes.reverse(),
					this.m_changes
				)
			}
		},
		Qa = class e {
			constructor(t, n, r = null) {
				;(this.ContinueProcessingPredicate = r),
					(this._originalSequence = t),
					(this._modifiedSequence = n)
				let [i, s, o] = e._getElements(t),
					[a, u, h] = e._getElements(n)
				;(this._hasStrings = o && h),
					(this._originalStringElements = i),
					(this._originalElementsOrHash = s),
					(this._modifiedStringElements = a),
					(this._modifiedElementsOrHash = u),
					(this.m_forwardHistory = []),
					(this.m_reverseHistory = [])
			}
			static _isStringArray(t) {
				return t.length > 0 && typeof t[0] == 'string'
			}
			static _getElements(t) {
				let n = t.getElements()
				if (e._isStringArray(n)) {
					let r = new Int32Array(n.length)
					for (let i = 0, s = n.length; i < s; i++) r[i] = W0(n[i], 0)
					return [n, r, !0]
				}
				return n instanceof Int32Array ? [[], n, !1] : [[], new Int32Array(n), !1]
			}
			ElementsAreEqual(t, n) {
				return this._originalElementsOrHash[t] !== this._modifiedElementsOrHash[n]
					? !1
					: this._hasStrings
					? this._originalStringElements[t] === this._modifiedStringElements[n]
					: !0
			}
			ElementsAreStrictEqual(t, n) {
				if (!this.ElementsAreEqual(t, n)) return !1
				let r = e._getStrictElement(this._originalSequence, t),
					i = e._getStrictElement(this._modifiedSequence, n)
				return r === i
			}
			static _getStrictElement(t, n) {
				return typeof t.getStrictElement == 'function' ? t.getStrictElement(n) : null
			}
			OriginalElementsAreEqual(t, n) {
				return this._originalElementsOrHash[t] !== this._originalElementsOrHash[n]
					? !1
					: this._hasStrings
					? this._originalStringElements[t] === this._originalStringElements[n]
					: !0
			}
			ModifiedElementsAreEqual(t, n) {
				return this._modifiedElementsOrHash[t] !== this._modifiedElementsOrHash[n]
					? !1
					: this._hasStrings
					? this._modifiedStringElements[t] === this._modifiedStringElements[n]
					: !0
			}
			ComputeDiff(t) {
				return this._ComputeDiff(
					0,
					this._originalElementsOrHash.length - 1,
					0,
					this._modifiedElementsOrHash.length - 1,
					t
				)
			}
			_ComputeDiff(t, n, r, i, s) {
				let o = [!1],
					a = this.ComputeDiffRecursive(t, n, r, i, o)
				return s && (a = this.PrettifyChanges(a)), { quitEarly: o[0], changes: a }
			}
			ComputeDiffRecursive(t, n, r, i, s) {
				for (s[0] = !1; t <= n && r <= i && this.ElementsAreEqual(t, r); ) t++, r++
				for (; n >= t && i >= r && this.ElementsAreEqual(n, i); ) n--, i--
				if (t > n || r > i) {
					let I
					return (
						r <= i
							? (bs.Assert(t === n + 1, 'originalStart should only be one more than originalEnd'),
							  (I = [new Ri(t, 0, r, i - r + 1)]))
							: t <= n
							? (bs.Assert(r === i + 1, 'modifiedStart should only be one more than modifiedEnd'),
							  (I = [new Ri(t, n - t + 1, r, 0)]))
							: (bs.Assert(t === n + 1, 'originalStart should only be one more than originalEnd'),
							  bs.Assert(r === i + 1, 'modifiedStart should only be one more than modifiedEnd'),
							  (I = [])),
						I
					)
				}
				let o = [0],
					a = [0],
					u = this.ComputeRecursionPoint(t, n, r, i, o, a, s),
					h = o[0],
					N = a[0]
				if (u !== null) return u
				if (!s[0]) {
					let I = this.ComputeDiffRecursive(t, h, r, N, s),
						Q = []
					return (
						s[0]
							? (Q = [new Ri(h + 1, n - (h + 1) + 1, N + 1, i - (N + 1) + 1)])
							: (Q = this.ComputeDiffRecursive(h + 1, n, N + 1, i, s)),
						this.ConcatenateChanges(I, Q)
					)
				}
				return [new Ri(t, n - t + 1, r, i - r + 1)]
			}
			WALKTRACE(t, n, r, i, s, o, a, u, h, N, I, Q, K, ue, de, Pe, Ze, Ae) {
				let ze = null,
					it = null,
					Et = new yl(),
					_t = n,
					ct = r,
					St = K[0] - Pe[0] - i,
					Je = -1073741824,
					Ve = this.m_forwardHistory.length - 1
				do {
					let Qt = St + t
					Qt === _t || (Qt < ct && h[Qt - 1] < h[Qt + 1])
						? ((I = h[Qt + 1]),
						  (ue = I - St - i),
						  I < Je && Et.MarkNextChange(),
						  (Je = I),
						  Et.AddModifiedElement(I + 1, ue),
						  (St = Qt + 1 - t))
						: ((I = h[Qt - 1] + 1),
						  (ue = I - St - i),
						  I < Je && Et.MarkNextChange(),
						  (Je = I - 1),
						  Et.AddOriginalElement(I, ue + 1),
						  (St = Qt - 1 - t)),
						Ve >= 0 && ((h = this.m_forwardHistory[Ve]), (t = h[0]), (_t = 1), (ct = h.length - 1))
				} while (--Ve >= -1)
				if (((ze = Et.getReverseChanges()), Ae[0])) {
					let Qt = K[0] + 1,
						qt = Pe[0] + 1
					if (ze !== null && ze.length > 0) {
						let Bt = ze[ze.length - 1]
						;(Qt = Math.max(Qt, Bt.getOriginalEnd())), (qt = Math.max(qt, Bt.getModifiedEnd()))
					}
					it = [new Ri(Qt, Q - Qt + 1, qt, de - qt + 1)]
				} else {
					;(Et = new yl()),
						(_t = o),
						(ct = a),
						(St = K[0] - Pe[0] - u),
						(Je = 1073741824),
						(Ve = Ze ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2)
					do {
						let Qt = St + s
						Qt === _t || (Qt < ct && N[Qt - 1] >= N[Qt + 1])
							? ((I = N[Qt + 1] - 1),
							  (ue = I - St - u),
							  I > Je && Et.MarkNextChange(),
							  (Je = I + 1),
							  Et.AddOriginalElement(I + 1, ue + 1),
							  (St = Qt + 1 - s))
							: ((I = N[Qt - 1]),
							  (ue = I - St - u),
							  I > Je && Et.MarkNextChange(),
							  (Je = I),
							  Et.AddModifiedElement(I + 1, ue + 1),
							  (St = Qt - 1 - s)),
							Ve >= 0 &&
								((N = this.m_reverseHistory[Ve]), (s = N[0]), (_t = 1), (ct = N.length - 1))
					} while (--Ve >= -1)
					it = Et.getChanges()
				}
				return this.ConcatenateChanges(ze, it)
			}
			ComputeRecursionPoint(t, n, r, i, s, o, a) {
				let u = 0,
					h = 0,
					N = 0,
					I = 0,
					Q = 0,
					K = 0
				t--, r--, (s[0] = 0), (o[0] = 0), (this.m_forwardHistory = []), (this.m_reverseHistory = [])
				let ue = n - t + (i - r),
					de = ue + 1,
					Pe = new Int32Array(de),
					Ze = new Int32Array(de),
					Ae = i - r,
					ze = n - t,
					it = t - r,
					Et = n - i,
					ct = (ze - Ae) % 2 === 0
				;(Pe[Ae] = t), (Ze[ze] = n), (a[0] = !1)
				for (let St = 1; St <= ue / 2 + 1; St++) {
					let Je = 0,
						Ve = 0
					;(N = this.ClipDiagonalBound(Ae - St, St, Ae, de)),
						(I = this.ClipDiagonalBound(Ae + St, St, Ae, de))
					for (let qt = N; qt <= I; qt += 2) {
						qt === N || (qt < I && Pe[qt - 1] < Pe[qt + 1])
							? (u = Pe[qt + 1])
							: (u = Pe[qt - 1] + 1),
							(h = u - (qt - Ae) - it)
						let Bt = u
						for (; u < n && h < i && this.ElementsAreEqual(u + 1, h + 1); ) u++, h++
						if (
							((Pe[qt] = u),
							u + h > Je + Ve && ((Je = u), (Ve = h)),
							!ct && Math.abs(qt - ze) <= St - 1 && u >= Ze[qt])
						)
							return (
								(s[0] = u),
								(o[0] = h),
								Bt <= Ze[qt] && 1447 > 0 && St <= 1447 + 1
									? this.WALKTRACE(Ae, N, I, it, ze, Q, K, Et, Pe, Ze, u, n, s, h, i, o, ct, a)
									: null
							)
					}
					let Qt = (Je - t + (Ve - r) - St) / 2
					if (
						this.ContinueProcessingPredicate !== null &&
						!this.ContinueProcessingPredicate(Je, Qt)
					)
						return (
							(a[0] = !0),
							(s[0] = Je),
							(o[0] = Ve),
							Qt > 0 && 1447 > 0 && St <= 1447 + 1
								? this.WALKTRACE(Ae, N, I, it, ze, Q, K, Et, Pe, Ze, u, n, s, h, i, o, ct, a)
								: (t++, r++, [new Ri(t, n - t + 1, r, i - r + 1)])
						)
					;(Q = this.ClipDiagonalBound(ze - St, St, ze, de)),
						(K = this.ClipDiagonalBound(ze + St, St, ze, de))
					for (let qt = Q; qt <= K; qt += 2) {
						qt === Q || (qt < K && Ze[qt - 1] >= Ze[qt + 1])
							? (u = Ze[qt + 1] - 1)
							: (u = Ze[qt - 1]),
							(h = u - (qt - ze) - Et)
						let Bt = u
						for (; u > t && h > r && this.ElementsAreEqual(u, h); ) u--, h--
						if (((Ze[qt] = u), ct && Math.abs(qt - Ae) <= St && u <= Pe[qt]))
							return (
								(s[0] = u),
								(o[0] = h),
								Bt >= Pe[qt] && 1447 > 0 && St <= 1447 + 1
									? this.WALKTRACE(Ae, N, I, it, ze, Q, K, Et, Pe, Ze, u, n, s, h, i, o, ct, a)
									: null
							)
					}
					if (St <= 1447) {
						let qt = new Int32Array(I - N + 2)
						;(qt[0] = Ae - N + 1),
							Ts.Copy2(Pe, N, qt, 1, I - N + 1),
							this.m_forwardHistory.push(qt),
							(qt = new Int32Array(K - Q + 2)),
							(qt[0] = ze - Q + 1),
							Ts.Copy2(Ze, Q, qt, 1, K - Q + 1),
							this.m_reverseHistory.push(qt)
					}
				}
				return this.WALKTRACE(Ae, N, I, it, ze, Q, K, Et, Pe, Ze, u, n, s, h, i, o, ct, a)
			}
			PrettifyChanges(t) {
				for (let n = 0; n < t.length; n++) {
					let r = t[n],
						i = n < t.length - 1 ? t[n + 1].originalStart : this._originalElementsOrHash.length,
						s = n < t.length - 1 ? t[n + 1].modifiedStart : this._modifiedElementsOrHash.length,
						o = r.originalLength > 0,
						a = r.modifiedLength > 0
					for (
						;
						r.originalStart + r.originalLength < i &&
						r.modifiedStart + r.modifiedLength < s &&
						(!o ||
							this.OriginalElementsAreEqual(r.originalStart, r.originalStart + r.originalLength)) &&
						(!a ||
							this.ModifiedElementsAreEqual(r.modifiedStart, r.modifiedStart + r.modifiedLength));

					) {
						let h = this.ElementsAreStrictEqual(r.originalStart, r.modifiedStart)
						if (
							this.ElementsAreStrictEqual(
								r.originalStart + r.originalLength,
								r.modifiedStart + r.modifiedLength
							) &&
							!h
						)
							break
						r.originalStart++, r.modifiedStart++
					}
					let u = [null]
					if (n < t.length - 1 && this.ChangesOverlap(t[n], t[n + 1], u)) {
						;(t[n] = u[0]), t.splice(n + 1, 1), n--
						continue
					}
				}
				for (let n = t.length - 1; n >= 0; n--) {
					let r = t[n],
						i = 0,
						s = 0
					if (n > 0) {
						let I = t[n - 1]
						;(i = I.originalStart + I.originalLength), (s = I.modifiedStart + I.modifiedLength)
					}
					let o = r.originalLength > 0,
						a = r.modifiedLength > 0,
						u = 0,
						h = this._boundaryScore(
							r.originalStart,
							r.originalLength,
							r.modifiedStart,
							r.modifiedLength
						)
					for (let I = 1; ; I++) {
						let Q = r.originalStart - I,
							K = r.modifiedStart - I
						if (
							Q < i ||
							K < s ||
							(o && !this.OriginalElementsAreEqual(Q, Q + r.originalLength)) ||
							(a && !this.ModifiedElementsAreEqual(K, K + r.modifiedLength))
						)
							break
						let de =
							(Q === i && K === s ? 5 : 0) +
							this._boundaryScore(Q, r.originalLength, K, r.modifiedLength)
						de > h && ((h = de), (u = I))
					}
					;(r.originalStart -= u), (r.modifiedStart -= u)
					let N = [null]
					if (n > 0 && this.ChangesOverlap(t[n - 1], t[n], N)) {
						;(t[n - 1] = N[0]), t.splice(n, 1), n++
						continue
					}
				}
				if (this._hasStrings)
					for (let n = 1, r = t.length; n < r; n++) {
						let i = t[n - 1],
							s = t[n],
							o = s.originalStart - i.originalStart - i.originalLength,
							a = i.originalStart,
							u = s.originalStart + s.originalLength,
							h = u - a,
							N = i.modifiedStart,
							I = s.modifiedStart + s.modifiedLength,
							Q = I - N
						if (o < 5 && h < 20 && Q < 20) {
							let K = this._findBetterContiguousSequence(a, h, N, Q, o)
							if (K) {
								let [ue, de] = K
								;(ue !== i.originalStart + i.originalLength ||
									de !== i.modifiedStart + i.modifiedLength) &&
									((i.originalLength = ue - i.originalStart),
									(i.modifiedLength = de - i.modifiedStart),
									(s.originalStart = ue + o),
									(s.modifiedStart = de + o),
									(s.originalLength = u - s.originalStart),
									(s.modifiedLength = I - s.modifiedStart))
							}
						}
					}
				return t
			}
			_findBetterContiguousSequence(t, n, r, i, s) {
				if (n < s || i < s) return null
				let o = t + n - s + 1,
					a = r + i - s + 1,
					u = 0,
					h = 0,
					N = 0
				for (let I = t; I < o; I++)
					for (let Q = r; Q < a; Q++) {
						let K = this._contiguousSequenceScore(I, Q, s)
						K > 0 && K > u && ((u = K), (h = I), (N = Q))
					}
				return u > 0 ? [h, N] : null
			}
			_contiguousSequenceScore(t, n, r) {
				let i = 0
				for (let s = 0; s < r; s++) {
					if (!this.ElementsAreEqual(t + s, n + s)) return 0
					i += this._originalStringElements[t + s].length
				}
				return i
			}
			_OriginalIsBoundary(t) {
				return t <= 0 || t >= this._originalElementsOrHash.length - 1
					? !0
					: this._hasStrings && /^\s*$/.test(this._originalStringElements[t])
			}
			_OriginalRegionIsBoundary(t, n) {
				if (this._OriginalIsBoundary(t) || this._OriginalIsBoundary(t - 1)) return !0
				if (n > 0) {
					let r = t + n
					if (this._OriginalIsBoundary(r - 1) || this._OriginalIsBoundary(r)) return !0
				}
				return !1
			}
			_ModifiedIsBoundary(t) {
				return t <= 0 || t >= this._modifiedElementsOrHash.length - 1
					? !0
					: this._hasStrings && /^\s*$/.test(this._modifiedStringElements[t])
			}
			_ModifiedRegionIsBoundary(t, n) {
				if (this._ModifiedIsBoundary(t) || this._ModifiedIsBoundary(t - 1)) return !0
				if (n > 0) {
					let r = t + n
					if (this._ModifiedIsBoundary(r - 1) || this._ModifiedIsBoundary(r)) return !0
				}
				return !1
			}
			_boundaryScore(t, n, r, i) {
				let s = this._OriginalRegionIsBoundary(t, n) ? 1 : 0,
					o = this._ModifiedRegionIsBoundary(r, i) ? 1 : 0
				return s + o
			}
			ConcatenateChanges(t, n) {
				let r = []
				if (t.length === 0 || n.length === 0) return n.length > 0 ? n : t
				if (this.ChangesOverlap(t[t.length - 1], n[0], r)) {
					let i = new Array(t.length + n.length - 1)
					return (
						Ts.Copy(t, 0, i, 0, t.length - 1),
						(i[t.length - 1] = r[0]),
						Ts.Copy(n, 1, i, t.length, n.length - 1),
						i
					)
				} else {
					let i = new Array(t.length + n.length)
					return Ts.Copy(t, 0, i, 0, t.length), Ts.Copy(n, 0, i, t.length, n.length), i
				}
			}
			ChangesOverlap(t, n, r) {
				if (
					(bs.Assert(
						t.originalStart <= n.originalStart,
						'Left change is not less than or equal to right change'
					),
					bs.Assert(
						t.modifiedStart <= n.modifiedStart,
						'Left change is not less than or equal to right change'
					),
					t.originalStart + t.originalLength >= n.originalStart ||
						t.modifiedStart + t.modifiedLength >= n.modifiedStart)
				) {
					let i = t.originalStart,
						s = t.originalLength,
						o = t.modifiedStart,
						a = t.modifiedLength
					return (
						t.originalStart + t.originalLength >= n.originalStart &&
							(s = n.originalStart + n.originalLength - t.originalStart),
						t.modifiedStart + t.modifiedLength >= n.modifiedStart &&
							(a = n.modifiedStart + n.modifiedLength - t.modifiedStart),
						(r[0] = new Ri(i, s, o, a)),
						!0
					)
				} else return (r[0] = null), !1
			}
			ClipDiagonalBound(t, n, r, i) {
				if (t >= 0 && t < i) return t
				let s = r,
					o = i - r - 1,
					a = n % 2 === 0
				if (t < 0) {
					let u = s % 2 === 0
					return a === u ? 0 : 1
				} else {
					let u = o % 2 === 0
					return a === u ? i - 1 : i - 2
				}
			}
		}
	var Js
	if (typeof wi.vscode < 'u' && typeof wi.vscode.process < 'u') {
		let e = wi.vscode.process
		Js = {
			get platform() {
				return e.platform
			},
			get arch() {
				return e.arch
			},
			get env() {
				return e.env
			},
			cwd() {
				return e.cwd()
			}
		}
	} else
		typeof process < 'u'
			? (Js = {
					get platform() {
						return process.platform
					},
					get arch() {
						return process.arch
					},
					get env() {
						return process.env
					},
					cwd() {
						return process.env.VSCODE_CWD || process.cwd()
					}
			  })
			: (Js = {
					get platform() {
						return Ws ? 'win32' : k0 ? 'darwin' : 'linux'
					},
					get arch() {},
					get env() {
						return {}
					},
					cwd() {
						return '/'
					}
			  })
	var Ya = Js.cwd,
		J0 = Js.env,
		z0 = Js.platform,
		H7 = Js.arch
	var av = 65,
		uv = 97,
		lv = 90,
		cv = 122,
		Ss = 46,
		Gr = 47,
		ui = 92,
		As = 58,
		pv = 63,
		El = class extends Error {
			constructor(t, n, r) {
				let i
				typeof n == 'string' && n.indexOf('not ') === 0
					? ((i = 'must not be'), (n = n.replace(/^not /, '')))
					: (i = 'must be')
				let s = t.indexOf('.') !== -1 ? 'property' : 'argument',
					o = `The "${t}" ${s} ${i} of type ${n}`
				;(o += `. Received type ${typeof r}`), super(o), (this.code = 'ERR_INVALID_ARG_TYPE')
			}
		}
	function fv(e, t) {
		if (e === null || typeof e != 'object') throw new El(t, 'Object', e)
	}
	function Tr(e, t) {
		if (typeof e != 'string') throw new El(t, 'string', e)
	}
	var li = z0 === 'win32'
	function jn(e) {
		return e === Gr || e === ui
	}
	function Yp(e) {
		return e === Gr
	}
	function Cs(e) {
		return (e >= av && e <= lv) || (e >= uv && e <= cv)
	}
	function vl(e, t, n, r) {
		let i = '',
			s = 0,
			o = -1,
			a = 0,
			u = 0
		for (let h = 0; h <= e.length; ++h) {
			if (h < e.length) u = e.charCodeAt(h)
			else {
				if (r(u)) break
				u = Gr
			}
			if (r(u)) {
				if (!(o === h - 1 || a === 1))
					if (a === 2) {
						if (
							i.length < 2 ||
							s !== 2 ||
							i.charCodeAt(i.length - 1) !== Ss ||
							i.charCodeAt(i.length - 2) !== Ss
						) {
							if (i.length > 2) {
								let N = i.lastIndexOf(n)
								N === -1
									? ((i = ''), (s = 0))
									: ((i = i.slice(0, N)), (s = i.length - 1 - i.lastIndexOf(n))),
									(o = h),
									(a = 0)
								continue
							} else if (i.length !== 0) {
								;(i = ''), (s = 0), (o = h), (a = 0)
								continue
							}
						}
						t && ((i += i.length > 0 ? `${n}..` : '..'), (s = 2))
					} else
						i.length > 0 ? (i += `${n}${e.slice(o + 1, h)}`) : (i = e.slice(o + 1, h)),
							(s = h - o - 1)
				;(o = h), (a = 0)
			} else u === Ss && a !== -1 ? ++a : (a = -1)
		}
		return i
	}
	function Q0(e, t) {
		fv(t, 'pathObject')
		let n = t.dir || t.root,
			r = t.base || `${t.name || ''}${t.ext || ''}`
		return n ? (n === t.root ? `${n}${r}` : `${n}${e}${r}`) : r
	}
	var Ar = {
			resolve(...e) {
				let t = '',
					n = '',
					r = !1
				for (let i = e.length - 1; i >= -1; i--) {
					let s
					if (i >= 0) {
						if (((s = e[i]), Tr(s, 'path'), s.length === 0)) continue
					} else
						t.length === 0
							? (s = Ya())
							: ((s = J0[`=${t}`] || Ya()),
							  (s === void 0 ||
									(s.slice(0, 2).toLowerCase() !== t.toLowerCase() && s.charCodeAt(2) === ui)) &&
									(s = `${t}\\`))
					let o = s.length,
						a = 0,
						u = '',
						h = !1,
						N = s.charCodeAt(0)
					if (o === 1) jn(N) && ((a = 1), (h = !0))
					else if (jn(N))
						if (((h = !0), jn(s.charCodeAt(1)))) {
							let I = 2,
								Q = I
							for (; I < o && !jn(s.charCodeAt(I)); ) I++
							if (I < o && I !== Q) {
								let K = s.slice(Q, I)
								for (Q = I; I < o && jn(s.charCodeAt(I)); ) I++
								if (I < o && I !== Q) {
									for (Q = I; I < o && !jn(s.charCodeAt(I)); ) I++
									;(I === o || I !== Q) && ((u = `\\\\${K}\\${s.slice(Q, I)}`), (a = I))
								}
							}
						} else a = 1
					else
						Cs(N) &&
							s.charCodeAt(1) === As &&
							((u = s.slice(0, 2)), (a = 2), o > 2 && jn(s.charCodeAt(2)) && ((h = !0), (a = 3)))
					if (u.length > 0)
						if (t.length > 0) {
							if (u.toLowerCase() !== t.toLowerCase()) continue
						} else t = u
					if (r) {
						if (t.length > 0) break
					} else if (((n = `${s.slice(a)}\\${n}`), (r = h), h && t.length > 0)) break
				}
				return (n = vl(n, !r, '\\', jn)), r ? `${t}\\${n}` : `${t}${n}` || '.'
			},
			normalize(e) {
				Tr(e, 'path')
				let t = e.length
				if (t === 0) return '.'
				let n = 0,
					r,
					i = !1,
					s = e.charCodeAt(0)
				if (t === 1) return Yp(s) ? '\\' : e
				if (jn(s))
					if (((i = !0), jn(e.charCodeAt(1)))) {
						let a = 2,
							u = a
						for (; a < t && !jn(e.charCodeAt(a)); ) a++
						if (a < t && a !== u) {
							let h = e.slice(u, a)
							for (u = a; a < t && jn(e.charCodeAt(a)); ) a++
							if (a < t && a !== u) {
								for (u = a; a < t && !jn(e.charCodeAt(a)); ) a++
								if (a === t) return `\\\\${h}\\${e.slice(u)}\\`
								a !== u && ((r = `\\\\${h}\\${e.slice(u, a)}`), (n = a))
							}
						}
					} else n = 1
				else
					Cs(s) &&
						e.charCodeAt(1) === As &&
						((r = e.slice(0, 2)), (n = 2), t > 2 && jn(e.charCodeAt(2)) && ((i = !0), (n = 3)))
				let o = n < t ? vl(e.slice(n), !i, '\\', jn) : ''
				return (
					o.length === 0 && !i && (o = '.'),
					o.length > 0 && jn(e.charCodeAt(t - 1)) && (o += '\\'),
					r === void 0 ? (i ? `\\${o}` : o) : i ? `${r}\\${o}` : `${r}${o}`
				)
			},
			isAbsolute(e) {
				Tr(e, 'path')
				let t = e.length
				if (t === 0) return !1
				let n = e.charCodeAt(0)
				return jn(n) || (t > 2 && Cs(n) && e.charCodeAt(1) === As && jn(e.charCodeAt(2)))
			},
			join(...e) {
				if (e.length === 0) return '.'
				let t, n
				for (let s = 0; s < e.length; ++s) {
					let o = e[s]
					Tr(o, 'path'), o.length > 0 && (t === void 0 ? (t = n = o) : (t += `\\${o}`))
				}
				if (t === void 0) return '.'
				let r = !0,
					i = 0
				if (typeof n == 'string' && jn(n.charCodeAt(0))) {
					++i
					let s = n.length
					s > 1 && jn(n.charCodeAt(1)) && (++i, s > 2 && (jn(n.charCodeAt(2)) ? ++i : (r = !1)))
				}
				if (r) {
					for (; i < t.length && jn(t.charCodeAt(i)); ) i++
					i >= 2 && (t = `\\${t.slice(i)}`)
				}
				return Ar.normalize(t)
			},
			relative(e, t) {
				if ((Tr(e, 'from'), Tr(t, 'to'), e === t)) return ''
				let n = Ar.resolve(e),
					r = Ar.resolve(t)
				if (n === r || ((e = n.toLowerCase()), (t = r.toLowerCase()), e === t)) return ''
				let i = 0
				for (; i < e.length && e.charCodeAt(i) === ui; ) i++
				let s = e.length
				for (; s - 1 > i && e.charCodeAt(s - 1) === ui; ) s--
				let o = s - i,
					a = 0
				for (; a < t.length && t.charCodeAt(a) === ui; ) a++
				let u = t.length
				for (; u - 1 > a && t.charCodeAt(u - 1) === ui; ) u--
				let h = u - a,
					N = o < h ? o : h,
					I = -1,
					Q = 0
				for (; Q < N; Q++) {
					let ue = e.charCodeAt(i + Q)
					if (ue !== t.charCodeAt(a + Q)) break
					ue === ui && (I = Q)
				}
				if (Q !== N) {
					if (I === -1) return r
				} else {
					if (h > N) {
						if (t.charCodeAt(a + Q) === ui) return r.slice(a + Q + 1)
						if (Q === 2) return r.slice(a + Q)
					}
					o > N && (e.charCodeAt(i + Q) === ui ? (I = Q) : Q === 2 && (I = 3)), I === -1 && (I = 0)
				}
				let K = ''
				for (Q = i + I + 1; Q <= s; ++Q)
					(Q === s || e.charCodeAt(Q) === ui) && (K += K.length === 0 ? '..' : '\\..')
				return (
					(a += I),
					K.length > 0 ? `${K}${r.slice(a, u)}` : (r.charCodeAt(a) === ui && ++a, r.slice(a, u))
				)
			},
			toNamespacedPath(e) {
				if (typeof e != 'string' || e.length === 0) return e
				let t = Ar.resolve(e)
				if (t.length <= 2) return e
				if (t.charCodeAt(0) === ui) {
					if (t.charCodeAt(1) === ui) {
						let n = t.charCodeAt(2)
						if (n !== pv && n !== Ss) return `\\\\?\\UNC\\${t.slice(2)}`
					}
				} else if (Cs(t.charCodeAt(0)) && t.charCodeAt(1) === As && t.charCodeAt(2) === ui)
					return `\\\\?\\${t}`
				return e
			},
			dirname(e) {
				Tr(e, 'path')
				let t = e.length
				if (t === 0) return '.'
				let n = -1,
					r = 0,
					i = e.charCodeAt(0)
				if (t === 1) return jn(i) ? e : '.'
				if (jn(i)) {
					if (((n = r = 1), jn(e.charCodeAt(1)))) {
						let a = 2,
							u = a
						for (; a < t && !jn(e.charCodeAt(a)); ) a++
						if (a < t && a !== u) {
							for (u = a; a < t && jn(e.charCodeAt(a)); ) a++
							if (a < t && a !== u) {
								for (u = a; a < t && !jn(e.charCodeAt(a)); ) a++
								if (a === t) return e
								a !== u && (n = r = a + 1)
							}
						}
					}
				} else
					Cs(i) && e.charCodeAt(1) === As && ((n = t > 2 && jn(e.charCodeAt(2)) ? 3 : 2), (r = n))
				let s = -1,
					o = !0
				for (let a = t - 1; a >= r; --a)
					if (jn(e.charCodeAt(a))) {
						if (!o) {
							s = a
							break
						}
					} else o = !1
				if (s === -1) {
					if (n === -1) return '.'
					s = n
				}
				return e.slice(0, s)
			},
			basename(e, t) {
				t !== void 0 && Tr(t, 'ext'), Tr(e, 'path')
				let n = 0,
					r = -1,
					i = !0,
					s
				if (
					(e.length >= 2 && Cs(e.charCodeAt(0)) && e.charCodeAt(1) === As && (n = 2),
					t !== void 0 && t.length > 0 && t.length <= e.length)
				) {
					if (t === e) return ''
					let o = t.length - 1,
						a = -1
					for (s = e.length - 1; s >= n; --s) {
						let u = e.charCodeAt(s)
						if (jn(u)) {
							if (!i) {
								n = s + 1
								break
							}
						} else
							a === -1 && ((i = !1), (a = s + 1)),
								o >= 0 && (u === t.charCodeAt(o) ? --o === -1 && (r = s) : ((o = -1), (r = a)))
					}
					return n === r ? (r = a) : r === -1 && (r = e.length), e.slice(n, r)
				}
				for (s = e.length - 1; s >= n; --s)
					if (jn(e.charCodeAt(s))) {
						if (!i) {
							n = s + 1
							break
						}
					} else r === -1 && ((i = !1), (r = s + 1))
				return r === -1 ? '' : e.slice(n, r)
			},
			extname(e) {
				Tr(e, 'path')
				let t = 0,
					n = -1,
					r = 0,
					i = -1,
					s = !0,
					o = 0
				e.length >= 2 && e.charCodeAt(1) === As && Cs(e.charCodeAt(0)) && (t = r = 2)
				for (let a = e.length - 1; a >= t; --a) {
					let u = e.charCodeAt(a)
					if (jn(u)) {
						if (!s) {
							r = a + 1
							break
						}
						continue
					}
					i === -1 && ((s = !1), (i = a + 1)),
						u === Ss ? (n === -1 ? (n = a) : o !== 1 && (o = 1)) : n !== -1 && (o = -1)
				}
				return n === -1 || i === -1 || o === 0 || (o === 1 && n === i - 1 && n === r + 1)
					? ''
					: e.slice(n, i)
			},
			format: Q0.bind(null, '\\'),
			parse(e) {
				Tr(e, 'path')
				let t = { root: '', dir: '', base: '', ext: '', name: '' }
				if (e.length === 0) return t
				let n = e.length,
					r = 0,
					i = e.charCodeAt(0)
				if (n === 1) return jn(i) ? ((t.root = t.dir = e), t) : ((t.base = t.name = e), t)
				if (jn(i)) {
					if (((r = 1), jn(e.charCodeAt(1)))) {
						let I = 2,
							Q = I
						for (; I < n && !jn(e.charCodeAt(I)); ) I++
						if (I < n && I !== Q) {
							for (Q = I; I < n && jn(e.charCodeAt(I)); ) I++
							if (I < n && I !== Q) {
								for (Q = I; I < n && !jn(e.charCodeAt(I)); ) I++
								I === n ? (r = I) : I !== Q && (r = I + 1)
							}
						}
					}
				} else if (Cs(i) && e.charCodeAt(1) === As) {
					if (n <= 2) return (t.root = t.dir = e), t
					if (((r = 2), jn(e.charCodeAt(2)))) {
						if (n === 3) return (t.root = t.dir = e), t
						r = 3
					}
				}
				r > 0 && (t.root = e.slice(0, r))
				let s = -1,
					o = r,
					a = -1,
					u = !0,
					h = e.length - 1,
					N = 0
				for (; h >= r; --h) {
					if (((i = e.charCodeAt(h)), jn(i))) {
						if (!u) {
							o = h + 1
							break
						}
						continue
					}
					a === -1 && ((u = !1), (a = h + 1)),
						i === Ss ? (s === -1 ? (s = h) : N !== 1 && (N = 1)) : s !== -1 && (N = -1)
				}
				return (
					a !== -1 &&
						(s === -1 || N === 0 || (N === 1 && s === a - 1 && s === o + 1)
							? (t.base = t.name = e.slice(o, a))
							: ((t.name = e.slice(o, s)), (t.base = e.slice(o, a)), (t.ext = e.slice(s, a)))),
					o > 0 && o !== r ? (t.dir = e.slice(0, o - 1)) : (t.dir = t.root),
					t
				)
			},
			sep: '\\',
			delimiter: ';',
			win32: null,
			posix: null
		},
		dv = (() => {
			if (li) {
				let e = /\\/g
				return () => {
					let t = Ya().replace(e, '/')
					return t.slice(t.indexOf('/'))
				}
			}
			return () => Ya()
		})(),
		Fr = {
			resolve(...e) {
				let t = '',
					n = !1
				for (let r = e.length - 1; r >= -1 && !n; r--) {
					let i = r >= 0 ? e[r] : dv()
					Tr(i, 'path'), i.length !== 0 && ((t = `${i}/${t}`), (n = i.charCodeAt(0) === Gr))
				}
				return (t = vl(t, !n, '/', Yp)), n ? `/${t}` : t.length > 0 ? t : '.'
			},
			normalize(e) {
				if ((Tr(e, 'path'), e.length === 0)) return '.'
				let t = e.charCodeAt(0) === Gr,
					n = e.charCodeAt(e.length - 1) === Gr
				return (
					(e = vl(e, !t, '/', Yp)),
					e.length === 0 ? (t ? '/' : n ? './' : '.') : (n && (e += '/'), t ? `/${e}` : e)
				)
			},
			isAbsolute(e) {
				return Tr(e, 'path'), e.length > 0 && e.charCodeAt(0) === Gr
			},
			join(...e) {
				if (e.length === 0) return '.'
				let t
				for (let n = 0; n < e.length; ++n) {
					let r = e[n]
					Tr(r, 'path'), r.length > 0 && (t === void 0 ? (t = r) : (t += `/${r}`))
				}
				return t === void 0 ? '.' : Fr.normalize(t)
			},
			relative(e, t) {
				if (
					(Tr(e, 'from'),
					Tr(t, 'to'),
					e === t || ((e = Fr.resolve(e)), (t = Fr.resolve(t)), e === t))
				)
					return ''
				let n = 1,
					r = e.length,
					i = r - n,
					s = 1,
					o = t.length - s,
					a = i < o ? i : o,
					u = -1,
					h = 0
				for (; h < a; h++) {
					let I = e.charCodeAt(n + h)
					if (I !== t.charCodeAt(s + h)) break
					I === Gr && (u = h)
				}
				if (h === a)
					if (o > a) {
						if (t.charCodeAt(s + h) === Gr) return t.slice(s + h + 1)
						if (h === 0) return t.slice(s + h)
					} else i > a && (e.charCodeAt(n + h) === Gr ? (u = h) : h === 0 && (u = 0))
				let N = ''
				for (h = n + u + 1; h <= r; ++h)
					(h === r || e.charCodeAt(h) === Gr) && (N += N.length === 0 ? '..' : '/..')
				return `${N}${t.slice(s + u)}`
			},
			toNamespacedPath(e) {
				return e
			},
			dirname(e) {
				if ((Tr(e, 'path'), e.length === 0)) return '.'
				let t = e.charCodeAt(0) === Gr,
					n = -1,
					r = !0
				for (let i = e.length - 1; i >= 1; --i)
					if (e.charCodeAt(i) === Gr) {
						if (!r) {
							n = i
							break
						}
					} else r = !1
				return n === -1 ? (t ? '/' : '.') : t && n === 1 ? '//' : e.slice(0, n)
			},
			basename(e, t) {
				t !== void 0 && Tr(t, 'ext'), Tr(e, 'path')
				let n = 0,
					r = -1,
					i = !0,
					s
				if (t !== void 0 && t.length > 0 && t.length <= e.length) {
					if (t === e) return ''
					let o = t.length - 1,
						a = -1
					for (s = e.length - 1; s >= 0; --s) {
						let u = e.charCodeAt(s)
						if (u === Gr) {
							if (!i) {
								n = s + 1
								break
							}
						} else
							a === -1 && ((i = !1), (a = s + 1)),
								o >= 0 && (u === t.charCodeAt(o) ? --o === -1 && (r = s) : ((o = -1), (r = a)))
					}
					return n === r ? (r = a) : r === -1 && (r = e.length), e.slice(n, r)
				}
				for (s = e.length - 1; s >= 0; --s)
					if (e.charCodeAt(s) === Gr) {
						if (!i) {
							n = s + 1
							break
						}
					} else r === -1 && ((i = !1), (r = s + 1))
				return r === -1 ? '' : e.slice(n, r)
			},
			extname(e) {
				Tr(e, 'path')
				let t = -1,
					n = 0,
					r = -1,
					i = !0,
					s = 0
				for (let o = e.length - 1; o >= 0; --o) {
					let a = e.charCodeAt(o)
					if (a === Gr) {
						if (!i) {
							n = o + 1
							break
						}
						continue
					}
					r === -1 && ((i = !1), (r = o + 1)),
						a === Ss ? (t === -1 ? (t = o) : s !== 1 && (s = 1)) : t !== -1 && (s = -1)
				}
				return t === -1 || r === -1 || s === 0 || (s === 1 && t === r - 1 && t === n + 1)
					? ''
					: e.slice(t, r)
			},
			format: Q0.bind(null, '/'),
			parse(e) {
				Tr(e, 'path')
				let t = { root: '', dir: '', base: '', ext: '', name: '' }
				if (e.length === 0) return t
				let n = e.charCodeAt(0) === Gr,
					r
				n ? ((t.root = '/'), (r = 1)) : (r = 0)
				let i = -1,
					s = 0,
					o = -1,
					a = !0,
					u = e.length - 1,
					h = 0
				for (; u >= r; --u) {
					let N = e.charCodeAt(u)
					if (N === Gr) {
						if (!a) {
							s = u + 1
							break
						}
						continue
					}
					o === -1 && ((a = !1), (o = u + 1)),
						N === Ss ? (i === -1 ? (i = u) : h !== 1 && (h = 1)) : i !== -1 && (h = -1)
				}
				if (o !== -1) {
					let N = s === 0 && n ? 1 : s
					i === -1 || h === 0 || (h === 1 && i === o - 1 && i === s + 1)
						? (t.base = t.name = e.slice(N, o))
						: ((t.name = e.slice(N, i)), (t.base = e.slice(N, o)), (t.ext = e.slice(i, o)))
				}
				return s > 0 ? (t.dir = e.slice(0, s - 1)) : n && (t.dir = '/'), t
			},
			sep: '/',
			delimiter: ':',
			win32: null,
			posix: null
		}
	Fr.win32 = Ar.win32 = Ar
	Fr.posix = Ar.posix = Fr
	var J7 = li ? Ar.normalize : Fr.normalize,
		z7 = li ? Ar.isAbsolute : Fr.isAbsolute,
		Q7 = li ? Ar.join : Fr.join,
		Y7 = li ? Ar.resolve : Fr.resolve,
		X7 = li ? Ar.relative : Fr.relative,
		K7 = li ? Ar.dirname : Fr.dirname,
		Z7 = li ? Ar.basename : Fr.basename,
		e8 = li ? Ar.extname : Fr.extname,
		t8 = li ? Ar.format : Fr.format,
		n8 = li ? Ar.parse : Fr.parse,
		r8 = li ? Ar.toNamespacedPath : Fr.toNamespacedPath,
		i8 = li ? Ar.sep : Fr.sep,
		s8 = li ? Ar.delimiter : Fr.delimiter
	var mv = /^\w[\w\d+.-]*$/,
		gv = /^\//,
		Dv = /^\/\//
	function yv(e, t) {
		if (!e.scheme && t)
			throw new Error(
				`[UriError]: Scheme is missing: {scheme: "", authority: "${e.authority}", path: "${e.path}", query: "${e.query}", fragment: "${e.fragment}"}`
			)
		if (e.scheme && !mv.test(e.scheme))
			throw new Error('[UriError]: Scheme contains illegal characters.')
		if (e.path) {
			if (e.authority) {
				if (!gv.test(e.path))
					throw new Error(
						'[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character'
					)
			} else if (Dv.test(e.path))
				throw new Error(
					'[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")'
				)
		}
	}
	function Ev(e, t) {
		return !e && !t ? 'file' : e
	}
	function vv(e, t) {
		switch (e) {
			case 'https':
			case 'http':
			case 'file':
				t ? t[0] !== Oi && (t = Oi + t) : (t = Oi)
				break
		}
		return t
	}
	var lr = '',
		Oi = '/',
		xv = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/,
		Fs = class e {
			static isUri(t) {
				return t instanceof e
					? !0
					: t
					? typeof t.authority == 'string' &&
					  typeof t.fragment == 'string' &&
					  typeof t.path == 'string' &&
					  typeof t.query == 'string' &&
					  typeof t.scheme == 'string' &&
					  typeof t.fsPath == 'string' &&
					  typeof t.with == 'function' &&
					  typeof t.toString == 'function'
					: !1
			}
			constructor(t, n, r, i, s, o = !1) {
				typeof t == 'object'
					? ((this.scheme = t.scheme || lr),
					  (this.authority = t.authority || lr),
					  (this.path = t.path || lr),
					  (this.query = t.query || lr),
					  (this.fragment = t.fragment || lr))
					: ((this.scheme = Ev(t, o)),
					  (this.authority = n || lr),
					  (this.path = vv(this.scheme, r || lr)),
					  (this.query = i || lr),
					  (this.fragment = s || lr),
					  yv(this, o))
			}
			get fsPath() {
				return Xp(this, !1)
			}
			with(t) {
				if (!t) return this
				let { scheme: n, authority: r, path: i, query: s, fragment: o } = t
				return (
					n === void 0 ? (n = this.scheme) : n === null && (n = lr),
					r === void 0 ? (r = this.authority) : r === null && (r = lr),
					i === void 0 ? (i = this.path) : i === null && (i = lr),
					s === void 0 ? (s = this.query) : s === null && (s = lr),
					o === void 0 ? (o = this.fragment) : o === null && (o = lr),
					n === this.scheme &&
					r === this.authority &&
					i === this.path &&
					s === this.query &&
					o === this.fragment
						? this
						: new Ns(n, r, i, s, o)
				)
			}
			static parse(t, n = !1) {
				let r = xv.exec(t)
				return r
					? new Ns(r[2] || lr, xl(r[4] || lr), xl(r[5] || lr), xl(r[7] || lr), xl(r[9] || lr), n)
					: new Ns(lr, lr, lr, lr, lr)
			}
			static file(t) {
				let n = lr
				if ((Ws && (t = t.replace(/\\/g, Oi)), t[0] === Oi && t[1] === Oi)) {
					let r = t.indexOf(Oi, 2)
					r === -1
						? ((n = t.substring(2)), (t = Oi))
						: ((n = t.substring(2, r)), (t = t.substring(r) || Oi))
				}
				return new Ns('file', n, t, lr, lr)
			}
			static from(t, n) {
				return new Ns(t.scheme, t.authority, t.path, t.query, t.fragment, n)
			}
			static joinPath(t, ...n) {
				if (!t.path) throw new Error('[UriError]: cannot call joinPath on URI without path')
				let r
				return (
					Ws && t.scheme === 'file'
						? (r = e.file(Ar.join(Xp(t, !0), ...n)).path)
						: (r = Fr.join(t.path, ...n)),
					t.with({ path: r })
				)
			}
			toString(t = !1) {
				return Kp(this, t)
			}
			toJSON() {
				return this
			}
			static revive(t) {
				if (t) {
					if (t instanceof e) return t
					{
						let n = new Ns(t)
						return (
							(n._formatted = t.external ?? null),
							(n._fsPath = t._sep === K0 ? t.fsPath ?? null : null),
							n
						)
					}
				} else return t
			}
		}
	var K0 = Ws ? 1 : void 0,
		Ns = class extends Fs {
			constructor() {
				super(...arguments), (this._formatted = null), (this._fsPath = null)
			}
			get fsPath() {
				return this._fsPath || (this._fsPath = Xp(this, !1)), this._fsPath
			}
			toString(t = !1) {
				return t
					? Kp(this, !0)
					: (this._formatted || (this._formatted = Kp(this, !1)), this._formatted)
			}
			toJSON() {
				let t = { $mid: 1 }
				return (
					this._fsPath && ((t.fsPath = this._fsPath), (t._sep = K0)),
					this._formatted && (t.external = this._formatted),
					this.path && (t.path = this.path),
					this.scheme && (t.scheme = this.scheme),
					this.authority && (t.authority = this.authority),
					this.query && (t.query = this.query),
					this.fragment && (t.fragment = this.fragment),
					t
				)
			}
		},
		Z0 = {
			58: '%3A',
			47: '%2F',
			63: '%3F',
			35: '%23',
			91: '%5B',
			93: '%5D',
			64: '%40',
			33: '%21',
			36: '%24',
			38: '%26',
			39: '%27',
			40: '%28',
			41: '%29',
			42: '%2A',
			43: '%2B',
			44: '%2C',
			59: '%3B',
			61: '%3D',
			32: '%20'
		}
	function Y0(e, t, n) {
		let r,
			i = -1
		for (let s = 0; s < e.length; s++) {
			let o = e.charCodeAt(s)
			if (
				(o >= 97 && o <= 122) ||
				(o >= 65 && o <= 90) ||
				(o >= 48 && o <= 57) ||
				o === 45 ||
				o === 46 ||
				o === 95 ||
				o === 126 ||
				(t && o === 47) ||
				(n && o === 91) ||
				(n && o === 93) ||
				(n && o === 58)
			)
				i !== -1 && ((r += encodeURIComponent(e.substring(i, s))), (i = -1)),
					r !== void 0 && (r += e.charAt(s))
			else {
				r === void 0 && (r = e.substr(0, s))
				let a = Z0[o]
				a !== void 0
					? (i !== -1 && ((r += encodeURIComponent(e.substring(i, s))), (i = -1)), (r += a))
					: i === -1 && (i = s)
			}
		}
		return i !== -1 && (r += encodeURIComponent(e.substring(i))), r !== void 0 ? r : e
	}
	function bv(e) {
		let t
		for (let n = 0; n < e.length; n++) {
			let r = e.charCodeAt(n)
			r === 35 || r === 63
				? (t === void 0 && (t = e.substr(0, n)), (t += Z0[r]))
				: t !== void 0 && (t += e[n])
		}
		return t !== void 0 ? t : e
	}
	function Xp(e, t) {
		let n
		return (
			e.authority && e.path.length > 1 && e.scheme === 'file'
				? (n = `//${e.authority}${e.path}`)
				: e.path.charCodeAt(0) === 47 &&
				  ((e.path.charCodeAt(1) >= 65 && e.path.charCodeAt(1) <= 90) ||
						(e.path.charCodeAt(1) >= 97 && e.path.charCodeAt(1) <= 122)) &&
				  e.path.charCodeAt(2) === 58
				? t
					? (n = e.path.substr(1))
					: (n = e.path[1].toLowerCase() + e.path.substr(2))
				: (n = e.path),
			Ws && (n = n.replace(/\//g, '\\')),
			n
		)
	}
	function Kp(e, t) {
		let n = t ? bv : Y0,
			r = '',
			{ scheme: i, authority: s, path: o, query: a, fragment: u } = e
		if ((i && ((r += i), (r += ':')), (s || i === 'file') && ((r += Oi), (r += Oi)), s)) {
			let h = s.indexOf('@')
			if (h !== -1) {
				let N = s.substr(0, h)
				;(s = s.substr(h + 1)),
					(h = N.lastIndexOf(':')),
					h === -1
						? (r += n(N, !1, !1))
						: ((r += n(N.substr(0, h), !1, !1)), (r += ':'), (r += n(N.substr(h + 1), !1, !0))),
					(r += '@')
			}
			;(s = s.toLowerCase()),
				(h = s.lastIndexOf(':')),
				h === -1 ? (r += n(s, !1, !0)) : ((r += n(s.substr(0, h), !1, !0)), (r += s.substr(h)))
		}
		if (o) {
			if (o.length >= 3 && o.charCodeAt(0) === 47 && o.charCodeAt(2) === 58) {
				let h = o.charCodeAt(1)
				h >= 65 && h <= 90 && (o = `/${String.fromCharCode(h + 32)}:${o.substr(3)}`)
			} else if (o.length >= 2 && o.charCodeAt(1) === 58) {
				let h = o.charCodeAt(0)
				h >= 65 && h <= 90 && (o = `${String.fromCharCode(h + 32)}:${o.substr(2)}`)
			}
			r += n(o, !0, !1)
		}
		return (
			a && ((r += '?'), (r += n(a, !1, !1))), u && ((r += '#'), (r += t ? u : Y0(u, !1, !1))), r
		)
	}
	function eh(e) {
		try {
			return decodeURIComponent(e)
		} catch {
			return e.length > 3 ? e.substr(0, 3) + eh(e.substr(3)) : e
		}
	}
	var X0 = /(%[0-9A-Za-z][0-9A-Za-z])+/g
	function xl(e) {
		return e.match(X0) ? e.replace(X0, (t) => eh(t)) : e
	}
	var Rr = class e {
		constructor(t, n) {
			;(this.lineNumber = t), (this.column = n)
		}
		with(t = this.lineNumber, n = this.column) {
			return t === this.lineNumber && n === this.column ? this : new e(t, n)
		}
		delta(t = 0, n = 0) {
			return this.with(this.lineNumber + t, this.column + n)
		}
		equals(t) {
			return e.equals(this, t)
		}
		static equals(t, n) {
			return !t && !n ? !0 : !!t && !!n && t.lineNumber === n.lineNumber && t.column === n.column
		}
		isBefore(t) {
			return e.isBefore(this, t)
		}
		static isBefore(t, n) {
			return t.lineNumber < n.lineNumber
				? !0
				: n.lineNumber < t.lineNumber
				? !1
				: t.column < n.column
		}
		isBeforeOrEqual(t) {
			return e.isBeforeOrEqual(this, t)
		}
		static isBeforeOrEqual(t, n) {
			return t.lineNumber < n.lineNumber
				? !0
				: n.lineNumber < t.lineNumber
				? !1
				: t.column <= n.column
		}
		static compare(t, n) {
			let r = t.lineNumber | 0,
				i = n.lineNumber | 0
			if (r === i) {
				let s = t.column | 0,
					o = n.column | 0
				return s - o
			}
			return r - i
		}
		clone() {
			return new e(this.lineNumber, this.column)
		}
		toString() {
			return '(' + this.lineNumber + ',' + this.column + ')'
		}
		static lift(t) {
			return new e(t.lineNumber, t.column)
		}
		static isIPosition(t) {
			return t && typeof t.lineNumber == 'number' && typeof t.column == 'number'
		}
	}
	var Wn = class e {
		constructor(t, n, r, i) {
			t > r || (t === r && n > i)
				? ((this.startLineNumber = r),
				  (this.startColumn = i),
				  (this.endLineNumber = t),
				  (this.endColumn = n))
				: ((this.startLineNumber = t),
				  (this.startColumn = n),
				  (this.endLineNumber = r),
				  (this.endColumn = i))
		}
		isEmpty() {
			return e.isEmpty(this)
		}
		static isEmpty(t) {
			return t.startLineNumber === t.endLineNumber && t.startColumn === t.endColumn
		}
		containsPosition(t) {
			return e.containsPosition(this, t)
		}
		static containsPosition(t, n) {
			return !(
				n.lineNumber < t.startLineNumber ||
				n.lineNumber > t.endLineNumber ||
				(n.lineNumber === t.startLineNumber && n.column < t.startColumn) ||
				(n.lineNumber === t.endLineNumber && n.column > t.endColumn)
			)
		}
		static strictContainsPosition(t, n) {
			return !(
				n.lineNumber < t.startLineNumber ||
				n.lineNumber > t.endLineNumber ||
				(n.lineNumber === t.startLineNumber && n.column <= t.startColumn) ||
				(n.lineNumber === t.endLineNumber && n.column >= t.endColumn)
			)
		}
		containsRange(t) {
			return e.containsRange(this, t)
		}
		static containsRange(t, n) {
			return !(
				n.startLineNumber < t.startLineNumber ||
				n.endLineNumber < t.startLineNumber ||
				n.startLineNumber > t.endLineNumber ||
				n.endLineNumber > t.endLineNumber ||
				(n.startLineNumber === t.startLineNumber && n.startColumn < t.startColumn) ||
				(n.endLineNumber === t.endLineNumber && n.endColumn > t.endColumn)
			)
		}
		strictContainsRange(t) {
			return e.strictContainsRange(this, t)
		}
		static strictContainsRange(t, n) {
			return !(
				n.startLineNumber < t.startLineNumber ||
				n.endLineNumber < t.startLineNumber ||
				n.startLineNumber > t.endLineNumber ||
				n.endLineNumber > t.endLineNumber ||
				(n.startLineNumber === t.startLineNumber && n.startColumn <= t.startColumn) ||
				(n.endLineNumber === t.endLineNumber && n.endColumn >= t.endColumn)
			)
		}
		plusRange(t) {
			return e.plusRange(this, t)
		}
		static plusRange(t, n) {
			let r, i, s, o
			return (
				n.startLineNumber < t.startLineNumber
					? ((r = n.startLineNumber), (i = n.startColumn))
					: n.startLineNumber === t.startLineNumber
					? ((r = n.startLineNumber), (i = Math.min(n.startColumn, t.startColumn)))
					: ((r = t.startLineNumber), (i = t.startColumn)),
				n.endLineNumber > t.endLineNumber
					? ((s = n.endLineNumber), (o = n.endColumn))
					: n.endLineNumber === t.endLineNumber
					? ((s = n.endLineNumber), (o = Math.max(n.endColumn, t.endColumn)))
					: ((s = t.endLineNumber), (o = t.endColumn)),
				new e(r, i, s, o)
			)
		}
		intersectRanges(t) {
			return e.intersectRanges(this, t)
		}
		static intersectRanges(t, n) {
			let r = t.startLineNumber,
				i = t.startColumn,
				s = t.endLineNumber,
				o = t.endColumn,
				a = n.startLineNumber,
				u = n.startColumn,
				h = n.endLineNumber,
				N = n.endColumn
			return (
				r < a ? ((r = a), (i = u)) : r === a && (i = Math.max(i, u)),
				s > h ? ((s = h), (o = N)) : s === h && (o = Math.min(o, N)),
				r > s || (r === s && i > o) ? null : new e(r, i, s, o)
			)
		}
		equalsRange(t) {
			return e.equalsRange(this, t)
		}
		static equalsRange(t, n) {
			return !t && !n
				? !0
				: !!t &&
						!!n &&
						t.startLineNumber === n.startLineNumber &&
						t.startColumn === n.startColumn &&
						t.endLineNumber === n.endLineNumber &&
						t.endColumn === n.endColumn
		}
		getEndPosition() {
			return e.getEndPosition(this)
		}
		static getEndPosition(t) {
			return new Rr(t.endLineNumber, t.endColumn)
		}
		getStartPosition() {
			return e.getStartPosition(this)
		}
		static getStartPosition(t) {
			return new Rr(t.startLineNumber, t.startColumn)
		}
		toString() {
			return (
				'[' +
				this.startLineNumber +
				',' +
				this.startColumn +
				' -> ' +
				this.endLineNumber +
				',' +
				this.endColumn +
				']'
			)
		}
		setEndPosition(t, n) {
			return new e(this.startLineNumber, this.startColumn, t, n)
		}
		setStartPosition(t, n) {
			return new e(t, n, this.endLineNumber, this.endColumn)
		}
		collapseToStart() {
			return e.collapseToStart(this)
		}
		static collapseToStart(t) {
			return new e(t.startLineNumber, t.startColumn, t.startLineNumber, t.startColumn)
		}
		collapseToEnd() {
			return e.collapseToEnd(this)
		}
		static collapseToEnd(t) {
			return new e(t.endLineNumber, t.endColumn, t.endLineNumber, t.endColumn)
		}
		delta(t) {
			return new e(
				this.startLineNumber + t,
				this.startColumn,
				this.endLineNumber + t,
				this.endColumn
			)
		}
		static fromPositions(t, n = t) {
			return new e(t.lineNumber, t.column, n.lineNumber, n.column)
		}
		static lift(t) {
			return t ? new e(t.startLineNumber, t.startColumn, t.endLineNumber, t.endColumn) : null
		}
		static isIRange(t) {
			return (
				t &&
				typeof t.startLineNumber == 'number' &&
				typeof t.startColumn == 'number' &&
				typeof t.endLineNumber == 'number' &&
				typeof t.endColumn == 'number'
			)
		}
		static areIntersectingOrTouching(t, n) {
			return !(
				t.endLineNumber < n.startLineNumber ||
				(t.endLineNumber === n.startLineNumber && t.endColumn < n.startColumn) ||
				n.endLineNumber < t.startLineNumber ||
				(n.endLineNumber === t.startLineNumber && n.endColumn < t.startColumn)
			)
		}
		static areIntersecting(t, n) {
			return !(
				t.endLineNumber < n.startLineNumber ||
				(t.endLineNumber === n.startLineNumber && t.endColumn <= n.startColumn) ||
				n.endLineNumber < t.startLineNumber ||
				(n.endLineNumber === t.startLineNumber && n.endColumn <= t.startColumn)
			)
		}
		static compareRangesUsingStarts(t, n) {
			if (t && n) {
				let s = t.startLineNumber | 0,
					o = n.startLineNumber | 0
				if (s === o) {
					let a = t.startColumn | 0,
						u = n.startColumn | 0
					if (a === u) {
						let h = t.endLineNumber | 0,
							N = n.endLineNumber | 0
						if (h === N) {
							let I = t.endColumn | 0,
								Q = n.endColumn | 0
							return I - Q
						}
						return h - N
					}
					return a - u
				}
				return s - o
			}
			return (t ? 1 : 0) - (n ? 1 : 0)
		}
		static compareRangesUsingEnds(t, n) {
			return t.endLineNumber === n.endLineNumber
				? t.endColumn === n.endColumn
					? t.startLineNumber === n.startLineNumber
						? t.startColumn - n.startColumn
						: t.startLineNumber - n.startLineNumber
					: t.endColumn - n.endColumn
				: t.endLineNumber - n.endLineNumber
		}
		static spansMultipleLines(t) {
			return t.endLineNumber > t.startLineNumber
		}
		toJSON() {
			return this
		}
	}
	function Zp(e) {
		return e < 0 ? 0 : e > 255 ? 255 : e | 0
	}
	function zs(e) {
		return e < 0 ? 0 : e > 4294967295 ? 4294967295 : e | 0
	}
	var bl = class {
		constructor(t) {
			;(this.values = t),
				(this.prefixSum = new Uint32Array(t.length)),
				(this.prefixSumValidIndex = new Int32Array(1)),
				(this.prefixSumValidIndex[0] = -1)
		}
		getCount() {
			return this.values.length
		}
		insertValues(t, n) {
			t = zs(t)
			let r = this.values,
				i = this.prefixSum,
				s = n.length
			return s === 0
				? !1
				: ((this.values = new Uint32Array(r.length + s)),
				  this.values.set(r.subarray(0, t), 0),
				  this.values.set(r.subarray(t), t + s),
				  this.values.set(n, t),
				  t - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = t - 1),
				  (this.prefixSum = new Uint32Array(this.values.length)),
				  this.prefixSumValidIndex[0] >= 0 &&
						this.prefixSum.set(i.subarray(0, this.prefixSumValidIndex[0] + 1)),
				  !0)
		}
		setValue(t, n) {
			return (
				(t = zs(t)),
				(n = zs(n)),
				this.values[t] === n
					? !1
					: ((this.values[t] = n),
					  t - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = t - 1),
					  !0)
			)
		}
		removeValues(t, n) {
			;(t = zs(t)), (n = zs(n))
			let r = this.values,
				i = this.prefixSum
			if (t >= r.length) return !1
			let s = r.length - t
			return (
				n >= s && (n = s),
				n === 0
					? !1
					: ((this.values = new Uint32Array(r.length - n)),
					  this.values.set(r.subarray(0, t), 0),
					  this.values.set(r.subarray(t + n), t),
					  (this.prefixSum = new Uint32Array(this.values.length)),
					  t - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = t - 1),
					  this.prefixSumValidIndex[0] >= 0 &&
							this.prefixSum.set(i.subarray(0, this.prefixSumValidIndex[0] + 1)),
					  !0)
			)
		}
		getTotalSum() {
			return this.values.length === 0 ? 0 : this._getPrefixSum(this.values.length - 1)
		}
		getPrefixSum(t) {
			return t < 0 ? 0 : ((t = zs(t)), this._getPrefixSum(t))
		}
		_getPrefixSum(t) {
			if (t <= this.prefixSumValidIndex[0]) return this.prefixSum[t]
			let n = this.prefixSumValidIndex[0] + 1
			n === 0 && ((this.prefixSum[0] = this.values[0]), n++),
				t >= this.values.length && (t = this.values.length - 1)
			for (let r = n; r <= t; r++) this.prefixSum[r] = this.prefixSum[r - 1] + this.values[r]
			return (
				(this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], t)), this.prefixSum[t]
			)
		}
		getIndexOf(t) {
			;(t = Math.floor(t)), this.getTotalSum()
			let n = 0,
				r = this.values.length - 1,
				i = 0,
				s = 0,
				o = 0
			for (; n <= r; )
				if (((i = (n + (r - n) / 2) | 0), (s = this.prefixSum[i]), (o = s - this.values[i]), t < o))
					r = i - 1
				else if (t >= s) n = i + 1
				else break
			return new ef(i, t - o)
		}
	}
	var ef = class {
		constructor(t, n) {
			;(this.index = t),
				(this.remainder = n),
				(this._prefixSumIndexOfResultBrand = void 0),
				(this.index = t),
				(this.remainder = n)
		}
	}
	var Tl = class {
		constructor(t, n, r, i) {
			;(this._uri = t),
				(this._lines = n),
				(this._eol = r),
				(this._versionId = i),
				(this._lineStarts = null),
				(this._cachedTextValue = null)
		}
		dispose() {
			this._lines.length = 0
		}
		get version() {
			return this._versionId
		}
		getText() {
			return (
				this._cachedTextValue === null && (this._cachedTextValue = this._lines.join(this._eol)),
				this._cachedTextValue
			)
		}
		onEvents(t) {
			t.eol && t.eol !== this._eol && ((this._eol = t.eol), (this._lineStarts = null))
			let n = t.changes
			for (let r of n)
				this._acceptDeleteRange(r.range),
					this._acceptInsertText(new Rr(r.range.startLineNumber, r.range.startColumn), r.text)
			;(this._versionId = t.versionId), (this._cachedTextValue = null)
		}
		_ensureLineStarts() {
			if (!this._lineStarts) {
				let t = this._eol.length,
					n = this._lines.length,
					r = new Uint32Array(n)
				for (let i = 0; i < n; i++) r[i] = this._lines[i].length + t
				this._lineStarts = new bl(r)
			}
		}
		_setLineText(t, n) {
			;(this._lines[t] = n),
				this._lineStarts && this._lineStarts.setValue(t, this._lines[t].length + this._eol.length)
		}
		_acceptDeleteRange(t) {
			if (t.startLineNumber === t.endLineNumber) {
				if (t.startColumn === t.endColumn) return
				this._setLineText(
					t.startLineNumber - 1,
					this._lines[t.startLineNumber - 1].substring(0, t.startColumn - 1) +
						this._lines[t.startLineNumber - 1].substring(t.endColumn - 1)
				)
				return
			}
			this._setLineText(
				t.startLineNumber - 1,
				this._lines[t.startLineNumber - 1].substring(0, t.startColumn - 1) +
					this._lines[t.endLineNumber - 1].substring(t.endColumn - 1)
			),
				this._lines.splice(t.startLineNumber, t.endLineNumber - t.startLineNumber),
				this._lineStarts &&
					this._lineStarts.removeValues(t.startLineNumber, t.endLineNumber - t.startLineNumber)
		}
		_acceptInsertText(t, n) {
			if (n.length === 0) return
			let r = B0(n)
			if (r.length === 1) {
				this._setLineText(
					t.lineNumber - 1,
					this._lines[t.lineNumber - 1].substring(0, t.column - 1) +
						r[0] +
						this._lines[t.lineNumber - 1].substring(t.column - 1)
				)
				return
			}
			;(r[r.length - 1] += this._lines[t.lineNumber - 1].substring(t.column - 1)),
				this._setLineText(
					t.lineNumber - 1,
					this._lines[t.lineNumber - 1].substring(0, t.column - 1) + r[0]
				)
			let i = new Uint32Array(r.length - 1)
			for (let s = 1; s < r.length; s++)
				this._lines.splice(t.lineNumber + s - 1, 0, r[s]),
					(i[s - 1] = r[s].length + this._eol.length)
			this._lineStarts && this._lineStarts.insertValues(t.lineNumber, i)
		}
	}
	var Tv = '`~!@#$%^&*()-=+[{]}\\|;:\'",.<>/?'
	function Av(e = '') {
		let t = '(-?\\d*\\.\\d\\w*)|([^'
		for (let n of Tv) e.indexOf(n) >= 0 || (t += '\\' + n)
		return (t += '\\s]+)'), new RegExp(t, 'g')
	}
	var tf = Av()
	function th(e) {
		let t = tf
		if (e && e instanceof RegExp)
			if (e.global) t = e
			else {
				let n = 'g'
				e.ignoreCase && (n += 'i'),
					e.multiline && (n += 'm'),
					e.unicode && (n += 'u'),
					(t = new RegExp(e.source, n))
			}
		return (t.lastIndex = 0), t
	}
	var nh = new Va()
	nh.unshift({ maxLen: 1e3, windowSize: 15, timeBudget: 150 })
	function Xa(e, t, n, r, i) {
		if ((i || (i = No.first(nh)), n.length > i.maxLen)) {
			let h = e - i.maxLen / 2
			return h < 0 ? (h = 0) : (r += h), (n = n.substring(h, e + i.maxLen / 2)), Xa(e, t, n, r, i)
		}
		let s = Date.now(),
			o = e - 1 - r,
			a = -1,
			u = null
		for (let h = 1; !(Date.now() - s >= i.timeBudget); h++) {
			let N = o - i.windowSize * h
			t.lastIndex = Math.max(0, N)
			let I = Cv(t, n, o, a)
			if ((!I && u) || ((u = I), N <= 0)) break
			a = N
		}
		if (u) {
			let h = { word: u[0], startColumn: r + 1 + u.index, endColumn: r + 1 + u.index + u[0].length }
			return (t.lastIndex = 0), h
		}
		return null
	}
	function Cv(e, t, n, r) {
		let i
		for (; (i = e.exec(t)); ) {
			let s = i.index || 0
			if (s <= n && e.lastIndex >= n) return i
			if (r > 0 && s > r) return null
		}
		return null
	}
	var Oo = class e {
		constructor(t) {
			let n = Zp(t)
			;(this._defaultValue = n), (this._asciiMap = e._createAsciiMap(n)), (this._map = new Map())
		}
		static _createAsciiMap(t) {
			let n = new Uint8Array(256)
			return n.fill(t), n
		}
		set(t, n) {
			let r = Zp(n)
			t >= 0 && t < 256 ? (this._asciiMap[t] = r) : this._map.set(t, r)
		}
		get(t) {
			return t >= 0 && t < 256 ? this._asciiMap[t] : this._map.get(t) || this._defaultValue
		}
		clear() {
			this._asciiMap.fill(this._defaultValue), this._map.clear()
		}
	}
	var rf = class {
			constructor(t, n, r) {
				let i = new Uint8Array(t * n)
				for (let s = 0, o = t * n; s < o; s++) i[s] = r
				;(this._data = i), (this.rows = t), (this.cols = n)
			}
			get(t, n) {
				return this._data[t * this.cols + n]
			}
			set(t, n, r) {
				this._data[t * this.cols + n] = r
			}
		},
		sf = class {
			constructor(t) {
				let n = 0,
					r = 0
				for (let s = 0, o = t.length; s < o; s++) {
					let [a, u, h] = t[s]
					u > n && (n = u), a > r && (r = a), h > r && (r = h)
				}
				n++, r++
				let i = new rf(r, n, 0)
				for (let s = 0, o = t.length; s < o; s++) {
					let [a, u, h] = t[s]
					i.set(a, u, h)
				}
				;(this._states = i), (this._maxCharCode = n)
			}
			nextState(t, n) {
				return n < 0 || n >= this._maxCharCode ? 0 : this._states.get(t, n)
			}
		},
		nf = null
	function Sv() {
		return (
			nf === null &&
				(nf = new sf([
					[1, 104, 2],
					[1, 72, 2],
					[1, 102, 6],
					[1, 70, 6],
					[2, 116, 3],
					[2, 84, 3],
					[3, 116, 4],
					[3, 84, 4],
					[4, 112, 5],
					[4, 80, 5],
					[5, 115, 9],
					[5, 83, 9],
					[5, 58, 10],
					[6, 105, 7],
					[6, 73, 7],
					[7, 108, 8],
					[7, 76, 8],
					[8, 101, 9],
					[8, 69, 9],
					[9, 58, 10],
					[10, 47, 11],
					[11, 47, 12]
				])),
			nf
		)
	}
	var Ka = null
	function Nv() {
		if (Ka === null) {
			Ka = new Oo(0)
			let e = ` 	<>'"\u3001\u3002\uFF61\uFF64\uFF0C\uFF0E\uFF1A\uFF1B\u2018\u3008\u300C\u300E\u3014\uFF08\uFF3B\uFF5B\uFF62\uFF63\uFF5D\uFF3D\uFF09\u3015\u300F\u300D\u3009\u2019\uFF40\uFF5E\u2026`
			for (let n = 0; n < e.length; n++) Ka.set(e.charCodeAt(n), 1)
			let t = '.,;:'
			for (let n = 0; n < t.length; n++) Ka.set(t.charCodeAt(n), 2)
		}
		return Ka
	}
	var of = class e {
		static _createLink(t, n, r, i, s) {
			let o = s - 1
			do {
				let a = n.charCodeAt(o)
				if (t.get(a) !== 2) break
				o--
			} while (o > i)
			if (i > 0) {
				let a = n.charCodeAt(i - 1),
					u = n.charCodeAt(o)
				;((a === 40 && u === 41) || (a === 91 && u === 93) || (a === 123 && u === 125)) && o--
			}
			return {
				range: { startLineNumber: r, startColumn: i + 1, endLineNumber: r, endColumn: o + 2 },
				url: n.substring(i, o + 1)
			}
		}
		static computeLinks(t, n = Sv()) {
			let r = Nv(),
				i = []
			for (let s = 1, o = t.getLineCount(); s <= o; s++) {
				let a = t.getLineContent(s),
					u = a.length,
					h = 0,
					N = 0,
					I = 0,
					Q = 1,
					K = !1,
					ue = !1,
					de = !1,
					Pe = !1
				for (; h < u; ) {
					let Ze = !1,
						Ae = a.charCodeAt(h)
					if (Q === 13) {
						let ze
						switch (Ae) {
							case 40:
								;(K = !0), (ze = 0)
								break
							case 41:
								ze = K ? 0 : 1
								break
							case 91:
								;(de = !0), (ue = !0), (ze = 0)
								break
							case 93:
								;(de = !1), (ze = ue ? 0 : 1)
								break
							case 123:
								;(Pe = !0), (ze = 0)
								break
							case 125:
								ze = Pe ? 0 : 1
								break
							case 39:
							case 34:
							case 96:
								I === Ae ? (ze = 1) : I === 39 || I === 34 || I === 96 ? (ze = 0) : (ze = 1)
								break
							case 42:
								ze = I === 42 ? 1 : 0
								break
							case 124:
								ze = I === 124 ? 1 : 0
								break
							case 32:
								ze = de ? 0 : 1
								break
							default:
								ze = r.get(Ae)
						}
						ze === 1 && (i.push(e._createLink(r, a, s, N, h)), (Ze = !0))
					} else if (Q === 12) {
						let ze
						Ae === 91 ? ((ue = !0), (ze = 0)) : (ze = r.get(Ae)), ze === 1 ? (Ze = !0) : (Q = 13)
					} else (Q = n.nextState(Q, Ae)), Q === 0 && (Ze = !0)
					Ze && ((Q = 1), (K = !1), (ue = !1), (Pe = !1), (N = h + 1), (I = Ae)), h++
				}
				Q === 13 && i.push(e._createLink(r, a, s, N, u))
			}
			return i
		}
	}
	function rh(e) {
		return !e || typeof e.getLineCount != 'function' || typeof e.getLineContent != 'function'
			? []
			: of.computeLinks(e)
	}
	var Bo = class {
		constructor() {
			this._defaultValueSet = [
				['true', 'false'],
				['True', 'False'],
				['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],
				['public', 'protected', 'private']
			]
		}
		navigateValueSet(t, n, r, i, s) {
			if (t && n) {
				let o = this.doNavigateValueSet(n, s)
				if (o) return { range: t, value: o }
			}
			if (r && i) {
				let o = this.doNavigateValueSet(i, s)
				if (o) return { range: r, value: o }
			}
			return null
		}
		doNavigateValueSet(t, n) {
			let r = this.numberReplace(t, n)
			return r !== null ? r : this.textReplace(t, n)
		}
		numberReplace(t, n) {
			let r = Math.pow(10, t.length - (t.lastIndexOf('.') + 1)),
				i = Number(t),
				s = parseFloat(t)
			return !isNaN(i) && !isNaN(s) && i === s
				? i === 0 && !n
					? null
					: ((i = Math.floor(i * r)), (i += n ? r : -r), String(i / r))
				: null
		}
		textReplace(t, n) {
			return this.valueSetsReplace(this._defaultValueSet, t, n)
		}
		valueSetsReplace(t, n, r) {
			let i = null
			for (let s = 0, o = t.length; i === null && s < o; s++) i = this.valueSetReplace(t[s], n, r)
			return i
		}
		valueSetReplace(t, n, r) {
			let i = t.indexOf(n)
			return i >= 0 ? ((i += r ? 1 : -1), i < 0 ? (i = t.length - 1) : (i %= t.length), t[i]) : null
		}
	}
	Bo.INSTANCE = new Bo()
	var Za = class {
			constructor() {
				;(this._keyCodeToStr = []), (this._strToKeyCode = Object.create(null))
			}
			define(t, n) {
				;(this._keyCodeToStr[t] = n), (this._strToKeyCode[n.toLowerCase()] = t)
			}
			keyCodeToStr(t) {
				return this._keyCodeToStr[t]
			}
			strToKeyCode(t) {
				return this._strToKeyCode[t.toLowerCase()] || 0
			}
		},
		Al = new Za(),
		af = new Za(),
		uf = new Za(),
		Fv = new Array(230),
		_v = {},
		wv = [],
		Lv = Object.create(null),
		Iv = Object.create(null)
	var sh = [],
		lf = []
	for (let e = 0; e <= 193; e++) sh[e] = -1
	for (let e = 0; e <= 132; e++) lf[e] = -1
	;(function () {
		let e = '',
			t = [
				[1, 0, 'None', 0, 'unknown', 0, 'VK_UNKNOWN', e, e],
				[1, 1, 'Hyper', 0, e, 0, e, e, e],
				[1, 2, 'Super', 0, e, 0, e, e, e],
				[1, 3, 'Fn', 0, e, 0, e, e, e],
				[1, 4, 'FnLock', 0, e, 0, e, e, e],
				[1, 5, 'Suspend', 0, e, 0, e, e, e],
				[1, 6, 'Resume', 0, e, 0, e, e, e],
				[1, 7, 'Turbo', 0, e, 0, e, e, e],
				[1, 8, 'Sleep', 0, e, 0, 'VK_SLEEP', e, e],
				[1, 9, 'WakeUp', 0, e, 0, e, e, e],
				[0, 10, 'KeyA', 31, 'A', 65, 'VK_A', e, e],
				[0, 11, 'KeyB', 32, 'B', 66, 'VK_B', e, e],
				[0, 12, 'KeyC', 33, 'C', 67, 'VK_C', e, e],
				[0, 13, 'KeyD', 34, 'D', 68, 'VK_D', e, e],
				[0, 14, 'KeyE', 35, 'E', 69, 'VK_E', e, e],
				[0, 15, 'KeyF', 36, 'F', 70, 'VK_F', e, e],
				[0, 16, 'KeyG', 37, 'G', 71, 'VK_G', e, e],
				[0, 17, 'KeyH', 38, 'H', 72, 'VK_H', e, e],
				[0, 18, 'KeyI', 39, 'I', 73, 'VK_I', e, e],
				[0, 19, 'KeyJ', 40, 'J', 74, 'VK_J', e, e],
				[0, 20, 'KeyK', 41, 'K', 75, 'VK_K', e, e],
				[0, 21, 'KeyL', 42, 'L', 76, 'VK_L', e, e],
				[0, 22, 'KeyM', 43, 'M', 77, 'VK_M', e, e],
				[0, 23, 'KeyN', 44, 'N', 78, 'VK_N', e, e],
				[0, 24, 'KeyO', 45, 'O', 79, 'VK_O', e, e],
				[0, 25, 'KeyP', 46, 'P', 80, 'VK_P', e, e],
				[0, 26, 'KeyQ', 47, 'Q', 81, 'VK_Q', e, e],
				[0, 27, 'KeyR', 48, 'R', 82, 'VK_R', e, e],
				[0, 28, 'KeyS', 49, 'S', 83, 'VK_S', e, e],
				[0, 29, 'KeyT', 50, 'T', 84, 'VK_T', e, e],
				[0, 30, 'KeyU', 51, 'U', 85, 'VK_U', e, e],
				[0, 31, 'KeyV', 52, 'V', 86, 'VK_V', e, e],
				[0, 32, 'KeyW', 53, 'W', 87, 'VK_W', e, e],
				[0, 33, 'KeyX', 54, 'X', 88, 'VK_X', e, e],
				[0, 34, 'KeyY', 55, 'Y', 89, 'VK_Y', e, e],
				[0, 35, 'KeyZ', 56, 'Z', 90, 'VK_Z', e, e],
				[0, 36, 'Digit1', 22, '1', 49, 'VK_1', e, e],
				[0, 37, 'Digit2', 23, '2', 50, 'VK_2', e, e],
				[0, 38, 'Digit3', 24, '3', 51, 'VK_3', e, e],
				[0, 39, 'Digit4', 25, '4', 52, 'VK_4', e, e],
				[0, 40, 'Digit5', 26, '5', 53, 'VK_5', e, e],
				[0, 41, 'Digit6', 27, '6', 54, 'VK_6', e, e],
				[0, 42, 'Digit7', 28, '7', 55, 'VK_7', e, e],
				[0, 43, 'Digit8', 29, '8', 56, 'VK_8', e, e],
				[0, 44, 'Digit9', 30, '9', 57, 'VK_9', e, e],
				[0, 45, 'Digit0', 21, '0', 48, 'VK_0', e, e],
				[1, 46, 'Enter', 3, 'Enter', 13, 'VK_RETURN', e, e],
				[1, 47, 'Escape', 9, 'Escape', 27, 'VK_ESCAPE', e, e],
				[1, 48, 'Backspace', 1, 'Backspace', 8, 'VK_BACK', e, e],
				[1, 49, 'Tab', 2, 'Tab', 9, 'VK_TAB', e, e],
				[1, 50, 'Space', 10, 'Space', 32, 'VK_SPACE', e, e],
				[0, 51, 'Minus', 88, '-', 189, 'VK_OEM_MINUS', '-', 'OEM_MINUS'],
				[0, 52, 'Equal', 86, '=', 187, 'VK_OEM_PLUS', '=', 'OEM_PLUS'],
				[0, 53, 'BracketLeft', 92, '[', 219, 'VK_OEM_4', '[', 'OEM_4'],
				[0, 54, 'BracketRight', 94, ']', 221, 'VK_OEM_6', ']', 'OEM_6'],
				[0, 55, 'Backslash', 93, '\\', 220, 'VK_OEM_5', '\\', 'OEM_5'],
				[0, 56, 'IntlHash', 0, e, 0, e, e, e],
				[0, 57, 'Semicolon', 85, ';', 186, 'VK_OEM_1', ';', 'OEM_1'],
				[0, 58, 'Quote', 95, "'", 222, 'VK_OEM_7', "'", 'OEM_7'],
				[0, 59, 'Backquote', 91, '`', 192, 'VK_OEM_3', '`', 'OEM_3'],
				[0, 60, 'Comma', 87, ',', 188, 'VK_OEM_COMMA', ',', 'OEM_COMMA'],
				[0, 61, 'Period', 89, '.', 190, 'VK_OEM_PERIOD', '.', 'OEM_PERIOD'],
				[0, 62, 'Slash', 90, '/', 191, 'VK_OEM_2', '/', 'OEM_2'],
				[1, 63, 'CapsLock', 8, 'CapsLock', 20, 'VK_CAPITAL', e, e],
				[1, 64, 'F1', 59, 'F1', 112, 'VK_F1', e, e],
				[1, 65, 'F2', 60, 'F2', 113, 'VK_F2', e, e],
				[1, 66, 'F3', 61, 'F3', 114, 'VK_F3', e, e],
				[1, 67, 'F4', 62, 'F4', 115, 'VK_F4', e, e],
				[1, 68, 'F5', 63, 'F5', 116, 'VK_F5', e, e],
				[1, 69, 'F6', 64, 'F6', 117, 'VK_F6', e, e],
				[1, 70, 'F7', 65, 'F7', 118, 'VK_F7', e, e],
				[1, 71, 'F8', 66, 'F8', 119, 'VK_F8', e, e],
				[1, 72, 'F9', 67, 'F9', 120, 'VK_F9', e, e],
				[1, 73, 'F10', 68, 'F10', 121, 'VK_F10', e, e],
				[1, 74, 'F11', 69, 'F11', 122, 'VK_F11', e, e],
				[1, 75, 'F12', 70, 'F12', 123, 'VK_F12', e, e],
				[1, 76, 'PrintScreen', 0, e, 0, e, e, e],
				[1, 77, 'ScrollLock', 84, 'ScrollLock', 145, 'VK_SCROLL', e, e],
				[1, 78, 'Pause', 7, 'PauseBreak', 19, 'VK_PAUSE', e, e],
				[1, 79, 'Insert', 19, 'Insert', 45, 'VK_INSERT', e, e],
				[1, 80, 'Home', 14, 'Home', 36, 'VK_HOME', e, e],
				[1, 81, 'PageUp', 11, 'PageUp', 33, 'VK_PRIOR', e, e],
				[1, 82, 'Delete', 20, 'Delete', 46, 'VK_DELETE', e, e],
				[1, 83, 'End', 13, 'End', 35, 'VK_END', e, e],
				[1, 84, 'PageDown', 12, 'PageDown', 34, 'VK_NEXT', e, e],
				[1, 85, 'ArrowRight', 17, 'RightArrow', 39, 'VK_RIGHT', 'Right', e],
				[1, 86, 'ArrowLeft', 15, 'LeftArrow', 37, 'VK_LEFT', 'Left', e],
				[1, 87, 'ArrowDown', 18, 'DownArrow', 40, 'VK_DOWN', 'Down', e],
				[1, 88, 'ArrowUp', 16, 'UpArrow', 38, 'VK_UP', 'Up', e],
				[1, 89, 'NumLock', 83, 'NumLock', 144, 'VK_NUMLOCK', e, e],
				[1, 90, 'NumpadDivide', 113, 'NumPad_Divide', 111, 'VK_DIVIDE', e, e],
				[1, 91, 'NumpadMultiply', 108, 'NumPad_Multiply', 106, 'VK_MULTIPLY', e, e],
				[1, 92, 'NumpadSubtract', 111, 'NumPad_Subtract', 109, 'VK_SUBTRACT', e, e],
				[1, 93, 'NumpadAdd', 109, 'NumPad_Add', 107, 'VK_ADD', e, e],
				[1, 94, 'NumpadEnter', 3, e, 0, e, e, e],
				[1, 95, 'Numpad1', 99, 'NumPad1', 97, 'VK_NUMPAD1', e, e],
				[1, 96, 'Numpad2', 100, 'NumPad2', 98, 'VK_NUMPAD2', e, e],
				[1, 97, 'Numpad3', 101, 'NumPad3', 99, 'VK_NUMPAD3', e, e],
				[1, 98, 'Numpad4', 102, 'NumPad4', 100, 'VK_NUMPAD4', e, e],
				[1, 99, 'Numpad5', 103, 'NumPad5', 101, 'VK_NUMPAD5', e, e],
				[1, 100, 'Numpad6', 104, 'NumPad6', 102, 'VK_NUMPAD6', e, e],
				[1, 101, 'Numpad7', 105, 'NumPad7', 103, 'VK_NUMPAD7', e, e],
				[1, 102, 'Numpad8', 106, 'NumPad8', 104, 'VK_NUMPAD8', e, e],
				[1, 103, 'Numpad9', 107, 'NumPad9', 105, 'VK_NUMPAD9', e, e],
				[1, 104, 'Numpad0', 98, 'NumPad0', 96, 'VK_NUMPAD0', e, e],
				[1, 105, 'NumpadDecimal', 112, 'NumPad_Decimal', 110, 'VK_DECIMAL', e, e],
				[0, 106, 'IntlBackslash', 97, 'OEM_102', 226, 'VK_OEM_102', e, e],
				[1, 107, 'ContextMenu', 58, 'ContextMenu', 93, e, e, e],
				[1, 108, 'Power', 0, e, 0, e, e, e],
				[1, 109, 'NumpadEqual', 0, e, 0, e, e, e],
				[1, 110, 'F13', 71, 'F13', 124, 'VK_F13', e, e],
				[1, 111, 'F14', 72, 'F14', 125, 'VK_F14', e, e],
				[1, 112, 'F15', 73, 'F15', 126, 'VK_F15', e, e],
				[1, 113, 'F16', 74, 'F16', 127, 'VK_F16', e, e],
				[1, 114, 'F17', 75, 'F17', 128, 'VK_F17', e, e],
				[1, 115, 'F18', 76, 'F18', 129, 'VK_F18', e, e],
				[1, 116, 'F19', 77, 'F19', 130, 'VK_F19', e, e],
				[1, 117, 'F20', 78, 'F20', 131, 'VK_F20', e, e],
				[1, 118, 'F21', 79, 'F21', 132, 'VK_F21', e, e],
				[1, 119, 'F22', 80, 'F22', 133, 'VK_F22', e, e],
				[1, 120, 'F23', 81, 'F23', 134, 'VK_F23', e, e],
				[1, 121, 'F24', 82, 'F24', 135, 'VK_F24', e, e],
				[1, 122, 'Open', 0, e, 0, e, e, e],
				[1, 123, 'Help', 0, e, 0, e, e, e],
				[1, 124, 'Select', 0, e, 0, e, e, e],
				[1, 125, 'Again', 0, e, 0, e, e, e],
				[1, 126, 'Undo', 0, e, 0, e, e, e],
				[1, 127, 'Cut', 0, e, 0, e, e, e],
				[1, 128, 'Copy', 0, e, 0, e, e, e],
				[1, 129, 'Paste', 0, e, 0, e, e, e],
				[1, 130, 'Find', 0, e, 0, e, e, e],
				[1, 131, 'AudioVolumeMute', 117, 'AudioVolumeMute', 173, 'VK_VOLUME_MUTE', e, e],
				[1, 132, 'AudioVolumeUp', 118, 'AudioVolumeUp', 175, 'VK_VOLUME_UP', e, e],
				[1, 133, 'AudioVolumeDown', 119, 'AudioVolumeDown', 174, 'VK_VOLUME_DOWN', e, e],
				[1, 134, 'NumpadComma', 110, 'NumPad_Separator', 108, 'VK_SEPARATOR', e, e],
				[0, 135, 'IntlRo', 115, 'ABNT_C1', 193, 'VK_ABNT_C1', e, e],
				[1, 136, 'KanaMode', 0, e, 0, e, e, e],
				[0, 137, 'IntlYen', 0, e, 0, e, e, e],
				[1, 138, 'Convert', 0, e, 0, e, e, e],
				[1, 139, 'NonConvert', 0, e, 0, e, e, e],
				[1, 140, 'Lang1', 0, e, 0, e, e, e],
				[1, 141, 'Lang2', 0, e, 0, e, e, e],
				[1, 142, 'Lang3', 0, e, 0, e, e, e],
				[1, 143, 'Lang4', 0, e, 0, e, e, e],
				[1, 144, 'Lang5', 0, e, 0, e, e, e],
				[1, 145, 'Abort', 0, e, 0, e, e, e],
				[1, 146, 'Props', 0, e, 0, e, e, e],
				[1, 147, 'NumpadParenLeft', 0, e, 0, e, e, e],
				[1, 148, 'NumpadParenRight', 0, e, 0, e, e, e],
				[1, 149, 'NumpadBackspace', 0, e, 0, e, e, e],
				[1, 150, 'NumpadMemoryStore', 0, e, 0, e, e, e],
				[1, 151, 'NumpadMemoryRecall', 0, e, 0, e, e, e],
				[1, 152, 'NumpadMemoryClear', 0, e, 0, e, e, e],
				[1, 153, 'NumpadMemoryAdd', 0, e, 0, e, e, e],
				[1, 154, 'NumpadMemorySubtract', 0, e, 0, e, e, e],
				[1, 155, 'NumpadClear', 131, 'Clear', 12, 'VK_CLEAR', e, e],
				[1, 156, 'NumpadClearEntry', 0, e, 0, e, e, e],
				[1, 0, e, 5, 'Ctrl', 17, 'VK_CONTROL', e, e],
				[1, 0, e, 4, 'Shift', 16, 'VK_SHIFT', e, e],
				[1, 0, e, 6, 'Alt', 18, 'VK_MENU', e, e],
				[1, 0, e, 57, 'Meta', 91, 'VK_COMMAND', e, e],
				[1, 157, 'ControlLeft', 5, e, 0, 'VK_LCONTROL', e, e],
				[1, 158, 'ShiftLeft', 4, e, 0, 'VK_LSHIFT', e, e],
				[1, 159, 'AltLeft', 6, e, 0, 'VK_LMENU', e, e],
				[1, 160, 'MetaLeft', 57, e, 0, 'VK_LWIN', e, e],
				[1, 161, 'ControlRight', 5, e, 0, 'VK_RCONTROL', e, e],
				[1, 162, 'ShiftRight', 4, e, 0, 'VK_RSHIFT', e, e],
				[1, 163, 'AltRight', 6, e, 0, 'VK_RMENU', e, e],
				[1, 164, 'MetaRight', 57, e, 0, 'VK_RWIN', e, e],
				[1, 165, 'BrightnessUp', 0, e, 0, e, e, e],
				[1, 166, 'BrightnessDown', 0, e, 0, e, e, e],
				[1, 167, 'MediaPlay', 0, e, 0, e, e, e],
				[1, 168, 'MediaRecord', 0, e, 0, e, e, e],
				[1, 169, 'MediaFastForward', 0, e, 0, e, e, e],
				[1, 170, 'MediaRewind', 0, e, 0, e, e, e],
				[1, 171, 'MediaTrackNext', 124, 'MediaTrackNext', 176, 'VK_MEDIA_NEXT_TRACK', e, e],
				[1, 172, 'MediaTrackPrevious', 125, 'MediaTrackPrevious', 177, 'VK_MEDIA_PREV_TRACK', e, e],
				[1, 173, 'MediaStop', 126, 'MediaStop', 178, 'VK_MEDIA_STOP', e, e],
				[1, 174, 'Eject', 0, e, 0, e, e, e],
				[1, 175, 'MediaPlayPause', 127, 'MediaPlayPause', 179, 'VK_MEDIA_PLAY_PAUSE', e, e],
				[
					1,
					176,
					'MediaSelect',
					128,
					'LaunchMediaPlayer',
					181,
					'VK_MEDIA_LAUNCH_MEDIA_SELECT',
					e,
					e
				],
				[1, 177, 'LaunchMail', 129, 'LaunchMail', 180, 'VK_MEDIA_LAUNCH_MAIL', e, e],
				[1, 178, 'LaunchApp2', 130, 'LaunchApp2', 183, 'VK_MEDIA_LAUNCH_APP2', e, e],
				[1, 179, 'LaunchApp1', 0, e, 0, 'VK_MEDIA_LAUNCH_APP1', e, e],
				[1, 180, 'SelectTask', 0, e, 0, e, e, e],
				[1, 181, 'LaunchScreenSaver', 0, e, 0, e, e, e],
				[1, 182, 'BrowserSearch', 120, 'BrowserSearch', 170, 'VK_BROWSER_SEARCH', e, e],
				[1, 183, 'BrowserHome', 121, 'BrowserHome', 172, 'VK_BROWSER_HOME', e, e],
				[1, 184, 'BrowserBack', 122, 'BrowserBack', 166, 'VK_BROWSER_BACK', e, e],
				[1, 185, 'BrowserForward', 123, 'BrowserForward', 167, 'VK_BROWSER_FORWARD', e, e],
				[1, 186, 'BrowserStop', 0, e, 0, 'VK_BROWSER_STOP', e, e],
				[1, 187, 'BrowserRefresh', 0, e, 0, 'VK_BROWSER_REFRESH', e, e],
				[1, 188, 'BrowserFavorites', 0, e, 0, 'VK_BROWSER_FAVORITES', e, e],
				[1, 189, 'ZoomToggle', 0, e, 0, e, e, e],
				[1, 190, 'MailReply', 0, e, 0, e, e, e],
				[1, 191, 'MailForward', 0, e, 0, e, e, e],
				[1, 192, 'MailSend', 0, e, 0, e, e, e],
				[1, 0, e, 114, 'KeyInComposition', 229, e, e, e],
				[1, 0, e, 116, 'ABNT_C2', 194, 'VK_ABNT_C2', e, e],
				[1, 0, e, 96, 'OEM_8', 223, 'VK_OEM_8', e, e],
				[1, 0, e, 0, e, 0, 'VK_KANA', e, e],
				[1, 0, e, 0, e, 0, 'VK_HANGUL', e, e],
				[1, 0, e, 0, e, 0, 'VK_JUNJA', e, e],
				[1, 0, e, 0, e, 0, 'VK_FINAL', e, e],
				[1, 0, e, 0, e, 0, 'VK_HANJA', e, e],
				[1, 0, e, 0, e, 0, 'VK_KANJI', e, e],
				[1, 0, e, 0, e, 0, 'VK_CONVERT', e, e],
				[1, 0, e, 0, e, 0, 'VK_NONCONVERT', e, e],
				[1, 0, e, 0, e, 0, 'VK_ACCEPT', e, e],
				[1, 0, e, 0, e, 0, 'VK_MODECHANGE', e, e],
				[1, 0, e, 0, e, 0, 'VK_SELECT', e, e],
				[1, 0, e, 0, e, 0, 'VK_PRINT', e, e],
				[1, 0, e, 0, e, 0, 'VK_EXECUTE', e, e],
				[1, 0, e, 0, e, 0, 'VK_SNAPSHOT', e, e],
				[1, 0, e, 0, e, 0, 'VK_HELP', e, e],
				[1, 0, e, 0, e, 0, 'VK_APPS', e, e],
				[1, 0, e, 0, e, 0, 'VK_PROCESSKEY', e, e],
				[1, 0, e, 0, e, 0, 'VK_PACKET', e, e],
				[1, 0, e, 0, e, 0, 'VK_DBE_SBCSCHAR', e, e],
				[1, 0, e, 0, e, 0, 'VK_DBE_DBCSCHAR', e, e],
				[1, 0, e, 0, e, 0, 'VK_ATTN', e, e],
				[1, 0, e, 0, e, 0, 'VK_CRSEL', e, e],
				[1, 0, e, 0, e, 0, 'VK_EXSEL', e, e],
				[1, 0, e, 0, e, 0, 'VK_EREOF', e, e],
				[1, 0, e, 0, e, 0, 'VK_PLAY', e, e],
				[1, 0, e, 0, e, 0, 'VK_ZOOM', e, e],
				[1, 0, e, 0, e, 0, 'VK_NONAME', e, e],
				[1, 0, e, 0, e, 0, 'VK_PA1', e, e],
				[1, 0, e, 0, e, 0, 'VK_OEM_CLEAR', e, e]
			],
			n = [],
			r = []
		for (let i of t) {
			let [s, o, a, u, h, N, I, Q, K] = i
			if (
				(r[o] ||
					((r[o] = !0),
					(wv[o] = a),
					(Lv[a] = o),
					(Iv[a.toLowerCase()] = o),
					s &&
						((sh[o] = u),
						u !== 0 && u !== 3 && u !== 5 && u !== 4 && u !== 6 && u !== 57 && (lf[u] = o))),
				!n[u])
			) {
				if (((n[u] = !0), !h))
					throw new Error(`String representation missing for key code ${u} around scan code ${a}`)
				Al.define(u, h), af.define(u, Q || h), uf.define(u, K || Q || h)
			}
			N && (Fv[N] = u), I && (_v[I] = u)
		}
		lf[3] = 46
	})()
	var ih
	;(function (e) {
		function t(a) {
			return Al.keyCodeToStr(a)
		}
		e.toString = t
		function n(a) {
			return Al.strToKeyCode(a)
		}
		e.fromString = n
		function r(a) {
			return af.keyCodeToStr(a)
		}
		e.toUserSettingsUS = r
		function i(a) {
			return uf.keyCodeToStr(a)
		}
		e.toUserSettingsGeneral = i
		function s(a) {
			return af.strToKeyCode(a) || uf.strToKeyCode(a)
		}
		e.fromUserSettings = s
		function o(a) {
			if (a >= 98 && a <= 113) return null
			switch (a) {
				case 16:
					return 'Up'
				case 18:
					return 'Down'
				case 15:
					return 'Left'
				case 17:
					return 'Right'
			}
			return Al.keyCodeToStr(a)
		}
		e.toElectronAccelerator = o
	})(ih || (ih = {}))
	function oh(e, t) {
		let n = ((t & 65535) << 16) >>> 0
		return (e | n) >>> 0
	}
	var Cl = class e extends Wn {
		constructor(t, n, r, i) {
			super(t, n, r, i),
				(this.selectionStartLineNumber = t),
				(this.selectionStartColumn = n),
				(this.positionLineNumber = r),
				(this.positionColumn = i)
		}
		toString() {
			return (
				'[' +
				this.selectionStartLineNumber +
				',' +
				this.selectionStartColumn +
				' -> ' +
				this.positionLineNumber +
				',' +
				this.positionColumn +
				']'
			)
		}
		equalsSelection(t) {
			return e.selectionsEqual(this, t)
		}
		static selectionsEqual(t, n) {
			return (
				t.selectionStartLineNumber === n.selectionStartLineNumber &&
				t.selectionStartColumn === n.selectionStartColumn &&
				t.positionLineNumber === n.positionLineNumber &&
				t.positionColumn === n.positionColumn
			)
		}
		getDirection() {
			return this.selectionStartLineNumber === this.startLineNumber &&
				this.selectionStartColumn === this.startColumn
				? 0
				: 1
		}
		setEndPosition(t, n) {
			return this.getDirection() === 0
				? new e(this.startLineNumber, this.startColumn, t, n)
				: new e(t, n, this.startLineNumber, this.startColumn)
		}
		getPosition() {
			return new Rr(this.positionLineNumber, this.positionColumn)
		}
		getSelectionStart() {
			return new Rr(this.selectionStartLineNumber, this.selectionStartColumn)
		}
		setStartPosition(t, n) {
			return this.getDirection() === 0
				? new e(t, n, this.endLineNumber, this.endColumn)
				: new e(this.endLineNumber, this.endColumn, t, n)
		}
		static fromPositions(t, n = t) {
			return new e(t.lineNumber, t.column, n.lineNumber, n.column)
		}
		static fromRange(t, n) {
			return n === 0
				? new e(t.startLineNumber, t.startColumn, t.endLineNumber, t.endColumn)
				: new e(t.endLineNumber, t.endColumn, t.startLineNumber, t.startColumn)
		}
		static liftSelection(t) {
			return new e(
				t.selectionStartLineNumber,
				t.selectionStartColumn,
				t.positionLineNumber,
				t.positionColumn
			)
		}
		static selectionsArrEqual(t, n) {
			if ((t && !n) || (!t && n)) return !1
			if (!t && !n) return !0
			if (t.length !== n.length) return !1
			for (let r = 0, i = t.length; r < i; r++) if (!this.selectionsEqual(t[r], n[r])) return !1
			return !0
		}
		static isISelection(t) {
			return (
				t &&
				typeof t.selectionStartLineNumber == 'number' &&
				typeof t.selectionStartColumn == 'number' &&
				typeof t.positionLineNumber == 'number' &&
				typeof t.positionColumn == 'number'
			)
		}
		static createWithDirection(t, n, r, i, s) {
			return s === 0 ? new e(t, n, r, i) : new e(r, i, t, n)
		}
	}
	var ah = Object.create(null)
	function F(e, t) {
		if (S0(t)) {
			let n = ah[t]
			if (n === void 0) throw new Error(`${e} references an unknown codicon: ${t}`)
			t = n
		}
		return (ah[e] = t), { id: e }
	}
	var hn = {
		add: F('add', 6e4),
		plus: F('plus', 6e4),
		gistNew: F('gist-new', 6e4),
		repoCreate: F('repo-create', 6e4),
		lightbulb: F('lightbulb', 60001),
		lightBulb: F('light-bulb', 60001),
		repo: F('repo', 60002),
		repoDelete: F('repo-delete', 60002),
		gistFork: F('gist-fork', 60003),
		repoForked: F('repo-forked', 60003),
		gitPullRequest: F('git-pull-request', 60004),
		gitPullRequestAbandoned: F('git-pull-request-abandoned', 60004),
		recordKeys: F('record-keys', 60005),
		keyboard: F('keyboard', 60005),
		tag: F('tag', 60006),
		tagAdd: F('tag-add', 60006),
		tagRemove: F('tag-remove', 60006),
		gitPullRequestLabel: F('git-pull-request-label', 60006),
		person: F('person', 60007),
		personFollow: F('person-follow', 60007),
		personOutline: F('person-outline', 60007),
		personFilled: F('person-filled', 60007),
		gitBranch: F('git-branch', 60008),
		gitBranchCreate: F('git-branch-create', 60008),
		gitBranchDelete: F('git-branch-delete', 60008),
		sourceControl: F('source-control', 60008),
		mirror: F('mirror', 60009),
		mirrorPublic: F('mirror-public', 60009),
		star: F('star', 60010),
		starAdd: F('star-add', 60010),
		starDelete: F('star-delete', 60010),
		starEmpty: F('star-empty', 60010),
		comment: F('comment', 60011),
		commentAdd: F('comment-add', 60011),
		alert: F('alert', 60012),
		warning: F('warning', 60012),
		search: F('search', 60013),
		searchSave: F('search-save', 60013),
		logOut: F('log-out', 60014),
		signOut: F('sign-out', 60014),
		logIn: F('log-in', 60015),
		signIn: F('sign-in', 60015),
		eye: F('eye', 60016),
		eyeUnwatch: F('eye-unwatch', 60016),
		eyeWatch: F('eye-watch', 60016),
		circleFilled: F('circle-filled', 60017),
		primitiveDot: F('primitive-dot', 60017),
		closeDirty: F('close-dirty', 60017),
		debugBreakpoint: F('debug-breakpoint', 60017),
		debugBreakpointDisabled: F('debug-breakpoint-disabled', 60017),
		debugHint: F('debug-hint', 60017),
		primitiveSquare: F('primitive-square', 60018),
		edit: F('edit', 60019),
		pencil: F('pencil', 60019),
		info: F('info', 60020),
		issueOpened: F('issue-opened', 60020),
		gistPrivate: F('gist-private', 60021),
		gitForkPrivate: F('git-fork-private', 60021),
		lock: F('lock', 60021),
		mirrorPrivate: F('mirror-private', 60021),
		close: F('close', 60022),
		removeClose: F('remove-close', 60022),
		x: F('x', 60022),
		repoSync: F('repo-sync', 60023),
		sync: F('sync', 60023),
		clone: F('clone', 60024),
		desktopDownload: F('desktop-download', 60024),
		beaker: F('beaker', 60025),
		microscope: F('microscope', 60025),
		vm: F('vm', 60026),
		deviceDesktop: F('device-desktop', 60026),
		file: F('file', 60027),
		fileText: F('file-text', 60027),
		more: F('more', 60028),
		ellipsis: F('ellipsis', 60028),
		kebabHorizontal: F('kebab-horizontal', 60028),
		mailReply: F('mail-reply', 60029),
		reply: F('reply', 60029),
		organization: F('organization', 60030),
		organizationFilled: F('organization-filled', 60030),
		organizationOutline: F('organization-outline', 60030),
		newFile: F('new-file', 60031),
		fileAdd: F('file-add', 60031),
		newFolder: F('new-folder', 60032),
		fileDirectoryCreate: F('file-directory-create', 60032),
		trash: F('trash', 60033),
		trashcan: F('trashcan', 60033),
		history: F('history', 60034),
		clock: F('clock', 60034),
		folder: F('folder', 60035),
		fileDirectory: F('file-directory', 60035),
		symbolFolder: F('symbol-folder', 60035),
		logoGithub: F('logo-github', 60036),
		markGithub: F('mark-github', 60036),
		github: F('github', 60036),
		terminal: F('terminal', 60037),
		console: F('console', 60037),
		repl: F('repl', 60037),
		zap: F('zap', 60038),
		symbolEvent: F('symbol-event', 60038),
		error: F('error', 60039),
		stop: F('stop', 60039),
		variable: F('variable', 60040),
		symbolVariable: F('symbol-variable', 60040),
		array: F('array', 60042),
		symbolArray: F('symbol-array', 60042),
		symbolModule: F('symbol-module', 60043),
		symbolPackage: F('symbol-package', 60043),
		symbolNamespace: F('symbol-namespace', 60043),
		symbolObject: F('symbol-object', 60043),
		symbolMethod: F('symbol-method', 60044),
		symbolFunction: F('symbol-function', 60044),
		symbolConstructor: F('symbol-constructor', 60044),
		symbolBoolean: F('symbol-boolean', 60047),
		symbolNull: F('symbol-null', 60047),
		symbolNumeric: F('symbol-numeric', 60048),
		symbolNumber: F('symbol-number', 60048),
		symbolStructure: F('symbol-structure', 60049),
		symbolStruct: F('symbol-struct', 60049),
		symbolParameter: F('symbol-parameter', 60050),
		symbolTypeParameter: F('symbol-type-parameter', 60050),
		symbolKey: F('symbol-key', 60051),
		symbolText: F('symbol-text', 60051),
		symbolReference: F('symbol-reference', 60052),
		goToFile: F('go-to-file', 60052),
		symbolEnum: F('symbol-enum', 60053),
		symbolValue: F('symbol-value', 60053),
		symbolRuler: F('symbol-ruler', 60054),
		symbolUnit: F('symbol-unit', 60054),
		activateBreakpoints: F('activate-breakpoints', 60055),
		archive: F('archive', 60056),
		arrowBoth: F('arrow-both', 60057),
		arrowDown: F('arrow-down', 60058),
		arrowLeft: F('arrow-left', 60059),
		arrowRight: F('arrow-right', 60060),
		arrowSmallDown: F('arrow-small-down', 60061),
		arrowSmallLeft: F('arrow-small-left', 60062),
		arrowSmallRight: F('arrow-small-right', 60063),
		arrowSmallUp: F('arrow-small-up', 60064),
		arrowUp: F('arrow-up', 60065),
		bell: F('bell', 60066),
		bold: F('bold', 60067),
		book: F('book', 60068),
		bookmark: F('bookmark', 60069),
		debugBreakpointConditionalUnverified: F('debug-breakpoint-conditional-unverified', 60070),
		debugBreakpointConditional: F('debug-breakpoint-conditional', 60071),
		debugBreakpointConditionalDisabled: F('debug-breakpoint-conditional-disabled', 60071),
		debugBreakpointDataUnverified: F('debug-breakpoint-data-unverified', 60072),
		debugBreakpointData: F('debug-breakpoint-data', 60073),
		debugBreakpointDataDisabled: F('debug-breakpoint-data-disabled', 60073),
		debugBreakpointLogUnverified: F('debug-breakpoint-log-unverified', 60074),
		debugBreakpointLog: F('debug-breakpoint-log', 60075),
		debugBreakpointLogDisabled: F('debug-breakpoint-log-disabled', 60075),
		briefcase: F('briefcase', 60076),
		broadcast: F('broadcast', 60077),
		browser: F('browser', 60078),
		bug: F('bug', 60079),
		calendar: F('calendar', 60080),
		caseSensitive: F('case-sensitive', 60081),
		check: F('check', 60082),
		checklist: F('checklist', 60083),
		chevronDown: F('chevron-down', 60084),
		dropDownButton: F('drop-down-button', 60084),
		chevronLeft: F('chevron-left', 60085),
		chevronRight: F('chevron-right', 60086),
		chevronUp: F('chevron-up', 60087),
		chromeClose: F('chrome-close', 60088),
		chromeMaximize: F('chrome-maximize', 60089),
		chromeMinimize: F('chrome-minimize', 60090),
		chromeRestore: F('chrome-restore', 60091),
		circle: F('circle', 60092),
		circleOutline: F('circle-outline', 60092),
		debugBreakpointUnverified: F('debug-breakpoint-unverified', 60092),
		circleSlash: F('circle-slash', 60093),
		circuitBoard: F('circuit-board', 60094),
		clearAll: F('clear-all', 60095),
		clippy: F('clippy', 60096),
		closeAll: F('close-all', 60097),
		cloudDownload: F('cloud-download', 60098),
		cloudUpload: F('cloud-upload', 60099),
		code: F('code', 60100),
		collapseAll: F('collapse-all', 60101),
		colorMode: F('color-mode', 60102),
		commentDiscussion: F('comment-discussion', 60103),
		compareChanges: F('compare-changes', 60157),
		creditCard: F('credit-card', 60105),
		dash: F('dash', 60108),
		dashboard: F('dashboard', 60109),
		database: F('database', 60110),
		debugContinue: F('debug-continue', 60111),
		debugDisconnect: F('debug-disconnect', 60112),
		debugPause: F('debug-pause', 60113),
		debugRestart: F('debug-restart', 60114),
		debugStart: F('debug-start', 60115),
		debugStepInto: F('debug-step-into', 60116),
		debugStepOut: F('debug-step-out', 60117),
		debugStepOver: F('debug-step-over', 60118),
		debugStop: F('debug-stop', 60119),
		debug: F('debug', 60120),
		deviceCameraVideo: F('device-camera-video', 60121),
		deviceCamera: F('device-camera', 60122),
		deviceMobile: F('device-mobile', 60123),
		diffAdded: F('diff-added', 60124),
		diffIgnored: F('diff-ignored', 60125),
		diffModified: F('diff-modified', 60126),
		diffRemoved: F('diff-removed', 60127),
		diffRenamed: F('diff-renamed', 60128),
		diff: F('diff', 60129),
		discard: F('discard', 60130),
		editorLayout: F('editor-layout', 60131),
		emptyWindow: F('empty-window', 60132),
		exclude: F('exclude', 60133),
		extensions: F('extensions', 60134),
		eyeClosed: F('eye-closed', 60135),
		fileBinary: F('file-binary', 60136),
		fileCode: F('file-code', 60137),
		fileMedia: F('file-media', 60138),
		filePdf: F('file-pdf', 60139),
		fileSubmodule: F('file-submodule', 60140),
		fileSymlinkDirectory: F('file-symlink-directory', 60141),
		fileSymlinkFile: F('file-symlink-file', 60142),
		fileZip: F('file-zip', 60143),
		files: F('files', 60144),
		filter: F('filter', 60145),
		flame: F('flame', 60146),
		foldDown: F('fold-down', 60147),
		foldUp: F('fold-up', 60148),
		fold: F('fold', 60149),
		folderActive: F('folder-active', 60150),
		folderOpened: F('folder-opened', 60151),
		gear: F('gear', 60152),
		gift: F('gift', 60153),
		gistSecret: F('gist-secret', 60154),
		gist: F('gist', 60155),
		gitCommit: F('git-commit', 60156),
		gitCompare: F('git-compare', 60157),
		gitMerge: F('git-merge', 60158),
		githubAction: F('github-action', 60159),
		githubAlt: F('github-alt', 60160),
		globe: F('globe', 60161),
		grabber: F('grabber', 60162),
		graph: F('graph', 60163),
		gripper: F('gripper', 60164),
		heart: F('heart', 60165),
		home: F('home', 60166),
		horizontalRule: F('horizontal-rule', 60167),
		hubot: F('hubot', 60168),
		inbox: F('inbox', 60169),
		issueClosed: F('issue-closed', 60324),
		issueReopened: F('issue-reopened', 60171),
		issues: F('issues', 60172),
		italic: F('italic', 60173),
		jersey: F('jersey', 60174),
		json: F('json', 60175),
		bracket: F('bracket', 60175),
		kebabVertical: F('kebab-vertical', 60176),
		key: F('key', 60177),
		law: F('law', 60178),
		lightbulbAutofix: F('lightbulb-autofix', 60179),
		linkExternal: F('link-external', 60180),
		link: F('link', 60181),
		listOrdered: F('list-ordered', 60182),
		listUnordered: F('list-unordered', 60183),
		liveShare: F('live-share', 60184),
		loading: F('loading', 60185),
		location: F('location', 60186),
		mailRead: F('mail-read', 60187),
		mail: F('mail', 60188),
		markdown: F('markdown', 60189),
		megaphone: F('megaphone', 60190),
		mention: F('mention', 60191),
		milestone: F('milestone', 60192),
		gitPullRequestMilestone: F('git-pull-request-milestone', 60192),
		mortarBoard: F('mortar-board', 60193),
		move: F('move', 60194),
		multipleWindows: F('multiple-windows', 60195),
		mute: F('mute', 60196),
		noNewline: F('no-newline', 60197),
		note: F('note', 60198),
		octoface: F('octoface', 60199),
		openPreview: F('open-preview', 60200),
		package: F('package', 60201),
		paintcan: F('paintcan', 60202),
		pin: F('pin', 60203),
		play: F('play', 60204),
		run: F('run', 60204),
		plug: F('plug', 60205),
		preserveCase: F('preserve-case', 60206),
		preview: F('preview', 60207),
		project: F('project', 60208),
		pulse: F('pulse', 60209),
		question: F('question', 60210),
		quote: F('quote', 60211),
		radioTower: F('radio-tower', 60212),
		reactions: F('reactions', 60213),
		references: F('references', 60214),
		refresh: F('refresh', 60215),
		regex: F('regex', 60216),
		remoteExplorer: F('remote-explorer', 60217),
		remote: F('remote', 60218),
		remove: F('remove', 60219),
		replaceAll: F('replace-all', 60220),
		replace: F('replace', 60221),
		repoClone: F('repo-clone', 60222),
		repoForcePush: F('repo-force-push', 60223),
		repoPull: F('repo-pull', 60224),
		repoPush: F('repo-push', 60225),
		report: F('report', 60226),
		requestChanges: F('request-changes', 60227),
		rocket: F('rocket', 60228),
		rootFolderOpened: F('root-folder-opened', 60229),
		rootFolder: F('root-folder', 60230),
		rss: F('rss', 60231),
		ruby: F('ruby', 60232),
		saveAll: F('save-all', 60233),
		saveAs: F('save-as', 60234),
		save: F('save', 60235),
		screenFull: F('screen-full', 60236),
		screenNormal: F('screen-normal', 60237),
		searchStop: F('search-stop', 60238),
		server: F('server', 60240),
		settingsGear: F('settings-gear', 60241),
		settings: F('settings', 60242),
		shield: F('shield', 60243),
		smiley: F('smiley', 60244),
		sortPrecedence: F('sort-precedence', 60245),
		splitHorizontal: F('split-horizontal', 60246),
		splitVertical: F('split-vertical', 60247),
		squirrel: F('squirrel', 60248),
		starFull: F('star-full', 60249),
		starHalf: F('star-half', 60250),
		symbolClass: F('symbol-class', 60251),
		symbolColor: F('symbol-color', 60252),
		symbolCustomColor: F('symbol-customcolor', 60252),
		symbolConstant: F('symbol-constant', 60253),
		symbolEnumMember: F('symbol-enum-member', 60254),
		symbolField: F('symbol-field', 60255),
		symbolFile: F('symbol-file', 60256),
		symbolInterface: F('symbol-interface', 60257),
		symbolKeyword: F('symbol-keyword', 60258),
		symbolMisc: F('symbol-misc', 60259),
		symbolOperator: F('symbol-operator', 60260),
		symbolProperty: F('symbol-property', 60261),
		wrench: F('wrench', 60261),
		wrenchSubaction: F('wrench-subaction', 60261),
		symbolSnippet: F('symbol-snippet', 60262),
		tasklist: F('tasklist', 60263),
		telescope: F('telescope', 60264),
		textSize: F('text-size', 60265),
		threeBars: F('three-bars', 60266),
		thumbsdown: F('thumbsdown', 60267),
		thumbsup: F('thumbsup', 60268),
		tools: F('tools', 60269),
		triangleDown: F('triangle-down', 60270),
		triangleLeft: F('triangle-left', 60271),
		triangleRight: F('triangle-right', 60272),
		triangleUp: F('triangle-up', 60273),
		twitter: F('twitter', 60274),
		unfold: F('unfold', 60275),
		unlock: F('unlock', 60276),
		unmute: F('unmute', 60277),
		unverified: F('unverified', 60278),
		verified: F('verified', 60279),
		versions: F('versions', 60280),
		vmActive: F('vm-active', 60281),
		vmOutline: F('vm-outline', 60282),
		vmRunning: F('vm-running', 60283),
		watch: F('watch', 60284),
		whitespace: F('whitespace', 60285),
		wholeWord: F('whole-word', 60286),
		window: F('window', 60287),
		wordWrap: F('word-wrap', 60288),
		zoomIn: F('zoom-in', 60289),
		zoomOut: F('zoom-out', 60290),
		listFilter: F('list-filter', 60291),
		listFlat: F('list-flat', 60292),
		listSelection: F('list-selection', 60293),
		selection: F('selection', 60293),
		listTree: F('list-tree', 60294),
		debugBreakpointFunctionUnverified: F('debug-breakpoint-function-unverified', 60295),
		debugBreakpointFunction: F('debug-breakpoint-function', 60296),
		debugBreakpointFunctionDisabled: F('debug-breakpoint-function-disabled', 60296),
		debugStackframeActive: F('debug-stackframe-active', 60297),
		circleSmallFilled: F('circle-small-filled', 60298),
		debugStackframeDot: F('debug-stackframe-dot', 60298),
		debugStackframe: F('debug-stackframe', 60299),
		debugStackframeFocused: F('debug-stackframe-focused', 60299),
		debugBreakpointUnsupported: F('debug-breakpoint-unsupported', 60300),
		symbolString: F('symbol-string', 60301),
		debugReverseContinue: F('debug-reverse-continue', 60302),
		debugStepBack: F('debug-step-back', 60303),
		debugRestartFrame: F('debug-restart-frame', 60304),
		callIncoming: F('call-incoming', 60306),
		callOutgoing: F('call-outgoing', 60307),
		menu: F('menu', 60308),
		expandAll: F('expand-all', 60309),
		feedback: F('feedback', 60310),
		gitPullRequestReviewer: F('git-pull-request-reviewer', 60310),
		groupByRefType: F('group-by-ref-type', 60311),
		ungroupByRefType: F('ungroup-by-ref-type', 60312),
		account: F('account', 60313),
		gitPullRequestAssignee: F('git-pull-request-assignee', 60313),
		bellDot: F('bell-dot', 60314),
		debugConsole: F('debug-console', 60315),
		library: F('library', 60316),
		output: F('output', 60317),
		runAll: F('run-all', 60318),
		syncIgnored: F('sync-ignored', 60319),
		pinned: F('pinned', 60320),
		githubInverted: F('github-inverted', 60321),
		debugAlt: F('debug-alt', 60305),
		serverProcess: F('server-process', 60322),
		serverEnvironment: F('server-environment', 60323),
		pass: F('pass', 60324),
		stopCircle: F('stop-circle', 60325),
		playCircle: F('play-circle', 60326),
		record: F('record', 60327),
		debugAltSmall: F('debug-alt-small', 60328),
		vmConnect: F('vm-connect', 60329),
		cloud: F('cloud', 60330),
		merge: F('merge', 60331),
		exportIcon: F('export', 60332),
		graphLeft: F('graph-left', 60333),
		magnet: F('magnet', 60334),
		notebook: F('notebook', 60335),
		redo: F('redo', 60336),
		checkAll: F('check-all', 60337),
		pinnedDirty: F('pinned-dirty', 60338),
		passFilled: F('pass-filled', 60339),
		circleLargeFilled: F('circle-large-filled', 60340),
		circleLarge: F('circle-large', 60341),
		circleLargeOutline: F('circle-large-outline', 60341),
		combine: F('combine', 60342),
		gather: F('gather', 60342),
		table: F('table', 60343),
		variableGroup: F('variable-group', 60344),
		typeHierarchy: F('type-hierarchy', 60345),
		typeHierarchySub: F('type-hierarchy-sub', 60346),
		typeHierarchySuper: F('type-hierarchy-super', 60347),
		gitPullRequestCreate: F('git-pull-request-create', 60348),
		runAbove: F('run-above', 60349),
		runBelow: F('run-below', 60350),
		notebookTemplate: F('notebook-template', 60351),
		debugRerun: F('debug-rerun', 60352),
		workspaceTrusted: F('workspace-trusted', 60353),
		workspaceUntrusted: F('workspace-untrusted', 60354),
		workspaceUnspecified: F('workspace-unspecified', 60355),
		terminalCmd: F('terminal-cmd', 60356),
		terminalDebian: F('terminal-debian', 60357),
		terminalLinux: F('terminal-linux', 60358),
		terminalPowershell: F('terminal-powershell', 60359),
		terminalTmux: F('terminal-tmux', 60360),
		terminalUbuntu: F('terminal-ubuntu', 60361),
		terminalBash: F('terminal-bash', 60362),
		arrowSwap: F('arrow-swap', 60363),
		copy: F('copy', 60364),
		personAdd: F('person-add', 60365),
		filterFilled: F('filter-filled', 60366),
		wand: F('wand', 60367),
		debugLineByLine: F('debug-line-by-line', 60368),
		inspect: F('inspect', 60369),
		layers: F('layers', 60370),
		layersDot: F('layers-dot', 60371),
		layersActive: F('layers-active', 60372),
		compass: F('compass', 60373),
		compassDot: F('compass-dot', 60374),
		compassActive: F('compass-active', 60375),
		azure: F('azure', 60376),
		issueDraft: F('issue-draft', 60377),
		gitPullRequestClosed: F('git-pull-request-closed', 60378),
		gitPullRequestDraft: F('git-pull-request-draft', 60379),
		debugAll: F('debug-all', 60380),
		debugCoverage: F('debug-coverage', 60381),
		runErrors: F('run-errors', 60382),
		folderLibrary: F('folder-library', 60383),
		debugContinueSmall: F('debug-continue-small', 60384),
		beakerStop: F('beaker-stop', 60385),
		graphLine: F('graph-line', 60386),
		graphScatter: F('graph-scatter', 60387),
		pieChart: F('pie-chart', 60388),
		bracketDot: F('bracket-dot', 60389),
		bracketError: F('bracket-error', 60390),
		lockSmall: F('lock-small', 60391),
		azureDevops: F('azure-devops', 60392),
		verifiedFilled: F('verified-filled', 60393),
		newLine: F('newline', 60394),
		layout: F('layout', 60395),
		layoutActivitybarLeft: F('layout-activitybar-left', 60396),
		layoutActivitybarRight: F('layout-activitybar-right', 60397),
		layoutPanelLeft: F('layout-panel-left', 60398),
		layoutPanelCenter: F('layout-panel-center', 60399),
		layoutPanelJustify: F('layout-panel-justify', 60400),
		layoutPanelRight: F('layout-panel-right', 60401),
		layoutPanel: F('layout-panel', 60402),
		layoutSidebarLeft: F('layout-sidebar-left', 60403),
		layoutSidebarRight: F('layout-sidebar-right', 60404),
		layoutStatusbar: F('layout-statusbar', 60405),
		layoutMenubar: F('layout-menubar', 60406),
		layoutCentered: F('layout-centered', 60407),
		layoutSidebarRightOff: F('layout-sidebar-right-off', 60416),
		layoutPanelOff: F('layout-panel-off', 60417),
		layoutSidebarLeftOff: F('layout-sidebar-left-off', 60418),
		target: F('target', 60408),
		indent: F('indent', 60409),
		recordSmall: F('record-small', 60410),
		errorSmall: F('error-small', 60411),
		arrowCircleDown: F('arrow-circle-down', 60412),
		arrowCircleLeft: F('arrow-circle-left', 60413),
		arrowCircleRight: F('arrow-circle-right', 60414),
		arrowCircleUp: F('arrow-circle-up', 60415),
		heartFilled: F('heart-filled', 60420),
		map: F('map', 60421),
		mapFilled: F('map-filled', 60422),
		circleSmall: F('circle-small', 60423),
		bellSlash: F('bell-slash', 60424),
		bellSlashDot: F('bell-slash-dot', 60425),
		commentUnresolved: F('comment-unresolved', 60426),
		gitPullRequestGoToChanges: F('git-pull-request-go-to-changes', 60427),
		gitPullRequestNewChanges: F('git-pull-request-new-changes', 60428),
		searchFuzzy: F('search-fuzzy', 60429),
		commentDraft: F('comment-draft', 60430),
		send: F('send', 60431),
		sparkle: F('sparkle', 60432),
		insert: F('insert', 60433),
		mic: F('mic', 60434),
		dialogError: F('dialog-error', 'error'),
		dialogWarning: F('dialog-warning', 'warning'),
		dialogInfo: F('dialog-info', 'info'),
		dialogClose: F('dialog-close', 'close'),
		treeItemExpanded: F('tree-item-expanded', 'chevron-down'),
		treeFilterOnTypeOn: F('tree-filter-on-type-on', 'list-filter'),
		treeFilterOnTypeOff: F('tree-filter-on-type-off', 'list-selection'),
		treeFilterClear: F('tree-filter-clear', 'close'),
		treeItemLoading: F('tree-item-loading', 'loading'),
		menuSelection: F('menu-selection', 'check'),
		menuSubmenu: F('menu-submenu', 'chevron-right'),
		menuBarMore: F('menubar-more', 'more'),
		scrollbarButtonLeft: F('scrollbar-button-left', 'triangle-left'),
		scrollbarButtonRight: F('scrollbar-button-right', 'triangle-right'),
		scrollbarButtonUp: F('scrollbar-button-up', 'triangle-up'),
		scrollbarButtonDown: F('scrollbar-button-down', 'triangle-down'),
		toolBarMore: F('toolbar-more', 'more'),
		quickInputBack: F('quick-input-back', 'arrow-left')
	}
	var Sl = class {
			constructor() {
				;(this._tokenizationSupports = new Map()),
					(this._factories = new Map()),
					(this._onDidChange = new Hr()),
					(this.onDidChange = this._onDidChange.event),
					(this._colorMap = null)
			}
			handleChange(t) {
				this._onDidChange.fire({ changedLanguages: t, changedColorMap: !1 })
			}
			register(t, n) {
				return (
					this._tokenizationSupports.set(t, n),
					this.handleChange([t]),
					vs(() => {
						this._tokenizationSupports.get(t) === n &&
							(this._tokenizationSupports.delete(t), this.handleChange([t]))
					})
				)
			}
			get(t) {
				return this._tokenizationSupports.get(t) || null
			}
			registerFactory(t, n) {
				this._factories.get(t)?.dispose()
				let r = new cf(this, t, n)
				return (
					this._factories.set(t, r),
					vs(() => {
						let i = this._factories.get(t)
						!i || i !== r || (this._factories.delete(t), i.dispose())
					})
				)
			}
			async getOrCreate(t) {
				let n = this.get(t)
				if (n) return n
				let r = this._factories.get(t)
				return !r || r.isResolved ? null : (await r.resolve(), this.get(t))
			}
			isResolved(t) {
				if (this.get(t)) return !0
				let r = this._factories.get(t)
				return !!(!r || r.isResolved)
			}
			setColorMap(t) {
				;(this._colorMap = t),
					this._onDidChange.fire({
						changedLanguages: Array.from(this._tokenizationSupports.keys()),
						changedColorMap: !0
					})
			}
			getColorMap() {
				return this._colorMap
			}
			getDefaultBackground() {
				return this._colorMap && this._colorMap.length > 2 ? this._colorMap[2] : null
			}
		},
		cf = class extends _i {
			get isResolved() {
				return this._isResolved
			}
			constructor(t, n, r) {
				super(),
					(this._registry = t),
					(this._languageId = n),
					(this._factory = r),
					(this._isDisposed = !1),
					(this._resolvePromise = null),
					(this._isResolved = !1)
			}
			dispose() {
				;(this._isDisposed = !0), super.dispose()
			}
			async resolve() {
				return this._resolvePromise || (this._resolvePromise = this._create()), this._resolvePromise
			}
			async _create() {
				let t = await this._factory.tokenizationSupport
				;(this._isResolved = !0),
					t && !this._isDisposed && this._register(this._registry.register(this._languageId, t))
			}
		}
	var Nl = class {
		constructor(t, n, r) {
			;(this.offset = t), (this.type = n), (this.language = r), (this._tokenBrand = void 0)
		}
		toString() {
			return '(' + this.offset + ', ' + this.type + ')'
		}
	}
	var uh
	;(function (e) {
		let t = new Map()
		t.set(0, hn.symbolMethod),
			t.set(1, hn.symbolFunction),
			t.set(2, hn.symbolConstructor),
			t.set(3, hn.symbolField),
			t.set(4, hn.symbolVariable),
			t.set(5, hn.symbolClass),
			t.set(6, hn.symbolStruct),
			t.set(7, hn.symbolInterface),
			t.set(8, hn.symbolModule),
			t.set(9, hn.symbolProperty),
			t.set(10, hn.symbolEvent),
			t.set(11, hn.symbolOperator),
			t.set(12, hn.symbolUnit),
			t.set(13, hn.symbolValue),
			t.set(15, hn.symbolEnum),
			t.set(14, hn.symbolConstant),
			t.set(15, hn.symbolEnum),
			t.set(16, hn.symbolEnumMember),
			t.set(17, hn.symbolKeyword),
			t.set(27, hn.symbolSnippet),
			t.set(18, hn.symbolText),
			t.set(19, hn.symbolColor),
			t.set(20, hn.symbolFile),
			t.set(21, hn.symbolReference),
			t.set(22, hn.symbolCustomColor),
			t.set(23, hn.symbolFolder),
			t.set(24, hn.symbolTypeParameter),
			t.set(25, hn.account),
			t.set(26, hn.issues)
		function n(s) {
			let o = t.get(s)
			return (
				o ||
					(console.info('No codicon found for CompletionItemKind ' + s), (o = hn.symbolProperty)),
				o
			)
		}
		e.toIcon = n
		let r = new Map()
		r.set('method', 0),
			r.set('function', 1),
			r.set('constructor', 2),
			r.set('field', 3),
			r.set('variable', 4),
			r.set('class', 5),
			r.set('struct', 6),
			r.set('interface', 7),
			r.set('module', 8),
			r.set('property', 9),
			r.set('event', 10),
			r.set('operator', 11),
			r.set('unit', 12),
			r.set('value', 13),
			r.set('constant', 14),
			r.set('enum', 15),
			r.set('enum-member', 16),
			r.set('enumMember', 16),
			r.set('keyword', 17),
			r.set('snippet', 27),
			r.set('text', 18),
			r.set('color', 19),
			r.set('file', 20),
			r.set('reference', 21),
			r.set('customcolor', 22),
			r.set('folder', 23),
			r.set('type-parameter', 24),
			r.set('typeParameter', 24),
			r.set('account', 25),
			r.set('issue', 26)
		function i(s, o) {
			let a = r.get(s)
			return typeof a > 'u' && !o && (a = 9), a
		}
		e.fromString = i
	})(uh || (uh = {}))
	var lh
	;(function (e) {
		;(e[(e.Automatic = 0)] = 'Automatic'), (e[(e.Explicit = 1)] = 'Explicit')
	})(lh || (lh = {}))
	var ch
	;(function (e) {
		;(e[(e.Invoke = 1)] = 'Invoke'),
			(e[(e.TriggerCharacter = 2)] = 'TriggerCharacter'),
			(e[(e.ContentChange = 3)] = 'ContentChange')
	})(ch || (ch = {}))
	var ph
	;(function (e) {
		;(e[(e.Text = 0)] = 'Text'), (e[(e.Read = 1)] = 'Read'), (e[(e.Write = 2)] = 'Write')
	})(ph || (ph = {}))
	var J8 = {
		17: sr('vs/editor/common/languages', 'Array', 'array'),
		16: sr('vs/editor/common/languages', 'Boolean', 'boolean'),
		4: sr('vs/editor/common/languages', 'Class', 'class'),
		13: sr('vs/editor/common/languages', 'Constant', 'constant'),
		8: sr('vs/editor/common/languages', 'Constructor', 'constructor'),
		9: sr('vs/editor/common/languages', 'Enum', 'enumeration'),
		21: sr('vs/editor/common/languages', 'EnumMember', 'enumeration member'),
		23: sr('vs/editor/common/languages', 'Event', 'event'),
		7: sr('vs/editor/common/languages', 'Field', 'field'),
		0: sr('vs/editor/common/languages', 'File', 'file'),
		11: sr('vs/editor/common/languages', 'Function', 'function'),
		10: sr('vs/editor/common/languages', 'Interface', 'interface'),
		19: sr('vs/editor/common/languages', 'Key', 'key'),
		5: sr('vs/editor/common/languages', 'Method', 'method'),
		1: sr('vs/editor/common/languages', 'Module', 'module'),
		2: sr('vs/editor/common/languages', 'Namespace', 'namespace'),
		20: sr('vs/editor/common/languages', 'Null', 'null'),
		15: sr('vs/editor/common/languages', 'Number', 'number'),
		18: sr('vs/editor/common/languages', 'Object', 'object'),
		24: sr('vs/editor/common/languages', 'Operator', 'operator'),
		3: sr('vs/editor/common/languages', 'Package', 'package'),
		6: sr('vs/editor/common/languages', 'Property', 'property'),
		14: sr('vs/editor/common/languages', 'String', 'string'),
		22: sr('vs/editor/common/languages', 'Struct', 'struct'),
		25: sr('vs/editor/common/languages', 'TypeParameter', 'type parameter'),
		12: sr('vs/editor/common/languages', 'Variable', 'variable')
	}
	var fh
	;(function (e) {
		let t = new Map()
		t.set(0, hn.symbolFile),
			t.set(1, hn.symbolModule),
			t.set(2, hn.symbolNamespace),
			t.set(3, hn.symbolPackage),
			t.set(4, hn.symbolClass),
			t.set(5, hn.symbolMethod),
			t.set(6, hn.symbolProperty),
			t.set(7, hn.symbolField),
			t.set(8, hn.symbolConstructor),
			t.set(9, hn.symbolEnum),
			t.set(10, hn.symbolInterface),
			t.set(11, hn.symbolFunction),
			t.set(12, hn.symbolVariable),
			t.set(13, hn.symbolConstant),
			t.set(14, hn.symbolString),
			t.set(15, hn.symbolNumber),
			t.set(16, hn.symbolBoolean),
			t.set(17, hn.symbolArray),
			t.set(18, hn.symbolObject),
			t.set(19, hn.symbolKey),
			t.set(20, hn.symbolNull),
			t.set(21, hn.symbolEnumMember),
			t.set(22, hn.symbolStruct),
			t.set(23, hn.symbolEvent),
			t.set(24, hn.symbolOperator),
			t.set(25, hn.symbolTypeParameter)
		function n(r) {
			let i = t.get(r)
			return i || (console.info('No codicon found for SymbolKind ' + r), (i = hn.symbolProperty)), i
		}
		e.toIcon = n
	})(fh || (fh = {}))
	var _s = class e {
		static fromValue(t) {
			switch (t) {
				case 'comment':
					return e.Comment
				case 'imports':
					return e.Imports
				case 'region':
					return e.Region
			}
			return new e(t)
		}
		constructor(t) {
			this.value = t
		}
	}
	_s.Comment = new _s('comment')
	_s.Imports = new _s('imports')
	_s.Region = new _s('region')
	var dh
	;(function (e) {
		function t(n) {
			return !n || typeof n != 'object' ? !1 : typeof n.id == 'string' && typeof n.title == 'string'
		}
		e.is = t
	})(dh || (dh = {}))
	var hh
	;(function (e) {
		;(e[(e.Collapsed = 0)] = 'Collapsed'), (e[(e.Expanded = 1)] = 'Expanded')
	})(hh || (hh = {}))
	var mh
	;(function (e) {
		;(e[(e.Unresolved = 0)] = 'Unresolved'), (e[(e.Resolved = 1)] = 'Resolved')
	})(mh || (mh = {}))
	var gh
	;(function (e) {
		;(e[(e.Editing = 0)] = 'Editing'), (e[(e.Preview = 1)] = 'Preview')
	})(gh || (gh = {}))
	var Dh
	;(function (e) {
		;(e[(e.Published = 0)] = 'Published'), (e[(e.Draft = 1)] = 'Draft')
	})(Dh || (Dh = {}))
	var yh
	;(function (e) {
		;(e[(e.Type = 1)] = 'Type'), (e[(e.Parameter = 2)] = 'Parameter')
	})(yh || (yh = {}))
	var z8 = new Sl(),
		Eh
	;(function (e) {
		;(e[(e.None = 0)] = 'None'),
			(e[(e.Option = 1)] = 'Option'),
			(e[(e.Default = 2)] = 'Default'),
			(e[(e.Preferred = 3)] = 'Preferred')
	})(Eh || (Eh = {}))
	var vh
	;(function (e) {
		;(e[(e.Unknown = 0)] = 'Unknown'),
			(e[(e.Disabled = 1)] = 'Disabled'),
			(e[(e.Enabled = 2)] = 'Enabled')
	})(vh || (vh = {}))
	var xh
	;(function (e) {
		;(e[(e.Invoke = 1)] = 'Invoke'), (e[(e.Auto = 2)] = 'Auto')
	})(xh || (xh = {}))
	var bh
	;(function (e) {
		;(e[(e.None = 0)] = 'None'),
			(e[(e.KeepWhitespace = 1)] = 'KeepWhitespace'),
			(e[(e.InsertAsSnippet = 4)] = 'InsertAsSnippet')
	})(bh || (bh = {}))
	var Th
	;(function (e) {
		;(e[(e.Method = 0)] = 'Method'),
			(e[(e.Function = 1)] = 'Function'),
			(e[(e.Constructor = 2)] = 'Constructor'),
			(e[(e.Field = 3)] = 'Field'),
			(e[(e.Variable = 4)] = 'Variable'),
			(e[(e.Class = 5)] = 'Class'),
			(e[(e.Struct = 6)] = 'Struct'),
			(e[(e.Interface = 7)] = 'Interface'),
			(e[(e.Module = 8)] = 'Module'),
			(e[(e.Property = 9)] = 'Property'),
			(e[(e.Event = 10)] = 'Event'),
			(e[(e.Operator = 11)] = 'Operator'),
			(e[(e.Unit = 12)] = 'Unit'),
			(e[(e.Value = 13)] = 'Value'),
			(e[(e.Constant = 14)] = 'Constant'),
			(e[(e.Enum = 15)] = 'Enum'),
			(e[(e.EnumMember = 16)] = 'EnumMember'),
			(e[(e.Keyword = 17)] = 'Keyword'),
			(e[(e.Text = 18)] = 'Text'),
			(e[(e.Color = 19)] = 'Color'),
			(e[(e.File = 20)] = 'File'),
			(e[(e.Reference = 21)] = 'Reference'),
			(e[(e.Customcolor = 22)] = 'Customcolor'),
			(e[(e.Folder = 23)] = 'Folder'),
			(e[(e.TypeParameter = 24)] = 'TypeParameter'),
			(e[(e.User = 25)] = 'User'),
			(e[(e.Issue = 26)] = 'Issue'),
			(e[(e.Snippet = 27)] = 'Snippet')
	})(Th || (Th = {}))
	var Ah
	;(function (e) {
		e[(e.Deprecated = 1)] = 'Deprecated'
	})(Ah || (Ah = {}))
	var Ch
	;(function (e) {
		;(e[(e.Invoke = 0)] = 'Invoke'),
			(e[(e.TriggerCharacter = 1)] = 'TriggerCharacter'),
			(e[(e.TriggerForIncompleteCompletions = 2)] = 'TriggerForIncompleteCompletions')
	})(Ch || (Ch = {}))
	var Sh
	;(function (e) {
		;(e[(e.EXACT = 0)] = 'EXACT'), (e[(e.ABOVE = 1)] = 'ABOVE'), (e[(e.BELOW = 2)] = 'BELOW')
	})(Sh || (Sh = {}))
	var Nh
	;(function (e) {
		;(e[(e.NotSet = 0)] = 'NotSet'),
			(e[(e.ContentFlush = 1)] = 'ContentFlush'),
			(e[(e.RecoverFromMarkers = 2)] = 'RecoverFromMarkers'),
			(e[(e.Explicit = 3)] = 'Explicit'),
			(e[(e.Paste = 4)] = 'Paste'),
			(e[(e.Undo = 5)] = 'Undo'),
			(e[(e.Redo = 6)] = 'Redo')
	})(Nh || (Nh = {}))
	var Fh
	;(function (e) {
		;(e[(e.LF = 1)] = 'LF'), (e[(e.CRLF = 2)] = 'CRLF')
	})(Fh || (Fh = {}))
	var _h
	;(function (e) {
		;(e[(e.Text = 0)] = 'Text'), (e[(e.Read = 1)] = 'Read'), (e[(e.Write = 2)] = 'Write')
	})(_h || (_h = {}))
	var wh
	;(function (e) {
		;(e[(e.None = 0)] = 'None'),
			(e[(e.Keep = 1)] = 'Keep'),
			(e[(e.Brackets = 2)] = 'Brackets'),
			(e[(e.Advanced = 3)] = 'Advanced'),
			(e[(e.Full = 4)] = 'Full')
	})(wh || (wh = {}))
	var Lh
	;(function (e) {
		;(e[(e.acceptSuggestionOnCommitCharacter = 0)] = 'acceptSuggestionOnCommitCharacter'),
			(e[(e.acceptSuggestionOnEnter = 1)] = 'acceptSuggestionOnEnter'),
			(e[(e.accessibilitySupport = 2)] = 'accessibilitySupport'),
			(e[(e.accessibilityPageSize = 3)] = 'accessibilityPageSize'),
			(e[(e.ariaLabel = 4)] = 'ariaLabel'),
			(e[(e.ariaRequired = 5)] = 'ariaRequired'),
			(e[(e.autoClosingBrackets = 6)] = 'autoClosingBrackets'),
			(e[(e.autoClosingComments = 7)] = 'autoClosingComments'),
			(e[(e.screenReaderAnnounceInlineSuggestion = 8)] = 'screenReaderAnnounceInlineSuggestion'),
			(e[(e.autoClosingDelete = 9)] = 'autoClosingDelete'),
			(e[(e.autoClosingOvertype = 10)] = 'autoClosingOvertype'),
			(e[(e.autoClosingQuotes = 11)] = 'autoClosingQuotes'),
			(e[(e.autoIndent = 12)] = 'autoIndent'),
			(e[(e.automaticLayout = 13)] = 'automaticLayout'),
			(e[(e.autoSurround = 14)] = 'autoSurround'),
			(e[(e.bracketPairColorization = 15)] = 'bracketPairColorization'),
			(e[(e.guides = 16)] = 'guides'),
			(e[(e.codeLens = 17)] = 'codeLens'),
			(e[(e.codeLensFontFamily = 18)] = 'codeLensFontFamily'),
			(e[(e.codeLensFontSize = 19)] = 'codeLensFontSize'),
			(e[(e.colorDecorators = 20)] = 'colorDecorators'),
			(e[(e.colorDecoratorsLimit = 21)] = 'colorDecoratorsLimit'),
			(e[(e.columnSelection = 22)] = 'columnSelection'),
			(e[(e.comments = 23)] = 'comments'),
			(e[(e.contextmenu = 24)] = 'contextmenu'),
			(e[(e.copyWithSyntaxHighlighting = 25)] = 'copyWithSyntaxHighlighting'),
			(e[(e.cursorBlinking = 26)] = 'cursorBlinking'),
			(e[(e.cursorSmoothCaretAnimation = 27)] = 'cursorSmoothCaretAnimation'),
			(e[(e.cursorStyle = 28)] = 'cursorStyle'),
			(e[(e.cursorSurroundingLines = 29)] = 'cursorSurroundingLines'),
			(e[(e.cursorSurroundingLinesStyle = 30)] = 'cursorSurroundingLinesStyle'),
			(e[(e.cursorWidth = 31)] = 'cursorWidth'),
			(e[(e.disableLayerHinting = 32)] = 'disableLayerHinting'),
			(e[(e.disableMonospaceOptimizations = 33)] = 'disableMonospaceOptimizations'),
			(e[(e.domReadOnly = 34)] = 'domReadOnly'),
			(e[(e.dragAndDrop = 35)] = 'dragAndDrop'),
			(e[(e.dropIntoEditor = 36)] = 'dropIntoEditor'),
			(e[(e.emptySelectionClipboard = 37)] = 'emptySelectionClipboard'),
			(e[(e.experimentalWhitespaceRendering = 38)] = 'experimentalWhitespaceRendering'),
			(e[(e.extraEditorClassName = 39)] = 'extraEditorClassName'),
			(e[(e.fastScrollSensitivity = 40)] = 'fastScrollSensitivity'),
			(e[(e.find = 41)] = 'find'),
			(e[(e.fixedOverflowWidgets = 42)] = 'fixedOverflowWidgets'),
			(e[(e.folding = 43)] = 'folding'),
			(e[(e.foldingStrategy = 44)] = 'foldingStrategy'),
			(e[(e.foldingHighlight = 45)] = 'foldingHighlight'),
			(e[(e.foldingImportsByDefault = 46)] = 'foldingImportsByDefault'),
			(e[(e.foldingMaximumRegions = 47)] = 'foldingMaximumRegions'),
			(e[(e.unfoldOnClickAfterEndOfLine = 48)] = 'unfoldOnClickAfterEndOfLine'),
			(e[(e.fontFamily = 49)] = 'fontFamily'),
			(e[(e.fontInfo = 50)] = 'fontInfo'),
			(e[(e.fontLigatures = 51)] = 'fontLigatures'),
			(e[(e.fontSize = 52)] = 'fontSize'),
			(e[(e.fontWeight = 53)] = 'fontWeight'),
			(e[(e.fontVariations = 54)] = 'fontVariations'),
			(e[(e.formatOnPaste = 55)] = 'formatOnPaste'),
			(e[(e.formatOnType = 56)] = 'formatOnType'),
			(e[(e.glyphMargin = 57)] = 'glyphMargin'),
			(e[(e.gotoLocation = 58)] = 'gotoLocation'),
			(e[(e.hideCursorInOverviewRuler = 59)] = 'hideCursorInOverviewRuler'),
			(e[(e.hover = 60)] = 'hover'),
			(e[(e.inDiffEditor = 61)] = 'inDiffEditor'),
			(e[(e.inlineSuggest = 62)] = 'inlineSuggest'),
			(e[(e.letterSpacing = 63)] = 'letterSpacing'),
			(e[(e.lightbulb = 64)] = 'lightbulb'),
			(e[(e.lineDecorationsWidth = 65)] = 'lineDecorationsWidth'),
			(e[(e.lineHeight = 66)] = 'lineHeight'),
			(e[(e.lineNumbers = 67)] = 'lineNumbers'),
			(e[(e.lineNumbersMinChars = 68)] = 'lineNumbersMinChars'),
			(e[(e.linkedEditing = 69)] = 'linkedEditing'),
			(e[(e.links = 70)] = 'links'),
			(e[(e.matchBrackets = 71)] = 'matchBrackets'),
			(e[(e.minimap = 72)] = 'minimap'),
			(e[(e.mouseStyle = 73)] = 'mouseStyle'),
			(e[(e.mouseWheelScrollSensitivity = 74)] = 'mouseWheelScrollSensitivity'),
			(e[(e.mouseWheelZoom = 75)] = 'mouseWheelZoom'),
			(e[(e.multiCursorMergeOverlapping = 76)] = 'multiCursorMergeOverlapping'),
			(e[(e.multiCursorModifier = 77)] = 'multiCursorModifier'),
			(e[(e.multiCursorPaste = 78)] = 'multiCursorPaste'),
			(e[(e.multiCursorLimit = 79)] = 'multiCursorLimit'),
			(e[(e.occurrencesHighlight = 80)] = 'occurrencesHighlight'),
			(e[(e.overviewRulerBorder = 81)] = 'overviewRulerBorder'),
			(e[(e.overviewRulerLanes = 82)] = 'overviewRulerLanes'),
			(e[(e.padding = 83)] = 'padding'),
			(e[(e.pasteAs = 84)] = 'pasteAs'),
			(e[(e.parameterHints = 85)] = 'parameterHints'),
			(e[(e.peekWidgetDefaultFocus = 86)] = 'peekWidgetDefaultFocus'),
			(e[(e.definitionLinkOpensInPeek = 87)] = 'definitionLinkOpensInPeek'),
			(e[(e.quickSuggestions = 88)] = 'quickSuggestions'),
			(e[(e.quickSuggestionsDelay = 89)] = 'quickSuggestionsDelay'),
			(e[(e.readOnly = 90)] = 'readOnly'),
			(e[(e.readOnlyMessage = 91)] = 'readOnlyMessage'),
			(e[(e.renameOnType = 92)] = 'renameOnType'),
			(e[(e.renderControlCharacters = 93)] = 'renderControlCharacters'),
			(e[(e.renderFinalNewline = 94)] = 'renderFinalNewline'),
			(e[(e.renderLineHighlight = 95)] = 'renderLineHighlight'),
			(e[(e.renderLineHighlightOnlyWhenFocus = 96)] = 'renderLineHighlightOnlyWhenFocus'),
			(e[(e.renderValidationDecorations = 97)] = 'renderValidationDecorations'),
			(e[(e.renderWhitespace = 98)] = 'renderWhitespace'),
			(e[(e.revealHorizontalRightPadding = 99)] = 'revealHorizontalRightPadding'),
			(e[(e.roundedSelection = 100)] = 'roundedSelection'),
			(e[(e.rulers = 101)] = 'rulers'),
			(e[(e.scrollbar = 102)] = 'scrollbar'),
			(e[(e.scrollBeyondLastColumn = 103)] = 'scrollBeyondLastColumn'),
			(e[(e.scrollBeyondLastLine = 104)] = 'scrollBeyondLastLine'),
			(e[(e.scrollPredominantAxis = 105)] = 'scrollPredominantAxis'),
			(e[(e.selectionClipboard = 106)] = 'selectionClipboard'),
			(e[(e.selectionHighlight = 107)] = 'selectionHighlight'),
			(e[(e.selectOnLineNumbers = 108)] = 'selectOnLineNumbers'),
			(e[(e.showFoldingControls = 109)] = 'showFoldingControls'),
			(e[(e.showUnused = 110)] = 'showUnused'),
			(e[(e.snippetSuggestions = 111)] = 'snippetSuggestions'),
			(e[(e.smartSelect = 112)] = 'smartSelect'),
			(e[(e.smoothScrolling = 113)] = 'smoothScrolling'),
			(e[(e.stickyScroll = 114)] = 'stickyScroll'),
			(e[(e.stickyTabStops = 115)] = 'stickyTabStops'),
			(e[(e.stopRenderingLineAfter = 116)] = 'stopRenderingLineAfter'),
			(e[(e.suggest = 117)] = 'suggest'),
			(e[(e.suggestFontSize = 118)] = 'suggestFontSize'),
			(e[(e.suggestLineHeight = 119)] = 'suggestLineHeight'),
			(e[(e.suggestOnTriggerCharacters = 120)] = 'suggestOnTriggerCharacters'),
			(e[(e.suggestSelection = 121)] = 'suggestSelection'),
			(e[(e.tabCompletion = 122)] = 'tabCompletion'),
			(e[(e.tabIndex = 123)] = 'tabIndex'),
			(e[(e.unicodeHighlighting = 124)] = 'unicodeHighlighting'),
			(e[(e.unusualLineTerminators = 125)] = 'unusualLineTerminators'),
			(e[(e.useShadowDOM = 126)] = 'useShadowDOM'),
			(e[(e.useTabStops = 127)] = 'useTabStops'),
			(e[(e.wordBreak = 128)] = 'wordBreak'),
			(e[(e.wordSeparators = 129)] = 'wordSeparators'),
			(e[(e.wordWrap = 130)] = 'wordWrap'),
			(e[(e.wordWrapBreakAfterCharacters = 131)] = 'wordWrapBreakAfterCharacters'),
			(e[(e.wordWrapBreakBeforeCharacters = 132)] = 'wordWrapBreakBeforeCharacters'),
			(e[(e.wordWrapColumn = 133)] = 'wordWrapColumn'),
			(e[(e.wordWrapOverride1 = 134)] = 'wordWrapOverride1'),
			(e[(e.wordWrapOverride2 = 135)] = 'wordWrapOverride2'),
			(e[(e.wrappingIndent = 136)] = 'wrappingIndent'),
			(e[(e.wrappingStrategy = 137)] = 'wrappingStrategy'),
			(e[(e.showDeprecated = 138)] = 'showDeprecated'),
			(e[(e.inlayHints = 139)] = 'inlayHints'),
			(e[(e.editorClassName = 140)] = 'editorClassName'),
			(e[(e.pixelRatio = 141)] = 'pixelRatio'),
			(e[(e.tabFocusMode = 142)] = 'tabFocusMode'),
			(e[(e.layoutInfo = 143)] = 'layoutInfo'),
			(e[(e.wrappingInfo = 144)] = 'wrappingInfo'),
			(e[(e.defaultColorDecorators = 145)] = 'defaultColorDecorators'),
			(e[(e.colorDecoratorsActivatedOn = 146)] = 'colorDecoratorsActivatedOn'),
			(e[(e.inlineCompletionsAccessibilityVerbose = 147)] = 'inlineCompletionsAccessibilityVerbose')
	})(Lh || (Lh = {}))
	var Ih
	;(function (e) {
		;(e[(e.TextDefined = 0)] = 'TextDefined'), (e[(e.LF = 1)] = 'LF'), (e[(e.CRLF = 2)] = 'CRLF')
	})(Ih || (Ih = {}))
	var kh
	;(function (e) {
		;(e[(e.LF = 0)] = 'LF'), (e[(e.CRLF = 1)] = 'CRLF')
	})(kh || (kh = {}))
	var Rh
	;(function (e) {
		;(e[(e.Left = 1)] = 'Left'), (e[(e.Right = 2)] = 'Right')
	})(Rh || (Rh = {}))
	var Oh
	;(function (e) {
		;(e[(e.None = 0)] = 'None'),
			(e[(e.Indent = 1)] = 'Indent'),
			(e[(e.IndentOutdent = 2)] = 'IndentOutdent'),
			(e[(e.Outdent = 3)] = 'Outdent')
	})(Oh || (Oh = {}))
	var Bh
	;(function (e) {
		;(e[(e.Both = 0)] = 'Both'),
			(e[(e.Right = 1)] = 'Right'),
			(e[(e.Left = 2)] = 'Left'),
			(e[(e.None = 3)] = 'None')
	})(Bh || (Bh = {}))
	var Ph
	;(function (e) {
		;(e[(e.Type = 1)] = 'Type'), (e[(e.Parameter = 2)] = 'Parameter')
	})(Ph || (Ph = {}))
	var Mh
	;(function (e) {
		;(e[(e.Automatic = 0)] = 'Automatic'), (e[(e.Explicit = 1)] = 'Explicit')
	})(Mh || (Mh = {}))
	var Fl
	;(function (e) {
		;(e[(e.DependsOnKbLayout = -1)] = 'DependsOnKbLayout'),
			(e[(e.Unknown = 0)] = 'Unknown'),
			(e[(e.Backspace = 1)] = 'Backspace'),
			(e[(e.Tab = 2)] = 'Tab'),
			(e[(e.Enter = 3)] = 'Enter'),
			(e[(e.Shift = 4)] = 'Shift'),
			(e[(e.Ctrl = 5)] = 'Ctrl'),
			(e[(e.Alt = 6)] = 'Alt'),
			(e[(e.PauseBreak = 7)] = 'PauseBreak'),
			(e[(e.CapsLock = 8)] = 'CapsLock'),
			(e[(e.Escape = 9)] = 'Escape'),
			(e[(e.Space = 10)] = 'Space'),
			(e[(e.PageUp = 11)] = 'PageUp'),
			(e[(e.PageDown = 12)] = 'PageDown'),
			(e[(e.End = 13)] = 'End'),
			(e[(e.Home = 14)] = 'Home'),
			(e[(e.LeftArrow = 15)] = 'LeftArrow'),
			(e[(e.UpArrow = 16)] = 'UpArrow'),
			(e[(e.RightArrow = 17)] = 'RightArrow'),
			(e[(e.DownArrow = 18)] = 'DownArrow'),
			(e[(e.Insert = 19)] = 'Insert'),
			(e[(e.Delete = 20)] = 'Delete'),
			(e[(e.Digit0 = 21)] = 'Digit0'),
			(e[(e.Digit1 = 22)] = 'Digit1'),
			(e[(e.Digit2 = 23)] = 'Digit2'),
			(e[(e.Digit3 = 24)] = 'Digit3'),
			(e[(e.Digit4 = 25)] = 'Digit4'),
			(e[(e.Digit5 = 26)] = 'Digit5'),
			(e[(e.Digit6 = 27)] = 'Digit6'),
			(e[(e.Digit7 = 28)] = 'Digit7'),
			(e[(e.Digit8 = 29)] = 'Digit8'),
			(e[(e.Digit9 = 30)] = 'Digit9'),
			(e[(e.KeyA = 31)] = 'KeyA'),
			(e[(e.KeyB = 32)] = 'KeyB'),
			(e[(e.KeyC = 33)] = 'KeyC'),
			(e[(e.KeyD = 34)] = 'KeyD'),
			(e[(e.KeyE = 35)] = 'KeyE'),
			(e[(e.KeyF = 36)] = 'KeyF'),
			(e[(e.KeyG = 37)] = 'KeyG'),
			(e[(e.KeyH = 38)] = 'KeyH'),
			(e[(e.KeyI = 39)] = 'KeyI'),
			(e[(e.KeyJ = 40)] = 'KeyJ'),
			(e[(e.KeyK = 41)] = 'KeyK'),
			(e[(e.KeyL = 42)] = 'KeyL'),
			(e[(e.KeyM = 43)] = 'KeyM'),
			(e[(e.KeyN = 44)] = 'KeyN'),
			(e[(e.KeyO = 45)] = 'KeyO'),
			(e[(e.KeyP = 46)] = 'KeyP'),
			(e[(e.KeyQ = 47)] = 'KeyQ'),
			(e[(e.KeyR = 48)] = 'KeyR'),
			(e[(e.KeyS = 49)] = 'KeyS'),
			(e[(e.KeyT = 50)] = 'KeyT'),
			(e[(e.KeyU = 51)] = 'KeyU'),
			(e[(e.KeyV = 52)] = 'KeyV'),
			(e[(e.KeyW = 53)] = 'KeyW'),
			(e[(e.KeyX = 54)] = 'KeyX'),
			(e[(e.KeyY = 55)] = 'KeyY'),
			(e[(e.KeyZ = 56)] = 'KeyZ'),
			(e[(e.Meta = 57)] = 'Meta'),
			(e[(e.ContextMenu = 58)] = 'ContextMenu'),
			(e[(e.F1 = 59)] = 'F1'),
			(e[(e.F2 = 60)] = 'F2'),
			(e[(e.F3 = 61)] = 'F3'),
			(e[(e.F4 = 62)] = 'F4'),
			(e[(e.F5 = 63)] = 'F5'),
			(e[(e.F6 = 64)] = 'F6'),
			(e[(e.F7 = 65)] = 'F7'),
			(e[(e.F8 = 66)] = 'F8'),
			(e[(e.F9 = 67)] = 'F9'),
			(e[(e.F10 = 68)] = 'F10'),
			(e[(e.F11 = 69)] = 'F11'),
			(e[(e.F12 = 70)] = 'F12'),
			(e[(e.F13 = 71)] = 'F13'),
			(e[(e.F14 = 72)] = 'F14'),
			(e[(e.F15 = 73)] = 'F15'),
			(e[(e.F16 = 74)] = 'F16'),
			(e[(e.F17 = 75)] = 'F17'),
			(e[(e.F18 = 76)] = 'F18'),
			(e[(e.F19 = 77)] = 'F19'),
			(e[(e.F20 = 78)] = 'F20'),
			(e[(e.F21 = 79)] = 'F21'),
			(e[(e.F22 = 80)] = 'F22'),
			(e[(e.F23 = 81)] = 'F23'),
			(e[(e.F24 = 82)] = 'F24'),
			(e[(e.NumLock = 83)] = 'NumLock'),
			(e[(e.ScrollLock = 84)] = 'ScrollLock'),
			(e[(e.Semicolon = 85)] = 'Semicolon'),
			(e[(e.Equal = 86)] = 'Equal'),
			(e[(e.Comma = 87)] = 'Comma'),
			(e[(e.Minus = 88)] = 'Minus'),
			(e[(e.Period = 89)] = 'Period'),
			(e[(e.Slash = 90)] = 'Slash'),
			(e[(e.Backquote = 91)] = 'Backquote'),
			(e[(e.BracketLeft = 92)] = 'BracketLeft'),
			(e[(e.Backslash = 93)] = 'Backslash'),
			(e[(e.BracketRight = 94)] = 'BracketRight'),
			(e[(e.Quote = 95)] = 'Quote'),
			(e[(e.OEM_8 = 96)] = 'OEM_8'),
			(e[(e.IntlBackslash = 97)] = 'IntlBackslash'),
			(e[(e.Numpad0 = 98)] = 'Numpad0'),
			(e[(e.Numpad1 = 99)] = 'Numpad1'),
			(e[(e.Numpad2 = 100)] = 'Numpad2'),
			(e[(e.Numpad3 = 101)] = 'Numpad3'),
			(e[(e.Numpad4 = 102)] = 'Numpad4'),
			(e[(e.Numpad5 = 103)] = 'Numpad5'),
			(e[(e.Numpad6 = 104)] = 'Numpad6'),
			(e[(e.Numpad7 = 105)] = 'Numpad7'),
			(e[(e.Numpad8 = 106)] = 'Numpad8'),
			(e[(e.Numpad9 = 107)] = 'Numpad9'),
			(e[(e.NumpadMultiply = 108)] = 'NumpadMultiply'),
			(e[(e.NumpadAdd = 109)] = 'NumpadAdd'),
			(e[(e.NUMPAD_SEPARATOR = 110)] = 'NUMPAD_SEPARATOR'),
			(e[(e.NumpadSubtract = 111)] = 'NumpadSubtract'),
			(e[(e.NumpadDecimal = 112)] = 'NumpadDecimal'),
			(e[(e.NumpadDivide = 113)] = 'NumpadDivide'),
			(e[(e.KEY_IN_COMPOSITION = 114)] = 'KEY_IN_COMPOSITION'),
			(e[(e.ABNT_C1 = 115)] = 'ABNT_C1'),
			(e[(e.ABNT_C2 = 116)] = 'ABNT_C2'),
			(e[(e.AudioVolumeMute = 117)] = 'AudioVolumeMute'),
			(e[(e.AudioVolumeUp = 118)] = 'AudioVolumeUp'),
			(e[(e.AudioVolumeDown = 119)] = 'AudioVolumeDown'),
			(e[(e.BrowserSearch = 120)] = 'BrowserSearch'),
			(e[(e.BrowserHome = 121)] = 'BrowserHome'),
			(e[(e.BrowserBack = 122)] = 'BrowserBack'),
			(e[(e.BrowserForward = 123)] = 'BrowserForward'),
			(e[(e.MediaTrackNext = 124)] = 'MediaTrackNext'),
			(e[(e.MediaTrackPrevious = 125)] = 'MediaTrackPrevious'),
			(e[(e.MediaStop = 126)] = 'MediaStop'),
			(e[(e.MediaPlayPause = 127)] = 'MediaPlayPause'),
			(e[(e.LaunchMediaPlayer = 128)] = 'LaunchMediaPlayer'),
			(e[(e.LaunchMail = 129)] = 'LaunchMail'),
			(e[(e.LaunchApp2 = 130)] = 'LaunchApp2'),
			(e[(e.Clear = 131)] = 'Clear'),
			(e[(e.MAX_VALUE = 132)] = 'MAX_VALUE')
	})(Fl || (Fl = {}))
	var _l
	;(function (e) {
		;(e[(e.Hint = 1)] = 'Hint'),
			(e[(e.Info = 2)] = 'Info'),
			(e[(e.Warning = 4)] = 'Warning'),
			(e[(e.Error = 8)] = 'Error')
	})(_l || (_l = {}))
	var wl
	;(function (e) {
		;(e[(e.Unnecessary = 1)] = 'Unnecessary'), (e[(e.Deprecated = 2)] = 'Deprecated')
	})(wl || (wl = {}))
	var jh
	;(function (e) {
		;(e[(e.Inline = 1)] = 'Inline'), (e[(e.Gutter = 2)] = 'Gutter')
	})(jh || (jh = {}))
	var $h
	;(function (e) {
		;(e[(e.UNKNOWN = 0)] = 'UNKNOWN'),
			(e[(e.TEXTAREA = 1)] = 'TEXTAREA'),
			(e[(e.GUTTER_GLYPH_MARGIN = 2)] = 'GUTTER_GLYPH_MARGIN'),
			(e[(e.GUTTER_LINE_NUMBERS = 3)] = 'GUTTER_LINE_NUMBERS'),
			(e[(e.GUTTER_LINE_DECORATIONS = 4)] = 'GUTTER_LINE_DECORATIONS'),
			(e[(e.GUTTER_VIEW_ZONE = 5)] = 'GUTTER_VIEW_ZONE'),
			(e[(e.CONTENT_TEXT = 6)] = 'CONTENT_TEXT'),
			(e[(e.CONTENT_EMPTY = 7)] = 'CONTENT_EMPTY'),
			(e[(e.CONTENT_VIEW_ZONE = 8)] = 'CONTENT_VIEW_ZONE'),
			(e[(e.CONTENT_WIDGET = 9)] = 'CONTENT_WIDGET'),
			(e[(e.OVERVIEW_RULER = 10)] = 'OVERVIEW_RULER'),
			(e[(e.SCROLLBAR = 11)] = 'SCROLLBAR'),
			(e[(e.OVERLAY_WIDGET = 12)] = 'OVERLAY_WIDGET'),
			(e[(e.OUTSIDE_EDITOR = 13)] = 'OUTSIDE_EDITOR')
	})($h || ($h = {}))
	var Vh
	;(function (e) {
		;(e[(e.TOP_RIGHT_CORNER = 0)] = 'TOP_RIGHT_CORNER'),
			(e[(e.BOTTOM_RIGHT_CORNER = 1)] = 'BOTTOM_RIGHT_CORNER'),
			(e[(e.TOP_CENTER = 2)] = 'TOP_CENTER')
	})(Vh || (Vh = {}))
	var Uh
	;(function (e) {
		;(e[(e.Left = 1)] = 'Left'),
			(e[(e.Center = 2)] = 'Center'),
			(e[(e.Right = 4)] = 'Right'),
			(e[(e.Full = 7)] = 'Full')
	})(Uh || (Uh = {}))
	var qh
	;(function (e) {
		;(e[(e.Left = 0)] = 'Left'),
			(e[(e.Right = 1)] = 'Right'),
			(e[(e.None = 2)] = 'None'),
			(e[(e.LeftOfInjectedText = 3)] = 'LeftOfInjectedText'),
			(e[(e.RightOfInjectedText = 4)] = 'RightOfInjectedText')
	})(qh || (qh = {}))
	var Gh
	;(function (e) {
		;(e[(e.Off = 0)] = 'Off'),
			(e[(e.On = 1)] = 'On'),
			(e[(e.Relative = 2)] = 'Relative'),
			(e[(e.Interval = 3)] = 'Interval'),
			(e[(e.Custom = 4)] = 'Custom')
	})(Gh || (Gh = {}))
	var Wh
	;(function (e) {
		;(e[(e.None = 0)] = 'None'), (e[(e.Text = 1)] = 'Text'), (e[(e.Blocks = 2)] = 'Blocks')
	})(Wh || (Wh = {}))
	var Hh
	;(function (e) {
		;(e[(e.Smooth = 0)] = 'Smooth'), (e[(e.Immediate = 1)] = 'Immediate')
	})(Hh || (Hh = {}))
	var Jh
	;(function (e) {
		;(e[(e.Auto = 1)] = 'Auto'), (e[(e.Hidden = 2)] = 'Hidden'), (e[(e.Visible = 3)] = 'Visible')
	})(Jh || (Jh = {}))
	var Ll
	;(function (e) {
		;(e[(e.LTR = 0)] = 'LTR'), (e[(e.RTL = 1)] = 'RTL')
	})(Ll || (Ll = {}))
	var zh
	;(function (e) {
		;(e[(e.Invoke = 1)] = 'Invoke'),
			(e[(e.TriggerCharacter = 2)] = 'TriggerCharacter'),
			(e[(e.ContentChange = 3)] = 'ContentChange')
	})(zh || (zh = {}))
	var Qh
	;(function (e) {
		;(e[(e.File = 0)] = 'File'),
			(e[(e.Module = 1)] = 'Module'),
			(e[(e.Namespace = 2)] = 'Namespace'),
			(e[(e.Package = 3)] = 'Package'),
			(e[(e.Class = 4)] = 'Class'),
			(e[(e.Method = 5)] = 'Method'),
			(e[(e.Property = 6)] = 'Property'),
			(e[(e.Field = 7)] = 'Field'),
			(e[(e.Constructor = 8)] = 'Constructor'),
			(e[(e.Enum = 9)] = 'Enum'),
			(e[(e.Interface = 10)] = 'Interface'),
			(e[(e.Function = 11)] = 'Function'),
			(e[(e.Variable = 12)] = 'Variable'),
			(e[(e.Constant = 13)] = 'Constant'),
			(e[(e.String = 14)] = 'String'),
			(e[(e.Number = 15)] = 'Number'),
			(e[(e.Boolean = 16)] = 'Boolean'),
			(e[(e.Array = 17)] = 'Array'),
			(e[(e.Object = 18)] = 'Object'),
			(e[(e.Key = 19)] = 'Key'),
			(e[(e.Null = 20)] = 'Null'),
			(e[(e.EnumMember = 21)] = 'EnumMember'),
			(e[(e.Struct = 22)] = 'Struct'),
			(e[(e.Event = 23)] = 'Event'),
			(e[(e.Operator = 24)] = 'Operator'),
			(e[(e.TypeParameter = 25)] = 'TypeParameter')
	})(Qh || (Qh = {}))
	var Yh
	;(function (e) {
		e[(e.Deprecated = 1)] = 'Deprecated'
	})(Yh || (Yh = {}))
	var Xh
	;(function (e) {
		;(e[(e.Hidden = 0)] = 'Hidden'),
			(e[(e.Blink = 1)] = 'Blink'),
			(e[(e.Smooth = 2)] = 'Smooth'),
			(e[(e.Phase = 3)] = 'Phase'),
			(e[(e.Expand = 4)] = 'Expand'),
			(e[(e.Solid = 5)] = 'Solid')
	})(Xh || (Xh = {}))
	var Kh
	;(function (e) {
		;(e[(e.Line = 1)] = 'Line'),
			(e[(e.Block = 2)] = 'Block'),
			(e[(e.Underline = 3)] = 'Underline'),
			(e[(e.LineThin = 4)] = 'LineThin'),
			(e[(e.BlockOutline = 5)] = 'BlockOutline'),
			(e[(e.UnderlineThin = 6)] = 'UnderlineThin')
	})(Kh || (Kh = {}))
	var Zh
	;(function (e) {
		;(e[(e.AlwaysGrowsWhenTypingAtEdges = 0)] = 'AlwaysGrowsWhenTypingAtEdges'),
			(e[(e.NeverGrowsWhenTypingAtEdges = 1)] = 'NeverGrowsWhenTypingAtEdges'),
			(e[(e.GrowsOnlyWhenTypingBefore = 2)] = 'GrowsOnlyWhenTypingBefore'),
			(e[(e.GrowsOnlyWhenTypingAfter = 3)] = 'GrowsOnlyWhenTypingAfter')
	})(Zh || (Zh = {}))
	var em
	;(function (e) {
		;(e[(e.None = 0)] = 'None'),
			(e[(e.Same = 1)] = 'Same'),
			(e[(e.Indent = 2)] = 'Indent'),
			(e[(e.DeepIndent = 3)] = 'DeepIndent')
	})(em || (em = {}))
	var Qs = class {
		static chord(t, n) {
			return oh(t, n)
		}
	}
	Qs.CtrlCmd = 2048
	Qs.Shift = 1024
	Qs.Alt = 512
	Qs.WinCtrl = 256
	function tm() {
		return {
			editor: void 0,
			languages: void 0,
			CancellationTokenSource: Wa,
			Emitter: Hr,
			KeyCode: Fl,
			KeyMod: Qs,
			Position: Rr,
			Range: Wn,
			Selection: Cl,
			SelectionDirection: Ll,
			MarkerSeverity: _l,
			MarkerTag: wl,
			Uri: Fs,
			Token: Nl
		}
	}
	var pf = class extends Oo {
		constructor(t) {
			super(0)
			for (let n = 0, r = t.length; n < r; n++) this.set(t.charCodeAt(n), 2)
			this.set(32, 1), this.set(9, 1)
		}
	}
	function Rv(e) {
		let t = {}
		return (n) => (t.hasOwnProperty(n) || (t[n] = e(n)), t[n])
	}
	var Ov = Rv((e) => new pf(e))
	var nm
	;(function (e) {
		;(e[(e.Left = 1)] = 'Left'),
			(e[(e.Center = 2)] = 'Center'),
			(e[(e.Right = 4)] = 'Right'),
			(e[(e.Full = 7)] = 'Full')
	})(nm || (nm = {}))
	var rm
	;(function (e) {
		;(e[(e.Left = 1)] = 'Left'), (e[(e.Right = 2)] = 'Right')
	})(rm || (rm = {}))
	var im
	;(function (e) {
		;(e[(e.Inline = 1)] = 'Inline'), (e[(e.Gutter = 2)] = 'Gutter')
	})(im || (im = {}))
	var sm
	;(function (e) {
		;(e[(e.Both = 0)] = 'Both'),
			(e[(e.Right = 1)] = 'Right'),
			(e[(e.Left = 2)] = 'Left'),
			(e[(e.None = 3)] = 'None')
	})(sm || (sm = {}))
	function Bv(e, t, n, r, i) {
		if (r === 0) return !0
		let s = t.charCodeAt(r - 1)
		if (e.get(s) !== 0 || s === 13 || s === 10) return !0
		if (i > 0) {
			let o = t.charCodeAt(r)
			if (e.get(o) !== 0) return !0
		}
		return !1
	}
	function Pv(e, t, n, r, i) {
		if (r + i === n) return !0
		let s = t.charCodeAt(r + i)
		if (e.get(s) !== 0 || s === 13 || s === 10) return !0
		if (i > 0) {
			let o = t.charCodeAt(r + i - 1)
			if (e.get(o) !== 0) return !0
		}
		return !1
	}
	function Mv(e, t, n, r, i) {
		return Bv(e, t, n, r, i) && Pv(e, t, n, r, i)
	}
	var Il = class {
		constructor(t, n) {
			;(this._wordSeparators = t),
				(this._searchRegex = n),
				(this._prevMatchStartIndex = -1),
				(this._prevMatchLength = 0)
		}
		reset(t) {
			;(this._searchRegex.lastIndex = t),
				(this._prevMatchStartIndex = -1),
				(this._prevMatchLength = 0)
		}
		next(t) {
			let n = t.length,
				r
			do {
				if (
					this._prevMatchStartIndex + this._prevMatchLength === n ||
					((r = this._searchRegex.exec(t)), !r)
				)
					return null
				let i = r.index,
					s = r[0].length
				if (i === this._prevMatchStartIndex && s === this._prevMatchLength) {
					if (s === 0) {
						j0(t, n, this._searchRegex.lastIndex) > 65535
							? (this._searchRegex.lastIndex += 2)
							: (this._searchRegex.lastIndex += 1)
						continue
					}
					return null
				}
				if (
					((this._prevMatchStartIndex = i),
					(this._prevMatchLength = s),
					!this._wordSeparators || Mv(this._wordSeparators, t, n, i, s))
				)
					return r
			} while (r)
			return null
		}
	}
	function om(e, t = 'Unreachable') {
		throw new Error(t)
	}
	function Po(e) {
		if (!e()) {
			debugger
			e(), nl(new ai('Assertion Failed'))
		}
	}
	function kl(e, t) {
		let n = 0
		for (; n < e.length - 1; ) {
			let r = e[n],
				i = e[n + 1]
			if (!t(r, i)) return !1
			n++
		}
		return !0
	}
	var Rl = class {
		static computeUnicodeHighlights(t, n, r) {
			let i = r ? r.startLineNumber : 1,
				s = r ? r.endLineNumber : t.getLineCount(),
				o = new Ol(n),
				a = o.getCandidateCodePoints(),
				u
			a === 'allNonBasicAscii'
				? (u = new RegExp('[^\\t\\n\\r\\x20-\\x7E]', 'g'))
				: (u = new RegExp(`${jv(Array.from(a))}`, 'g'))
			let h = new Il(null, u),
				N = [],
				I = !1,
				Q,
				K = 0,
				ue = 0,
				de = 0
			e: for (let Pe = i, Ze = s; Pe <= Ze; Pe++) {
				let Ae = t.getLineContent(Pe),
					ze = Ae.length
				h.reset(0)
				do
					if (((Q = h.next(Ae)), Q)) {
						let it = Q.index,
							Et = Q.index + Q[0].length
						if (it > 0) {
							let Je = Ae.charCodeAt(it - 1)
							Ro(Je) && it--
						}
						if (Et + 1 < ze) {
							let Je = Ae.charCodeAt(Et - 1)
							Ro(Je) && Et++
						}
						let _t = Ae.substring(it, Et),
							ct = Xa(it + 1, tf, Ae, 0)
						ct && ct.endColumn <= it + 1 && (ct = null)
						let St = o.shouldHighlightNonBasicASCII(_t, ct ? ct.word : null)
						if (St !== 0) {
							St === 3 ? K++ : St === 2 ? ue++ : St === 1 ? de++ : om(St)
							let Je = 1e3
							if (N.length >= Je) {
								I = !0
								break e
							}
							N.push(new Wn(Pe, it + 1, Pe, Et + 1))
						}
					}
				while (Q)
			}
			return {
				ranges: N,
				hasMore: I,
				ambiguousCharacterCount: K,
				invisibleCharacterCount: ue,
				nonBasicAsciiCharacterCount: de
			}
		}
		static computeUnicodeHighlightReason(t, n) {
			let r = new Ol(n)
			switch (r.shouldHighlightNonBasicASCII(t, null)) {
				case 0:
					return null
				case 2:
					return { kind: 1 }
				case 3: {
					let s = t.codePointAt(0),
						o = r.ambiguousCharacters.getPrimaryConfusable(s),
						a = Hi.getLocales().filter(
							(u) => !Hi.getInstance(new Set([...n.allowedLocales, u])).isAmbiguous(s)
						)
					return { kind: 0, confusableWith: String.fromCodePoint(o), notAmbiguousInLocales: a }
				}
				case 1:
					return { kind: 2 }
			}
		}
	}
	function jv(e, t) {
		return `[${O0(e.map((r) => String.fromCodePoint(r)).join(''))}]`
	}
	var Ol = class {
		constructor(t) {
			;(this.options = t),
				(this.allowedCodePoints = new Set(t.allowedCodePoints)),
				(this.ambiguousCharacters = Hi.getInstance(new Set(t.allowedLocales)))
		}
		getCandidateCodePoints() {
			if (this.options.nonBasicASCII) return 'allNonBasicAscii'
			let t = new Set()
			if (this.options.invisibleCharacters)
				for (let n of Hs.codePoints) am(String.fromCodePoint(n)) || t.add(n)
			if (this.options.ambiguousCharacters)
				for (let n of this.ambiguousCharacters.getConfusableCodePoints()) t.add(n)
			for (let n of this.allowedCodePoints) t.delete(n)
			return t
		}
		shouldHighlightNonBasicASCII(t, n) {
			let r = t.codePointAt(0)
			if (this.allowedCodePoints.has(r)) return 0
			if (this.options.nonBasicASCII) return 1
			let i = !1,
				s = !1
			if (n)
				for (let o of n) {
					let a = o.codePointAt(0),
						u = $0(o)
					;(i = i || u),
						!u &&
							!this.ambiguousCharacters.isAmbiguous(a) &&
							!Hs.isInvisibleCharacter(a) &&
							(s = !0)
				}
			return !i && s
				? 0
				: this.options.invisibleCharacters && !am(t) && Hs.isInvisibleCharacter(r)
				? 2
				: this.options.ambiguousCharacters && this.ambiguousCharacters.isAmbiguous(r)
				? 3
				: 0
		}
	}
	function am(e) {
		return (
			e === ' ' ||
			e ===
				`
` ||
			e === '	'
		)
	}
	var ws = class {
			constructor(t, n, r) {
				;(this.changes = t), (this.moves = n), (this.hitTimeout = r)
			}
		},
		Bl = class e {
			constructor(t, n) {
				;(this.lineRangeMapping = t), (this.changes = n)
			}
			flip() {
				return new e(
					this.lineRangeMapping.flip(),
					this.changes.map((t) => t.flip())
				)
			}
		}
	var $n = class e {
		static addRange(t, n) {
			let r = 0
			for (; r < n.length && n[r].endExclusive < t.start; ) r++
			let i = r
			for (; i < n.length && n[i].start <= t.endExclusive; ) i++
			if (r === i) n.splice(r, 0, t)
			else {
				let s = Math.min(t.start, n[r].start),
					o = Math.max(t.endExclusive, n[i - 1].endExclusive)
				n.splice(r, i - r, new e(s, o))
			}
		}
		static tryCreate(t, n) {
			if (!(t > n)) return new e(t, n)
		}
		static ofLength(t) {
			return new e(0, t)
		}
		constructor(t, n) {
			if (((this.start = t), (this.endExclusive = n), t > n))
				throw new ai(`Invalid range: ${this.toString()}`)
		}
		get isEmpty() {
			return this.start === this.endExclusive
		}
		delta(t) {
			return new e(this.start + t, this.endExclusive + t)
		}
		deltaStart(t) {
			return new e(this.start + t, this.endExclusive)
		}
		deltaEnd(t) {
			return new e(this.start, this.endExclusive + t)
		}
		get length() {
			return this.endExclusive - this.start
		}
		toString() {
			return `[${this.start}, ${this.endExclusive})`
		}
		equals(t) {
			return this.start === t.start && this.endExclusive === t.endExclusive
		}
		containsRange(t) {
			return this.start <= t.start && t.endExclusive <= this.endExclusive
		}
		contains(t) {
			return this.start <= t && t < this.endExclusive
		}
		join(t) {
			return new e(Math.min(this.start, t.start), Math.max(this.endExclusive, t.endExclusive))
		}
		intersect(t) {
			let n = Math.max(this.start, t.start),
				r = Math.min(this.endExclusive, t.endExclusive)
			if (n <= r) return new e(n, r)
		}
		intersectsOrTouches(t) {
			let n = Math.max(this.start, t.start),
				r = Math.min(this.endExclusive, t.endExclusive)
			return n <= r
		}
		slice(t) {
			return t.slice(this.start, this.endExclusive)
		}
		clip(t) {
			if (this.isEmpty) throw new ai(`Invalid clipping range: ${this.toString()}`)
			return Math.max(this.start, Math.min(this.endExclusive - 1, t))
		}
		clipCyclic(t) {
			if (this.isEmpty) throw new ai(`Invalid clipping range: ${this.toString()}`)
			return t < this.start
				? this.endExclusive - ((this.start - t) % this.length)
				: t >= this.endExclusive
				? this.start + ((t - this.start) % this.length)
				: t
		}
		map(t) {
			let n = []
			for (let r = this.start; r < this.endExclusive; r++) n.push(t(r))
			return n
		}
		forEach(t) {
			for (let n = this.start; n < this.endExclusive; n++) t(n)
		}
	}
	var Xn = class e {
			static fromRange(t) {
				return new e(t.startLineNumber, t.endLineNumber)
			}
			static subtract(t, n) {
				return n
					? t.startLineNumber < n.startLineNumber &&
					  n.endLineNumberExclusive < t.endLineNumberExclusive
						? [
								new e(t.startLineNumber, n.startLineNumber),
								new e(n.endLineNumberExclusive, t.endLineNumberExclusive)
						  ]
						: n.startLineNumber <= t.startLineNumber &&
						  t.endLineNumberExclusive <= n.endLineNumberExclusive
						? []
						: n.endLineNumberExclusive < t.endLineNumberExclusive
						? [
								new e(
									Math.max(n.endLineNumberExclusive, t.startLineNumber),
									t.endLineNumberExclusive
								)
						  ]
						: [new e(t.startLineNumber, Math.min(n.startLineNumber, t.endLineNumberExclusive))]
					: [t]
			}
			static joinMany(t) {
				if (t.length === 0) return []
				let n = new Ys(t[0].slice())
				for (let r = 1; r < t.length; r++) n = n.getUnion(new Ys(t[r].slice()))
				return n.ranges
			}
			static ofLength(t, n) {
				return new e(t, t + n)
			}
			static deserialize(t) {
				return new e(t[0], t[1])
			}
			constructor(t, n) {
				if (t > n) throw new ai(`startLineNumber ${t} cannot be after endLineNumberExclusive ${n}`)
				;(this.startLineNumber = t), (this.endLineNumberExclusive = n)
			}
			contains(t) {
				return this.startLineNumber <= t && t < this.endLineNumberExclusive
			}
			get isEmpty() {
				return this.startLineNumber === this.endLineNumberExclusive
			}
			delta(t) {
				return new e(this.startLineNumber + t, this.endLineNumberExclusive + t)
			}
			deltaLength(t) {
				return new e(this.startLineNumber, this.endLineNumberExclusive + t)
			}
			get length() {
				return this.endLineNumberExclusive - this.startLineNumber
			}
			join(t) {
				return new e(
					Math.min(this.startLineNumber, t.startLineNumber),
					Math.max(this.endLineNumberExclusive, t.endLineNumberExclusive)
				)
			}
			toString() {
				return `[${this.startLineNumber},${this.endLineNumberExclusive})`
			}
			intersect(t) {
				let n = Math.max(this.startLineNumber, t.startLineNumber),
					r = Math.min(this.endLineNumberExclusive, t.endLineNumberExclusive)
				if (n <= r) return new e(n, r)
			}
			intersectsStrict(t) {
				return (
					this.startLineNumber < t.endLineNumberExclusive &&
					t.startLineNumber < this.endLineNumberExclusive
				)
			}
			overlapOrTouch(t) {
				return (
					this.startLineNumber <= t.endLineNumberExclusive &&
					t.startLineNumber <= this.endLineNumberExclusive
				)
			}
			equals(t) {
				return (
					this.startLineNumber === t.startLineNumber &&
					this.endLineNumberExclusive === t.endLineNumberExclusive
				)
			}
			toInclusiveRange() {
				return this.isEmpty
					? null
					: new Wn(
							this.startLineNumber,
							1,
							this.endLineNumberExclusive - 1,
							Number.MAX_SAFE_INTEGER
					  )
			}
			toExclusiveRange() {
				return new Wn(this.startLineNumber, 1, this.endLineNumberExclusive, 1)
			}
			mapToLineArray(t) {
				let n = []
				for (let r = this.startLineNumber; r < this.endLineNumberExclusive; r++) n.push(t(r))
				return n
			}
			forEach(t) {
				for (let n = this.startLineNumber; n < this.endLineNumberExclusive; n++) t(n)
			}
			serialize() {
				return [this.startLineNumber, this.endLineNumberExclusive]
			}
			includes(t) {
				return this.startLineNumber <= t && t < this.endLineNumberExclusive
			}
			toOffsetRange() {
				return new $n(this.startLineNumber - 1, this.endLineNumberExclusive - 1)
			}
		},
		Ys = class e {
			constructor(t = []) {
				this._normalizedRanges = t
			}
			get ranges() {
				return this._normalizedRanges
			}
			addRange(t) {
				if (t.length === 0) return
				let n = ja(this._normalizedRanges, (i) => i.endLineNumberExclusive >= t.startLineNumber),
					r = Vs(this._normalizedRanges, (i) => i.startLineNumber <= t.endLineNumberExclusive) + 1
				if (n === r) this._normalizedRanges.splice(n, 0, t)
				else if (n === r - 1) {
					let i = this._normalizedRanges[n]
					this._normalizedRanges[n] = i.join(t)
				} else {
					let i = this._normalizedRanges[n].join(this._normalizedRanges[r - 1]).join(t)
					this._normalizedRanges.splice(n, r - n, i)
				}
			}
			contains(t) {
				let n = us(this._normalizedRanges, (r) => r.startLineNumber <= t)
				return !!n && n.endLineNumberExclusive > t
			}
			intersects(t) {
				let n = us(this._normalizedRanges, (r) => r.startLineNumber < t.endLineNumberExclusive)
				return !!n && n.endLineNumberExclusive > t.startLineNumber
			}
			getUnion(t) {
				if (this._normalizedRanges.length === 0) return t
				if (t._normalizedRanges.length === 0) return this
				let n = [],
					r = 0,
					i = 0,
					s = null
				for (; r < this._normalizedRanges.length || i < t._normalizedRanges.length; ) {
					let o = null
					if (r < this._normalizedRanges.length && i < t._normalizedRanges.length) {
						let a = this._normalizedRanges[r],
							u = t._normalizedRanges[i]
						a.startLineNumber < u.startLineNumber ? ((o = a), r++) : ((o = u), i++)
					} else
						r < this._normalizedRanges.length
							? ((o = this._normalizedRanges[r]), r++)
							: ((o = t._normalizedRanges[i]), i++)
					s === null
						? (s = o)
						: s.endLineNumberExclusive >= o.startLineNumber
						? (s = new Xn(
								s.startLineNumber,
								Math.max(s.endLineNumberExclusive, o.endLineNumberExclusive)
						  ))
						: (n.push(s), (s = o))
				}
				return s !== null && n.push(s), new e(n)
			}
			subtractFrom(t) {
				let n = ja(this._normalizedRanges, (o) => o.endLineNumberExclusive >= t.startLineNumber),
					r = Vs(this._normalizedRanges, (o) => o.startLineNumber <= t.endLineNumberExclusive) + 1
				if (n === r) return new e([t])
				let i = [],
					s = t.startLineNumber
				for (let o = n; o < r; o++) {
					let a = this._normalizedRanges[o]
					a.startLineNumber > s && i.push(new Xn(s, a.startLineNumber)),
						(s = a.endLineNumberExclusive)
				}
				return s < t.endLineNumberExclusive && i.push(new Xn(s, t.endLineNumberExclusive)), new e(i)
			}
			toString() {
				return this._normalizedRanges.map((t) => t.toString()).join(', ')
			}
			getIntersection(t) {
				let n = [],
					r = 0,
					i = 0
				for (; r < this._normalizedRanges.length && i < t._normalizedRanges.length; ) {
					let s = this._normalizedRanges[r],
						o = t._normalizedRanges[i],
						a = s.intersect(o)
					a && !a.isEmpty && n.push(a),
						s.endLineNumberExclusive < o.endLineNumberExclusive ? r++ : i++
				}
				return new e(n)
			}
			getWithDelta(t) {
				return new e(this._normalizedRanges.map((n) => n.delta(t)))
			}
		}
	var Ls = class e {
			static inverse(t, n, r) {
				let i = [],
					s = 1,
					o = 1
				for (let u of t) {
					let h = new Bi(
						new Xn(s, u.original.startLineNumber),
						new Xn(o, u.modified.startLineNumber),
						void 0
					)
					h.modified.isEmpty || i.push(h),
						(s = u.original.endLineNumberExclusive),
						(o = u.modified.endLineNumberExclusive)
				}
				let a = new Bi(new Xn(s, n + 1), new Xn(o, r + 1), void 0)
				return a.modified.isEmpty || i.push(a), i
			}
			constructor(t, n) {
				;(this.original = t), (this.modified = n)
			}
			toString() {
				return `{${this.original.toString()}->${this.modified.toString()}}`
			}
			flip() {
				return new e(this.modified, this.original)
			}
			join(t) {
				return new e(this.original.join(t.original), this.modified.join(t.modified))
			}
			get changedLineCount() {
				return Math.max(this.original.length, this.modified.length)
			}
		},
		Bi = class e extends Ls {
			constructor(t, n, r) {
				super(t, n), (this.innerChanges = r)
			}
			flip() {
				return new e(
					this.modified,
					this.original,
					this.innerChanges?.map((t) => t.flip())
				)
			}
		},
		Xs = class e {
			constructor(t, n) {
				;(this.originalRange = t), (this.modifiedRange = n)
			}
			toString() {
				return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`
			}
			flip() {
				return new e(this.modifiedRange, this.originalRange)
			}
		}
	var $v = 3,
		Pl = class {
			computeDiff(t, n, r) {
				let s = new tu(t, n, {
						maxComputationTime: r.maxComputationTimeMs,
						shouldIgnoreTrimWhitespace: r.ignoreTrimWhitespace,
						shouldComputeCharChanges: !0,
						shouldMakePrettyDiff: !0,
						shouldPostProcessCharChanges: !0
					}).computeDiff(),
					o = [],
					a = null
				for (let u of s.changes) {
					let h
					u.originalEndLineNumber === 0
						? (h = new Xn(u.originalStartLineNumber + 1, u.originalStartLineNumber + 1))
						: (h = new Xn(u.originalStartLineNumber, u.originalEndLineNumber + 1))
					let N
					u.modifiedEndLineNumber === 0
						? (N = new Xn(u.modifiedStartLineNumber + 1, u.modifiedStartLineNumber + 1))
						: (N = new Xn(u.modifiedStartLineNumber, u.modifiedEndLineNumber + 1))
					let I = new Bi(
						h,
						N,
						u.charChanges?.map(
							(Q) =>
								new Xs(
									new Wn(
										Q.originalStartLineNumber,
										Q.originalStartColumn,
										Q.originalEndLineNumber,
										Q.originalEndColumn
									),
									new Wn(
										Q.modifiedStartLineNumber,
										Q.modifiedStartColumn,
										Q.modifiedEndLineNumber,
										Q.modifiedEndColumn
									)
								)
						)
					)
					a &&
						(a.modified.endLineNumberExclusive === I.modified.startLineNumber ||
							a.original.endLineNumberExclusive === I.original.startLineNumber) &&
						((I = new Bi(
							a.original.join(I.original),
							a.modified.join(I.modified),
							a.innerChanges && I.innerChanges ? a.innerChanges.concat(I.innerChanges) : void 0
						)),
						o.pop()),
						o.push(I),
						(a = I)
				}
				return (
					Po(() =>
						kl(
							o,
							(u, h) =>
								h.original.startLineNumber - u.original.endLineNumberExclusive ===
									h.modified.startLineNumber - u.modified.endLineNumberExclusive &&
								u.original.endLineNumberExclusive < h.original.startLineNumber &&
								u.modified.endLineNumberExclusive < h.modified.startLineNumber
						)
					),
					new ws(o, [], s.quitEarly)
				)
			}
		}
	function lm(e, t, n, r) {
		return new Qa(e, t, n).ComputeDiff(r)
	}
	var Ml = class {
			constructor(t) {
				let n = [],
					r = []
				for (let i = 0, s = t.length; i < s; i++) (n[i] = df(t[i], 1)), (r[i] = hf(t[i], 1))
				;(this.lines = t), (this._startColumns = n), (this._endColumns = r)
			}
			getElements() {
				let t = []
				for (let n = 0, r = this.lines.length; n < r; n++)
					t[n] = this.lines[n].substring(this._startColumns[n] - 1, this._endColumns[n] - 1)
				return t
			}
			getStrictElement(t) {
				return this.lines[t]
			}
			getStartLineNumber(t) {
				return t + 1
			}
			getEndLineNumber(t) {
				return t + 1
			}
			createCharSequence(t, n, r) {
				let i = [],
					s = [],
					o = [],
					a = 0
				for (let u = n; u <= r; u++) {
					let h = this.lines[u],
						N = t ? this._startColumns[u] : 1,
						I = t ? this._endColumns[u] : h.length + 1
					for (let Q = N; Q < I; Q++) (i[a] = h.charCodeAt(Q - 1)), (s[a] = u + 1), (o[a] = Q), a++
					!t && u < r && ((i[a] = 10), (s[a] = u + 1), (o[a] = h.length + 1), a++)
				}
				return new ff(i, s, o)
			}
		},
		ff = class {
			constructor(t, n, r) {
				;(this._charCodes = t), (this._lineNumbers = n), (this._columns = r)
			}
			toString() {
				return (
					'[' +
					this._charCodes
						.map(
							(t, n) =>
								(t === 10 ? '\\n' : String.fromCharCode(t)) +
								`-(${this._lineNumbers[n]},${this._columns[n]})`
						)
						.join(', ') +
					']'
				)
			}
			_assertIndex(t, n) {
				if (t < 0 || t >= n.length) throw new Error('Illegal index')
			}
			getElements() {
				return this._charCodes
			}
			getStartLineNumber(t) {
				return t > 0 && t === this._lineNumbers.length
					? this.getEndLineNumber(t - 1)
					: (this._assertIndex(t, this._lineNumbers), this._lineNumbers[t])
			}
			getEndLineNumber(t) {
				return t === -1
					? this.getStartLineNumber(t + 1)
					: (this._assertIndex(t, this._lineNumbers),
					  this._charCodes[t] === 10 ? this._lineNumbers[t] + 1 : this._lineNumbers[t])
			}
			getStartColumn(t) {
				return t > 0 && t === this._columns.length
					? this.getEndColumn(t - 1)
					: (this._assertIndex(t, this._columns), this._columns[t])
			}
			getEndColumn(t) {
				return t === -1
					? this.getStartColumn(t + 1)
					: (this._assertIndex(t, this._columns),
					  this._charCodes[t] === 10 ? 1 : this._columns[t] + 1)
			}
		},
		Mo = class e {
			constructor(t, n, r, i, s, o, a, u) {
				;(this.originalStartLineNumber = t),
					(this.originalStartColumn = n),
					(this.originalEndLineNumber = r),
					(this.originalEndColumn = i),
					(this.modifiedStartLineNumber = s),
					(this.modifiedStartColumn = o),
					(this.modifiedEndLineNumber = a),
					(this.modifiedEndColumn = u)
			}
			static createFromDiffChange(t, n, r) {
				let i = n.getStartLineNumber(t.originalStart),
					s = n.getStartColumn(t.originalStart),
					o = n.getEndLineNumber(t.originalStart + t.originalLength - 1),
					a = n.getEndColumn(t.originalStart + t.originalLength - 1),
					u = r.getStartLineNumber(t.modifiedStart),
					h = r.getStartColumn(t.modifiedStart),
					N = r.getEndLineNumber(t.modifiedStart + t.modifiedLength - 1),
					I = r.getEndColumn(t.modifiedStart + t.modifiedLength - 1)
				return new e(i, s, o, a, u, h, N, I)
			}
		}
	function Vv(e) {
		if (e.length <= 1) return e
		let t = [e[0]],
			n = t[0]
		for (let r = 1, i = e.length; r < i; r++) {
			let s = e[r],
				o = s.originalStart - (n.originalStart + n.originalLength),
				a = s.modifiedStart - (n.modifiedStart + n.modifiedLength)
			Math.min(o, a) < $v
				? ((n.originalLength = s.originalStart + s.originalLength - n.originalStart),
				  (n.modifiedLength = s.modifiedStart + s.modifiedLength - n.modifiedStart))
				: (t.push(s), (n = s))
		}
		return t
	}
	var eu = class e {
			constructor(t, n, r, i, s) {
				;(this.originalStartLineNumber = t),
					(this.originalEndLineNumber = n),
					(this.modifiedStartLineNumber = r),
					(this.modifiedEndLineNumber = i),
					(this.charChanges = s)
			}
			static createFromDiffResult(t, n, r, i, s, o, a) {
				let u, h, N, I, Q
				if (
					(n.originalLength === 0
						? ((u = r.getStartLineNumber(n.originalStart) - 1), (h = 0))
						: ((u = r.getStartLineNumber(n.originalStart)),
						  (h = r.getEndLineNumber(n.originalStart + n.originalLength - 1))),
					n.modifiedLength === 0
						? ((N = i.getStartLineNumber(n.modifiedStart) - 1), (I = 0))
						: ((N = i.getStartLineNumber(n.modifiedStart)),
						  (I = i.getEndLineNumber(n.modifiedStart + n.modifiedLength - 1))),
					o &&
						n.originalLength > 0 &&
						n.originalLength < 20 &&
						n.modifiedLength > 0 &&
						n.modifiedLength < 20 &&
						s())
				) {
					let K = r.createCharSequence(t, n.originalStart, n.originalStart + n.originalLength - 1),
						ue = i.createCharSequence(t, n.modifiedStart, n.modifiedStart + n.modifiedLength - 1)
					if (K.getElements().length > 0 && ue.getElements().length > 0) {
						let de = lm(K, ue, s, !0).changes
						a && (de = Vv(de)), (Q = [])
						for (let Pe = 0, Ze = de.length; Pe < Ze; Pe++)
							Q.push(Mo.createFromDiffChange(de[Pe], K, ue))
					}
				}
				return new e(u, h, N, I, Q)
			}
		},
		tu = class {
			constructor(t, n, r) {
				;(this.shouldComputeCharChanges = r.shouldComputeCharChanges),
					(this.shouldPostProcessCharChanges = r.shouldPostProcessCharChanges),
					(this.shouldIgnoreTrimWhitespace = r.shouldIgnoreTrimWhitespace),
					(this.shouldMakePrettyDiff = r.shouldMakePrettyDiff),
					(this.originalLines = t),
					(this.modifiedLines = n),
					(this.original = new Ml(t)),
					(this.modified = new Ml(n)),
					(this.continueLineDiff = um(r.maxComputationTime)),
					(this.continueCharDiff = um(
						r.maxComputationTime === 0 ? 0 : Math.min(r.maxComputationTime, 5e3)
					))
			}
			computeDiff() {
				if (this.original.lines.length === 1 && this.original.lines[0].length === 0)
					return this.modified.lines.length === 1 && this.modified.lines[0].length === 0
						? { quitEarly: !1, changes: [] }
						: {
								quitEarly: !1,
								changes: [
									{
										originalStartLineNumber: 1,
										originalEndLineNumber: 1,
										modifiedStartLineNumber: 1,
										modifiedEndLineNumber: this.modified.lines.length,
										charChanges: void 0
									}
								]
						  }
				if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0)
					return {
						quitEarly: !1,
						changes: [
							{
								originalStartLineNumber: 1,
								originalEndLineNumber: this.original.lines.length,
								modifiedStartLineNumber: 1,
								modifiedEndLineNumber: 1,
								charChanges: void 0
							}
						]
					}
				let t = lm(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff),
					n = t.changes,
					r = t.quitEarly
				if (this.shouldIgnoreTrimWhitespace) {
					let a = []
					for (let u = 0, h = n.length; u < h; u++)
						a.push(
							eu.createFromDiffResult(
								this.shouldIgnoreTrimWhitespace,
								n[u],
								this.original,
								this.modified,
								this.continueCharDiff,
								this.shouldComputeCharChanges,
								this.shouldPostProcessCharChanges
							)
						)
					return { quitEarly: r, changes: a }
				}
				let i = [],
					s = 0,
					o = 0
				for (let a = -1, u = n.length; a < u; a++) {
					let h = a + 1 < u ? n[a + 1] : null,
						N = h ? h.originalStart : this.originalLines.length,
						I = h ? h.modifiedStart : this.modifiedLines.length
					for (; s < N && o < I; ) {
						let Q = this.originalLines[s],
							K = this.modifiedLines[o]
						if (Q !== K) {
							{
								let ue = df(Q, 1),
									de = df(K, 1)
								for (; ue > 1 && de > 1; ) {
									let Pe = Q.charCodeAt(ue - 2),
										Ze = K.charCodeAt(de - 2)
									if (Pe !== Ze) break
									ue--, de--
								}
								;(ue > 1 || de > 1) &&
									this._pushTrimWhitespaceCharChange(i, s + 1, 1, ue, o + 1, 1, de)
							}
							{
								let ue = hf(Q, 1),
									de = hf(K, 1),
									Pe = Q.length + 1,
									Ze = K.length + 1
								for (; ue < Pe && de < Ze; ) {
									let Ae = Q.charCodeAt(ue - 1),
										ze = Q.charCodeAt(de - 1)
									if (Ae !== ze) break
									ue++, de++
								}
								;(ue < Pe || de < Ze) &&
									this._pushTrimWhitespaceCharChange(i, s + 1, ue, Pe, o + 1, de, Ze)
							}
						}
						s++, o++
					}
					h &&
						(i.push(
							eu.createFromDiffResult(
								this.shouldIgnoreTrimWhitespace,
								h,
								this.original,
								this.modified,
								this.continueCharDiff,
								this.shouldComputeCharChanges,
								this.shouldPostProcessCharChanges
							)
						),
						(s += h.originalLength),
						(o += h.modifiedLength))
				}
				return { quitEarly: r, changes: i }
			}
			_pushTrimWhitespaceCharChange(t, n, r, i, s, o, a) {
				if (this._mergeTrimWhitespaceCharChange(t, n, r, i, s, o, a)) return
				let u
				this.shouldComputeCharChanges && (u = [new Mo(n, r, n, i, s, o, s, a)]),
					t.push(new eu(n, n, s, s, u))
			}
			_mergeTrimWhitespaceCharChange(t, n, r, i, s, o, a) {
				let u = t.length
				if (u === 0) return !1
				let h = t[u - 1]
				return h.originalEndLineNumber === 0 || h.modifiedEndLineNumber === 0
					? !1
					: h.originalEndLineNumber === n && h.modifiedEndLineNumber === s
					? (this.shouldComputeCharChanges &&
							h.charChanges &&
							h.charChanges.push(new Mo(n, r, n, i, s, o, s, a)),
					  !0)
					: h.originalEndLineNumber + 1 === n && h.modifiedEndLineNumber + 1 === s
					? ((h.originalEndLineNumber = n),
					  (h.modifiedEndLineNumber = s),
					  this.shouldComputeCharChanges &&
							h.charChanges &&
							h.charChanges.push(new Mo(n, r, n, i, s, o, s, a)),
					  !0)
					: !1
			}
		}
	function df(e, t) {
		let n = P0(e)
		return n === -1 ? t : n + 1
	}
	function hf(e, t) {
		let n = M0(e)
		return n === -1 ? t : n + 2
	}
	function um(e) {
		if (e === 0) return () => !0
		let t = Date.now()
		return () => Date.now() - t < e
	}
	var Ji = class e {
			static trivial(t, n) {
				return new e([new $r($n.ofLength(t.length), $n.ofLength(n.length))], !1)
			}
			static trivialTimedOut(t, n) {
				return new e([new $r($n.ofLength(t.length), $n.ofLength(n.length))], !0)
			}
			constructor(t, n) {
				;(this.diffs = t), (this.hitTimeout = n)
			}
		},
		$r = class e {
			static invert(t, n) {
				let r = []
				return (
					d0(t, (i, s) => {
						r.push(
							e.fromOffsetPairs(
								i ? i.getEndExclusives() : Ei.zero,
								s
									? s.getStarts()
									: new Ei(n, (i ? i.seq2Range.endExclusive - i.seq1Range.endExclusive : 0) + n)
							)
						)
					}),
					r
				)
			}
			static fromOffsetPairs(t, n) {
				return new e(new $n(t.offset1, n.offset1), new $n(t.offset2, n.offset2))
			}
			constructor(t, n) {
				;(this.seq1Range = t), (this.seq2Range = n)
			}
			swap() {
				return new e(this.seq2Range, this.seq1Range)
			}
			toString() {
				return `${this.seq1Range} <-> ${this.seq2Range}`
			}
			join(t) {
				return new e(this.seq1Range.join(t.seq1Range), this.seq2Range.join(t.seq2Range))
			}
			delta(t) {
				return t === 0 ? this : new e(this.seq1Range.delta(t), this.seq2Range.delta(t))
			}
			deltaStart(t) {
				return t === 0 ? this : new e(this.seq1Range.deltaStart(t), this.seq2Range.deltaStart(t))
			}
			deltaEnd(t) {
				return t === 0 ? this : new e(this.seq1Range.deltaEnd(t), this.seq2Range.deltaEnd(t))
			}
			intersectsOrTouches(t) {
				return (
					this.seq1Range.intersectsOrTouches(t.seq1Range) ||
					this.seq2Range.intersectsOrTouches(t.seq2Range)
				)
			}
			intersect(t) {
				let n = this.seq1Range.intersect(t.seq1Range),
					r = this.seq2Range.intersect(t.seq2Range)
				if (!(!n || !r)) return new e(n, r)
			}
			getStarts() {
				return new Ei(this.seq1Range.start, this.seq2Range.start)
			}
			getEndExclusives() {
				return new Ei(this.seq1Range.endExclusive, this.seq2Range.endExclusive)
			}
		},
		Ei = class {
			constructor(t, n) {
				;(this.offset1 = t), (this.offset2 = n)
			}
			toString() {
				return `${this.offset1} <-> ${this.offset2}`
			}
		}
	Ei.zero = new Ei(0, 0)
	Ei.max = new Ei(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER)
	var zi = class {
		isValid() {
			return !0
		}
	}
	zi.instance = new zi()
	var jl = class {
		constructor(t) {
			if (((this.timeout = t), (this.startTime = Date.now()), (this.valid = !0), t <= 0))
				throw new ai('timeout must be positive')
		}
		isValid() {
			if (!(Date.now() - this.startTime < this.timeout) && this.valid) {
				this.valid = !1
				debugger
			}
			return this.valid
		}
		disable() {
			;(this.timeout = Number.MAX_SAFE_INTEGER), (this.isValid = () => !0), (this.valid = !0)
		}
	}
	var jo = class {
		constructor(t, n) {
			;(this.width = t), (this.height = n), (this.array = []), (this.array = new Array(t * n))
		}
		get(t, n) {
			return this.array[t + n * this.width]
		}
		set(t, n, r) {
			this.array[t + n * this.width] = r
		}
	}
	function nu(e) {
		return e === 32 || e === 9
	}
	var $o = class e {
		static getKey(t) {
			let n = this.chrKeys.get(t)
			return n === void 0 && ((n = this.chrKeys.size), this.chrKeys.set(t, n)), n
		}
		constructor(t, n, r) {
			;(this.range = t), (this.lines = n), (this.source = r), (this.histogram = [])
			let i = 0
			for (let s = t.startLineNumber - 1; s < t.endLineNumberExclusive - 1; s++) {
				let o = n[s]
				for (let u = 0; u < o.length; u++) {
					i++
					let h = o[u],
						N = e.getKey(h)
					this.histogram[N] = (this.histogram[N] || 0) + 1
				}
				i++
				let a = e.getKey(`
`)
				this.histogram[a] = (this.histogram[a] || 0) + 1
			}
			this.totalCount = i
		}
		computeSimilarity(t) {
			let n = 0,
				r = Math.max(this.histogram.length, t.histogram.length)
			for (let i = 0; i < r; i++) n += Math.abs((this.histogram[i] ?? 0) - (t.histogram[i] ?? 0))
			return 1 - n / (this.totalCount + t.totalCount)
		}
	}
	$o.chrKeys = new Map()
	var $l = class {
		compute(t, n, r = zi.instance, i) {
			if (t.length === 0 || n.length === 0) return Ji.trivial(t, n)
			let s = new jo(t.length, n.length),
				o = new jo(t.length, n.length),
				a = new jo(t.length, n.length)
			for (let ue = 0; ue < t.length; ue++)
				for (let de = 0; de < n.length; de++) {
					if (!r.isValid()) return Ji.trivialTimedOut(t, n)
					let Pe = ue === 0 ? 0 : s.get(ue - 1, de),
						Ze = de === 0 ? 0 : s.get(ue, de - 1),
						Ae
					t.getElement(ue) === n.getElement(de)
						? (ue === 0 || de === 0 ? (Ae = 0) : (Ae = s.get(ue - 1, de - 1)),
						  ue > 0 && de > 0 && o.get(ue - 1, de - 1) === 3 && (Ae += a.get(ue - 1, de - 1)),
						  (Ae += i ? i(ue, de) : 1))
						: (Ae = -1)
					let ze = Math.max(Pe, Ze, Ae)
					if (ze === Ae) {
						let it = ue > 0 && de > 0 ? a.get(ue - 1, de - 1) : 0
						a.set(ue, de, it + 1), o.set(ue, de, 3)
					} else
						ze === Pe
							? (a.set(ue, de, 0), o.set(ue, de, 1))
							: ze === Ze && (a.set(ue, de, 0), o.set(ue, de, 2))
					s.set(ue, de, ze)
				}
			let u = [],
				h = t.length,
				N = n.length
			function I(ue, de) {
				;(ue + 1 !== h || de + 1 !== N) && u.push(new $r(new $n(ue + 1, h), new $n(de + 1, N))),
					(h = ue),
					(N = de)
			}
			let Q = t.length - 1,
				K = n.length - 1
			for (; Q >= 0 && K >= 0; )
				o.get(Q, K) === 3 ? (I(Q, K), Q--, K--) : o.get(Q, K) === 1 ? Q-- : K--
			return I(-1, -1), u.reverse(), new Ji(u, !1)
		}
	}
	var Vo = class {
			compute(t, n, r = zi.instance) {
				if (t.length === 0 || n.length === 0) return Ji.trivial(t, n)
				let i = t,
					s = n
				function o(de, Pe) {
					for (; de < i.length && Pe < s.length && i.getElement(de) === s.getElement(Pe); )
						de++, Pe++
					return de
				}
				let a = 0,
					u = new mf()
				u.set(0, o(0, 0))
				let h = new gf()
				h.set(0, u.get(0) === 0 ? null : new Vl(null, 0, 0, u.get(0)))
				let N = 0
				e: for (;;) {
					if ((a++, !r.isValid())) return Ji.trivialTimedOut(i, s)
					let de = -Math.min(a, s.length + (a % 2)),
						Pe = Math.min(a, i.length + (a % 2))
					for (N = de; N <= Pe; N += 2) {
						let Ze = 0,
							Ae = N === Pe ? -1 : u.get(N + 1),
							ze = N === de ? -1 : u.get(N - 1) + 1
						Ze++
						let it = Math.min(Math.max(Ae, ze), i.length),
							Et = it - N
						if ((Ze++, it > i.length || Et > s.length)) continue
						let _t = o(it, Et)
						u.set(N, _t)
						let ct = it === Ae ? h.get(N + 1) : h.get(N - 1)
						if (
							(h.set(N, _t !== it ? new Vl(ct, it, Et, _t - it) : ct),
							u.get(N) === i.length && u.get(N) - N === s.length)
						)
							break e
					}
				}
				let I = h.get(N),
					Q = [],
					K = i.length,
					ue = s.length
				for (;;) {
					let de = I ? I.x + I.length : 0,
						Pe = I ? I.y + I.length : 0
					if (((de !== K || Pe !== ue) && Q.push(new $r(new $n(de, K), new $n(Pe, ue))), !I)) break
					;(K = I.x), (ue = I.y), (I = I.prev)
				}
				return Q.reverse(), new Ji(Q, !1)
			}
		},
		Vl = class {
			constructor(t, n, r, i) {
				;(this.prev = t), (this.x = n), (this.y = r), (this.length = i)
			}
		},
		mf = class {
			constructor() {
				;(this.positiveArr = new Int32Array(10)), (this.negativeArr = new Int32Array(10))
			}
			get(t) {
				return t < 0 ? ((t = -t - 1), this.negativeArr[t]) : this.positiveArr[t]
			}
			set(t, n) {
				if (t < 0) {
					if (((t = -t - 1), t >= this.negativeArr.length)) {
						let r = this.negativeArr
						;(this.negativeArr = new Int32Array(r.length * 2)), this.negativeArr.set(r)
					}
					this.negativeArr[t] = n
				} else {
					if (t >= this.positiveArr.length) {
						let r = this.positiveArr
						;(this.positiveArr = new Int32Array(r.length * 2)), this.positiveArr.set(r)
					}
					this.positiveArr[t] = n
				}
			}
		},
		gf = class {
			constructor() {
				;(this.positiveArr = []), (this.negativeArr = [])
			}
			get(t) {
				return t < 0 ? ((t = -t - 1), this.negativeArr[t]) : this.positiveArr[t]
			}
			set(t, n) {
				t < 0 ? ((t = -t - 1), (this.negativeArr[t] = n)) : (this.positiveArr[t] = n)
			}
		}
	var Is = class {
		constructor(t, n, r) {
			;(this.lines = t),
				(this.considerWhitespaceChanges = r),
				(this.elements = []),
				(this.firstCharOffsetByLine = []),
				(this.additionalOffsetByLine = [])
			let i = !1
			n.start > 0 &&
				n.endExclusive >= t.length &&
				((n = new $n(n.start - 1, n.endExclusive)), (i = !0)),
				(this.lineRange = n),
				(this.firstCharOffsetByLine[0] = 0)
			for (let s = this.lineRange.start; s < this.lineRange.endExclusive; s++) {
				let o = t[s],
					a = 0
				if (i) (a = o.length), (o = ''), (i = !1)
				else if (!r) {
					let u = o.trimStart()
					;(a = o.length - u.length), (o = u.trimEnd())
				}
				this.additionalOffsetByLine.push(a)
				for (let u = 0; u < o.length; u++) this.elements.push(o.charCodeAt(u))
				s < t.length - 1 &&
					(this.elements.push(
						`
`.charCodeAt(0)
					),
					(this.firstCharOffsetByLine[s - this.lineRange.start + 1] = this.elements.length))
			}
			this.additionalOffsetByLine.push(0)
		}
		toString() {
			return `Slice: "${this.text}"`
		}
		get text() {
			return this.getText(new $n(0, this.length))
		}
		getText(t) {
			return this.elements
				.slice(t.start, t.endExclusive)
				.map((n) => String.fromCharCode(n))
				.join('')
		}
		getElement(t) {
			return this.elements[t]
		}
		get length() {
			return this.elements.length
		}
		getBoundaryScore(t) {
			let n = pm(t > 0 ? this.elements[t - 1] : -1),
				r = pm(t < this.elements.length ? this.elements[t] : -1)
			if (n === 6 && r === 7) return 0
			let i = 0
			return n !== r && ((i += 10), n === 0 && r === 1 && (i += 1)), (i += cm(n)), (i += cm(r)), i
		}
		translateOffset(t) {
			if (this.lineRange.isEmpty) return new Rr(this.lineRange.start + 1, 1)
			let n = Vs(this.firstCharOffsetByLine, (r) => r <= t)
			return new Rr(
				this.lineRange.start + n + 1,
				t - this.firstCharOffsetByLine[n] + this.additionalOffsetByLine[n] + 1
			)
		}
		translateRange(t) {
			return Wn.fromPositions(this.translateOffset(t.start), this.translateOffset(t.endExclusive))
		}
		findWordContaining(t) {
			if (t < 0 || t >= this.elements.length || !Df(this.elements[t])) return
			let n = t
			for (; n > 0 && Df(this.elements[n - 1]); ) n--
			let r = t
			for (; r < this.elements.length && Df(this.elements[r]); ) r++
			return new $n(n, r)
		}
		countLinesIn(t) {
			return (
				this.translateOffset(t.endExclusive).lineNumber - this.translateOffset(t.start).lineNumber
			)
		}
		isStronglyEqual(t, n) {
			return this.elements[t] === this.elements[n]
		}
		extendToFullLines(t) {
			let n = us(this.firstCharOffsetByLine, (i) => i <= t.start) ?? 0,
				r = c0(this.firstCharOffsetByLine, (i) => t.endExclusive <= i) ?? this.elements.length
			return new $n(n, r)
		}
	}
	function Df(e) {
		return (e >= 97 && e <= 122) || (e >= 65 && e <= 90) || (e >= 48 && e <= 57)
	}
	var Uv = { 0: 0, 1: 0, 2: 0, 3: 10, 4: 2, 5: 3, 6: 10, 7: 10 }
	function cm(e) {
		return Uv[e]
	}
	function pm(e) {
		return e === 10
			? 7
			: e === 13
			? 6
			: nu(e)
			? 5
			: e >= 97 && e <= 122
			? 0
			: e >= 65 && e <= 90
			? 1
			: e >= 48 && e <= 57
			? 2
			: e === -1
			? 3
			: 4
	}
	function dm(e, t, n, r, i, s) {
		let { moves: o, excludedChanges: a } = qv(e, t, n, s)
		if (!s.isValid()) return []
		let u = e.filter((N) => !a.has(N)),
			h = Gv(u, r, i, t, n, s)
		return (
			m0(o, h),
			(o = Wv(o)),
			(o = o.filter(
				(N) =>
					N.original
						.toOffsetRange()
						.slice(t)
						.map((Q) => Q.trim()).join(`
`).length >= 10
			)),
			(o = Hv(e, o)),
			o
		)
	}
	function qv(e, t, n, r) {
		let i = [],
			s = e
				.filter((u) => u.modified.isEmpty && u.original.length >= 3)
				.map((u) => new $o(u.original, t, u)),
			o = new Set(
				e
					.filter((u) => u.original.isEmpty && u.modified.length >= 3)
					.map((u) => new $o(u.modified, n, u))
			),
			a = new Set()
		for (let u of s) {
			let h = -1,
				N
			for (let I of o) {
				let Q = u.computeSimilarity(I)
				Q > h && ((h = Q), (N = I))
			}
			if (
				(h > 0.9 &&
					N &&
					(o.delete(N), i.push(new Ls(u.range, N.range)), a.add(u.source), a.add(N.source)),
				!r.isValid())
			)
				return { moves: i, excludedChanges: a }
		}
		return { moves: i, excludedChanges: a }
	}
	function Gv(e, t, n, r, i, s) {
		let o = [],
			a = new So()
		for (let Q of e)
			for (let K = Q.original.startLineNumber; K < Q.original.endLineNumberExclusive - 2; K++) {
				let ue = `${t[K - 1]}:${t[K + 1 - 1]}:${t[K + 2 - 1]}`
				a.add(ue, { range: new Xn(K, K + 3) })
			}
		let u = []
		e.sort(Us((Q) => Q.modified.startLineNumber, qs))
		for (let Q of e) {
			let K = []
			for (let ue = Q.modified.startLineNumber; ue < Q.modified.endLineNumberExclusive - 2; ue++) {
				let de = `${n[ue - 1]}:${n[ue + 1 - 1]}:${n[ue + 2 - 1]}`,
					Pe = new Xn(ue, ue + 3),
					Ze = []
				a.forEach(de, ({ range: Ae }) => {
					for (let it of K)
						if (
							it.originalLineRange.endLineNumberExclusive + 1 === Ae.endLineNumberExclusive &&
							it.modifiedLineRange.endLineNumberExclusive + 1 === Pe.endLineNumberExclusive
						) {
							;(it.originalLineRange = new Xn(
								it.originalLineRange.startLineNumber,
								Ae.endLineNumberExclusive
							)),
								(it.modifiedLineRange = new Xn(
									it.modifiedLineRange.startLineNumber,
									Pe.endLineNumberExclusive
								)),
								Ze.push(it)
							return
						}
					let ze = { modifiedLineRange: Pe, originalLineRange: Ae }
					u.push(ze), Ze.push(ze)
				}),
					(K = Ze)
			}
			if (!s.isValid()) return []
		}
		u.sort(g0(Us((Q) => Q.modifiedLineRange.length, qs)))
		let h = new Ys(),
			N = new Ys()
		for (let Q of u) {
			let K = Q.modifiedLineRange.startLineNumber - Q.originalLineRange.startLineNumber,
				ue = h.subtractFrom(Q.modifiedLineRange),
				de = N.subtractFrom(Q.originalLineRange).getWithDelta(K),
				Pe = ue.getIntersection(de)
			for (let Ze of Pe.ranges) {
				if (Ze.length < 3) continue
				let Ae = Ze,
					ze = Ze.delta(-K)
				o.push(new Ls(ze, Ae)), h.addRange(Ae), N.addRange(ze)
			}
		}
		o.sort(Us((Q) => Q.original.startLineNumber, qs))
		let I = new Co(e)
		for (let Q = 0; Q < o.length; Q++) {
			let K = o[Q],
				ue = I.findLastMonotonous(
					(_t) => _t.original.startLineNumber <= K.original.startLineNumber
				),
				de = us(e, (_t) => _t.modified.startLineNumber <= K.modified.startLineNumber),
				Pe = Math.max(
					K.original.startLineNumber - ue.original.startLineNumber,
					K.modified.startLineNumber - de.modified.startLineNumber
				),
				Ze = I.findLastMonotonous(
					(_t) => _t.original.startLineNumber < K.original.endLineNumberExclusive
				),
				Ae = us(e, (_t) => _t.modified.startLineNumber < K.modified.endLineNumberExclusive),
				ze = Math.max(
					Ze.original.endLineNumberExclusive - K.original.endLineNumberExclusive,
					Ae.modified.endLineNumberExclusive - K.modified.endLineNumberExclusive
				),
				it
			for (it = 0; it < Pe; it++) {
				let _t = K.original.startLineNumber - it - 1,
					ct = K.modified.startLineNumber - it - 1
				if (
					_t > r.length ||
					ct > i.length ||
					h.contains(ct) ||
					N.contains(_t) ||
					!fm(r[_t - 1], i[ct - 1], s)
				)
					break
			}
			it > 0 &&
				(N.addRange(new Xn(K.original.startLineNumber - it, K.original.startLineNumber)),
				h.addRange(new Xn(K.modified.startLineNumber - it, K.modified.startLineNumber)))
			let Et
			for (Et = 0; Et < ze; Et++) {
				let _t = K.original.endLineNumberExclusive + Et,
					ct = K.modified.endLineNumberExclusive + Et
				if (
					_t > r.length ||
					ct > i.length ||
					h.contains(ct) ||
					N.contains(_t) ||
					!fm(r[_t - 1], i[ct - 1], s)
				)
					break
			}
			Et > 0 &&
				(N.addRange(
					new Xn(K.original.endLineNumberExclusive, K.original.endLineNumberExclusive + Et)
				),
				h.addRange(
					new Xn(K.modified.endLineNumberExclusive, K.modified.endLineNumberExclusive + Et)
				)),
				(it > 0 || Et > 0) &&
					(o[Q] = new Ls(
						new Xn(K.original.startLineNumber - it, K.original.endLineNumberExclusive + Et),
						new Xn(K.modified.startLineNumber - it, K.modified.endLineNumberExclusive + Et)
					))
		}
		return o
	}
	function fm(e, t, n) {
		if (e.trim() === t.trim()) return !0
		if (e.length > 300 && t.length > 300) return !1
		let i = new Vo().compute(new Is([e], new $n(0, 1), !1), new Is([t], new $n(0, 1), !1), n),
			s = 0,
			o = $r.invert(i.diffs, e.length)
		for (let N of o)
			N.seq1Range.forEach((I) => {
				nu(e.charCodeAt(I)) || s++
			})
		function a(N) {
			let I = 0
			for (let Q = 0; Q < e.length; Q++) nu(N.charCodeAt(Q)) || I++
			return I
		}
		let u = a(e.length > t.length ? e : t)
		return s / u > 0.6 && u > 10
	}
	function Wv(e) {
		if (e.length === 0) return e
		e.sort(Us((n) => n.original.startLineNumber, qs))
		let t = [e[0]]
		for (let n = 1; n < e.length; n++) {
			let r = t[t.length - 1],
				i = e[n],
				s = i.original.startLineNumber - r.original.endLineNumberExclusive,
				o = i.modified.startLineNumber - r.modified.endLineNumberExclusive
			if (s >= 0 && o >= 0 && s + o <= 2) {
				t[t.length - 1] = r.join(i)
				continue
			}
			t.push(i)
		}
		return t
	}
	function Hv(e, t) {
		let n = new Co(e)
		return (
			(t = t.filter((r) => {
				let i =
						n.findLastMonotonous(
							(a) => a.original.endLineNumberExclusive < r.original.endLineNumberExclusive
						) || new Ls(new Xn(1, 1), new Xn(1, 1)),
					s = us(e, (a) => a.modified.endLineNumberExclusive < r.modified.endLineNumberExclusive)
				return i !== s
			})),
			t
		)
	}
	function yf(e, t, n) {
		let r = n
		return (r = Jv(e, t, r)), (r = zv(e, t, r)), r
	}
	function Jv(e, t, n) {
		if (n.length === 0) return n
		let r = []
		r.push(n[0])
		for (let s = 1; s < n.length; s++) {
			let o = r[r.length - 1],
				a = n[s]
			if (a.seq1Range.isEmpty || a.seq2Range.isEmpty) {
				let u = a.seq1Range.start - o.seq1Range.endExclusive,
					h
				for (
					h = 1;
					h <= u &&
					!(
						e.getElement(a.seq1Range.start - h) !== e.getElement(a.seq1Range.endExclusive - h) ||
						t.getElement(a.seq2Range.start - h) !== t.getElement(a.seq2Range.endExclusive - h)
					);
					h++
				);
				if ((h--, h === u)) {
					r[r.length - 1] = new $r(
						new $n(o.seq1Range.start, a.seq1Range.endExclusive - u),
						new $n(o.seq2Range.start, a.seq2Range.endExclusive - u)
					)
					continue
				}
				a = a.delta(-h)
			}
			r.push(a)
		}
		let i = []
		for (let s = 0; s < r.length - 1; s++) {
			let o = r[s + 1],
				a = r[s]
			if (a.seq1Range.isEmpty || a.seq2Range.isEmpty) {
				let u = o.seq1Range.start - a.seq1Range.endExclusive,
					h
				for (
					h = 0;
					h < u &&
					!(
						!e.isStronglyEqual(a.seq1Range.start + h, a.seq1Range.endExclusive + h) ||
						!t.isStronglyEqual(a.seq2Range.start + h, a.seq2Range.endExclusive + h)
					);
					h++
				);
				if (h === u) {
					r[s + 1] = new $r(
						new $n(a.seq1Range.start + u, o.seq1Range.endExclusive),
						new $n(a.seq2Range.start + u, o.seq2Range.endExclusive)
					)
					continue
				}
				h > 0 && (a = a.delta(h))
			}
			i.push(a)
		}
		return r.length > 0 && i.push(r[r.length - 1]), i
	}
	function zv(e, t, n) {
		if (!e.getBoundaryScore || !t.getBoundaryScore) return n
		for (let r = 0; r < n.length; r++) {
			let i = r > 0 ? n[r - 1] : void 0,
				s = n[r],
				o = r + 1 < n.length ? n[r + 1] : void 0,
				a = new $n(i ? i.seq1Range.start + 1 : 0, o ? o.seq1Range.endExclusive - 1 : e.length),
				u = new $n(i ? i.seq2Range.start + 1 : 0, o ? o.seq2Range.endExclusive - 1 : t.length)
			s.seq1Range.isEmpty
				? (n[r] = hm(s, e, t, a, u))
				: s.seq2Range.isEmpty && (n[r] = hm(s.swap(), t, e, u, a).swap())
		}
		return n
	}
	function hm(e, t, n, r, i) {
		let o = 1
		for (
			;
			e.seq1Range.start - o >= r.start &&
			e.seq2Range.start - o >= i.start &&
			n.isStronglyEqual(e.seq2Range.start - o, e.seq2Range.endExclusive - o) &&
			o < 100;

		)
			o++
		o--
		let a = 0
		for (
			;
			e.seq1Range.start + a < r.endExclusive &&
			e.seq2Range.endExclusive + a < i.endExclusive &&
			n.isStronglyEqual(e.seq2Range.start + a, e.seq2Range.endExclusive + a) &&
			a < 100;

		)
			a++
		if (o === 0 && a === 0) return e
		let u = 0,
			h = -1
		for (let N = -o; N <= a; N++) {
			let I = e.seq2Range.start + N,
				Q = e.seq2Range.endExclusive + N,
				K = e.seq1Range.start + N,
				ue = t.getBoundaryScore(K) + n.getBoundaryScore(I) + n.getBoundaryScore(Q)
			ue > h && ((h = ue), (u = N))
		}
		return e.delta(u)
	}
	function mm(e, t, n) {
		let r = []
		for (let i of n) {
			let s = r[r.length - 1]
			if (!s) {
				r.push(i)
				continue
			}
			i.seq1Range.start - s.seq1Range.endExclusive <= 2 ||
			i.seq2Range.start - s.seq2Range.endExclusive <= 2
				? (r[r.length - 1] = new $r(s.seq1Range.join(i.seq1Range), s.seq2Range.join(i.seq2Range)))
				: r.push(i)
		}
		return r
	}
	function gm(e, t, n) {
		let r = [],
			i
		function s() {
			if (!i) return
			let a = i.s1Range.length - i.deleted,
				u = i.s2Range.length - i.added
			Math.max(i.deleted, i.added) + (i.count - 1) > a && r.push(new $r(i.s1Range, i.s2Range)),
				(i = void 0)
		}
		for (let a of n) {
			let u = function (K, ue) {
					if (!i || !i.s1Range.containsRange(K) || !i.s2Range.containsRange(ue))
						if (i && !(i.s1Range.endExclusive < K.start && i.s2Range.endExclusive < ue.start)) {
							let Ze = $n.tryCreate(i.s1Range.endExclusive, K.start),
								Ae = $n.tryCreate(i.s2Range.endExclusive, ue.start)
							;(i.deleted += Ze?.length ?? 0),
								(i.added += Ae?.length ?? 0),
								(i.s1Range = i.s1Range.join(K)),
								(i.s2Range = i.s2Range.join(ue))
						} else s(), (i = { added: 0, deleted: 0, count: 0, s1Range: K, s2Range: ue })
					let de = K.intersect(a.seq1Range),
						Pe = ue.intersect(a.seq2Range)
					i.count++, (i.deleted += de?.length ?? 0), (i.added += Pe?.length ?? 0)
				},
				h = e.findWordContaining(a.seq1Range.start - 1),
				N = t.findWordContaining(a.seq2Range.start - 1),
				I = e.findWordContaining(a.seq1Range.endExclusive),
				Q = t.findWordContaining(a.seq2Range.endExclusive)
			h && I && N && Q && h.equals(I) && N.equals(Q)
				? u(h, N)
				: (h && N && u(h, N), I && Q && u(I, Q))
		}
		return s(), Qv(n, r)
	}
	function Qv(e, t) {
		let n = []
		for (; e.length > 0 || t.length > 0; ) {
			let r = e[0],
				i = t[0],
				s
			r && (!i || r.seq1Range.start < i.seq1Range.start) ? (s = e.shift()) : (s = t.shift()),
				n.length > 0 && n[n.length - 1].seq1Range.endExclusive >= s.seq1Range.start
					? (n[n.length - 1] = n[n.length - 1].join(s))
					: n.push(s)
		}
		return n
	}
	function Dm(e, t, n) {
		let r = n
		if (r.length === 0) return r
		let i = 0,
			s
		do {
			s = !1
			let o = [r[0]]
			for (let a = 1; a < r.length; a++) {
				let N = function (Q, K) {
						let ue = new $n(h.seq1Range.endExclusive, u.seq1Range.start)
						return (
							e.getText(ue).replace(/\s/g, '').length <= 4 &&
							(Q.seq1Range.length + Q.seq2Range.length > 5 ||
								K.seq1Range.length + K.seq2Range.length > 5)
						)
					},
					u = r[a],
					h = o[o.length - 1]
				N(h, u) ? ((s = !0), (o[o.length - 1] = o[o.length - 1].join(u))) : o.push(u)
			}
			r = o
		} while (i++ < 10 && s)
		return r
	}
	function ym(e, t, n) {
		let r = n
		if (r.length === 0) return r
		let i = 0,
			s
		do {
			s = !1
			let a = [r[0]]
			for (let u = 1; u < r.length; u++) {
				let I = function (K, ue) {
						let de = new $n(N.seq1Range.endExclusive, h.seq1Range.start)
						if (e.countLinesIn(de) > 5 || de.length > 500) return !1
						let Ze = e.getText(de).trim()
						if (Ze.length > 20 || Ze.split(/\r\n|\r|\n/).length > 1) return !1
						let Ae = e.countLinesIn(K.seq1Range),
							ze = K.seq1Range.length,
							it = t.countLinesIn(K.seq2Range),
							Et = K.seq2Range.length,
							_t = e.countLinesIn(ue.seq1Range),
							ct = ue.seq1Range.length,
							St = t.countLinesIn(ue.seq2Range),
							Je = ue.seq2Range.length,
							Ve = 2 * 40 + 50
						function Qt(qt) {
							return Math.min(qt, Ve)
						}
						return (
							Math.pow(Math.pow(Qt(Ae * 40 + ze), 1.5) + Math.pow(Qt(it * 40 + Et), 1.5), 1.5) +
								Math.pow(Math.pow(Qt(_t * 40 + ct), 1.5) + Math.pow(Qt(St * 40 + Je), 1.5), 1.5) >
							(Ve ** 1.5) ** 1.5 * 1.3
						)
					},
					h = r[u],
					N = a[a.length - 1]
				I(N, h) ? ((s = !0), (a[a.length - 1] = a[a.length - 1].join(h))) : a.push(h)
			}
			r = a
		} while (i++ < 10 && s)
		let o = []
		return (
			h0(r, (a, u, h) => {
				let N = u
				function I(Ze) {
					return (
						Ze.length > 0 && Ze.trim().length <= 3 && u.seq1Range.length + u.seq2Range.length > 100
					)
				}
				let Q = e.extendToFullLines(u.seq1Range),
					K = e.getText(new $n(Q.start, u.seq1Range.start))
				I(K) && (N = N.deltaStart(-K.length))
				let ue = e.getText(new $n(u.seq1Range.endExclusive, Q.endExclusive))
				I(ue) && (N = N.deltaEnd(ue.length))
				let de = $r.fromOffsetPairs(a ? a.getEndExclusives() : Ei.zero, h ? h.getStarts() : Ei.max),
					Pe = N.intersect(de)
				o.push(Pe)
			}),
			o
		)
	}
	var ru = class {
		constructor(t, n) {
			;(this.trimmedHash = t), (this.lines = n)
		}
		getElement(t) {
			return this.trimmedHash[t]
		}
		get length() {
			return this.trimmedHash.length
		}
		getBoundaryScore(t) {
			let n = t === 0 ? 0 : Em(this.lines[t - 1]),
				r = t === this.lines.length ? 0 : Em(this.lines[t])
			return 1e3 - (n + r)
		}
		getText(t) {
			return this.lines.slice(t.start, t.endExclusive).join(`
`)
		}
		isStronglyEqual(t, n) {
			return this.lines[t] === this.lines[n]
		}
	}
	function Em(e) {
		let t = 0
		for (; t < e.length && (e.charCodeAt(t) === 32 || e.charCodeAt(t) === 9); ) t++
		return t
	}
	var Ul = class {
		constructor() {
			;(this.dynamicProgrammingDiffing = new $l()), (this.myersDiffingAlgorithm = new Vo())
		}
		computeDiff(t, n, r) {
			if (t.length <= 1 && p0(t, n, (Et, _t) => Et === _t)) return new ws([], [], !1)
			if ((t.length === 1 && t[0].length === 0) || (n.length === 1 && n[0].length === 0))
				return new ws(
					[
						new Bi(new Xn(1, t.length + 1), new Xn(1, n.length + 1), [
							new Xs(
								new Wn(1, 1, t.length, t[0].length + 1),
								new Wn(1, 1, n.length, n[0].length + 1)
							)
						])
					],
					[],
					!1
				)
			let i = r.maxComputationTimeMs === 0 ? zi.instance : new jl(r.maxComputationTimeMs),
				s = !r.ignoreTrimWhitespace,
				o = new Map()
			function a(Et) {
				let _t = o.get(Et)
				return _t === void 0 && ((_t = o.size), o.set(Et, _t)), _t
			}
			let u = t.map((Et) => a(Et.trim())),
				h = n.map((Et) => a(Et.trim())),
				N = new ru(u, t),
				I = new ru(h, n),
				Q = (() =>
					N.length + I.length < 1700
						? this.dynamicProgrammingDiffing.compute(N, I, i, (Et, _t) =>
								t[Et] === n[_t] ? (n[_t].length === 0 ? 0.1 : 1 + Math.log(1 + n[_t].length)) : 0.99
						  )
						: this.myersDiffingAlgorithm.compute(N, I))(),
				K = Q.diffs,
				ue = Q.hitTimeout
			;(K = yf(N, I, K)), (K = Dm(N, I, K))
			let de = [],
				Pe = (Et) => {
					if (s)
						for (let _t = 0; _t < Et; _t++) {
							let ct = Ze + _t,
								St = Ae + _t
							if (t[ct] !== n[St]) {
								let Je = this.refineDiff(t, n, new $r(new $n(ct, ct + 1), new $n(St, St + 1)), i, s)
								for (let Ve of Je.mappings) de.push(Ve)
								Je.hitTimeout && (ue = !0)
							}
						}
				},
				Ze = 0,
				Ae = 0
			for (let Et of K) {
				Po(() => Et.seq1Range.start - Ze === Et.seq2Range.start - Ae)
				let _t = Et.seq1Range.start - Ze
				Pe(_t), (Ze = Et.seq1Range.endExclusive), (Ae = Et.seq2Range.endExclusive)
				let ct = this.refineDiff(t, n, Et, i, s)
				ct.hitTimeout && (ue = !0)
				for (let St of ct.mappings) de.push(St)
			}
			Pe(t.length - Ze)
			let ze = vm(de, t, n),
				it = []
			return (
				r.computeMoves && (it = this.computeMoves(ze, t, n, u, h, i, s)),
				Po(() => {
					function Et(ct, St) {
						if (ct.lineNumber < 1 || ct.lineNumber > St.length) return !1
						let Je = St[ct.lineNumber - 1]
						return !(ct.column < 1 || ct.column > Je.length + 1)
					}
					function _t(ct, St) {
						return !(
							ct.startLineNumber < 1 ||
							ct.startLineNumber > St.length + 1 ||
							ct.endLineNumberExclusive < 1 ||
							ct.endLineNumberExclusive > St.length + 1
						)
					}
					for (let ct of ze) {
						if (!ct.innerChanges) return !1
						for (let St of ct.innerChanges)
							if (
								!(
									Et(St.modifiedRange.getStartPosition(), n) &&
									Et(St.modifiedRange.getEndPosition(), n) &&
									Et(St.originalRange.getStartPosition(), t) &&
									Et(St.originalRange.getEndPosition(), t)
								)
							)
								return !1
						if (!_t(ct.modified, n) || !_t(ct.original, t)) return !1
					}
					return !0
				}),
				new ws(ze, it, ue)
			)
		}
		computeMoves(t, n, r, i, s, o, a) {
			return dm(t, n, r, i, s, o).map((N) => {
				let I = this.refineDiff(
						n,
						r,
						new $r(N.original.toOffsetRange(), N.modified.toOffsetRange()),
						o,
						a
					),
					Q = vm(I.mappings, n, r, !0)
				return new Bl(N, Q)
			})
		}
		refineDiff(t, n, r, i, s) {
			let o = new Is(t, r.seq1Range, s),
				a = new Is(n, r.seq2Range, s),
				u =
					o.length + a.length < 500
						? this.dynamicProgrammingDiffing.compute(o, a, i)
						: this.myersDiffingAlgorithm.compute(o, a, i),
				h = u.diffs
			return (
				(h = yf(o, a, h)),
				(h = gm(o, a, h)),
				(h = mm(o, a, h)),
				(h = ym(o, a, h)),
				{
					mappings: h.map(
						(I) => new Xs(o.translateRange(I.seq1Range), a.translateRange(I.seq2Range))
					),
					hitTimeout: u.hitTimeout
				}
			)
		}
	}
	function vm(e, t, n, r = !1) {
		let i = []
		for (let s of f0(
			e.map((o) => Yv(o, t, n)),
			(o, a) => o.original.overlapOrTouch(a.original) || o.modified.overlapOrTouch(a.modified)
		)) {
			let o = s[0],
				a = s[s.length - 1]
			i.push(
				new Bi(
					o.original.join(a.original),
					o.modified.join(a.modified),
					s.map((u) => u.innerChanges[0])
				)
			)
		}
		return (
			Po(() =>
				!r && i.length > 0 && i[0].original.startLineNumber !== i[0].modified.startLineNumber
					? !1
					: kl(
							i,
							(s, o) =>
								o.original.startLineNumber - s.original.endLineNumberExclusive ===
									o.modified.startLineNumber - s.modified.endLineNumberExclusive &&
								s.original.endLineNumberExclusive < o.original.startLineNumber &&
								s.modified.endLineNumberExclusive < o.modified.startLineNumber
					  )
			),
			i
		)
	}
	function Yv(e, t, n) {
		let r = 0,
			i = 0
		e.modifiedRange.endColumn === 1 &&
			e.originalRange.endColumn === 1 &&
			e.originalRange.startLineNumber + r <= e.originalRange.endLineNumber &&
			e.modifiedRange.startLineNumber + r <= e.modifiedRange.endLineNumber &&
			(i = -1),
			e.modifiedRange.startColumn - 1 >= n[e.modifiedRange.startLineNumber - 1].length &&
				e.originalRange.startColumn - 1 >= t[e.originalRange.startLineNumber - 1].length &&
				e.originalRange.startLineNumber <= e.originalRange.endLineNumber + i &&
				e.modifiedRange.startLineNumber <= e.modifiedRange.endLineNumber + i &&
				(r = 1)
		let s = new Xn(e.originalRange.startLineNumber + r, e.originalRange.endLineNumber + 1 + i),
			o = new Xn(e.modifiedRange.startLineNumber + r, e.modifiedRange.endLineNumber + 1 + i)
		return new Bi(s, o, [e])
	}
	var ql = { getLegacy: () => new Pl(), getDefault: () => new Ul() }
	function ks(e, t) {
		let n = Math.pow(10, t)
		return Math.round(e * n) / n
	}
	var Er = class {
			constructor(t, n, r, i = 1) {
				;(this._rgbaBrand = void 0),
					(this.r = Math.min(255, Math.max(0, t)) | 0),
					(this.g = Math.min(255, Math.max(0, n)) | 0),
					(this.b = Math.min(255, Math.max(0, r)) | 0),
					(this.a = ks(Math.max(Math.min(1, i), 0), 3))
			}
			static equals(t, n) {
				return t.r === n.r && t.g === n.g && t.b === n.b && t.a === n.a
			}
		},
		Qi = class e {
			constructor(t, n, r, i) {
				;(this._hslaBrand = void 0),
					(this.h = Math.max(Math.min(360, t), 0) | 0),
					(this.s = ks(Math.max(Math.min(1, n), 0), 3)),
					(this.l = ks(Math.max(Math.min(1, r), 0), 3)),
					(this.a = ks(Math.max(Math.min(1, i), 0), 3))
			}
			static equals(t, n) {
				return t.h === n.h && t.s === n.s && t.l === n.l && t.a === n.a
			}
			static fromRGBA(t) {
				let n = t.r / 255,
					r = t.g / 255,
					i = t.b / 255,
					s = t.a,
					o = Math.max(n, r, i),
					a = Math.min(n, r, i),
					u = 0,
					h = 0,
					N = (a + o) / 2,
					I = o - a
				if (I > 0) {
					switch (((h = Math.min(N <= 0.5 ? I / (2 * N) : I / (2 - 2 * N), 1)), o)) {
						case n:
							u = (r - i) / I + (r < i ? 6 : 0)
							break
						case r:
							u = (i - n) / I + 2
							break
						case i:
							u = (n - r) / I + 4
							break
					}
					;(u *= 60), (u = Math.round(u))
				}
				return new e(u, h, N, s)
			}
			static _hue2rgb(t, n, r) {
				return (
					r < 0 && (r += 1),
					r > 1 && (r -= 1),
					r < 1 / 6
						? t + (n - t) * 6 * r
						: r < 1 / 2
						? n
						: r < 2 / 3
						? t + (n - t) * (2 / 3 - r) * 6
						: t
				)
			}
			static toRGBA(t) {
				let n = t.h / 360,
					{ s: r, l: i, a: s } = t,
					o,
					a,
					u
				if (r === 0) o = a = u = i
				else {
					let h = i < 0.5 ? i * (1 + r) : i + r - i * r,
						N = 2 * i - h
					;(o = e._hue2rgb(N, h, n + 1 / 3)),
						(a = e._hue2rgb(N, h, n)),
						(u = e._hue2rgb(N, h, n - 1 / 3))
				}
				return new Er(Math.round(o * 255), Math.round(a * 255), Math.round(u * 255), s)
			}
		},
		Uo = class e {
			constructor(t, n, r, i) {
				;(this._hsvaBrand = void 0),
					(this.h = Math.max(Math.min(360, t), 0) | 0),
					(this.s = ks(Math.max(Math.min(1, n), 0), 3)),
					(this.v = ks(Math.max(Math.min(1, r), 0), 3)),
					(this.a = ks(Math.max(Math.min(1, i), 0), 3))
			}
			static equals(t, n) {
				return t.h === n.h && t.s === n.s && t.v === n.v && t.a === n.a
			}
			static fromRGBA(t) {
				let n = t.r / 255,
					r = t.g / 255,
					i = t.b / 255,
					s = Math.max(n, r, i),
					o = Math.min(n, r, i),
					a = s - o,
					u = s === 0 ? 0 : a / s,
					h
				return (
					a === 0
						? (h = 0)
						: s === n
						? (h = ((((r - i) / a) % 6) + 6) % 6)
						: s === r
						? (h = (i - n) / a + 2)
						: (h = (n - r) / a + 4),
					new e(Math.round(h * 60), u, s, t.a)
				)
			}
			static toRGBA(t) {
				let { h: n, s: r, v: i, a: s } = t,
					o = i * r,
					a = o * (1 - Math.abs(((n / 60) % 2) - 1)),
					u = i - o,
					[h, N, I] = [0, 0, 0]
				return (
					n < 60
						? ((h = o), (N = a))
						: n < 120
						? ((h = a), (N = o))
						: n < 180
						? ((N = o), (I = a))
						: n < 240
						? ((N = a), (I = o))
						: n < 300
						? ((h = a), (I = o))
						: n <= 360 && ((h = o), (I = a)),
					(h = Math.round((h + u) * 255)),
					(N = Math.round((N + u) * 255)),
					(I = Math.round((I + u) * 255)),
					new Er(h, N, I, s)
				)
			}
		},
		vr = class e {
			static fromHex(t) {
				return e.Format.CSS.parseHex(t) || e.red
			}
			static equals(t, n) {
				return !t && !n ? !0 : !t || !n ? !1 : t.equals(n)
			}
			get hsla() {
				return this._hsla ? this._hsla : Qi.fromRGBA(this.rgba)
			}
			get hsva() {
				return this._hsva ? this._hsva : Uo.fromRGBA(this.rgba)
			}
			constructor(t) {
				if (t)
					if (t instanceof Er) this.rgba = t
					else if (t instanceof Qi) (this._hsla = t), (this.rgba = Qi.toRGBA(t))
					else if (t instanceof Uo) (this._hsva = t), (this.rgba = Uo.toRGBA(t))
					else throw new Error('Invalid color ctor argument')
				else throw new Error('Color needs a value')
			}
			equals(t) {
				return (
					!!t &&
					Er.equals(this.rgba, t.rgba) &&
					Qi.equals(this.hsla, t.hsla) &&
					Uo.equals(this.hsva, t.hsva)
				)
			}
			getRelativeLuminance() {
				let t = e._relativeLuminanceForComponent(this.rgba.r),
					n = e._relativeLuminanceForComponent(this.rgba.g),
					r = e._relativeLuminanceForComponent(this.rgba.b),
					i = 0.2126 * t + 0.7152 * n + 0.0722 * r
				return ks(i, 4)
			}
			static _relativeLuminanceForComponent(t) {
				let n = t / 255
				return n <= 0.03928 ? n / 12.92 : Math.pow((n + 0.055) / 1.055, 2.4)
			}
			getContrastRatio(t) {
				let n = this.getRelativeLuminance(),
					r = t.getRelativeLuminance()
				return n > r ? (n + 0.05) / (r + 0.05) : (r + 0.05) / (n + 0.05)
			}
			isDarker() {
				return (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1e3 < 128
			}
			isLighter() {
				return (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1e3 >= 128
			}
			isLighterThan(t) {
				let n = this.getRelativeLuminance(),
					r = t.getRelativeLuminance()
				return n > r
			}
			isDarkerThan(t) {
				let n = this.getRelativeLuminance(),
					r = t.getRelativeLuminance()
				return n < r
			}
			lighten(t) {
				return new e(new Qi(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * t, this.hsla.a))
			}
			darken(t) {
				return new e(new Qi(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * t, this.hsla.a))
			}
			transparent(t) {
				let { r: n, g: r, b: i, a: s } = this.rgba
				return new e(new Er(n, r, i, s * t))
			}
			isTransparent() {
				return this.rgba.a === 0
			}
			isOpaque() {
				return this.rgba.a === 1
			}
			opposite() {
				return new e(new Er(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a))
			}
			blend(t) {
				let n = t.rgba,
					r = this.rgba.a,
					i = n.a,
					s = r + i * (1 - r)
				if (s < 1e-6) return e.transparent
				let o = (this.rgba.r * r) / s + (n.r * i * (1 - r)) / s,
					a = (this.rgba.g * r) / s + (n.g * i * (1 - r)) / s,
					u = (this.rgba.b * r) / s + (n.b * i * (1 - r)) / s
				return new e(new Er(o, a, u, s))
			}
			makeOpaque(t) {
				if (this.isOpaque() || t.rgba.a !== 1) return this
				let { r: n, g: r, b: i, a: s } = this.rgba
				return new e(
					new Er(
						t.rgba.r - s * (t.rgba.r - n),
						t.rgba.g - s * (t.rgba.g - r),
						t.rgba.b - s * (t.rgba.b - i),
						1
					)
				)
			}
			flatten(...t) {
				let n = t.reduceRight((r, i) => e._flatten(i, r))
				return e._flatten(this, n)
			}
			static _flatten(t, n) {
				let r = 1 - t.rgba.a
				return new e(
					new Er(
						r * n.rgba.r + t.rgba.a * t.rgba.r,
						r * n.rgba.g + t.rgba.a * t.rgba.g,
						r * n.rgba.b + t.rgba.a * t.rgba.b
					)
				)
			}
			toString() {
				return this._toString || (this._toString = e.Format.CSS.format(this)), this._toString
			}
			static getLighterColor(t, n, r) {
				if (t.isLighterThan(n)) return t
				r = r || 0.5
				let i = t.getRelativeLuminance(),
					s = n.getRelativeLuminance()
				return (r = (r * (s - i)) / s), t.lighten(r)
			}
			static getDarkerColor(t, n, r) {
				if (t.isDarkerThan(n)) return t
				r = r || 0.5
				let i = t.getRelativeLuminance(),
					s = n.getRelativeLuminance()
				return (r = (r * (i - s)) / i), t.darken(r)
			}
		}
	vr.white = new vr(new Er(255, 255, 255, 1))
	vr.black = new vr(new Er(0, 0, 0, 1))
	vr.red = new vr(new Er(255, 0, 0, 1))
	vr.blue = new vr(new Er(0, 0, 255, 1))
	vr.green = new vr(new Er(0, 255, 0, 1))
	vr.cyan = new vr(new Er(0, 255, 255, 1))
	vr.lightgrey = new vr(new Er(211, 211, 211, 1))
	vr.transparent = new vr(new Er(0, 0, 0, 0))
	;(function (e) {
		let t
		;(function (n) {
			let r
			;(function (i) {
				function s(de) {
					return de.rgba.a === 1
						? `rgb(${de.rgba.r}, ${de.rgba.g}, ${de.rgba.b})`
						: e.Format.CSS.formatRGBA(de)
				}
				i.formatRGB = s
				function o(de) {
					return `rgba(${de.rgba.r}, ${de.rgba.g}, ${de.rgba.b}, ${+de.rgba.a.toFixed(2)})`
				}
				i.formatRGBA = o
				function a(de) {
					return de.hsla.a === 1
						? `hsl(${de.hsla.h}, ${(de.hsla.s * 100).toFixed(2)}%, ${(de.hsla.l * 100).toFixed(
								2
						  )}%)`
						: e.Format.CSS.formatHSLA(de)
				}
				i.formatHSL = a
				function u(de) {
					return `hsla(${de.hsla.h}, ${(de.hsla.s * 100).toFixed(2)}%, ${(de.hsla.l * 100).toFixed(
						2
					)}%, ${de.hsla.a.toFixed(2)})`
				}
				i.formatHSLA = u
				function h(de) {
					let Pe = de.toString(16)
					return Pe.length !== 2 ? '0' + Pe : Pe
				}
				function N(de) {
					return `#${h(de.rgba.r)}${h(de.rgba.g)}${h(de.rgba.b)}`
				}
				i.formatHex = N
				function I(de, Pe = !1) {
					return Pe && de.rgba.a === 1
						? e.Format.CSS.formatHex(de)
						: `#${h(de.rgba.r)}${h(de.rgba.g)}${h(de.rgba.b)}${h(Math.round(de.rgba.a * 255))}`
				}
				i.formatHexA = I
				function Q(de) {
					return de.isOpaque() ? e.Format.CSS.formatHex(de) : e.Format.CSS.formatRGBA(de)
				}
				i.format = Q
				function K(de) {
					let Pe = de.length
					if (Pe === 0 || de.charCodeAt(0) !== 35) return null
					if (Pe === 7) {
						let Ze = 16 * ue(de.charCodeAt(1)) + ue(de.charCodeAt(2)),
							Ae = 16 * ue(de.charCodeAt(3)) + ue(de.charCodeAt(4)),
							ze = 16 * ue(de.charCodeAt(5)) + ue(de.charCodeAt(6))
						return new e(new Er(Ze, Ae, ze, 1))
					}
					if (Pe === 9) {
						let Ze = 16 * ue(de.charCodeAt(1)) + ue(de.charCodeAt(2)),
							Ae = 16 * ue(de.charCodeAt(3)) + ue(de.charCodeAt(4)),
							ze = 16 * ue(de.charCodeAt(5)) + ue(de.charCodeAt(6)),
							it = 16 * ue(de.charCodeAt(7)) + ue(de.charCodeAt(8))
						return new e(new Er(Ze, Ae, ze, it / 255))
					}
					if (Pe === 4) {
						let Ze = ue(de.charCodeAt(1)),
							Ae = ue(de.charCodeAt(2)),
							ze = ue(de.charCodeAt(3))
						return new e(new Er(16 * Ze + Ze, 16 * Ae + Ae, 16 * ze + ze))
					}
					if (Pe === 5) {
						let Ze = ue(de.charCodeAt(1)),
							Ae = ue(de.charCodeAt(2)),
							ze = ue(de.charCodeAt(3)),
							it = ue(de.charCodeAt(4))
						return new e(new Er(16 * Ze + Ze, 16 * Ae + Ae, 16 * ze + ze, (16 * it + it) / 255))
					}
					return null
				}
				i.parseHex = K
				function ue(de) {
					switch (de) {
						case 48:
							return 0
						case 49:
							return 1
						case 50:
							return 2
						case 51:
							return 3
						case 52:
							return 4
						case 53:
							return 5
						case 54:
							return 6
						case 55:
							return 7
						case 56:
							return 8
						case 57:
							return 9
						case 97:
							return 10
						case 65:
							return 10
						case 98:
							return 11
						case 66:
							return 11
						case 99:
							return 12
						case 67:
							return 12
						case 100:
							return 13
						case 68:
							return 13
						case 101:
							return 14
						case 69:
							return 14
						case 102:
							return 15
						case 70:
							return 15
					}
					return 0
				}
			})((r = n.CSS || (n.CSS = {})))
		})((t = e.Format || (e.Format = {})))
	})(vr || (vr = {}))
	function Tm(e) {
		let t = []
		for (let n of e) {
			let r = Number(n)
			;(r || (r === 0 && n.replace(/\s/g, '') !== '')) && t.push(r)
		}
		return t
	}
	function Ef(e, t, n, r) {
		return { red: e / 255, blue: n / 255, green: t / 255, alpha: r }
	}
	function iu(e, t) {
		let n = t.index,
			r = t[0].length
		if (!n) return
		let i = e.positionAt(n)
		return {
			startLineNumber: i.lineNumber,
			startColumn: i.column,
			endLineNumber: i.lineNumber,
			endColumn: i.column + r
		}
	}
	function Xv(e, t) {
		if (!e) return
		let n = vr.Format.CSS.parseHex(t)
		if (n) return { range: e, color: Ef(n.rgba.r, n.rgba.g, n.rgba.b, n.rgba.a) }
	}
	function xm(e, t, n) {
		if (!e || t.length !== 1) return
		let i = t[0].values(),
			s = Tm(i)
		return { range: e, color: Ef(s[0], s[1], s[2], n ? s[3] : 1) }
	}
	function bm(e, t, n) {
		if (!e || t.length !== 1) return
		let i = t[0].values(),
			s = Tm(i),
			o = new vr(new Qi(s[0], s[1] / 100, s[2] / 100, n ? s[3] : 1))
		return { range: e, color: Ef(o.rgba.r, o.rgba.g, o.rgba.b, o.rgba.a) }
	}
	function su(e, t) {
		return typeof e == 'string' ? [...e.matchAll(t)] : e.findMatches(t)
	}
	function Kv(e) {
		let t = [],
			r = su(
				e,
				/\b(rgb|rgba|hsl|hsla)(\([0-9\s,.\%]*\))|(#)([A-Fa-f0-9]{3})\b|(#)([A-Fa-f0-9]{4})\b|(#)([A-Fa-f0-9]{6})\b|(#)([A-Fa-f0-9]{8})\b/gm
			)
		if (r.length > 0)
			for (let i of r) {
				let s = i.filter((h) => h !== void 0),
					o = s[1],
					a = s[2]
				if (!a) continue
				let u
				if (o === 'rgb') {
					let h =
						/^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*\)$/gm
					u = xm(iu(e, i), su(a, h), !1)
				} else if (o === 'rgba') {
					let h =
						/^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm
					u = xm(iu(e, i), su(a, h), !0)
				} else if (o === 'hsl') {
					let h =
						/^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*\)$/gm
					u = bm(iu(e, i), su(a, h), !1)
				} else if (o === 'hsla') {
					let h =
						/^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm
					u = bm(iu(e, i), su(a, h), !0)
				} else o === '#' && (u = Xv(iu(e, i), o + a))
				u && t.push(u)
			}
		return t
	}
	function Am(e) {
		return !e || typeof e.getValue != 'function' || typeof e.positionAt != 'function' ? [] : Kv(e)
	}
	var vf = class extends Tl {
			get uri() {
				return this._uri
			}
			get eol() {
				return this._eol
			}
			getValue() {
				return this.getText()
			}
			findMatches(t) {
				let n = []
				for (let r = 0; r < this._lines.length; r++) {
					let i = this._lines[r],
						s = this.offsetAt(new Rr(r + 1, 1)),
						o = i.matchAll(t)
					for (let a of o) (a.index || a.index === 0) && (a.index = a.index + s), n.push(a)
				}
				return n
			}
			getLinesContent() {
				return this._lines.slice(0)
			}
			getLineCount() {
				return this._lines.length
			}
			getLineContent(t) {
				return this._lines[t - 1]
			}
			getWordAtPosition(t, n) {
				let r = Xa(t.column, th(n), this._lines[t.lineNumber - 1], 0)
				return r ? new Wn(t.lineNumber, r.startColumn, t.lineNumber, r.endColumn) : null
			}
			getWordUntilPosition(t, n) {
				let r = this.getWordAtPosition(t, n)
				return r
					? {
							word: this._lines[t.lineNumber - 1].substring(r.startColumn - 1, t.column - 1),
							startColumn: r.startColumn,
							endColumn: t.column
					  }
					: { word: '', startColumn: t.column, endColumn: t.column }
			}
			words(t) {
				let n = this._lines,
					r = this._wordenize.bind(this),
					i = 0,
					s = '',
					o = 0,
					a = []
				return {
					*[Symbol.iterator]() {
						for (;;)
							if (o < a.length) {
								let u = s.substring(a[o].start, a[o].end)
								;(o += 1), yield u
							} else if (i < n.length) (s = n[i]), (a = r(s, t)), (o = 0), (i += 1)
							else break
					}
				}
			}
			getLineWords(t, n) {
				let r = this._lines[t - 1],
					i = this._wordenize(r, n),
					s = []
				for (let o of i)
					s.push({
						word: r.substring(o.start, o.end),
						startColumn: o.start + 1,
						endColumn: o.end + 1
					})
				return s
			}
			_wordenize(t, n) {
				let r = [],
					i
				for (n.lastIndex = 0; (i = n.exec(t)) && i[0].length !== 0; )
					r.push({ start: i.index, end: i.index + i[0].length })
				return r
			}
			getValueInRange(t) {
				if (((t = this._validateRange(t)), t.startLineNumber === t.endLineNumber))
					return this._lines[t.startLineNumber - 1].substring(t.startColumn - 1, t.endColumn - 1)
				let n = this._eol,
					r = t.startLineNumber - 1,
					i = t.endLineNumber - 1,
					s = []
				s.push(this._lines[r].substring(t.startColumn - 1))
				for (let o = r + 1; o < i; o++) s.push(this._lines[o])
				return s.push(this._lines[i].substring(0, t.endColumn - 1)), s.join(n)
			}
			offsetAt(t) {
				return (
					(t = this._validatePosition(t)),
					this._ensureLineStarts(),
					this._lineStarts.getPrefixSum(t.lineNumber - 2) + (t.column - 1)
				)
			}
			positionAt(t) {
				;(t = Math.floor(t)), (t = Math.max(0, t)), this._ensureLineStarts()
				let n = this._lineStarts.getIndexOf(t),
					r = this._lines[n.index].length
				return { lineNumber: 1 + n.index, column: 1 + Math.min(n.remainder, r) }
			}
			_validateRange(t) {
				let n = this._validatePosition({ lineNumber: t.startLineNumber, column: t.startColumn }),
					r = this._validatePosition({ lineNumber: t.endLineNumber, column: t.endColumn })
				return n.lineNumber !== t.startLineNumber ||
					n.column !== t.startColumn ||
					r.lineNumber !== t.endLineNumber ||
					r.column !== t.endColumn
					? {
							startLineNumber: n.lineNumber,
							startColumn: n.column,
							endLineNumber: r.lineNumber,
							endColumn: r.column
					  }
					: t
			}
			_validatePosition(t) {
				if (!Rr.isIPosition(t)) throw new Error('bad position')
				let { lineNumber: n, column: r } = t,
					i = !1
				if (n < 1) (n = 1), (r = 1), (i = !0)
				else if (n > this._lines.length)
					(n = this._lines.length), (r = this._lines[n - 1].length + 1), (i = !0)
				else {
					let s = this._lines[n - 1].length + 1
					r < 1 ? ((r = 1), (i = !0)) : r > s && ((r = s), (i = !0))
				}
				return i ? { lineNumber: n, column: r } : t
			}
		},
		qo = class e {
			constructor(t, n) {
				;(this._host = t),
					(this._models = Object.create(null)),
					(this._foreignModuleFactory = n),
					(this._foreignModule = null)
			}
			dispose() {
				this._models = Object.create(null)
			}
			_getModel(t) {
				return this._models[t]
			}
			_getModels() {
				let t = []
				return Object.keys(this._models).forEach((n) => t.push(this._models[n])), t
			}
			acceptNewModel(t) {
				this._models[t.url] = new vf(Fs.parse(t.url), t.lines, t.EOL, t.versionId)
			}
			acceptModelChanged(t, n) {
				if (!this._models[t]) return
				this._models[t].onEvents(n)
			}
			acceptRemovedModel(t) {
				this._models[t] && delete this._models[t]
			}
			async computeUnicodeHighlights(t, n, r) {
				let i = this._getModel(t)
				return i
					? Rl.computeUnicodeHighlights(i, n, r)
					: {
							ranges: [],
							hasMore: !1,
							ambiguousCharacterCount: 0,
							invisibleCharacterCount: 0,
							nonBasicAsciiCharacterCount: 0
					  }
			}
			async computeDiff(t, n, r, i) {
				let s = this._getModel(t),
					o = this._getModel(n)
				return !s || !o ? null : e.computeDiff(s, o, r, i)
			}
			static computeDiff(t, n, r, i) {
				let s = i === 'advanced' ? ql.getDefault() : ql.getLegacy(),
					o = t.getLinesContent(),
					a = n.getLinesContent(),
					u = s.computeDiff(o, a, r),
					h = u.changes.length > 0 ? !1 : this._modelsAreIdentical(t, n)
				function N(I) {
					return I.map((Q) => [
						Q.original.startLineNumber,
						Q.original.endLineNumberExclusive,
						Q.modified.startLineNumber,
						Q.modified.endLineNumberExclusive,
						Q.innerChanges?.map((K) => [
							K.originalRange.startLineNumber,
							K.originalRange.startColumn,
							K.originalRange.endLineNumber,
							K.originalRange.endColumn,
							K.modifiedRange.startLineNumber,
							K.modifiedRange.startColumn,
							K.modifiedRange.endLineNumber,
							K.modifiedRange.endColumn
						])
					])
				}
				return {
					identical: h,
					quitEarly: u.hitTimeout,
					changes: N(u.changes),
					moves: u.moves.map((I) => [
						I.lineRangeMapping.original.startLineNumber,
						I.lineRangeMapping.original.endLineNumberExclusive,
						I.lineRangeMapping.modified.startLineNumber,
						I.lineRangeMapping.modified.endLineNumberExclusive,
						N(I.changes)
					])
				}
			}
			static _modelsAreIdentical(t, n) {
				let r = t.getLineCount(),
					i = n.getLineCount()
				if (r !== i) return !1
				for (let s = 1; s <= r; s++) {
					let o = t.getLineContent(s),
						a = n.getLineContent(s)
					if (o !== a) return !1
				}
				return !0
			}
			async computeDirtyDiff(t, n, r) {
				let i = this._getModel(t),
					s = this._getModel(n)
				if (!i || !s) return null
				let o = i.getLinesContent(),
					a = s.getLinesContent()
				return new tu(o, a, {
					shouldComputeCharChanges: !1,
					shouldPostProcessCharChanges: !1,
					shouldIgnoreTrimWhitespace: r,
					shouldMakePrettyDiff: !0,
					maxComputationTime: 1e3
				}).computeDiff().changes
			}
			async computeMoreMinimalEdits(t, n, r) {
				let i = this._getModel(t)
				if (!i) return n
				let s = [],
					o
				n = n.slice(0).sort((u, h) => {
					if (u.range && h.range) return Wn.compareRangesUsingStarts(u.range, h.range)
					let N = u.range ? 0 : 1,
						I = h.range ? 0 : 1
					return N - I
				})
				let a = 0
				for (let u = 1; u < n.length; u++)
					Wn.getEndPosition(n[a].range).equals(Wn.getStartPosition(n[u].range))
						? ((n[a].range = Wn.fromPositions(
								Wn.getStartPosition(n[a].range),
								Wn.getEndPosition(n[u].range)
						  )),
						  (n[a].text += n[u].text))
						: (a++, (n[a] = n[u]))
				n.length = a + 1
				for (let { range: u, text: h, eol: N } of n) {
					if ((typeof N == 'number' && (o = N), Wn.isEmpty(u) && !h)) continue
					let I = i.getValueInRange(u)
					if (((h = h.replace(/\r\n|\n|\r/g, i.eol)), I === h)) continue
					if (Math.max(h.length, I.length) > e._diffLimit) {
						s.push({ range: u, text: h })
						continue
					}
					let Q = H0(I, h, r),
						K = i.offsetAt(Wn.lift(u).getStartPosition())
					for (let ue of Q) {
						let de = i.positionAt(K + ue.originalStart),
							Pe = i.positionAt(K + ue.originalStart + ue.originalLength),
							Ze = {
								text: h.substr(ue.modifiedStart, ue.modifiedLength),
								range: {
									startLineNumber: de.lineNumber,
									startColumn: de.column,
									endLineNumber: Pe.lineNumber,
									endColumn: Pe.column
								}
							}
						i.getValueInRange(Ze.range) !== Ze.text && s.push(Ze)
					}
				}
				return (
					typeof o == 'number' &&
						s.push({
							eol: o,
							text: '',
							range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 }
						}),
					s
				)
			}
			computeHumanReadableDiff(t, n, r) {
				let i = this._getModel(t)
				if (!i) return n
				let s = [],
					o
				n = n.slice(0).sort((a, u) => {
					if (a.range && u.range) return Wn.compareRangesUsingStarts(a.range, u.range)
					let h = a.range ? 0 : 1,
						N = u.range ? 0 : 1
					return h - N
				})
				for (let { range: a, text: u, eol: h } of n) {
					let de = function (Ze, Ae) {
							return new Rr(
								Ze.lineNumber + Ae.lineNumber - 1,
								Ae.lineNumber === 1 ? Ze.column + Ae.column - 1 : Ae.column
							)
						},
						Pe = function (Ze, Ae) {
							let ze = []
							for (let it = Ae.startLineNumber; it <= Ae.endLineNumber; it++) {
								let Et = Ze[it - 1]
								it === Ae.startLineNumber && it === Ae.endLineNumber
									? ze.push(Et.substring(Ae.startColumn - 1, Ae.endColumn - 1))
									: it === Ae.startLineNumber
									? ze.push(Et.substring(Ae.startColumn - 1))
									: it === Ae.endLineNumber
									? ze.push(Et.substring(0, Ae.endColumn - 1))
									: ze.push(Et)
							}
							return ze
						}
					if ((typeof h == 'number' && (o = h), Wn.isEmpty(a) && !u)) continue
					let N = i.getValueInRange(a)
					if (((u = u.replace(/\r\n|\n|\r/g, i.eol)), N === u)) continue
					if (Math.max(u.length, N.length) > e._diffLimit) {
						s.push({ range: a, text: u })
						continue
					}
					let I = N.split(/\r\n|\n|\r/),
						Q = u.split(/\r\n|\n|\r/),
						K = ql.getDefault().computeDiff(I, Q, r),
						ue = Wn.lift(a).getStartPosition()
					for (let Ze of K.changes)
						if (Ze.innerChanges)
							for (let Ae of Ze.innerChanges)
								s.push({
									range: Wn.fromPositions(
										de(ue, Ae.originalRange.getStartPosition()),
										de(ue, Ae.originalRange.getEndPosition())
									),
									text: Pe(Q, Ae.modifiedRange).join(i.eol)
								})
						else throw new ai('The experimental diff algorithm always produces inner changes')
				}
				return (
					typeof o == 'number' &&
						s.push({
							eol: o,
							text: '',
							range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 }
						}),
					s
				)
			}
			async computeLinks(t) {
				let n = this._getModel(t)
				return n ? rh(n) : null
			}
			async computeDefaultDocumentColors(t) {
				let n = this._getModel(t)
				return n ? Am(n) : null
			}
			async textualSuggest(t, n, r, i) {
				let s = new _o(),
					o = new RegExp(r, i),
					a = new Set()
				e: for (let u of t) {
					let h = this._getModel(u)
					if (h) {
						for (let N of h.words(o))
							if (!(N === n || !isNaN(Number(N))) && (a.add(N), a.size > e._suggestionsLimit))
								break e
					}
				}
				return { words: Array.from(a), duration: s.elapsed() }
			}
			async computeWordRanges(t, n, r, i) {
				let s = this._getModel(t)
				if (!s) return Object.create(null)
				let o = new RegExp(r, i),
					a = Object.create(null)
				for (let u = n.startLineNumber; u < n.endLineNumber; u++) {
					let h = s.getLineWords(u, o)
					for (let N of h) {
						if (!isNaN(Number(N.word))) continue
						let I = a[N.word]
						I || ((I = []), (a[N.word] = I)),
							I.push({
								startLineNumber: u,
								startColumn: N.startColumn,
								endLineNumber: u,
								endColumn: N.endColumn
							})
					}
				}
				return a
			}
			async navigateValueSet(t, n, r, i, s) {
				let o = this._getModel(t)
				if (!o) return null
				let a = new RegExp(i, s)
				n.startColumn === n.endColumn &&
					(n = {
						startLineNumber: n.startLineNumber,
						startColumn: n.startColumn,
						endLineNumber: n.endLineNumber,
						endColumn: n.endColumn + 1
					})
				let u = o.getValueInRange(n),
					h = o.getWordAtPosition({ lineNumber: n.startLineNumber, column: n.startColumn }, a)
				if (!h) return null
				let N = o.getValueInRange(h)
				return Bo.INSTANCE.navigateValueSet(n, u, h, N, r)
			}
			loadForeignModule(t, n, r) {
				let o = {
					host: N0(r, (a, u) => this._host.fhr(a, u)),
					getMirrorModels: () => this._getModels()
				}
				return this._foreignModuleFactory
					? ((this._foreignModule = this._foreignModuleFactory(o, n)),
					  Promise.resolve(Ga(this._foreignModule)))
					: Promise.reject(new Error('Unexpected usage'))
			}
			fmr(t, n) {
				if (!this._foreignModule || typeof this._foreignModule[t] != 'function')
					return Promise.reject(new Error('Missing requestHandler or method: ' + t))
				try {
					return Promise.resolve(this._foreignModule[t].apply(this._foreignModule, n))
				} catch (r) {
					return Promise.reject(r)
				}
			}
		}
	qo._diffLimit = 1e5
	qo._suggestionsLimit = 1e4
	typeof importScripts == 'function' && (globalThis.monaco = tm())
	var xf = !1
	function bf(e) {
		if (xf) return
		xf = !0
		let t = new gl(
			(n) => {
				globalThis.postMessage(n)
			},
			(n) => new qo(n, e)
		)
		globalThis.onmessage = (n) => {
			t.onmessage(n.data)
		}
	}
	globalThis.onmessage = (e) => {
		xf || bf(null)
	}
	function On(e, t) {
		if (!!!e) throw new Error(t)
	}
	function Yr(e) {
		return typeof e == 'object' && e !== null
	}
	function xr(e, t) {
		if (!!!e) throw new Error(t ?? 'Unexpected invariant triggered.')
	}
	var Zv = /\r\n|[\n\r]/g
	function Go(e, t) {
		let n = 0,
			r = 1
		for (let i of e.body.matchAll(Zv)) {
			if ((typeof i.index == 'number' || xr(!1), i.index >= t)) break
			;(n = i.index + i[0].length), (r += 1)
		}
		return { line: r, column: t + 1 - n }
	}
	function Tf(e) {
		return Gl(e.source, Go(e.source, e.start))
	}
	function Gl(e, t) {
		let n = e.locationOffset.column - 1,
			r = ''.padStart(n) + e.body,
			i = t.line - 1,
			s = e.locationOffset.line - 1,
			o = t.line + s,
			a = t.line === 1 ? n : 0,
			u = t.column + a,
			h = `${e.name}:${o}:${u}
`,
			N = r.split(/\r\n|[\n\r]/g),
			I = N[i]
		if (I.length > 120) {
			let Q = Math.floor(u / 80),
				K = u % 80,
				ue = []
			for (let de = 0; de < I.length; de += 80) ue.push(I.slice(de, de + 80))
			return (
				h +
				Cm([
					[`${o} |`, ue[0]],
					...ue.slice(1, Q + 1).map((de) => ['|', de]),
					['|', '^'.padStart(K)],
					['|', ue[Q + 1]]
				])
			)
		}
		return (
			h +
			Cm([
				[`${o - 1} |`, N[i - 1]],
				[`${o} |`, I],
				['|', '^'.padStart(u)],
				[`${o + 1} |`, N[i + 1]]
			])
		)
	}
	function Cm(e) {
		let t = e.filter(([r, i]) => i !== void 0),
			n = Math.max(...t.map(([r]) => r.length))
		return t.map(([r, i]) => r.padStart(n) + (i ? ' ' + i : '')).join(`
`)
	}
	function ex(e) {
		let t = e[0]
		return t == null || 'kind' in t || 'length' in t
			? {
					nodes: t,
					source: e[1],
					positions: e[2],
					path: e[3],
					originalError: e[4],
					extensions: e[5]
			  }
			: t
	}
	var et = class e extends Error {
		constructor(t, ...n) {
			var r, i, s
			let { nodes: o, source: a, positions: u, path: h, originalError: N, extensions: I } = ex(n)
			super(t),
				(this.name = 'GraphQLError'),
				(this.path = h ?? void 0),
				(this.originalError = N ?? void 0),
				(this.nodes = Sm(Array.isArray(o) ? o : o ? [o] : void 0))
			let Q = Sm(
				(r = this.nodes) === null || r === void 0
					? void 0
					: r.map((ue) => ue.loc).filter((ue) => ue != null)
			)
			;(this.source = a ?? (Q == null || (i = Q[0]) === null || i === void 0 ? void 0 : i.source)),
				(this.positions = u ?? Q?.map((ue) => ue.start)),
				(this.locations =
					u && a ? u.map((ue) => Go(a, ue)) : Q?.map((ue) => Go(ue.source, ue.start)))
			let K = Yr(N?.extensions) ? N?.extensions : void 0
			;(this.extensions = (s = I ?? K) !== null && s !== void 0 ? s : Object.create(null)),
				Object.defineProperties(this, {
					message: { writable: !0, enumerable: !0 },
					name: { enumerable: !1 },
					nodes: { enumerable: !1 },
					source: { enumerable: !1 },
					positions: { enumerable: !1 },
					originalError: { enumerable: !1 }
				}),
				N != null && N.stack
					? Object.defineProperty(this, 'stack', { value: N.stack, writable: !0, configurable: !0 })
					: Error.captureStackTrace
					? Error.captureStackTrace(this, e)
					: Object.defineProperty(this, 'stack', {
							value: Error().stack,
							writable: !0,
							configurable: !0
					  })
		}
		get [Symbol.toStringTag]() {
			return 'GraphQLError'
		}
		toString() {
			let t = this.message
			if (this.nodes)
				for (let n of this.nodes)
					n.loc &&
						(t +=
							`

` + Tf(n.loc))
			else if (this.source && this.locations)
				for (let n of this.locations)
					t +=
						`

` + Gl(this.source, n)
			return t
		}
		toJSON() {
			let t = { message: this.message }
			return (
				this.locations != null && (t.locations = this.locations),
				this.path != null && (t.path = this.path),
				this.extensions != null &&
					Object.keys(this.extensions).length > 0 &&
					(t.extensions = this.extensions),
				t
			)
		}
	}
	function Sm(e) {
		return e === void 0 || e.length === 0 ? void 0 : e
	}
	function _r(e, t, n) {
		return new et(`Syntax Error: ${n}`, { source: e, positions: [t] })
	}
	var ou = class {
			constructor(t, n, r) {
				;(this.start = t.start),
					(this.end = n.end),
					(this.startToken = t),
					(this.endToken = n),
					(this.source = r)
			}
			get [Symbol.toStringTag]() {
				return 'Location'
			}
			toJSON() {
				return { start: this.start, end: this.end }
			}
		},
		Wo = class {
			constructor(t, n, r, i, s, o) {
				;(this.kind = t),
					(this.start = n),
					(this.end = r),
					(this.line = i),
					(this.column = s),
					(this.value = o),
					(this.prev = null),
					(this.next = null)
			}
			get [Symbol.toStringTag]() {
				return 'Token'
			}
			toJSON() {
				return { kind: this.kind, value: this.value, line: this.line, column: this.column }
			}
		},
		Af = {
			Name: [],
			Document: ['definitions'],
			OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],
			VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],
			Variable: ['name'],
			SelectionSet: ['selections'],
			Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],
			Argument: ['name', 'value'],
			FragmentSpread: ['name', 'directives'],
			InlineFragment: ['typeCondition', 'directives', 'selectionSet'],
			FragmentDefinition: [
				'name',
				'variableDefinitions',
				'typeCondition',
				'directives',
				'selectionSet'
			],
			IntValue: [],
			FloatValue: [],
			StringValue: [],
			BooleanValue: [],
			NullValue: [],
			EnumValue: [],
			ListValue: ['values'],
			ObjectValue: ['fields'],
			ObjectField: ['name', 'value'],
			Directive: ['name', 'arguments'],
			NamedType: ['name'],
			ListType: ['type'],
			NonNullType: ['type'],
			SchemaDefinition: ['description', 'directives', 'operationTypes'],
			OperationTypeDefinition: ['type'],
			ScalarTypeDefinition: ['description', 'name', 'directives'],
			ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
			FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],
			InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],
			InterfaceTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
			UnionTypeDefinition: ['description', 'name', 'directives', 'types'],
			EnumTypeDefinition: ['description', 'name', 'directives', 'values'],
			EnumValueDefinition: ['description', 'name', 'directives'],
			InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],
			DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],
			SchemaExtension: ['directives', 'operationTypes'],
			ScalarTypeExtension: ['name', 'directives'],
			ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
			InterfaceTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
			UnionTypeExtension: ['name', 'directives', 'types'],
			EnumTypeExtension: ['name', 'directives', 'values'],
			InputObjectTypeExtension: ['name', 'directives', 'fields']
		},
		tx = new Set(Object.keys(Af))
	function au(e) {
		let t = e?.kind
		return typeof t == 'string' && tx.has(t)
	}
	var Or
	;(function (e) {
		;(e.QUERY = 'query'), (e.MUTATION = 'mutation'), (e.SUBSCRIPTION = 'subscription')
	})(Or || (Or = {}))
	var Jt
	;(function (e) {
		;(e.QUERY = 'QUERY'),
			(e.MUTATION = 'MUTATION'),
			(e.SUBSCRIPTION = 'SUBSCRIPTION'),
			(e.FIELD = 'FIELD'),
			(e.FRAGMENT_DEFINITION = 'FRAGMENT_DEFINITION'),
			(e.FRAGMENT_SPREAD = 'FRAGMENT_SPREAD'),
			(e.INLINE_FRAGMENT = 'INLINE_FRAGMENT'),
			(e.VARIABLE_DEFINITION = 'VARIABLE_DEFINITION'),
			(e.SCHEMA = 'SCHEMA'),
			(e.SCALAR = 'SCALAR'),
			(e.OBJECT = 'OBJECT'),
			(e.FIELD_DEFINITION = 'FIELD_DEFINITION'),
			(e.ARGUMENT_DEFINITION = 'ARGUMENT_DEFINITION'),
			(e.INTERFACE = 'INTERFACE'),
			(e.UNION = 'UNION'),
			(e.ENUM = 'ENUM'),
			(e.ENUM_VALUE = 'ENUM_VALUE'),
			(e.INPUT_OBJECT = 'INPUT_OBJECT'),
			(e.INPUT_FIELD_DEFINITION = 'INPUT_FIELD_DEFINITION')
	})(Jt || (Jt = {}))
	var oe
	;(function (e) {
		;(e.NAME = 'Name'),
			(e.DOCUMENT = 'Document'),
			(e.OPERATION_DEFINITION = 'OperationDefinition'),
			(e.VARIABLE_DEFINITION = 'VariableDefinition'),
			(e.SELECTION_SET = 'SelectionSet'),
			(e.FIELD = 'Field'),
			(e.ARGUMENT = 'Argument'),
			(e.FRAGMENT_SPREAD = 'FragmentSpread'),
			(e.INLINE_FRAGMENT = 'InlineFragment'),
			(e.FRAGMENT_DEFINITION = 'FragmentDefinition'),
			(e.VARIABLE = 'Variable'),
			(e.INT = 'IntValue'),
			(e.FLOAT = 'FloatValue'),
			(e.STRING = 'StringValue'),
			(e.BOOLEAN = 'BooleanValue'),
			(e.NULL = 'NullValue'),
			(e.ENUM = 'EnumValue'),
			(e.LIST = 'ListValue'),
			(e.OBJECT = 'ObjectValue'),
			(e.OBJECT_FIELD = 'ObjectField'),
			(e.DIRECTIVE = 'Directive'),
			(e.NAMED_TYPE = 'NamedType'),
			(e.LIST_TYPE = 'ListType'),
			(e.NON_NULL_TYPE = 'NonNullType'),
			(e.SCHEMA_DEFINITION = 'SchemaDefinition'),
			(e.OPERATION_TYPE_DEFINITION = 'OperationTypeDefinition'),
			(e.SCALAR_TYPE_DEFINITION = 'ScalarTypeDefinition'),
			(e.OBJECT_TYPE_DEFINITION = 'ObjectTypeDefinition'),
			(e.FIELD_DEFINITION = 'FieldDefinition'),
			(e.INPUT_VALUE_DEFINITION = 'InputValueDefinition'),
			(e.INTERFACE_TYPE_DEFINITION = 'InterfaceTypeDefinition'),
			(e.UNION_TYPE_DEFINITION = 'UnionTypeDefinition'),
			(e.ENUM_TYPE_DEFINITION = 'EnumTypeDefinition'),
			(e.ENUM_VALUE_DEFINITION = 'EnumValueDefinition'),
			(e.INPUT_OBJECT_TYPE_DEFINITION = 'InputObjectTypeDefinition'),
			(e.DIRECTIVE_DEFINITION = 'DirectiveDefinition'),
			(e.SCHEMA_EXTENSION = 'SchemaExtension'),
			(e.SCALAR_TYPE_EXTENSION = 'ScalarTypeExtension'),
			(e.OBJECT_TYPE_EXTENSION = 'ObjectTypeExtension'),
			(e.INTERFACE_TYPE_EXTENSION = 'InterfaceTypeExtension'),
			(e.UNION_TYPE_EXTENSION = 'UnionTypeExtension'),
			(e.ENUM_TYPE_EXTENSION = 'EnumTypeExtension'),
			(e.INPUT_OBJECT_TYPE_EXTENSION = 'InputObjectTypeExtension')
	})(oe || (oe = {}))
	function Wl(e) {
		return e === 9 || e === 32
	}
	function Ho(e) {
		return e >= 48 && e <= 57
	}
	function Nm(e) {
		return (e >= 97 && e <= 122) || (e >= 65 && e <= 90)
	}
	function uu(e) {
		return Nm(e) || e === 95
	}
	function Hl(e) {
		return Nm(e) || Ho(e) || e === 95
	}
	function Fm(e) {
		var t
		let n = Number.MAX_SAFE_INTEGER,
			r = null,
			i = -1
		for (let o = 0; o < e.length; ++o) {
			var s
			let a = e[o],
				u = nx(a)
			u !== a.length &&
				((r = (s = r) !== null && s !== void 0 ? s : o), (i = o), o !== 0 && u < n && (n = u))
		}
		return e
			.map((o, a) => (a === 0 ? o : o.slice(n)))
			.slice((t = r) !== null && t !== void 0 ? t : 0, i + 1)
	}
	function nx(e) {
		let t = 0
		for (; t < e.length && Wl(e.charCodeAt(t)); ) ++t
		return t
	}
	function _m(e, t) {
		let n = e.replace(/"""/g, '\\"""'),
			r = n.split(/\r\n|[\n\r]/g),
			i = r.length === 1,
			s = r.length > 1 && r.slice(1).every((K) => K.length === 0 || Wl(K.charCodeAt(0))),
			o = n.endsWith('\\"""'),
			a = e.endsWith('"') && !o,
			u = e.endsWith('\\'),
			h = a || u,
			N = !(t != null && t.minimize) && (!i || e.length > 70 || h || s || o),
			I = '',
			Q = i && Wl(e.charCodeAt(0))
		return (
			((N && !Q) || s) &&
				(I += `
`),
			(I += n),
			(N || h) &&
				(I += `
`),
			'"""' + I + '"""'
		)
	}
	var ft
	;(function (e) {
		;(e.SOF = '<SOF>'),
			(e.EOF = '<EOF>'),
			(e.BANG = '!'),
			(e.DOLLAR = '$'),
			(e.AMP = '&'),
			(e.PAREN_L = '('),
			(e.PAREN_R = ')'),
			(e.SPREAD = '...'),
			(e.COLON = ':'),
			(e.EQUALS = '='),
			(e.AT = '@'),
			(e.BRACKET_L = '['),
			(e.BRACKET_R = ']'),
			(e.BRACE_L = '{'),
			(e.PIPE = '|'),
			(e.BRACE_R = '}'),
			(e.NAME = 'Name'),
			(e.INT = 'Int'),
			(e.FLOAT = 'Float'),
			(e.STRING = 'String'),
			(e.BLOCK_STRING = 'BlockString'),
			(e.COMMENT = 'Comment')
	})(ft || (ft = {}))
	var cu = class {
		constructor(t) {
			let n = new Wo(ft.SOF, 0, 0, 0, 0)
			;(this.source = t),
				(this.lastToken = n),
				(this.token = n),
				(this.line = 1),
				(this.lineStart = 0)
		}
		get [Symbol.toStringTag]() {
			return 'Lexer'
		}
		advance() {
			return (this.lastToken = this.token), (this.token = this.lookahead())
		}
		lookahead() {
			let t = this.token
			if (t.kind !== ft.EOF)
				do
					if (t.next) t = t.next
					else {
						let n = rx(this, t.end)
						;(t.next = n), (n.prev = t), (t = n)
					}
				while (t.kind === ft.COMMENT)
			return t
		}
	}
	function Lm(e) {
		return (
			e === ft.BANG ||
			e === ft.DOLLAR ||
			e === ft.AMP ||
			e === ft.PAREN_L ||
			e === ft.PAREN_R ||
			e === ft.SPREAD ||
			e === ft.COLON ||
			e === ft.EQUALS ||
			e === ft.AT ||
			e === ft.BRACKET_L ||
			e === ft.BRACKET_R ||
			e === ft.BRACE_L ||
			e === ft.PIPE ||
			e === ft.BRACE_R
		)
	}
	function Jo(e) {
		return (e >= 0 && e <= 55295) || (e >= 57344 && e <= 1114111)
	}
	function Jl(e, t) {
		return Im(e.charCodeAt(t)) && km(e.charCodeAt(t + 1))
	}
	function Im(e) {
		return e >= 55296 && e <= 56319
	}
	function km(e) {
		return e >= 56320 && e <= 57343
	}
	function Ks(e, t) {
		let n = e.source.body.codePointAt(t)
		if (n === void 0) return ft.EOF
		if (n >= 32 && n <= 126) {
			let r = String.fromCodePoint(n)
			return r === '"' ? `'"'` : `"${r}"`
		}
		return 'U+' + n.toString(16).toUpperCase().padStart(4, '0')
	}
	function Br(e, t, n, r, i) {
		let s = e.line,
			o = 1 + n - e.lineStart
		return new Wo(t, n, r, s, o, i)
	}
	function rx(e, t) {
		let n = e.source.body,
			r = n.length,
			i = t
		for (; i < r; ) {
			let s = n.charCodeAt(i)
			switch (s) {
				case 65279:
				case 9:
				case 32:
				case 44:
					++i
					continue
				case 10:
					++i, ++e.line, (e.lineStart = i)
					continue
				case 13:
					n.charCodeAt(i + 1) === 10 ? (i += 2) : ++i, ++e.line, (e.lineStart = i)
					continue
				case 35:
					return ix(e, i)
				case 33:
					return Br(e, ft.BANG, i, i + 1)
				case 36:
					return Br(e, ft.DOLLAR, i, i + 1)
				case 38:
					return Br(e, ft.AMP, i, i + 1)
				case 40:
					return Br(e, ft.PAREN_L, i, i + 1)
				case 41:
					return Br(e, ft.PAREN_R, i, i + 1)
				case 46:
					if (n.charCodeAt(i + 1) === 46 && n.charCodeAt(i + 2) === 46)
						return Br(e, ft.SPREAD, i, i + 3)
					break
				case 58:
					return Br(e, ft.COLON, i, i + 1)
				case 61:
					return Br(e, ft.EQUALS, i, i + 1)
				case 64:
					return Br(e, ft.AT, i, i + 1)
				case 91:
					return Br(e, ft.BRACKET_L, i, i + 1)
				case 93:
					return Br(e, ft.BRACKET_R, i, i + 1)
				case 123:
					return Br(e, ft.BRACE_L, i, i + 1)
				case 124:
					return Br(e, ft.PIPE, i, i + 1)
				case 125:
					return Br(e, ft.BRACE_R, i, i + 1)
				case 34:
					return n.charCodeAt(i + 1) === 34 && n.charCodeAt(i + 2) === 34 ? cx(e, i) : ox(e, i)
			}
			if (Ho(s) || s === 45) return sx(e, i, s)
			if (uu(s)) return px(e, i)
			throw _r(
				e.source,
				i,
				s === 39
					? `Unexpected single quote character ('), did you mean to use a double quote (")?`
					: Jo(s) || Jl(n, i)
					? `Unexpected character: ${Ks(e, i)}.`
					: `Invalid character: ${Ks(e, i)}.`
			)
		}
		return Br(e, ft.EOF, r, r)
	}
	function ix(e, t) {
		let n = e.source.body,
			r = n.length,
			i = t + 1
		for (; i < r; ) {
			let s = n.charCodeAt(i)
			if (s === 10 || s === 13) break
			if (Jo(s)) ++i
			else if (Jl(n, i)) i += 2
			else break
		}
		return Br(e, ft.COMMENT, t, i, n.slice(t + 1, i))
	}
	function sx(e, t, n) {
		let r = e.source.body,
			i = t,
			s = n,
			o = !1
		if ((s === 45 && (s = r.charCodeAt(++i)), s === 48)) {
			if (((s = r.charCodeAt(++i)), Ho(s)))
				throw _r(e.source, i, `Invalid number, unexpected digit after 0: ${Ks(e, i)}.`)
		} else (i = Cf(e, i, s)), (s = r.charCodeAt(i))
		if (
			(s === 46 && ((o = !0), (s = r.charCodeAt(++i)), (i = Cf(e, i, s)), (s = r.charCodeAt(i))),
			(s === 69 || s === 101) &&
				((o = !0),
				(s = r.charCodeAt(++i)),
				(s === 43 || s === 45) && (s = r.charCodeAt(++i)),
				(i = Cf(e, i, s)),
				(s = r.charCodeAt(i))),
			s === 46 || uu(s))
		)
			throw _r(e.source, i, `Invalid number, expected digit but got: ${Ks(e, i)}.`)
		return Br(e, o ? ft.FLOAT : ft.INT, t, i, r.slice(t, i))
	}
	function Cf(e, t, n) {
		if (!Ho(n)) throw _r(e.source, t, `Invalid number, expected digit but got: ${Ks(e, t)}.`)
		let r = e.source.body,
			i = t + 1
		for (; Ho(r.charCodeAt(i)); ) ++i
		return i
	}
	function ox(e, t) {
		let n = e.source.body,
			r = n.length,
			i = t + 1,
			s = i,
			o = ''
		for (; i < r; ) {
			let a = n.charCodeAt(i)
			if (a === 34) return (o += n.slice(s, i)), Br(e, ft.STRING, t, i + 1, o)
			if (a === 92) {
				o += n.slice(s, i)
				let u =
					n.charCodeAt(i + 1) === 117
						? n.charCodeAt(i + 2) === 123
							? ax(e, i)
							: ux(e, i)
						: lx(e, i)
				;(o += u.value), (i += u.size), (s = i)
				continue
			}
			if (a === 10 || a === 13) break
			if (Jo(a)) ++i
			else if (Jl(n, i)) i += 2
			else throw _r(e.source, i, `Invalid character within String: ${Ks(e, i)}.`)
		}
		throw _r(e.source, i, 'Unterminated string.')
	}
	function ax(e, t) {
		let n = e.source.body,
			r = 0,
			i = 3
		for (; i < 12; ) {
			let s = n.charCodeAt(t + i++)
			if (s === 125) {
				if (i < 5 || !Jo(r)) break
				return { value: String.fromCodePoint(r), size: i }
			}
			if (((r = (r << 4) | lu(s)), r < 0)) break
		}
		throw _r(e.source, t, `Invalid Unicode escape sequence: "${n.slice(t, t + i)}".`)
	}
	function ux(e, t) {
		let n = e.source.body,
			r = wm(n, t + 2)
		if (Jo(r)) return { value: String.fromCodePoint(r), size: 6 }
		if (Im(r) && n.charCodeAt(t + 6) === 92 && n.charCodeAt(t + 7) === 117) {
			let i = wm(n, t + 8)
			if (km(i)) return { value: String.fromCodePoint(r, i), size: 12 }
		}
		throw _r(e.source, t, `Invalid Unicode escape sequence: "${n.slice(t, t + 6)}".`)
	}
	function wm(e, t) {
		return (
			(lu(e.charCodeAt(t)) << 12) |
			(lu(e.charCodeAt(t + 1)) << 8) |
			(lu(e.charCodeAt(t + 2)) << 4) |
			lu(e.charCodeAt(t + 3))
		)
	}
	function lu(e) {
		return e >= 48 && e <= 57
			? e - 48
			: e >= 65 && e <= 70
			? e - 55
			: e >= 97 && e <= 102
			? e - 87
			: -1
	}
	function lx(e, t) {
		let n = e.source.body
		switch (n.charCodeAt(t + 1)) {
			case 34:
				return { value: '"', size: 2 }
			case 92:
				return { value: '\\', size: 2 }
			case 47:
				return { value: '/', size: 2 }
			case 98:
				return { value: '\b', size: 2 }
			case 102:
				return { value: '\f', size: 2 }
			case 110:
				return {
					value: `
`,
					size: 2
				}
			case 114:
				return { value: '\r', size: 2 }
			case 116:
				return { value: '	', size: 2 }
		}
		throw _r(e.source, t, `Invalid character escape sequence: "${n.slice(t, t + 2)}".`)
	}
	function cx(e, t) {
		let n = e.source.body,
			r = n.length,
			i = e.lineStart,
			s = t + 3,
			o = s,
			a = '',
			u = []
		for (; s < r; ) {
			let h = n.charCodeAt(s)
			if (h === 34 && n.charCodeAt(s + 1) === 34 && n.charCodeAt(s + 2) === 34) {
				;(a += n.slice(o, s)), u.push(a)
				let N = Br(
					e,
					ft.BLOCK_STRING,
					t,
					s + 3,
					Fm(u).join(`
`)
				)
				return (e.line += u.length - 1), (e.lineStart = i), N
			}
			if (
				h === 92 &&
				n.charCodeAt(s + 1) === 34 &&
				n.charCodeAt(s + 2) === 34 &&
				n.charCodeAt(s + 3) === 34
			) {
				;(a += n.slice(o, s)), (o = s + 1), (s += 4)
				continue
			}
			if (h === 10 || h === 13) {
				;(a += n.slice(o, s)),
					u.push(a),
					h === 13 && n.charCodeAt(s + 1) === 10 ? (s += 2) : ++s,
					(a = ''),
					(o = s),
					(i = s)
				continue
			}
			if (Jo(h)) ++s
			else if (Jl(n, s)) s += 2
			else throw _r(e.source, s, `Invalid character within String: ${Ks(e, s)}.`)
		}
		throw _r(e.source, s, 'Unterminated string.')
	}
	function px(e, t) {
		let n = e.source.body,
			r = n.length,
			i = t + 1
		for (; i < r; ) {
			let s = n.charCodeAt(i)
			if (Hl(s)) ++i
			else break
		}
		return Br(e, ft.NAME, t, i, n.slice(t, i))
	}
	function yt(e) {
		return zl(e, [])
	}
	function zl(e, t) {
		switch (typeof e) {
			case 'string':
				return JSON.stringify(e)
			case 'function':
				return e.name ? `[function ${e.name}]` : '[function]'
			case 'object':
				return fx(e, t)
			default:
				return String(e)
		}
	}
	function fx(e, t) {
		if (e === null) return 'null'
		if (t.includes(e)) return '[Circular]'
		let n = [...t, e]
		if (dx(e)) {
			let r = e.toJSON()
			if (r !== e) return typeof r == 'string' ? r : zl(r, n)
		} else if (Array.isArray(e)) return mx(e, n)
		return hx(e, n)
	}
	function dx(e) {
		return typeof e.toJSON == 'function'
	}
	function hx(e, t) {
		let n = Object.entries(e)
		return n.length === 0
			? '{}'
			: t.length > 2
			? '[' + gx(e) + ']'
			: '{ ' + n.map(([i, s]) => i + ': ' + zl(s, t)).join(', ') + ' }'
	}
	function mx(e, t) {
		if (e.length === 0) return '[]'
		if (t.length > 2) return '[Array]'
		let n = Math.min(10, e.length),
			r = e.length - n,
			i = []
		for (let s = 0; s < n; ++s) i.push(zl(e[s], t))
		return (
			r === 1 ? i.push('... 1 more item') : r > 1 && i.push(`... ${r} more items`),
			'[' + i.join(', ') + ']'
		)
	}
	function gx(e) {
		let t = Object.prototype.toString
			.call(e)
			.replace(/^\[object /, '')
			.replace(/]$/, '')
		if (t === 'Object' && typeof e.constructor == 'function') {
			let n = e.constructor.name
			if (typeof n == 'string' && n !== '') return n
		}
		return t
	}
	var ti =
		globalThis.process && globalThis.process.env.NODE_ENV === 'production'
			? function (t, n) {
					return t instanceof n
			  }
			: function (t, n) {
					if (t instanceof n) return !0
					if (typeof t == 'object' && t !== null) {
						var r
						let i = n.prototype[Symbol.toStringTag],
							s =
								Symbol.toStringTag in t
									? t[Symbol.toStringTag]
									: (r = t.constructor) === null || r === void 0
									? void 0
									: r.name
						if (i === s) {
							let o = yt(t)
							throw new Error(`Cannot use ${i} "${o}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`)
						}
					}
					return !1
			  }
	var zo = class {
		constructor(t, n = 'GraphQL request', r = { line: 1, column: 1 }) {
			typeof t == 'string' || On(!1, `Body must be a string. Received: ${yt(t)}.`),
				(this.body = t),
				(this.name = n),
				(this.locationOffset = r),
				this.locationOffset.line > 0 ||
					On(!1, 'line in locationOffset is 1-indexed and must be positive.'),
				this.locationOffset.column > 0 ||
					On(!1, 'column in locationOffset is 1-indexed and must be positive.')
		}
		get [Symbol.toStringTag]() {
			return 'Source'
		}
	}
	function Rm(e) {
		return ti(e, zo)
	}
	function Pi(e, t) {
		return new Yl(e, t).parseDocument()
	}
	function Xl(e, t) {
		let n = new Yl(e, t)
		n.expectToken(ft.SOF)
		let r = n.parseValueLiteral(!1)
		return n.expectToken(ft.EOF), r
	}
	var Yl = class {
		constructor(t, n = {}) {
			let r = Rm(t) ? t : new zo(t)
			;(this._lexer = new cu(r)), (this._options = n), (this._tokenCounter = 0)
		}
		parseName() {
			let t = this.expectToken(ft.NAME)
			return this.node(t, { kind: oe.NAME, value: t.value })
		}
		parseDocument() {
			return this.node(this._lexer.token, {
				kind: oe.DOCUMENT,
				definitions: this.many(ft.SOF, this.parseDefinition, ft.EOF)
			})
		}
		parseDefinition() {
			if (this.peek(ft.BRACE_L)) return this.parseOperationDefinition()
			let t = this.peekDescription(),
				n = t ? this._lexer.lookahead() : this._lexer.token
			if (n.kind === ft.NAME) {
				switch (n.value) {
					case 'schema':
						return this.parseSchemaDefinition()
					case 'scalar':
						return this.parseScalarTypeDefinition()
					case 'type':
						return this.parseObjectTypeDefinition()
					case 'interface':
						return this.parseInterfaceTypeDefinition()
					case 'union':
						return this.parseUnionTypeDefinition()
					case 'enum':
						return this.parseEnumTypeDefinition()
					case 'input':
						return this.parseInputObjectTypeDefinition()
					case 'directive':
						return this.parseDirectiveDefinition()
				}
				if (t)
					throw _r(
						this._lexer.source,
						this._lexer.token.start,
						'Unexpected description, descriptions are supported only on type definitions.'
					)
				switch (n.value) {
					case 'query':
					case 'mutation':
					case 'subscription':
						return this.parseOperationDefinition()
					case 'fragment':
						return this.parseFragmentDefinition()
					case 'extend':
						return this.parseTypeSystemExtension()
				}
			}
			throw this.unexpected(n)
		}
		parseOperationDefinition() {
			let t = this._lexer.token
			if (this.peek(ft.BRACE_L))
				return this.node(t, {
					kind: oe.OPERATION_DEFINITION,
					operation: Or.QUERY,
					name: void 0,
					variableDefinitions: [],
					directives: [],
					selectionSet: this.parseSelectionSet()
				})
			let n = this.parseOperationType(),
				r
			return (
				this.peek(ft.NAME) && (r = this.parseName()),
				this.node(t, {
					kind: oe.OPERATION_DEFINITION,
					operation: n,
					name: r,
					variableDefinitions: this.parseVariableDefinitions(),
					directives: this.parseDirectives(!1),
					selectionSet: this.parseSelectionSet()
				})
			)
		}
		parseOperationType() {
			let t = this.expectToken(ft.NAME)
			switch (t.value) {
				case 'query':
					return Or.QUERY
				case 'mutation':
					return Or.MUTATION
				case 'subscription':
					return Or.SUBSCRIPTION
			}
			throw this.unexpected(t)
		}
		parseVariableDefinitions() {
			return this.optionalMany(ft.PAREN_L, this.parseVariableDefinition, ft.PAREN_R)
		}
		parseVariableDefinition() {
			return this.node(this._lexer.token, {
				kind: oe.VARIABLE_DEFINITION,
				variable: this.parseVariable(),
				type: (this.expectToken(ft.COLON), this.parseTypeReference()),
				defaultValue: this.expectOptionalToken(ft.EQUALS) ? this.parseConstValueLiteral() : void 0,
				directives: this.parseConstDirectives()
			})
		}
		parseVariable() {
			let t = this._lexer.token
			return (
				this.expectToken(ft.DOLLAR), this.node(t, { kind: oe.VARIABLE, name: this.parseName() })
			)
		}
		parseSelectionSet() {
			return this.node(this._lexer.token, {
				kind: oe.SELECTION_SET,
				selections: this.many(ft.BRACE_L, this.parseSelection, ft.BRACE_R)
			})
		}
		parseSelection() {
			return this.peek(ft.SPREAD) ? this.parseFragment() : this.parseField()
		}
		parseField() {
			let t = this._lexer.token,
				n = this.parseName(),
				r,
				i
			return (
				this.expectOptionalToken(ft.COLON) ? ((r = n), (i = this.parseName())) : (i = n),
				this.node(t, {
					kind: oe.FIELD,
					alias: r,
					name: i,
					arguments: this.parseArguments(!1),
					directives: this.parseDirectives(!1),
					selectionSet: this.peek(ft.BRACE_L) ? this.parseSelectionSet() : void 0
				})
			)
		}
		parseArguments(t) {
			let n = t ? this.parseConstArgument : this.parseArgument
			return this.optionalMany(ft.PAREN_L, n, ft.PAREN_R)
		}
		parseArgument(t = !1) {
			let n = this._lexer.token,
				r = this.parseName()
			return (
				this.expectToken(ft.COLON),
				this.node(n, { kind: oe.ARGUMENT, name: r, value: this.parseValueLiteral(t) })
			)
		}
		parseConstArgument() {
			return this.parseArgument(!0)
		}
		parseFragment() {
			let t = this._lexer.token
			this.expectToken(ft.SPREAD)
			let n = this.expectOptionalKeyword('on')
			return !n && this.peek(ft.NAME)
				? this.node(t, {
						kind: oe.FRAGMENT_SPREAD,
						name: this.parseFragmentName(),
						directives: this.parseDirectives(!1)
				  })
				: this.node(t, {
						kind: oe.INLINE_FRAGMENT,
						typeCondition: n ? this.parseNamedType() : void 0,
						directives: this.parseDirectives(!1),
						selectionSet: this.parseSelectionSet()
				  })
		}
		parseFragmentDefinition() {
			let t = this._lexer.token
			return (
				this.expectKeyword('fragment'),
				this._options.allowLegacyFragmentVariables === !0
					? this.node(t, {
							kind: oe.FRAGMENT_DEFINITION,
							name: this.parseFragmentName(),
							variableDefinitions: this.parseVariableDefinitions(),
							typeCondition: (this.expectKeyword('on'), this.parseNamedType()),
							directives: this.parseDirectives(!1),
							selectionSet: this.parseSelectionSet()
					  })
					: this.node(t, {
							kind: oe.FRAGMENT_DEFINITION,
							name: this.parseFragmentName(),
							typeCondition: (this.expectKeyword('on'), this.parseNamedType()),
							directives: this.parseDirectives(!1),
							selectionSet: this.parseSelectionSet()
					  })
			)
		}
		parseFragmentName() {
			if (this._lexer.token.value === 'on') throw this.unexpected()
			return this.parseName()
		}
		parseValueLiteral(t) {
			let n = this._lexer.token
			switch (n.kind) {
				case ft.BRACKET_L:
					return this.parseList(t)
				case ft.BRACE_L:
					return this.parseObject(t)
				case ft.INT:
					return this.advanceLexer(), this.node(n, { kind: oe.INT, value: n.value })
				case ft.FLOAT:
					return this.advanceLexer(), this.node(n, { kind: oe.FLOAT, value: n.value })
				case ft.STRING:
				case ft.BLOCK_STRING:
					return this.parseStringLiteral()
				case ft.NAME:
					switch ((this.advanceLexer(), n.value)) {
						case 'true':
							return this.node(n, { kind: oe.BOOLEAN, value: !0 })
						case 'false':
							return this.node(n, { kind: oe.BOOLEAN, value: !1 })
						case 'null':
							return this.node(n, { kind: oe.NULL })
						default:
							return this.node(n, { kind: oe.ENUM, value: n.value })
					}
				case ft.DOLLAR:
					if (t)
						if ((this.expectToken(ft.DOLLAR), this._lexer.token.kind === ft.NAME)) {
							let r = this._lexer.token.value
							throw _r(
								this._lexer.source,
								n.start,
								`Unexpected variable "$${r}" in constant value.`
							)
						} else throw this.unexpected(n)
					return this.parseVariable()
				default:
					throw this.unexpected()
			}
		}
		parseConstValueLiteral() {
			return this.parseValueLiteral(!0)
		}
		parseStringLiteral() {
			let t = this._lexer.token
			return (
				this.advanceLexer(),
				this.node(t, { kind: oe.STRING, value: t.value, block: t.kind === ft.BLOCK_STRING })
			)
		}
		parseList(t) {
			let n = () => this.parseValueLiteral(t)
			return this.node(this._lexer.token, {
				kind: oe.LIST,
				values: this.any(ft.BRACKET_L, n, ft.BRACKET_R)
			})
		}
		parseObject(t) {
			let n = () => this.parseObjectField(t)
			return this.node(this._lexer.token, {
				kind: oe.OBJECT,
				fields: this.any(ft.BRACE_L, n, ft.BRACE_R)
			})
		}
		parseObjectField(t) {
			let n = this._lexer.token,
				r = this.parseName()
			return (
				this.expectToken(ft.COLON),
				this.node(n, { kind: oe.OBJECT_FIELD, name: r, value: this.parseValueLiteral(t) })
			)
		}
		parseDirectives(t) {
			let n = []
			for (; this.peek(ft.AT); ) n.push(this.parseDirective(t))
			return n
		}
		parseConstDirectives() {
			return this.parseDirectives(!0)
		}
		parseDirective(t) {
			let n = this._lexer.token
			return (
				this.expectToken(ft.AT),
				this.node(n, {
					kind: oe.DIRECTIVE,
					name: this.parseName(),
					arguments: this.parseArguments(t)
				})
			)
		}
		parseTypeReference() {
			let t = this._lexer.token,
				n
			if (this.expectOptionalToken(ft.BRACKET_L)) {
				let r = this.parseTypeReference()
				this.expectToken(ft.BRACKET_R), (n = this.node(t, { kind: oe.LIST_TYPE, type: r }))
			} else n = this.parseNamedType()
			return this.expectOptionalToken(ft.BANG)
				? this.node(t, { kind: oe.NON_NULL_TYPE, type: n })
				: n
		}
		parseNamedType() {
			return this.node(this._lexer.token, { kind: oe.NAMED_TYPE, name: this.parseName() })
		}
		peekDescription() {
			return this.peek(ft.STRING) || this.peek(ft.BLOCK_STRING)
		}
		parseDescription() {
			if (this.peekDescription()) return this.parseStringLiteral()
		}
		parseSchemaDefinition() {
			let t = this._lexer.token,
				n = this.parseDescription()
			this.expectKeyword('schema')
			let r = this.parseConstDirectives(),
				i = this.many(ft.BRACE_L, this.parseOperationTypeDefinition, ft.BRACE_R)
			return this.node(t, {
				kind: oe.SCHEMA_DEFINITION,
				description: n,
				directives: r,
				operationTypes: i
			})
		}
		parseOperationTypeDefinition() {
			let t = this._lexer.token,
				n = this.parseOperationType()
			this.expectToken(ft.COLON)
			let r = this.parseNamedType()
			return this.node(t, { kind: oe.OPERATION_TYPE_DEFINITION, operation: n, type: r })
		}
		parseScalarTypeDefinition() {
			let t = this._lexer.token,
				n = this.parseDescription()
			this.expectKeyword('scalar')
			let r = this.parseName(),
				i = this.parseConstDirectives()
			return this.node(t, {
				kind: oe.SCALAR_TYPE_DEFINITION,
				description: n,
				name: r,
				directives: i
			})
		}
		parseObjectTypeDefinition() {
			let t = this._lexer.token,
				n = this.parseDescription()
			this.expectKeyword('type')
			let r = this.parseName(),
				i = this.parseImplementsInterfaces(),
				s = this.parseConstDirectives(),
				o = this.parseFieldsDefinition()
			return this.node(t, {
				kind: oe.OBJECT_TYPE_DEFINITION,
				description: n,
				name: r,
				interfaces: i,
				directives: s,
				fields: o
			})
		}
		parseImplementsInterfaces() {
			return this.expectOptionalKeyword('implements')
				? this.delimitedMany(ft.AMP, this.parseNamedType)
				: []
		}
		parseFieldsDefinition() {
			return this.optionalMany(ft.BRACE_L, this.parseFieldDefinition, ft.BRACE_R)
		}
		parseFieldDefinition() {
			let t = this._lexer.token,
				n = this.parseDescription(),
				r = this.parseName(),
				i = this.parseArgumentDefs()
			this.expectToken(ft.COLON)
			let s = this.parseTypeReference(),
				o = this.parseConstDirectives()
			return this.node(t, {
				kind: oe.FIELD_DEFINITION,
				description: n,
				name: r,
				arguments: i,
				type: s,
				directives: o
			})
		}
		parseArgumentDefs() {
			return this.optionalMany(ft.PAREN_L, this.parseInputValueDef, ft.PAREN_R)
		}
		parseInputValueDef() {
			let t = this._lexer.token,
				n = this.parseDescription(),
				r = this.parseName()
			this.expectToken(ft.COLON)
			let i = this.parseTypeReference(),
				s
			this.expectOptionalToken(ft.EQUALS) && (s = this.parseConstValueLiteral())
			let o = this.parseConstDirectives()
			return this.node(t, {
				kind: oe.INPUT_VALUE_DEFINITION,
				description: n,
				name: r,
				type: i,
				defaultValue: s,
				directives: o
			})
		}
		parseInterfaceTypeDefinition() {
			let t = this._lexer.token,
				n = this.parseDescription()
			this.expectKeyword('interface')
			let r = this.parseName(),
				i = this.parseImplementsInterfaces(),
				s = this.parseConstDirectives(),
				o = this.parseFieldsDefinition()
			return this.node(t, {
				kind: oe.INTERFACE_TYPE_DEFINITION,
				description: n,
				name: r,
				interfaces: i,
				directives: s,
				fields: o
			})
		}
		parseUnionTypeDefinition() {
			let t = this._lexer.token,
				n = this.parseDescription()
			this.expectKeyword('union')
			let r = this.parseName(),
				i = this.parseConstDirectives(),
				s = this.parseUnionMemberTypes()
			return this.node(t, {
				kind: oe.UNION_TYPE_DEFINITION,
				description: n,
				name: r,
				directives: i,
				types: s
			})
		}
		parseUnionMemberTypes() {
			return this.expectOptionalToken(ft.EQUALS)
				? this.delimitedMany(ft.PIPE, this.parseNamedType)
				: []
		}
		parseEnumTypeDefinition() {
			let t = this._lexer.token,
				n = this.parseDescription()
			this.expectKeyword('enum')
			let r = this.parseName(),
				i = this.parseConstDirectives(),
				s = this.parseEnumValuesDefinition()
			return this.node(t, {
				kind: oe.ENUM_TYPE_DEFINITION,
				description: n,
				name: r,
				directives: i,
				values: s
			})
		}
		parseEnumValuesDefinition() {
			return this.optionalMany(ft.BRACE_L, this.parseEnumValueDefinition, ft.BRACE_R)
		}
		parseEnumValueDefinition() {
			let t = this._lexer.token,
				n = this.parseDescription(),
				r = this.parseEnumValueName(),
				i = this.parseConstDirectives()
			return this.node(t, {
				kind: oe.ENUM_VALUE_DEFINITION,
				description: n,
				name: r,
				directives: i
			})
		}
		parseEnumValueName() {
			if (
				this._lexer.token.value === 'true' ||
				this._lexer.token.value === 'false' ||
				this._lexer.token.value === 'null'
			)
				throw _r(
					this._lexer.source,
					this._lexer.token.start,
					`${Ql(this._lexer.token)} is reserved and cannot be used for an enum value.`
				)
			return this.parseName()
		}
		parseInputObjectTypeDefinition() {
			let t = this._lexer.token,
				n = this.parseDescription()
			this.expectKeyword('input')
			let r = this.parseName(),
				i = this.parseConstDirectives(),
				s = this.parseInputFieldsDefinition()
			return this.node(t, {
				kind: oe.INPUT_OBJECT_TYPE_DEFINITION,
				description: n,
				name: r,
				directives: i,
				fields: s
			})
		}
		parseInputFieldsDefinition() {
			return this.optionalMany(ft.BRACE_L, this.parseInputValueDef, ft.BRACE_R)
		}
		parseTypeSystemExtension() {
			let t = this._lexer.lookahead()
			if (t.kind === ft.NAME)
				switch (t.value) {
					case 'schema':
						return this.parseSchemaExtension()
					case 'scalar':
						return this.parseScalarTypeExtension()
					case 'type':
						return this.parseObjectTypeExtension()
					case 'interface':
						return this.parseInterfaceTypeExtension()
					case 'union':
						return this.parseUnionTypeExtension()
					case 'enum':
						return this.parseEnumTypeExtension()
					case 'input':
						return this.parseInputObjectTypeExtension()
				}
			throw this.unexpected(t)
		}
		parseSchemaExtension() {
			let t = this._lexer.token
			this.expectKeyword('extend'), this.expectKeyword('schema')
			let n = this.parseConstDirectives(),
				r = this.optionalMany(ft.BRACE_L, this.parseOperationTypeDefinition, ft.BRACE_R)
			if (n.length === 0 && r.length === 0) throw this.unexpected()
			return this.node(t, { kind: oe.SCHEMA_EXTENSION, directives: n, operationTypes: r })
		}
		parseScalarTypeExtension() {
			let t = this._lexer.token
			this.expectKeyword('extend'), this.expectKeyword('scalar')
			let n = this.parseName(),
				r = this.parseConstDirectives()
			if (r.length === 0) throw this.unexpected()
			return this.node(t, { kind: oe.SCALAR_TYPE_EXTENSION, name: n, directives: r })
		}
		parseObjectTypeExtension() {
			let t = this._lexer.token
			this.expectKeyword('extend'), this.expectKeyword('type')
			let n = this.parseName(),
				r = this.parseImplementsInterfaces(),
				i = this.parseConstDirectives(),
				s = this.parseFieldsDefinition()
			if (r.length === 0 && i.length === 0 && s.length === 0) throw this.unexpected()
			return this.node(t, {
				kind: oe.OBJECT_TYPE_EXTENSION,
				name: n,
				interfaces: r,
				directives: i,
				fields: s
			})
		}
		parseInterfaceTypeExtension() {
			let t = this._lexer.token
			this.expectKeyword('extend'), this.expectKeyword('interface')
			let n = this.parseName(),
				r = this.parseImplementsInterfaces(),
				i = this.parseConstDirectives(),
				s = this.parseFieldsDefinition()
			if (r.length === 0 && i.length === 0 && s.length === 0) throw this.unexpected()
			return this.node(t, {
				kind: oe.INTERFACE_TYPE_EXTENSION,
				name: n,
				interfaces: r,
				directives: i,
				fields: s
			})
		}
		parseUnionTypeExtension() {
			let t = this._lexer.token
			this.expectKeyword('extend'), this.expectKeyword('union')
			let n = this.parseName(),
				r = this.parseConstDirectives(),
				i = this.parseUnionMemberTypes()
			if (r.length === 0 && i.length === 0) throw this.unexpected()
			return this.node(t, { kind: oe.UNION_TYPE_EXTENSION, name: n, directives: r, types: i })
		}
		parseEnumTypeExtension() {
			let t = this._lexer.token
			this.expectKeyword('extend'), this.expectKeyword('enum')
			let n = this.parseName(),
				r = this.parseConstDirectives(),
				i = this.parseEnumValuesDefinition()
			if (r.length === 0 && i.length === 0) throw this.unexpected()
			return this.node(t, { kind: oe.ENUM_TYPE_EXTENSION, name: n, directives: r, values: i })
		}
		parseInputObjectTypeExtension() {
			let t = this._lexer.token
			this.expectKeyword('extend'), this.expectKeyword('input')
			let n = this.parseName(),
				r = this.parseConstDirectives(),
				i = this.parseInputFieldsDefinition()
			if (r.length === 0 && i.length === 0) throw this.unexpected()
			return this.node(t, {
				kind: oe.INPUT_OBJECT_TYPE_EXTENSION,
				name: n,
				directives: r,
				fields: i
			})
		}
		parseDirectiveDefinition() {
			let t = this._lexer.token,
				n = this.parseDescription()
			this.expectKeyword('directive'), this.expectToken(ft.AT)
			let r = this.parseName(),
				i = this.parseArgumentDefs(),
				s = this.expectOptionalKeyword('repeatable')
			this.expectKeyword('on')
			let o = this.parseDirectiveLocations()
			return this.node(t, {
				kind: oe.DIRECTIVE_DEFINITION,
				description: n,
				name: r,
				arguments: i,
				repeatable: s,
				locations: o
			})
		}
		parseDirectiveLocations() {
			return this.delimitedMany(ft.PIPE, this.parseDirectiveLocation)
		}
		parseDirectiveLocation() {
			let t = this._lexer.token,
				n = this.parseName()
			if (Object.prototype.hasOwnProperty.call(Jt, n.value)) return n
			throw this.unexpected(t)
		}
		node(t, n) {
			return (
				this._options.noLocation !== !0 &&
					(n.loc = new ou(t, this._lexer.lastToken, this._lexer.source)),
				n
			)
		}
		peek(t) {
			return this._lexer.token.kind === t
		}
		expectToken(t) {
			let n = this._lexer.token
			if (n.kind === t) return this.advanceLexer(), n
			throw _r(this._lexer.source, n.start, `Expected ${Om(t)}, found ${Ql(n)}.`)
		}
		expectOptionalToken(t) {
			return this._lexer.token.kind === t ? (this.advanceLexer(), !0) : !1
		}
		expectKeyword(t) {
			let n = this._lexer.token
			if (n.kind === ft.NAME && n.value === t) this.advanceLexer()
			else throw _r(this._lexer.source, n.start, `Expected "${t}", found ${Ql(n)}.`)
		}
		expectOptionalKeyword(t) {
			let n = this._lexer.token
			return n.kind === ft.NAME && n.value === t ? (this.advanceLexer(), !0) : !1
		}
		unexpected(t) {
			let n = t ?? this._lexer.token
			return _r(this._lexer.source, n.start, `Unexpected ${Ql(n)}.`)
		}
		any(t, n, r) {
			this.expectToken(t)
			let i = []
			for (; !this.expectOptionalToken(r); ) i.push(n.call(this))
			return i
		}
		optionalMany(t, n, r) {
			if (this.expectOptionalToken(t)) {
				let i = []
				do i.push(n.call(this))
				while (!this.expectOptionalToken(r))
				return i
			}
			return []
		}
		many(t, n, r) {
			this.expectToken(t)
			let i = []
			do i.push(n.call(this))
			while (!this.expectOptionalToken(r))
			return i
		}
		delimitedMany(t, n) {
			this.expectOptionalToken(t)
			let r = []
			do r.push(n.call(this))
			while (this.expectOptionalToken(t))
			return r
		}
		advanceLexer() {
			let { maxTokens: t } = this._options,
				n = this._lexer.advance()
			if (t !== void 0 && n.kind !== ft.EOF && (++this._tokenCounter, this._tokenCounter > t))
				throw _r(
					this._lexer.source,
					n.start,
					`Document contains more that ${t} tokens. Parsing aborted.`
				)
		}
	}
	function Ql(e) {
		let t = e.value
		return Om(e.kind) + (t != null ? ` "${t}"` : '')
	}
	function Om(e) {
		return Lm(e) ? `"${e}"` : e
	}
	function ci(e, t) {
		let [n, r] = t ? [e, t] : [void 0, e],
			i = ' Did you mean '
		n && (i += n + ' ')
		let s = r.map((u) => `"${u}"`)
		switch (s.length) {
			case 0:
				return ''
			case 1:
				return i + s[0] + '?'
			case 2:
				return i + s[0] + ' or ' + s[1] + '?'
		}
		let o = s.slice(0, 5),
			a = o.pop()
		return i + o.join(', ') + ', or ' + a + '?'
	}
	function Sf(e) {
		return e
	}
	function vi(e, t) {
		let n = Object.create(null)
		for (let r of e) n[t(r)] = r
		return n
	}
	function Yi(e, t, n) {
		let r = Object.create(null)
		for (let i of e) r[t(i)] = n(i)
		return r
	}
	function Mi(e, t) {
		let n = Object.create(null)
		for (let r of Object.keys(e)) n[r] = t(e[r], r)
		return n
	}
	function Qo(e, t) {
		let n = 0,
			r = 0
		for (; n < e.length && r < t.length; ) {
			let i = e.charCodeAt(n),
				s = t.charCodeAt(r)
			if (Kl(i) && Kl(s)) {
				let o = 0
				do ++n, (o = o * 10 + i - Nf), (i = e.charCodeAt(n))
				while (Kl(i) && o > 0)
				let a = 0
				do ++r, (a = a * 10 + s - Nf), (s = t.charCodeAt(r))
				while (Kl(s) && a > 0)
				if (o < a) return -1
				if (o > a) return 1
			} else {
				if (i < s) return -1
				if (i > s) return 1
				++n, ++r
			}
		}
		return e.length - t.length
	}
	var Nf = 48,
		Dx = 57
	function Kl(e) {
		return !isNaN(e) && Nf <= e && e <= Dx
	}
	function xi(e, t) {
		let n = Object.create(null),
			r = new Ff(e),
			i = Math.floor(e.length * 0.4) + 1
		for (let s of t) {
			let o = r.measure(s, i)
			o !== void 0 && (n[s] = o)
		}
		return Object.keys(n).sort((s, o) => {
			let a = n[s] - n[o]
			return a !== 0 ? a : Qo(s, o)
		})
	}
	var Ff = class {
		constructor(t) {
			;(this._input = t),
				(this._inputLowerCase = t.toLowerCase()),
				(this._inputArray = Bm(this._inputLowerCase)),
				(this._rows = [
					new Array(t.length + 1).fill(0),
					new Array(t.length + 1).fill(0),
					new Array(t.length + 1).fill(0)
				])
		}
		measure(t, n) {
			if (this._input === t) return 0
			let r = t.toLowerCase()
			if (this._inputLowerCase === r) return 1
			let i = Bm(r),
				s = this._inputArray
			if (i.length < s.length) {
				let N = i
				;(i = s), (s = N)
			}
			let o = i.length,
				a = s.length
			if (o - a > n) return
			let u = this._rows
			for (let N = 0; N <= a; N++) u[0][N] = N
			for (let N = 1; N <= o; N++) {
				let I = u[(N - 1) % 3],
					Q = u[N % 3],
					K = (Q[0] = N)
				for (let ue = 1; ue <= a; ue++) {
					let de = i[N - 1] === s[ue - 1] ? 0 : 1,
						Pe = Math.min(I[ue] + 1, Q[ue - 1] + 1, I[ue - 1] + de)
					if (N > 1 && ue > 1 && i[N - 1] === s[ue - 2] && i[N - 2] === s[ue - 1]) {
						let Ze = u[(N - 2) % 3][ue - 2]
						Pe = Math.min(Pe, Ze + 1)
					}
					Pe < K && (K = Pe), (Q[ue] = Pe)
				}
				if (K > n) return
			}
			let h = u[o % 3][a]
			return h <= n ? h : void 0
		}
	}
	function Bm(e) {
		let t = e.length,
			n = new Array(t)
		for (let r = 0; r < t; ++r) n[r] = e.charCodeAt(r)
		return n
	}
	function ni(e) {
		if (e == null) return Object.create(null)
		if (Object.getPrototypeOf(e) === null) return e
		let t = Object.create(null)
		for (let [n, r] of Object.entries(e)) t[n] = r
		return t
	}
	function Pm(e) {
		return `"${e.replace(yx, Ex)}"`
	}
	var yx = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g
	function Ex(e) {
		return vx[e.charCodeAt(0)]
	}
	var vx = [
		'\\u0000',
		'\\u0001',
		'\\u0002',
		'\\u0003',
		'\\u0004',
		'\\u0005',
		'\\u0006',
		'\\u0007',
		'\\b',
		'\\t',
		'\\n',
		'\\u000B',
		'\\f',
		'\\r',
		'\\u000E',
		'\\u000F',
		'\\u0010',
		'\\u0011',
		'\\u0012',
		'\\u0013',
		'\\u0014',
		'\\u0015',
		'\\u0016',
		'\\u0017',
		'\\u0018',
		'\\u0019',
		'\\u001A',
		'\\u001B',
		'\\u001C',
		'\\u001D',
		'\\u001E',
		'\\u001F',
		'',
		'',
		'\\"',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'\\\\',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'',
		'\\u007F',
		'\\u0080',
		'\\u0081',
		'\\u0082',
		'\\u0083',
		'\\u0084',
		'\\u0085',
		'\\u0086',
		'\\u0087',
		'\\u0088',
		'\\u0089',
		'\\u008A',
		'\\u008B',
		'\\u008C',
		'\\u008D',
		'\\u008E',
		'\\u008F',
		'\\u0090',
		'\\u0091',
		'\\u0092',
		'\\u0093',
		'\\u0094',
		'\\u0095',
		'\\u0096',
		'\\u0097',
		'\\u0098',
		'\\u0099',
		'\\u009A',
		'\\u009B',
		'\\u009C',
		'\\u009D',
		'\\u009E',
		'\\u009F'
	]
	var cs = Object.freeze({})
	function Jr(e, t, n = Af) {
		let r = new Map()
		for (let Ze of Object.values(oe)) r.set(Ze, Zs(t, Ze))
		let i,
			s = Array.isArray(e),
			o = [e],
			a = -1,
			u = [],
			h = e,
			N,
			I,
			Q = [],
			K = []
		do {
			a++
			let Ze = a === o.length,
				Ae = Ze && u.length !== 0
			if (Ze) {
				if (((N = K.length === 0 ? void 0 : Q[Q.length - 1]), (h = I), (I = K.pop()), Ae))
					if (s) {
						h = h.slice()
						let it = 0
						for (let [Et, _t] of u) {
							let ct = Et - it
							_t === null ? (h.splice(ct, 1), it++) : (h[ct] = _t)
						}
					} else {
						h = Object.defineProperties({}, Object.getOwnPropertyDescriptors(h))
						for (let [it, Et] of u) h[it] = Et
					}
				;(a = i.index), (o = i.keys), (u = i.edits), (s = i.inArray), (i = i.prev)
			} else if (I) {
				if (((N = s ? a : o[a]), (h = I[N]), h == null)) continue
				Q.push(N)
			}
			let ze
			if (!Array.isArray(h)) {
				var ue, de
				au(h) || On(!1, `Invalid AST Node: ${yt(h)}.`)
				let it = Ze
					? (ue = r.get(h.kind)) === null || ue === void 0
						? void 0
						: ue.leave
					: (de = r.get(h.kind)) === null || de === void 0
					? void 0
					: de.enter
				if (((ze = it?.call(t, h, N, I, Q, K)), ze === cs)) break
				if (ze === !1) {
					if (!Ze) {
						Q.pop()
						continue
					}
				} else if (ze !== void 0 && (u.push([N, ze]), !Ze))
					if (au(ze)) h = ze
					else {
						Q.pop()
						continue
					}
			}
			if ((ze === void 0 && Ae && u.push([N, h]), Ze)) Q.pop()
			else {
				var Pe
				;(i = { inArray: s, index: a, keys: o, edits: u, prev: i }),
					(s = Array.isArray(h)),
					(o = s ? h : (Pe = n[h.kind]) !== null && Pe !== void 0 ? Pe : []),
					(a = -1),
					(u = []),
					I && K.push(I),
					(I = h)
			}
		} while (i !== void 0)
		return u.length !== 0 ? u[u.length - 1][1] : e
	}
	function pu(e) {
		let t = new Array(e.length).fill(null),
			n = Object.create(null)
		for (let r of Object.values(oe)) {
			let i = !1,
				s = new Array(e.length).fill(void 0),
				o = new Array(e.length).fill(void 0)
			for (let u = 0; u < e.length; ++u) {
				let { enter: h, leave: N } = Zs(e[u], r)
				i || (i = h != null || N != null), (s[u] = h), (o[u] = N)
			}
			if (!i) continue
			let a = {
				enter(...u) {
					let h = u[0]
					for (let I = 0; I < e.length; I++)
						if (t[I] === null) {
							var N
							let Q = (N = s[I]) === null || N === void 0 ? void 0 : N.apply(e[I], u)
							if (Q === !1) t[I] = h
							else if (Q === cs) t[I] = cs
							else if (Q !== void 0) return Q
						}
				},
				leave(...u) {
					let h = u[0]
					for (let I = 0; I < e.length; I++)
						if (t[I] === null) {
							var N
							let Q = (N = o[I]) === null || N === void 0 ? void 0 : N.apply(e[I], u)
							if (Q === cs) t[I] = cs
							else if (Q !== void 0 && Q !== !1) return Q
						} else t[I] === h && (t[I] = null)
				}
			}
			n[r] = a
		}
		return n
	}
	function Zs(e, t) {
		let n = e[t]
		return typeof n == 'object'
			? n
			: typeof n == 'function'
			? { enter: n, leave: void 0 }
			: { enter: e.enter, leave: e.leave }
	}
	function tr(e) {
		return Jr(e, bx)
	}
	var xx = 80,
		bx = {
			Name: { leave: (e) => e.value },
			Variable: { leave: (e) => '$' + e.name },
			Document: {
				leave: (e) =>
					un(
						e.definitions,
						`

`
					)
			},
			OperationDefinition: {
				leave(e) {
					let t = Hn('(', un(e.variableDefinitions, ', '), ')'),
						n = un([e.operation, un([e.name, t]), un(e.directives, ' ')], ' ')
					return (n === 'query' ? '' : n + ' ') + e.selectionSet
				}
			},
			VariableDefinition: {
				leave: ({ variable: e, type: t, defaultValue: n, directives: r }) =>
					e + ': ' + t + Hn(' = ', n) + Hn(' ', un(r, ' '))
			},
			SelectionSet: { leave: ({ selections: e }) => ji(e) },
			Field: {
				leave({ alias: e, name: t, arguments: n, directives: r, selectionSet: i }) {
					let s = Hn('', e, ': ') + t,
						o = s + Hn('(', un(n, ', '), ')')
					return (
						o.length > xx &&
							(o =
								s +
								Hn(
									`(
`,
									Zl(
										un(
											n,
											`
`
										)
									),
									`
)`
								)),
						un([o, un(r, ' '), i], ' ')
					)
				}
			},
			Argument: { leave: ({ name: e, value: t }) => e + ': ' + t },
			FragmentSpread: { leave: ({ name: e, directives: t }) => '...' + e + Hn(' ', un(t, ' ')) },
			InlineFragment: {
				leave: ({ typeCondition: e, directives: t, selectionSet: n }) =>
					un(['...', Hn('on ', e), un(t, ' '), n], ' ')
			},
			FragmentDefinition: {
				leave: ({
					name: e,
					typeCondition: t,
					variableDefinitions: n,
					directives: r,
					selectionSet: i
				}) => `fragment ${e}${Hn('(', un(n, ', '), ')')} on ${t} ${Hn('', un(r, ' '), ' ')}` + i
			},
			IntValue: { leave: ({ value: e }) => e },
			FloatValue: { leave: ({ value: e }) => e },
			StringValue: { leave: ({ value: e, block: t }) => (t ? _m(e) : Pm(e)) },
			BooleanValue: { leave: ({ value: e }) => (e ? 'true' : 'false') },
			NullValue: { leave: () => 'null' },
			EnumValue: { leave: ({ value: e }) => e },
			ListValue: { leave: ({ values: e }) => '[' + un(e, ', ') + ']' },
			ObjectValue: { leave: ({ fields: e }) => '{' + un(e, ', ') + '}' },
			ObjectField: { leave: ({ name: e, value: t }) => e + ': ' + t },
			Directive: { leave: ({ name: e, arguments: t }) => '@' + e + Hn('(', un(t, ', '), ')') },
			NamedType: { leave: ({ name: e }) => e },
			ListType: { leave: ({ type: e }) => '[' + e + ']' },
			NonNullType: { leave: ({ type: e }) => e + '!' },
			SchemaDefinition: {
				leave: ({ description: e, directives: t, operationTypes: n }) =>
					Hn(
						'',
						e,
						`
`
					) + un(['schema', un(t, ' '), ji(n)], ' ')
			},
			OperationTypeDefinition: { leave: ({ operation: e, type: t }) => e + ': ' + t },
			ScalarTypeDefinition: {
				leave: ({ description: e, name: t, directives: n }) =>
					Hn(
						'',
						e,
						`
`
					) + un(['scalar', t, un(n, ' ')], ' ')
			},
			ObjectTypeDefinition: {
				leave: ({ description: e, name: t, interfaces: n, directives: r, fields: i }) =>
					Hn(
						'',
						e,
						`
`
					) + un(['type', t, Hn('implements ', un(n, ' & ')), un(r, ' '), ji(i)], ' ')
			},
			FieldDefinition: {
				leave: ({ description: e, name: t, arguments: n, type: r, directives: i }) =>
					Hn(
						'',
						e,
						`
`
					) +
					t +
					(Mm(n)
						? Hn(
								`(
`,
								Zl(
									un(
										n,
										`
`
									)
								),
								`
)`
						  )
						: Hn('(', un(n, ', '), ')')) +
					': ' +
					r +
					Hn(' ', un(i, ' '))
			},
			InputValueDefinition: {
				leave: ({ description: e, name: t, type: n, defaultValue: r, directives: i }) =>
					Hn(
						'',
						e,
						`
`
					) + un([t + ': ' + n, Hn('= ', r), un(i, ' ')], ' ')
			},
			InterfaceTypeDefinition: {
				leave: ({ description: e, name: t, interfaces: n, directives: r, fields: i }) =>
					Hn(
						'',
						e,
						`
`
					) + un(['interface', t, Hn('implements ', un(n, ' & ')), un(r, ' '), ji(i)], ' ')
			},
			UnionTypeDefinition: {
				leave: ({ description: e, name: t, directives: n, types: r }) =>
					Hn(
						'',
						e,
						`
`
					) + un(['union', t, un(n, ' '), Hn('= ', un(r, ' | '))], ' ')
			},
			EnumTypeDefinition: {
				leave: ({ description: e, name: t, directives: n, values: r }) =>
					Hn(
						'',
						e,
						`
`
					) + un(['enum', t, un(n, ' '), ji(r)], ' ')
			},
			EnumValueDefinition: {
				leave: ({ description: e, name: t, directives: n }) =>
					Hn(
						'',
						e,
						`
`
					) + un([t, un(n, ' ')], ' ')
			},
			InputObjectTypeDefinition: {
				leave: ({ description: e, name: t, directives: n, fields: r }) =>
					Hn(
						'',
						e,
						`
`
					) + un(['input', t, un(n, ' '), ji(r)], ' ')
			},
			DirectiveDefinition: {
				leave: ({ description: e, name: t, arguments: n, repeatable: r, locations: i }) =>
					Hn(
						'',
						e,
						`
`
					) +
					'directive @' +
					t +
					(Mm(n)
						? Hn(
								`(
`,
								Zl(
									un(
										n,
										`
`
									)
								),
								`
)`
						  )
						: Hn('(', un(n, ', '), ')')) +
					(r ? ' repeatable' : '') +
					' on ' +
					un(i, ' | ')
			},
			SchemaExtension: {
				leave: ({ directives: e, operationTypes: t }) =>
					un(['extend schema', un(e, ' '), ji(t)], ' ')
			},
			ScalarTypeExtension: {
				leave: ({ name: e, directives: t }) => un(['extend scalar', e, un(t, ' ')], ' ')
			},
			ObjectTypeExtension: {
				leave: ({ name: e, interfaces: t, directives: n, fields: r }) =>
					un(['extend type', e, Hn('implements ', un(t, ' & ')), un(n, ' '), ji(r)], ' ')
			},
			InterfaceTypeExtension: {
				leave: ({ name: e, interfaces: t, directives: n, fields: r }) =>
					un(['extend interface', e, Hn('implements ', un(t, ' & ')), un(n, ' '), ji(r)], ' ')
			},
			UnionTypeExtension: {
				leave: ({ name: e, directives: t, types: n }) =>
					un(['extend union', e, un(t, ' '), Hn('= ', un(n, ' | '))], ' ')
			},
			EnumTypeExtension: {
				leave: ({ name: e, directives: t, values: n }) =>
					un(['extend enum', e, un(t, ' '), ji(n)], ' ')
			},
			InputObjectTypeExtension: {
				leave: ({ name: e, directives: t, fields: n }) =>
					un(['extend input', e, un(t, ' '), ji(n)], ' ')
			}
		}
	function un(e, t = '') {
		var n
		return (n = e?.filter((r) => r).join(t)) !== null && n !== void 0 ? n : ''
	}
	function ji(e) {
		return Hn(
			`{
`,
			Zl(
				un(
					e,
					`
`
				)
			),
			`
}`
		)
	}
	function Hn(e, t, n = '') {
		return t != null && t !== '' ? e + t + n : ''
	}
	function Zl(e) {
		return Hn(
			'  ',
			e.replace(
				/\n/g,
				`
  `
			)
		)
	}
	function Mm(e) {
		var t
		return (t = e?.some((n) =>
			n.includes(`
`)
		)) !== null && t !== void 0
			? t
			: !1
	}
	function fu(e, t) {
		switch (e.kind) {
			case oe.NULL:
				return null
			case oe.INT:
				return parseInt(e.value, 10)
			case oe.FLOAT:
				return parseFloat(e.value)
			case oe.STRING:
			case oe.ENUM:
			case oe.BOOLEAN:
				return e.value
			case oe.LIST:
				return e.values.map((n) => fu(n, t))
			case oe.OBJECT:
				return Yi(
					e.fields,
					(n) => n.name.value,
					(n) => fu(n.value, t)
				)
			case oe.VARIABLE:
				return t?.[e.name.value]
		}
	}
	function pi(e) {
		if (
			(e != null || On(!1, 'Must provide name.'),
			typeof e == 'string' || On(!1, 'Expected name to be a string.'),
			e.length === 0)
		)
			throw new et('Expected name to be a non-empty string.')
		for (let t = 1; t < e.length; ++t)
			if (!Hl(e.charCodeAt(t)))
				throw new et(`Names must only contain [_a-zA-Z0-9] but "${e}" does not.`)
		if (!uu(e.charCodeAt(0))) throw new et(`Names must start with [_a-zA-Z] but "${e}" does not.`)
		return e
	}
	function _f(e) {
		if (e === 'true' || e === 'false' || e === 'null')
			throw new et(`Enum values cannot be named: ${e}`)
		return pi(e)
	}
	function Xo(e) {
		return Vr(e) || Un(e) || qn(e) || wr(e) || fr(e) || Yn(e) || Zn(e) || Nn(e)
	}
	function Vr(e) {
		return ti(e, Xr)
	}
	function Un(e) {
		return ti(e, Pr)
	}
	function tc(e) {
		if (!Un(e)) throw new Error(`Expected ${yt(e)} to be a GraphQL Object type.`)
		return e
	}
	function qn(e) {
		return ti(e, ri)
	}
	function nc(e) {
		if (!qn(e)) throw new Error(`Expected ${yt(e)} to be a GraphQL Interface type.`)
		return e
	}
	function wr(e) {
		return ti(e, Xi)
	}
	function fr(e) {
		return ti(e, Kr)
	}
	function Yn(e) {
		return ti(e, Li)
	}
	function Zn(e) {
		return ti(e, cr)
	}
	function Nn(e) {
		return ti(e, An)
	}
	function Lr(e) {
		return Vr(e) || fr(e) || Yn(e) || (du(e) && Lr(e.ofType))
	}
	function bi(e) {
		return Vr(e) || Un(e) || qn(e) || wr(e) || fr(e) || (du(e) && bi(e.ofType))
	}
	function Ti(e) {
		return Vr(e) || fr(e)
	}
	function gr(e) {
		return Un(e) || qn(e) || wr(e)
	}
	function Zr(e) {
		return qn(e) || wr(e)
	}
	function rc(e) {
		if (!Zr(e)) throw new Error(`Expected ${yt(e)} to be a GraphQL abstract type.`)
		return e
	}
	var cr = class {
			constructor(t) {
				Xo(t) || On(!1, `Expected ${yt(t)} to be a GraphQL type.`), (this.ofType = t)
			}
			get [Symbol.toStringTag]() {
				return 'GraphQLList'
			}
			toString() {
				return '[' + String(this.ofType) + ']'
			}
			toJSON() {
				return this.toString()
			}
		},
		An = class {
			constructor(t) {
				ic(t) || On(!1, `Expected ${yt(t)} to be a GraphQL nullable type.`), (this.ofType = t)
			}
			get [Symbol.toStringTag]() {
				return 'GraphQLNonNull'
			}
			toString() {
				return String(this.ofType) + '!'
			}
			toJSON() {
				return this.toString()
			}
		}
	function du(e) {
		return Zn(e) || Nn(e)
	}
	function ic(e) {
		return Xo(e) && !Nn(e)
	}
	function sc(e) {
		if (!ic(e)) throw new Error(`Expected ${yt(e)} to be a GraphQL nullable type.`)
		return e
	}
	function Rs(e) {
		if (e) return Nn(e) ? e.ofType : e
	}
	function oc(e) {
		return Vr(e) || Un(e) || qn(e) || wr(e) || fr(e) || Yn(e)
	}
	function or(e) {
		if (e) {
			let t = e
			for (; du(t); ) t = t.ofType
			return t
		}
	}
	function ac(e) {
		return typeof e == 'function' ? e() : e
	}
	function uc(e) {
		return typeof e == 'function' ? e() : e
	}
	var Xr = class {
			constructor(t) {
				var n, r, i, s
				let o = (n = t.parseValue) !== null && n !== void 0 ? n : Sf
				;(this.name = pi(t.name)),
					(this.description = t.description),
					(this.specifiedByURL = t.specifiedByURL),
					(this.serialize = (r = t.serialize) !== null && r !== void 0 ? r : Sf),
					(this.parseValue = o),
					(this.parseLiteral =
						(i = t.parseLiteral) !== null && i !== void 0 ? i : (a, u) => o(fu(a, u))),
					(this.extensions = ni(t.extensions)),
					(this.astNode = t.astNode),
					(this.extensionASTNodes = (s = t.extensionASTNodes) !== null && s !== void 0 ? s : []),
					t.specifiedByURL == null ||
						typeof t.specifiedByURL == 'string' ||
						On(
							!1,
							`${this.name} must provide "specifiedByURL" as a string, but got: ${yt(
								t.specifiedByURL
							)}.`
						),
					t.serialize == null ||
						typeof t.serialize == 'function' ||
						On(
							!1,
							`${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
						),
					t.parseLiteral &&
						((typeof t.parseValue == 'function' && typeof t.parseLiteral == 'function') ||
							On(!1, `${this.name} must provide both "parseValue" and "parseLiteral" functions.`))
			}
			get [Symbol.toStringTag]() {
				return 'GraphQLScalarType'
			}
			toConfig() {
				return {
					name: this.name,
					description: this.description,
					specifiedByURL: this.specifiedByURL,
					serialize: this.serialize,
					parseValue: this.parseValue,
					parseLiteral: this.parseLiteral,
					extensions: this.extensions,
					astNode: this.astNode,
					extensionASTNodes: this.extensionASTNodes
				}
			}
			toString() {
				return this.name
			}
			toJSON() {
				return this.toString()
			}
		},
		Pr = class {
			constructor(t) {
				var n
				;(this.name = pi(t.name)),
					(this.description = t.description),
					(this.isTypeOf = t.isTypeOf),
					(this.extensions = ni(t.extensions)),
					(this.astNode = t.astNode),
					(this.extensionASTNodes = (n = t.extensionASTNodes) !== null && n !== void 0 ? n : []),
					(this._fields = () => $m(t)),
					(this._interfaces = () => jm(t)),
					t.isTypeOf == null ||
						typeof t.isTypeOf == 'function' ||
						On(
							!1,
							`${this.name} must provide "isTypeOf" as a function, but got: ${yt(t.isTypeOf)}.`
						)
			}
			get [Symbol.toStringTag]() {
				return 'GraphQLObjectType'
			}
			getFields() {
				return typeof this._fields == 'function' && (this._fields = this._fields()), this._fields
			}
			getInterfaces() {
				return (
					typeof this._interfaces == 'function' && (this._interfaces = this._interfaces()),
					this._interfaces
				)
			}
			toConfig() {
				return {
					name: this.name,
					description: this.description,
					interfaces: this.getInterfaces(),
					fields: Vm(this.getFields()),
					isTypeOf: this.isTypeOf,
					extensions: this.extensions,
					astNode: this.astNode,
					extensionASTNodes: this.extensionASTNodes
				}
			}
			toString() {
				return this.name
			}
			toJSON() {
				return this.toString()
			}
		}
	function jm(e) {
		var t
		let n = ac((t = e.interfaces) !== null && t !== void 0 ? t : [])
		return (
			Array.isArray(n) ||
				On(!1, `${e.name} interfaces must be an Array or a function which returns an Array.`),
			n
		)
	}
	function $m(e) {
		let t = uc(e.fields)
		return (
			Yo(t) ||
				On(
					!1,
					`${e.name} fields must be an object with field names as keys or a function which returns such an object.`
				),
			Mi(t, (n, r) => {
				var i
				Yo(n) || On(!1, `${e.name}.${r} field config must be an object.`),
					n.resolve == null ||
						typeof n.resolve == 'function' ||
						On(
							!1,
							`${e.name}.${r} field resolver must be a function if provided, but got: ${yt(
								n.resolve
							)}.`
						)
				let s = (i = n.args) !== null && i !== void 0 ? i : {}
				return (
					Yo(s) || On(!1, `${e.name}.${r} args must be an object with argument names as keys.`),
					{
						name: pi(r),
						description: n.description,
						type: n.type,
						args: wf(s),
						resolve: n.resolve,
						subscribe: n.subscribe,
						deprecationReason: n.deprecationReason,
						extensions: ni(n.extensions),
						astNode: n.astNode
					}
				)
			})
		)
	}
	function wf(e) {
		return Object.entries(e).map(([t, n]) => ({
			name: pi(t),
			description: n.description,
			type: n.type,
			defaultValue: n.defaultValue,
			deprecationReason: n.deprecationReason,
			extensions: ni(n.extensions),
			astNode: n.astNode
		}))
	}
	function Yo(e) {
		return Yr(e) && !Array.isArray(e)
	}
	function Vm(e) {
		return Mi(e, (t) => ({
			description: t.description,
			type: t.type,
			args: Lf(t.args),
			resolve: t.resolve,
			subscribe: t.subscribe,
			deprecationReason: t.deprecationReason,
			extensions: t.extensions,
			astNode: t.astNode
		}))
	}
	function Lf(e) {
		return Yi(
			e,
			(t) => t.name,
			(t) => ({
				description: t.description,
				type: t.type,
				defaultValue: t.defaultValue,
				deprecationReason: t.deprecationReason,
				extensions: t.extensions,
				astNode: t.astNode
			})
		)
	}
	function ps(e) {
		return Nn(e.type) && e.defaultValue === void 0
	}
	var ri = class {
			constructor(t) {
				var n
				;(this.name = pi(t.name)),
					(this.description = t.description),
					(this.resolveType = t.resolveType),
					(this.extensions = ni(t.extensions)),
					(this.astNode = t.astNode),
					(this.extensionASTNodes = (n = t.extensionASTNodes) !== null && n !== void 0 ? n : []),
					(this._fields = $m.bind(void 0, t)),
					(this._interfaces = jm.bind(void 0, t)),
					t.resolveType == null ||
						typeof t.resolveType == 'function' ||
						On(
							!1,
							`${this.name} must provide "resolveType" as a function, but got: ${yt(
								t.resolveType
							)}.`
						)
			}
			get [Symbol.toStringTag]() {
				return 'GraphQLInterfaceType'
			}
			getFields() {
				return typeof this._fields == 'function' && (this._fields = this._fields()), this._fields
			}
			getInterfaces() {
				return (
					typeof this._interfaces == 'function' && (this._interfaces = this._interfaces()),
					this._interfaces
				)
			}
			toConfig() {
				return {
					name: this.name,
					description: this.description,
					interfaces: this.getInterfaces(),
					fields: Vm(this.getFields()),
					resolveType: this.resolveType,
					extensions: this.extensions,
					astNode: this.astNode,
					extensionASTNodes: this.extensionASTNodes
				}
			}
			toString() {
				return this.name
			}
			toJSON() {
				return this.toString()
			}
		},
		Xi = class {
			constructor(t) {
				var n
				;(this.name = pi(t.name)),
					(this.description = t.description),
					(this.resolveType = t.resolveType),
					(this.extensions = ni(t.extensions)),
					(this.astNode = t.astNode),
					(this.extensionASTNodes = (n = t.extensionASTNodes) !== null && n !== void 0 ? n : []),
					(this._types = Tx.bind(void 0, t)),
					t.resolveType == null ||
						typeof t.resolveType == 'function' ||
						On(
							!1,
							`${this.name} must provide "resolveType" as a function, but got: ${yt(
								t.resolveType
							)}.`
						)
			}
			get [Symbol.toStringTag]() {
				return 'GraphQLUnionType'
			}
			getTypes() {
				return typeof this._types == 'function' && (this._types = this._types()), this._types
			}
			toConfig() {
				return {
					name: this.name,
					description: this.description,
					types: this.getTypes(),
					resolveType: this.resolveType,
					extensions: this.extensions,
					astNode: this.astNode,
					extensionASTNodes: this.extensionASTNodes
				}
			}
			toString() {
				return this.name
			}
			toJSON() {
				return this.toString()
			}
		}
	function Tx(e) {
		let t = ac(e.types)
		return (
			Array.isArray(t) ||
				On(
					!1,
					`Must provide Array of types or a function which returns such an array for Union ${e.name}.`
				),
			t
		)
	}
	var Kr = class {
		constructor(t) {
			var n
			;(this.name = pi(t.name)),
				(this.description = t.description),
				(this.extensions = ni(t.extensions)),
				(this.astNode = t.astNode),
				(this.extensionASTNodes = (n = t.extensionASTNodes) !== null && n !== void 0 ? n : []),
				(this._values = Ax(this.name, t.values)),
				(this._valueLookup = new Map(this._values.map((r) => [r.value, r]))),
				(this._nameLookup = vi(this._values, (r) => r.name))
		}
		get [Symbol.toStringTag]() {
			return 'GraphQLEnumType'
		}
		getValues() {
			return this._values
		}
		getValue(t) {
			return this._nameLookup[t]
		}
		serialize(t) {
			let n = this._valueLookup.get(t)
			if (n === void 0) throw new et(`Enum "${this.name}" cannot represent value: ${yt(t)}`)
			return n.name
		}
		parseValue(t) {
			if (typeof t != 'string') {
				let r = yt(t)
				throw new et(`Enum "${this.name}" cannot represent non-string value: ${r}.` + ec(this, r))
			}
			let n = this.getValue(t)
			if (n == null)
				throw new et(`Value "${t}" does not exist in "${this.name}" enum.` + ec(this, t))
			return n.value
		}
		parseLiteral(t, n) {
			if (t.kind !== oe.ENUM) {
				let i = tr(t)
				throw new et(`Enum "${this.name}" cannot represent non-enum value: ${i}.` + ec(this, i), {
					nodes: t
				})
			}
			let r = this.getValue(t.value)
			if (r == null) {
				let i = tr(t)
				throw new et(`Value "${i}" does not exist in "${this.name}" enum.` + ec(this, i), {
					nodes: t
				})
			}
			return r.value
		}
		toConfig() {
			let t = Yi(
				this.getValues(),
				(n) => n.name,
				(n) => ({
					description: n.description,
					value: n.value,
					deprecationReason: n.deprecationReason,
					extensions: n.extensions,
					astNode: n.astNode
				})
			)
			return {
				name: this.name,
				description: this.description,
				values: t,
				extensions: this.extensions,
				astNode: this.astNode,
				extensionASTNodes: this.extensionASTNodes
			}
		}
		toString() {
			return this.name
		}
		toJSON() {
			return this.toString()
		}
	}
	function ec(e, t) {
		let n = e.getValues().map((i) => i.name),
			r = xi(t, n)
		return ci('the enum value', r)
	}
	function Ax(e, t) {
		return (
			Yo(t) || On(!1, `${e} values must be an object with value names as keys.`),
			Object.entries(t).map(
				([n, r]) => (
					Yo(r) ||
						On(
							!1,
							`${e}.${n} must refer to an object with a "value" key representing an internal value but got: ${yt(
								r
							)}.`
						),
					{
						name: _f(n),
						description: r.description,
						value: r.value !== void 0 ? r.value : n,
						deprecationReason: r.deprecationReason,
						extensions: ni(r.extensions),
						astNode: r.astNode
					}
				)
			)
		)
	}
	var Li = class {
		constructor(t) {
			var n
			;(this.name = pi(t.name)),
				(this.description = t.description),
				(this.extensions = ni(t.extensions)),
				(this.astNode = t.astNode),
				(this.extensionASTNodes = (n = t.extensionASTNodes) !== null && n !== void 0 ? n : []),
				(this._fields = Cx.bind(void 0, t))
		}
		get [Symbol.toStringTag]() {
			return 'GraphQLInputObjectType'
		}
		getFields() {
			return typeof this._fields == 'function' && (this._fields = this._fields()), this._fields
		}
		toConfig() {
			let t = Mi(this.getFields(), (n) => ({
				description: n.description,
				type: n.type,
				defaultValue: n.defaultValue,
				deprecationReason: n.deprecationReason,
				extensions: n.extensions,
				astNode: n.astNode
			}))
			return {
				name: this.name,
				description: this.description,
				fields: t,
				extensions: this.extensions,
				astNode: this.astNode,
				extensionASTNodes: this.extensionASTNodes
			}
		}
		toString() {
			return this.name
		}
		toJSON() {
			return this.toString()
		}
	}
	function Cx(e) {
		let t = uc(e.fields)
		return (
			Yo(t) ||
				On(
					!1,
					`${e.name} fields must be an object with field names as keys or a function which returns such an object.`
				),
			Mi(
				t,
				(n, r) => (
					!('resolve' in n) ||
						On(
							!1,
							`${e.name}.${r} field has a resolve property, but Input Types cannot define resolvers.`
						),
					{
						name: pi(r),
						description: n.description,
						type: n.type,
						defaultValue: n.defaultValue,
						deprecationReason: n.deprecationReason,
						extensions: ni(n.extensions),
						astNode: n.astNode
					}
				)
			)
		)
	}
	function Ko(e) {
		return Nn(e.type) && e.defaultValue === void 0
	}
	function Zo(e, t) {
		return e === t ? !0 : (Nn(e) && Nn(t)) || (Zn(e) && Zn(t)) ? Zo(e.ofType, t.ofType) : !1
	}
	function Ki(e, t, n) {
		return t === n
			? !0
			: Nn(n)
			? Nn(t)
				? Ki(e, t.ofType, n.ofType)
				: !1
			: Nn(t)
			? Ki(e, t.ofType, n)
			: Zn(n)
			? Zn(t)
				? Ki(e, t.ofType, n.ofType)
				: !1
			: Zn(t)
			? !1
			: Zr(n) && (qn(t) || Un(t)) && e.isSubType(n, t)
	}
	function eo(e, t, n) {
		return t === n
			? !0
			: Zr(t)
			? Zr(n)
				? e.getPossibleTypes(t).some((r) => e.isSubType(n, r))
				: e.isSubType(t, n)
			: Zr(n)
			? e.isSubType(n, t)
			: !1
	}
	var hu = 2147483647,
		mu = -2147483648,
		If = new Xr({
			name: 'Int',
			description:
				'The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.',
			serialize(e) {
				let t = yu(e)
				if (typeof t == 'boolean') return t ? 1 : 0
				let n = t
				if (
					(typeof t == 'string' && t !== '' && (n = Number(t)),
					typeof n != 'number' || !Number.isInteger(n))
				)
					throw new et(`Int cannot represent non-integer value: ${yt(t)}`)
				if (n > hu || n < mu)
					throw new et('Int cannot represent non 32-bit signed integer value: ' + yt(t))
				return n
			},
			parseValue(e) {
				if (typeof e != 'number' || !Number.isInteger(e))
					throw new et(`Int cannot represent non-integer value: ${yt(e)}`)
				if (e > hu || e < mu)
					throw new et(`Int cannot represent non 32-bit signed integer value: ${e}`)
				return e
			},
			parseLiteral(e) {
				if (e.kind !== oe.INT)
					throw new et(`Int cannot represent non-integer value: ${tr(e)}`, { nodes: e })
				let t = parseInt(e.value, 10)
				if (t > hu || t < mu)
					throw new et(`Int cannot represent non 32-bit signed integer value: ${e.value}`, {
						nodes: e
					})
				return t
			}
		}),
		gu = new Xr({
			name: 'Float',
			description:
				'The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).',
			serialize(e) {
				let t = yu(e)
				if (typeof t == 'boolean') return t ? 1 : 0
				let n = t
				if (
					(typeof t == 'string' && t !== '' && (n = Number(t)),
					typeof n != 'number' || !Number.isFinite(n))
				)
					throw new et(`Float cannot represent non numeric value: ${yt(t)}`)
				return n
			},
			parseValue(e) {
				if (typeof e != 'number' || !Number.isFinite(e))
					throw new et(`Float cannot represent non numeric value: ${yt(e)}`)
				return e
			},
			parseLiteral(e) {
				if (e.kind !== oe.FLOAT && e.kind !== oe.INT)
					throw new et(`Float cannot represent non numeric value: ${tr(e)}`, e)
				return parseFloat(e.value)
			}
		}),
		hr = new Xr({
			name: 'String',
			description:
				'The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.',
			serialize(e) {
				let t = yu(e)
				if (typeof t == 'string') return t
				if (typeof t == 'boolean') return t ? 'true' : 'false'
				if (typeof t == 'number' && Number.isFinite(t)) return t.toString()
				throw new et(`String cannot represent value: ${yt(e)}`)
			},
			parseValue(e) {
				if (typeof e != 'string')
					throw new et(`String cannot represent a non string value: ${yt(e)}`)
				return e
			},
			parseLiteral(e) {
				if (e.kind !== oe.STRING)
					throw new et(`String cannot represent a non string value: ${tr(e)}`, { nodes: e })
				return e.value
			}
		}),
		Cr = new Xr({
			name: 'Boolean',
			description: 'The `Boolean` scalar type represents `true` or `false`.',
			serialize(e) {
				let t = yu(e)
				if (typeof t == 'boolean') return t
				if (Number.isFinite(t)) return t !== 0
				throw new et(`Boolean cannot represent a non boolean value: ${yt(t)}`)
			},
			parseValue(e) {
				if (typeof e != 'boolean')
					throw new et(`Boolean cannot represent a non boolean value: ${yt(e)}`)
				return e
			},
			parseLiteral(e) {
				if (e.kind !== oe.BOOLEAN)
					throw new et(`Boolean cannot represent a non boolean value: ${tr(e)}`, { nodes: e })
				return e.value
			}
		}),
		Du = new Xr({
			name: 'ID',
			description:
				'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
			serialize(e) {
				let t = yu(e)
				if (typeof t == 'string') return t
				if (Number.isInteger(t)) return String(t)
				throw new et(`ID cannot represent value: ${yt(e)}`)
			},
			parseValue(e) {
				if (typeof e == 'string') return e
				if (typeof e == 'number' && Number.isInteger(e)) return e.toString()
				throw new et(`ID cannot represent value: ${yt(e)}`)
			},
			parseLiteral(e) {
				if (e.kind !== oe.STRING && e.kind !== oe.INT)
					throw new et('ID cannot represent a non-string and non-integer value: ' + tr(e), {
						nodes: e
					})
				return e.value
			}
		}),
		fs = Object.freeze([hr, If, gu, Cr, Du])
	function lc(e) {
		return fs.some(({ name: t }) => e.name === t)
	}
	function yu(e) {
		if (Yr(e)) {
			if (typeof e.valueOf == 'function') {
				let t = e.valueOf()
				if (!Yr(t)) return t
			}
			if (typeof e.toJSON == 'function') return e.toJSON()
		}
		return e
	}
	function Eu(e) {
		return ti(e, Ai)
	}
	var Ai = class {
			constructor(t) {
				var n, r
				;(this.name = pi(t.name)),
					(this.description = t.description),
					(this.locations = t.locations),
					(this.isRepeatable = (n = t.isRepeatable) !== null && n !== void 0 ? n : !1),
					(this.extensions = ni(t.extensions)),
					(this.astNode = t.astNode),
					Array.isArray(t.locations) || On(!1, `@${t.name} locations must be an Array.`)
				let i = (r = t.args) !== null && r !== void 0 ? r : {}
				;(Yr(i) && !Array.isArray(i)) ||
					On(!1, `@${t.name} args must be an object with argument names as keys.`),
					(this.args = wf(i))
			}
			get [Symbol.toStringTag]() {
				return 'GraphQLDirective'
			}
			toConfig() {
				return {
					name: this.name,
					description: this.description,
					locations: this.locations,
					args: Lf(this.args),
					isRepeatable: this.isRepeatable,
					extensions: this.extensions,
					astNode: this.astNode
				}
			}
			toString() {
				return '@' + this.name
			}
			toJSON() {
				return this.toString()
			}
		},
		cc = new Ai({
			name: 'include',
			description:
				'Directs the executor to include this field or fragment only when the `if` argument is true.',
			locations: [Jt.FIELD, Jt.FRAGMENT_SPREAD, Jt.INLINE_FRAGMENT],
			args: { if: { type: new An(Cr), description: 'Included when true.' } }
		}),
		pc = new Ai({
			name: 'skip',
			description:
				'Directs the executor to skip this field or fragment when the `if` argument is true.',
			locations: [Jt.FIELD, Jt.FRAGMENT_SPREAD, Jt.INLINE_FRAGMENT],
			args: { if: { type: new An(Cr), description: 'Skipped when true.' } }
		}),
		Um = 'No longer supported',
		ea = new Ai({
			name: 'deprecated',
			description: 'Marks an element of a GraphQL schema as no longer supported.',
			locations: [
				Jt.FIELD_DEFINITION,
				Jt.ARGUMENT_DEFINITION,
				Jt.INPUT_FIELD_DEFINITION,
				Jt.ENUM_VALUE
			],
			args: {
				reason: {
					type: hr,
					description:
						'Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).',
					defaultValue: Um
				}
			}
		}),
		fc = new Ai({
			name: 'specifiedBy',
			description: 'Exposes a URL that specifies the behavior of this scalar.',
			locations: [Jt.SCALAR],
			args: {
				url: {
					type: new An(hr),
					description: 'The URL that specifies the behavior of this scalar.'
				}
			}
		}),
		Ci = Object.freeze([cc, pc, ea, fc])
	function qm(e) {
		return typeof e == 'object' && typeof e?.[Symbol.iterator] == 'function'
	}
	function to(e, t) {
		if (Nn(t)) {
			let n = to(e, t.ofType)
			return n?.kind === oe.NULL ? null : n
		}
		if (e === null) return { kind: oe.NULL }
		if (e === void 0) return null
		if (Zn(t)) {
			let n = t.ofType
			if (qm(e)) {
				let r = []
				for (let i of e) {
					let s = to(i, n)
					s != null && r.push(s)
				}
				return { kind: oe.LIST, values: r }
			}
			return to(e, n)
		}
		if (Yn(t)) {
			if (!Yr(e)) return null
			let n = []
			for (let r of Object.values(t.getFields())) {
				let i = to(e[r.name], r.type)
				i && n.push({ kind: oe.OBJECT_FIELD, name: { kind: oe.NAME, value: r.name }, value: i })
			}
			return { kind: oe.OBJECT, fields: n }
		}
		if (Ti(t)) {
			let n = t.serialize(e)
			if (n == null) return null
			if (typeof n == 'boolean') return { kind: oe.BOOLEAN, value: n }
			if (typeof n == 'number' && Number.isFinite(n)) {
				let r = String(n)
				return Gm.test(r) ? { kind: oe.INT, value: r } : { kind: oe.FLOAT, value: r }
			}
			if (typeof n == 'string')
				return fr(t)
					? { kind: oe.ENUM, value: n }
					: t === Du && Gm.test(n)
					? { kind: oe.INT, value: n }
					: { kind: oe.STRING, value: n }
			throw new TypeError(`Cannot convert value to AST: ${yt(n)}.`)
		}
		xr(!1, 'Unexpected input type: ' + yt(t))
	}
	var Gm = /^-?(?:0|[1-9][0-9]*)$/
	var ta = new Pr({
			name: '__Schema',
			description:
				'A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.',
			fields: () => ({
				description: { type: hr, resolve: (e) => e.description },
				types: {
					description: 'A list of all types supported by this server.',
					type: new An(new cr(new An(Si))),
					resolve(e) {
						return Object.values(e.getTypeMap())
					}
				},
				queryType: {
					description: 'The type that query operations will be rooted at.',
					type: new An(Si),
					resolve: (e) => e.getQueryType()
				},
				mutationType: {
					description:
						'If this server supports mutation, the type that mutation operations will be rooted at.',
					type: Si,
					resolve: (e) => e.getMutationType()
				},
				subscriptionType: {
					description:
						'If this server support subscription, the type that subscription operations will be rooted at.',
					type: Si,
					resolve: (e) => e.getSubscriptionType()
				},
				directives: {
					description: 'A list of all directives supported by this server.',
					type: new An(new cr(new An(dc))),
					resolve: (e) => e.getDirectives()
				}
			})
		}),
		dc = new Pr({
			name: '__Directive',
			description: `A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.

In some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.`,
			fields: () => ({
				name: { type: new An(hr), resolve: (e) => e.name },
				description: { type: hr, resolve: (e) => e.description },
				isRepeatable: { type: new An(Cr), resolve: (e) => e.isRepeatable },
				locations: { type: new An(new cr(new An(hc))), resolve: (e) => e.locations },
				args: {
					type: new An(new cr(new An(na))),
					args: { includeDeprecated: { type: Cr, defaultValue: !1 } },
					resolve(e, { includeDeprecated: t }) {
						return t ? e.args : e.args.filter((n) => n.deprecationReason == null)
					}
				}
			})
		}),
		hc = new Kr({
			name: '__DirectiveLocation',
			description:
				'A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.',
			values: {
				QUERY: { value: Jt.QUERY, description: 'Location adjacent to a query operation.' },
				MUTATION: { value: Jt.MUTATION, description: 'Location adjacent to a mutation operation.' },
				SUBSCRIPTION: {
					value: Jt.SUBSCRIPTION,
					description: 'Location adjacent to a subscription operation.'
				},
				FIELD: { value: Jt.FIELD, description: 'Location adjacent to a field.' },
				FRAGMENT_DEFINITION: {
					value: Jt.FRAGMENT_DEFINITION,
					description: 'Location adjacent to a fragment definition.'
				},
				FRAGMENT_SPREAD: {
					value: Jt.FRAGMENT_SPREAD,
					description: 'Location adjacent to a fragment spread.'
				},
				INLINE_FRAGMENT: {
					value: Jt.INLINE_FRAGMENT,
					description: 'Location adjacent to an inline fragment.'
				},
				VARIABLE_DEFINITION: {
					value: Jt.VARIABLE_DEFINITION,
					description: 'Location adjacent to a variable definition.'
				},
				SCHEMA: { value: Jt.SCHEMA, description: 'Location adjacent to a schema definition.' },
				SCALAR: { value: Jt.SCALAR, description: 'Location adjacent to a scalar definition.' },
				OBJECT: {
					value: Jt.OBJECT,
					description: 'Location adjacent to an object type definition.'
				},
				FIELD_DEFINITION: {
					value: Jt.FIELD_DEFINITION,
					description: 'Location adjacent to a field definition.'
				},
				ARGUMENT_DEFINITION: {
					value: Jt.ARGUMENT_DEFINITION,
					description: 'Location adjacent to an argument definition.'
				},
				INTERFACE: {
					value: Jt.INTERFACE,
					description: 'Location adjacent to an interface definition.'
				},
				UNION: { value: Jt.UNION, description: 'Location adjacent to a union definition.' },
				ENUM: { value: Jt.ENUM, description: 'Location adjacent to an enum definition.' },
				ENUM_VALUE: {
					value: Jt.ENUM_VALUE,
					description: 'Location adjacent to an enum value definition.'
				},
				INPUT_OBJECT: {
					value: Jt.INPUT_OBJECT,
					description: 'Location adjacent to an input object type definition.'
				},
				INPUT_FIELD_DEFINITION: {
					value: Jt.INPUT_FIELD_DEFINITION,
					description: 'Location adjacent to an input object field definition.'
				}
			}
		}),
		Si = new Pr({
			name: '__Type',
			description:
				'The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.',
			fields: () => ({
				kind: {
					type: new An(Dc),
					resolve(e) {
						if (Vr(e)) return nr.SCALAR
						if (Un(e)) return nr.OBJECT
						if (qn(e)) return nr.INTERFACE
						if (wr(e)) return nr.UNION
						if (fr(e)) return nr.ENUM
						if (Yn(e)) return nr.INPUT_OBJECT
						if (Zn(e)) return nr.LIST
						if (Nn(e)) return nr.NON_NULL
						xr(!1, `Unexpected type: "${yt(e)}".`)
					}
				},
				name: { type: hr, resolve: (e) => ('name' in e ? e.name : void 0) },
				description: { type: hr, resolve: (e) => ('description' in e ? e.description : void 0) },
				specifiedByURL: {
					type: hr,
					resolve: (e) => ('specifiedByURL' in e ? e.specifiedByURL : void 0)
				},
				fields: {
					type: new cr(new An(mc)),
					args: { includeDeprecated: { type: Cr, defaultValue: !1 } },
					resolve(e, { includeDeprecated: t }) {
						if (Un(e) || qn(e)) {
							let n = Object.values(e.getFields())
							return t ? n : n.filter((r) => r.deprecationReason == null)
						}
					}
				},
				interfaces: {
					type: new cr(new An(Si)),
					resolve(e) {
						if (Un(e) || qn(e)) return e.getInterfaces()
					}
				},
				possibleTypes: {
					type: new cr(new An(Si)),
					resolve(e, t, n, { schema: r }) {
						if (Zr(e)) return r.getPossibleTypes(e)
					}
				},
				enumValues: {
					type: new cr(new An(gc)),
					args: { includeDeprecated: { type: Cr, defaultValue: !1 } },
					resolve(e, { includeDeprecated: t }) {
						if (fr(e)) {
							let n = e.getValues()
							return t ? n : n.filter((r) => r.deprecationReason == null)
						}
					}
				},
				inputFields: {
					type: new cr(new An(na)),
					args: { includeDeprecated: { type: Cr, defaultValue: !1 } },
					resolve(e, { includeDeprecated: t }) {
						if (Yn(e)) {
							let n = Object.values(e.getFields())
							return t ? n : n.filter((r) => r.deprecationReason == null)
						}
					}
				},
				ofType: { type: Si, resolve: (e) => ('ofType' in e ? e.ofType : void 0) }
			})
		}),
		mc = new Pr({
			name: '__Field',
			description:
				'Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.',
			fields: () => ({
				name: { type: new An(hr), resolve: (e) => e.name },
				description: { type: hr, resolve: (e) => e.description },
				args: {
					type: new An(new cr(new An(na))),
					args: { includeDeprecated: { type: Cr, defaultValue: !1 } },
					resolve(e, { includeDeprecated: t }) {
						return t ? e.args : e.args.filter((n) => n.deprecationReason == null)
					}
				},
				type: { type: new An(Si), resolve: (e) => e.type },
				isDeprecated: { type: new An(Cr), resolve: (e) => e.deprecationReason != null },
				deprecationReason: { type: hr, resolve: (e) => e.deprecationReason }
			})
		}),
		na = new Pr({
			name: '__InputValue',
			description:
				'Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.',
			fields: () => ({
				name: { type: new An(hr), resolve: (e) => e.name },
				description: { type: hr, resolve: (e) => e.description },
				type: { type: new An(Si), resolve: (e) => e.type },
				defaultValue: {
					type: hr,
					description:
						'A GraphQL-formatted string representing the default value for this input value.',
					resolve(e) {
						let { type: t, defaultValue: n } = e,
							r = to(n, t)
						return r ? tr(r) : null
					}
				},
				isDeprecated: { type: new An(Cr), resolve: (e) => e.deprecationReason != null },
				deprecationReason: { type: hr, resolve: (e) => e.deprecationReason }
			})
		}),
		gc = new Pr({
			name: '__EnumValue',
			description:
				'One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.',
			fields: () => ({
				name: { type: new An(hr), resolve: (e) => e.name },
				description: { type: hr, resolve: (e) => e.description },
				isDeprecated: { type: new An(Cr), resolve: (e) => e.deprecationReason != null },
				deprecationReason: { type: hr, resolve: (e) => e.deprecationReason }
			})
		}),
		nr
	;(function (e) {
		;(e.SCALAR = 'SCALAR'),
			(e.OBJECT = 'OBJECT'),
			(e.INTERFACE = 'INTERFACE'),
			(e.UNION = 'UNION'),
			(e.ENUM = 'ENUM'),
			(e.INPUT_OBJECT = 'INPUT_OBJECT'),
			(e.LIST = 'LIST'),
			(e.NON_NULL = 'NON_NULL')
	})(nr || (nr = {}))
	var Dc = new Kr({
			name: '__TypeKind',
			description: 'An enum describing what kind of type a given `__Type` is.',
			values: {
				SCALAR: { value: nr.SCALAR, description: 'Indicates this type is a scalar.' },
				OBJECT: {
					value: nr.OBJECT,
					description:
						'Indicates this type is an object. `fields` and `interfaces` are valid fields.'
				},
				INTERFACE: {
					value: nr.INTERFACE,
					description:
						'Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields.'
				},
				UNION: {
					value: nr.UNION,
					description: 'Indicates this type is a union. `possibleTypes` is a valid field.'
				},
				ENUM: {
					value: nr.ENUM,
					description: 'Indicates this type is an enum. `enumValues` is a valid field.'
				},
				INPUT_OBJECT: {
					value: nr.INPUT_OBJECT,
					description: 'Indicates this type is an input object. `inputFields` is a valid field.'
				},
				LIST: {
					value: nr.LIST,
					description: 'Indicates this type is a list. `ofType` is a valid field.'
				},
				NON_NULL: {
					value: nr.NON_NULL,
					description: 'Indicates this type is a non-null. `ofType` is a valid field.'
				}
			}
		}),
		Zi = {
			name: '__schema',
			type: new An(ta),
			description: 'Access the current type schema of this server.',
			args: [],
			resolve: (e, t, n, { schema: r }) => r,
			deprecationReason: void 0,
			extensions: Object.create(null),
			astNode: void 0
		},
		es = {
			name: '__type',
			type: Si,
			description: 'Request the type information of a single type.',
			args: [
				{
					name: 'name',
					description: void 0,
					type: new An(hr),
					defaultValue: void 0,
					deprecationReason: void 0,
					extensions: Object.create(null),
					astNode: void 0
				}
			],
			resolve: (e, { name: t }, n, { schema: r }) => r.getType(t),
			deprecationReason: void 0,
			extensions: Object.create(null),
			astNode: void 0
		},
		ts = {
			name: '__typename',
			type: new An(hr),
			description: 'The name of the current Object type at runtime.',
			args: [],
			resolve: (e, t, n, { parentType: r }) => r.name,
			deprecationReason: void 0,
			extensions: Object.create(null),
			astNode: void 0
		},
		ds = Object.freeze([ta, dc, hc, Si, mc, na, gc, Dc])
	function ra(e) {
		return ds.some(({ name: t }) => e.name === t)
	}
	function Wm(e) {
		return ti(e, Os)
	}
	function kf(e) {
		if (!Wm(e)) throw new Error(`Expected ${yt(e)} to be a GraphQL schema.`)
		return e
	}
	var Os = class {
		constructor(t) {
			var n, r
			;(this.__validationErrors = t.assumeValid === !0 ? [] : void 0),
				Yr(t) || On(!1, 'Must provide configuration object.'),
				!t.types ||
					Array.isArray(t.types) ||
					On(!1, `"types" must be Array if provided but got: ${yt(t.types)}.`),
				!t.directives ||
					Array.isArray(t.directives) ||
					On(!1, `"directives" must be Array if provided but got: ${yt(t.directives)}.`),
				(this.description = t.description),
				(this.extensions = ni(t.extensions)),
				(this.astNode = t.astNode),
				(this.extensionASTNodes = (n = t.extensionASTNodes) !== null && n !== void 0 ? n : []),
				(this._queryType = t.query),
				(this._mutationType = t.mutation),
				(this._subscriptionType = t.subscription),
				(this._directives = (r = t.directives) !== null && r !== void 0 ? r : Ci)
			let i = new Set(t.types)
			if (t.types != null) for (let s of t.types) i.delete(s), $i(s, i)
			this._queryType != null && $i(this._queryType, i),
				this._mutationType != null && $i(this._mutationType, i),
				this._subscriptionType != null && $i(this._subscriptionType, i)
			for (let s of this._directives) if (Eu(s)) for (let o of s.args) $i(o.type, i)
			$i(ta, i),
				(this._typeMap = Object.create(null)),
				(this._subTypeMap = Object.create(null)),
				(this._implementationsMap = Object.create(null))
			for (let s of i) {
				if (s == null) continue
				let o = s.name
				if (
					(o || On(!1, 'One of the provided types for building the Schema is missing a name.'),
					this._typeMap[o] !== void 0)
				)
					throw new Error(
						`Schema must contain uniquely named types but contains multiple types named "${o}".`
					)
				if (((this._typeMap[o] = s), qn(s))) {
					for (let a of s.getInterfaces())
						if (qn(a)) {
							let u = this._implementationsMap[a.name]
							u === void 0 &&
								(u = this._implementationsMap[a.name] = { objects: [], interfaces: [] }),
								u.interfaces.push(s)
						}
				} else if (Un(s)) {
					for (let a of s.getInterfaces())
						if (qn(a)) {
							let u = this._implementationsMap[a.name]
							u === void 0 &&
								(u = this._implementationsMap[a.name] = { objects: [], interfaces: [] }),
								u.objects.push(s)
						}
				}
			}
		}
		get [Symbol.toStringTag]() {
			return 'GraphQLSchema'
		}
		getQueryType() {
			return this._queryType
		}
		getMutationType() {
			return this._mutationType
		}
		getSubscriptionType() {
			return this._subscriptionType
		}
		getRootType(t) {
			switch (t) {
				case Or.QUERY:
					return this.getQueryType()
				case Or.MUTATION:
					return this.getMutationType()
				case Or.SUBSCRIPTION:
					return this.getSubscriptionType()
			}
		}
		getTypeMap() {
			return this._typeMap
		}
		getType(t) {
			return this.getTypeMap()[t]
		}
		getPossibleTypes(t) {
			return wr(t) ? t.getTypes() : this.getImplementations(t).objects
		}
		getImplementations(t) {
			let n = this._implementationsMap[t.name]
			return n ?? { objects: [], interfaces: [] }
		}
		isSubType(t, n) {
			let r = this._subTypeMap[t.name]
			if (r === void 0) {
				if (((r = Object.create(null)), wr(t))) for (let i of t.getTypes()) r[i.name] = !0
				else {
					let i = this.getImplementations(t)
					for (let s of i.objects) r[s.name] = !0
					for (let s of i.interfaces) r[s.name] = !0
				}
				this._subTypeMap[t.name] = r
			}
			return r[n.name] !== void 0
		}
		getDirectives() {
			return this._directives
		}
		getDirective(t) {
			return this.getDirectives().find((n) => n.name === t)
		}
		toConfig() {
			return {
				description: this.description,
				query: this.getQueryType(),
				mutation: this.getMutationType(),
				subscription: this.getSubscriptionType(),
				types: Object.values(this.getTypeMap()),
				directives: this.getDirectives(),
				extensions: this.extensions,
				astNode: this.astNode,
				extensionASTNodes: this.extensionASTNodes,
				assumeValid: this.__validationErrors !== void 0
			}
		}
	}
	function $i(e, t) {
		let n = or(e)
		if (!t.has(n)) {
			if ((t.add(n), wr(n))) for (let r of n.getTypes()) $i(r, t)
			else if (Un(n) || qn(n)) {
				for (let r of n.getInterfaces()) $i(r, t)
				for (let r of Object.values(n.getFields())) {
					$i(r.type, t)
					for (let i of r.args) $i(i.type, t)
				}
			} else if (Yn(n)) for (let r of Object.values(n.getFields())) $i(r.type, t)
		}
		return t
	}
	function Qm(e) {
		if ((kf(e), e.__validationErrors)) return e.__validationErrors
		let t = new Of(e)
		Sx(t), Nx(t), Fx(t)
		let n = t.getErrors()
		return (e.__validationErrors = n), n
	}
	function Bf(e) {
		let t = Qm(e)
		if (t.length !== 0)
			throw new Error(
				t.map((n) => n.message).join(`

`)
			)
	}
	var Of = class {
		constructor(t) {
			;(this._errors = []), (this.schema = t)
		}
		reportError(t, n) {
			let r = Array.isArray(n) ? n.filter(Boolean) : n
			this._errors.push(new et(t, { nodes: r }))
		}
		getErrors() {
			return this._errors
		}
	}
	function Sx(e) {
		let t = e.schema,
			n = t.getQueryType()
		if (!n) e.reportError('Query root type must be provided.', t.astNode)
		else if (!Un(n)) {
			var r
			e.reportError(
				`Query root type must be Object type, it cannot be ${yt(n)}.`,
				(r = Rf(t, Or.QUERY)) !== null && r !== void 0 ? r : n.astNode
			)
		}
		let i = t.getMutationType()
		if (i && !Un(i)) {
			var s
			e.reportError(
				`Mutation root type must be Object type if provided, it cannot be ${yt(i)}.`,
				(s = Rf(t, Or.MUTATION)) !== null && s !== void 0 ? s : i.astNode
			)
		}
		let o = t.getSubscriptionType()
		if (o && !Un(o)) {
			var a
			e.reportError(
				`Subscription root type must be Object type if provided, it cannot be ${yt(o)}.`,
				(a = Rf(t, Or.SUBSCRIPTION)) !== null && a !== void 0 ? a : o.astNode
			)
		}
	}
	function Rf(e, t) {
		var n
		return (n = [e.astNode, ...e.extensionASTNodes]
			.flatMap((r) => {
				var i
				return (i = r?.operationTypes) !== null && i !== void 0 ? i : []
			})
			.find((r) => r.operation === t)) === null || n === void 0
			? void 0
			: n.type
	}
	function Nx(e) {
		for (let n of e.schema.getDirectives()) {
			if (!Eu(n)) {
				e.reportError(`Expected directive but got: ${yt(n)}.`, n?.astNode)
				continue
			}
			no(e, n)
			for (let r of n.args)
				if (
					(no(e, r),
					Lr(r.type) ||
						e.reportError(
							`The type of @${n.name}(${r.name}:) must be Input Type but got: ${yt(r.type)}.`,
							r.astNode
						),
					ps(r) && r.deprecationReason != null)
				) {
					var t
					e.reportError(`Required argument @${n.name}(${r.name}:) cannot be deprecated.`, [
						Pf(r.astNode),
						(t = r.astNode) === null || t === void 0 ? void 0 : t.type
					])
				}
		}
	}
	function no(e, t) {
		t.name.startsWith('__') &&
			e.reportError(
				`Name "${t.name}" must not begin with "__", which is reserved by GraphQL introspection.`,
				t.astNode
			)
	}
	function Fx(e) {
		let t = Rx(e),
			n = e.schema.getTypeMap()
		for (let r of Object.values(n)) {
			if (!oc(r)) {
				e.reportError(`Expected GraphQL named type but got: ${yt(r)}.`, r.astNode)
				continue
			}
			ra(r) || no(e, r),
				Un(r) || qn(r)
					? (Hm(e, r), Jm(e, r))
					: wr(r)
					? Lx(e, r)
					: fr(r)
					? Ix(e, r)
					: Yn(r) && (kx(e, r), t(r))
		}
	}
	function Hm(e, t) {
		let n = Object.values(t.getFields())
		n.length === 0 &&
			e.reportError(`Type ${t.name} must define one or more fields.`, [
				t.astNode,
				...t.extensionASTNodes
			])
		for (let o of n) {
			if ((no(e, o), !bi(o.type))) {
				var r
				e.reportError(
					`The type of ${t.name}.${o.name} must be Output Type but got: ${yt(o.type)}.`,
					(r = o.astNode) === null || r === void 0 ? void 0 : r.type
				)
			}
			for (let a of o.args) {
				let u = a.name
				if ((no(e, a), !Lr(a.type))) {
					var i
					e.reportError(
						`The type of ${t.name}.${o.name}(${u}:) must be Input Type but got: ${yt(a.type)}.`,
						(i = a.astNode) === null || i === void 0 ? void 0 : i.type
					)
				}
				if (ps(a) && a.deprecationReason != null) {
					var s
					e.reportError(`Required argument ${t.name}.${o.name}(${u}:) cannot be deprecated.`, [
						Pf(a.astNode),
						(s = a.astNode) === null || s === void 0 ? void 0 : s.type
					])
				}
			}
		}
	}
	function Jm(e, t) {
		let n = Object.create(null)
		for (let r of t.getInterfaces()) {
			if (!qn(r)) {
				e.reportError(
					`Type ${yt(t)} must only implement Interface types, it cannot implement ${yt(r)}.`,
					vu(t, r)
				)
				continue
			}
			if (t === r) {
				e.reportError(
					`Type ${t.name} cannot implement itself because it would create a circular reference.`,
					vu(t, r)
				)
				continue
			}
			if (n[r.name]) {
				e.reportError(`Type ${t.name} can only implement ${r.name} once.`, vu(t, r))
				continue
			}
			;(n[r.name] = !0), wx(e, t, r), _x(e, t, r)
		}
	}
	function _x(e, t, n) {
		let r = t.getFields()
		for (let u of Object.values(n.getFields())) {
			let h = u.name,
				N = r[h]
			if (!N) {
				e.reportError(
					`Interface field ${n.name}.${h} expected but ${t.name} does not provide it.`,
					[u.astNode, t.astNode, ...t.extensionASTNodes]
				)
				continue
			}
			if (!Ki(e.schema, N.type, u.type)) {
				var i, s
				e.reportError(
					`Interface field ${n.name}.${h} expects type ${yt(u.type)} but ${
						t.name
					}.${h} is type ${yt(N.type)}.`,
					[
						(i = u.astNode) === null || i === void 0 ? void 0 : i.type,
						(s = N.astNode) === null || s === void 0 ? void 0 : s.type
					]
				)
			}
			for (let I of u.args) {
				let Q = I.name,
					K = N.args.find((ue) => ue.name === Q)
				if (!K) {
					e.reportError(
						`Interface field argument ${n.name}.${h}(${Q}:) expected but ${t.name}.${h} does not provide it.`,
						[I.astNode, N.astNode]
					)
					continue
				}
				if (!Zo(I.type, K.type)) {
					var o, a
					e.reportError(
						`Interface field argument ${n.name}.${h}(${Q}:) expects type ${yt(I.type)} but ${
							t.name
						}.${h}(${Q}:) is type ${yt(K.type)}.`,
						[
							(o = I.astNode) === null || o === void 0 ? void 0 : o.type,
							(a = K.astNode) === null || a === void 0 ? void 0 : a.type
						]
					)
				}
			}
			for (let I of N.args) {
				let Q = I.name
				!u.args.find((ue) => ue.name === Q) &&
					ps(I) &&
					e.reportError(
						`Object field ${t.name}.${h} includes required argument ${Q} that is missing from the Interface field ${n.name}.${h}.`,
						[I.astNode, u.astNode]
					)
			}
		}
	}
	function wx(e, t, n) {
		let r = t.getInterfaces()
		for (let i of n.getInterfaces())
			r.includes(i) ||
				e.reportError(
					i === t
						? `Type ${t.name} cannot implement ${n.name} because it would create a circular reference.`
						: `Type ${t.name} must implement ${i.name} because it is implemented by ${n.name}.`,
					[...vu(n, i), ...vu(t, n)]
				)
	}
	function Lx(e, t) {
		let n = t.getTypes()
		n.length === 0 &&
			e.reportError(`Union type ${t.name} must define one or more member types.`, [
				t.astNode,
				...t.extensionASTNodes
			])
		let r = Object.create(null)
		for (let i of n) {
			if (r[i.name]) {
				e.reportError(`Union type ${t.name} can only include type ${i.name} once.`, zm(t, i.name))
				continue
			}
			;(r[i.name] = !0),
				Un(i) ||
					e.reportError(
						`Union type ${t.name} can only include Object types, it cannot include ${yt(i)}.`,
						zm(t, String(i))
					)
		}
	}
	function Ix(e, t) {
		let n = t.getValues()
		n.length === 0 &&
			e.reportError(`Enum type ${t.name} must define one or more values.`, [
				t.astNode,
				...t.extensionASTNodes
			])
		for (let r of n) no(e, r)
	}
	function kx(e, t) {
		let n = Object.values(t.getFields())
		n.length === 0 &&
			e.reportError(`Input Object type ${t.name} must define one or more fields.`, [
				t.astNode,
				...t.extensionASTNodes
			])
		for (let s of n) {
			if ((no(e, s), !Lr(s.type))) {
				var r
				e.reportError(
					`The type of ${t.name}.${s.name} must be Input Type but got: ${yt(s.type)}.`,
					(r = s.astNode) === null || r === void 0 ? void 0 : r.type
				)
			}
			if (Ko(s) && s.deprecationReason != null) {
				var i
				e.reportError(`Required input field ${t.name}.${s.name} cannot be deprecated.`, [
					Pf(s.astNode),
					(i = s.astNode) === null || i === void 0 ? void 0 : i.type
				])
			}
		}
	}
	function Rx(e) {
		let t = Object.create(null),
			n = [],
			r = Object.create(null)
		return i
		function i(s) {
			if (t[s.name]) return
			;(t[s.name] = !0), (r[s.name] = n.length)
			let o = Object.values(s.getFields())
			for (let a of o)
				if (Nn(a.type) && Yn(a.type.ofType)) {
					let u = a.type.ofType,
						h = r[u.name]
					if ((n.push(a), h === void 0)) i(u)
					else {
						let N = n.slice(h),
							I = N.map((Q) => Q.name).join('.')
						e.reportError(
							`Cannot reference Input Object "${u.name}" within itself through a series of non-null fields: "${I}".`,
							N.map((Q) => Q.astNode)
						)
					}
					n.pop()
				}
			r[s.name] = void 0
		}
	}
	function vu(e, t) {
		let { astNode: n, extensionASTNodes: r } = e
		return (n != null ? [n, ...r] : r)
			.flatMap((s) => {
				var o
				return (o = s.interfaces) !== null && o !== void 0 ? o : []
			})
			.filter((s) => s.name.value === t.name)
	}
	function zm(e, t) {
		let { astNode: n, extensionASTNodes: r } = e
		return (n != null ? [n, ...r] : r)
			.flatMap((s) => {
				var o
				return (o = s.types) !== null && o !== void 0 ? o : []
			})
			.filter((s) => s.name.value === t)
	}
	function Pf(e) {
		var t
		return e == null || (t = e.directives) === null || t === void 0
			? void 0
			: t.find((n) => n.name.value === ea.name)
	}
	function br(e, t) {
		switch (t.kind) {
			case oe.LIST_TYPE: {
				let n = br(e, t.type)
				return n && new cr(n)
			}
			case oe.NON_NULL_TYPE: {
				let n = br(e, t.type)
				return n && new An(n)
			}
			case oe.NAMED_TYPE:
				return e.getType(t.name.value)
		}
	}
	var ro = class {
		constructor(t, n, r) {
			;(this._schema = t),
				(this._typeStack = []),
				(this._parentTypeStack = []),
				(this._inputTypeStack = []),
				(this._fieldDefStack = []),
				(this._defaultValueStack = []),
				(this._directive = null),
				(this._argument = null),
				(this._enumValue = null),
				(this._getFieldDef = r ?? Ox),
				n &&
					(Lr(n) && this._inputTypeStack.push(n),
					gr(n) && this._parentTypeStack.push(n),
					bi(n) && this._typeStack.push(n))
		}
		get [Symbol.toStringTag]() {
			return 'TypeInfo'
		}
		getType() {
			if (this._typeStack.length > 0) return this._typeStack[this._typeStack.length - 1]
		}
		getParentType() {
			if (this._parentTypeStack.length > 0)
				return this._parentTypeStack[this._parentTypeStack.length - 1]
		}
		getInputType() {
			if (this._inputTypeStack.length > 0)
				return this._inputTypeStack[this._inputTypeStack.length - 1]
		}
		getParentInputType() {
			if (this._inputTypeStack.length > 1)
				return this._inputTypeStack[this._inputTypeStack.length - 2]
		}
		getFieldDef() {
			if (this._fieldDefStack.length > 0) return this._fieldDefStack[this._fieldDefStack.length - 1]
		}
		getDefaultValue() {
			if (this._defaultValueStack.length > 0)
				return this._defaultValueStack[this._defaultValueStack.length - 1]
		}
		getDirective() {
			return this._directive
		}
		getArgument() {
			return this._argument
		}
		getEnumValue() {
			return this._enumValue
		}
		enter(t) {
			let n = this._schema
			switch (t.kind) {
				case oe.SELECTION_SET: {
					let i = or(this.getType())
					this._parentTypeStack.push(gr(i) ? i : void 0)
					break
				}
				case oe.FIELD: {
					let i = this.getParentType(),
						s,
						o
					i && ((s = this._getFieldDef(n, i, t)), s && (o = s.type)),
						this._fieldDefStack.push(s),
						this._typeStack.push(bi(o) ? o : void 0)
					break
				}
				case oe.DIRECTIVE:
					this._directive = n.getDirective(t.name.value)
					break
				case oe.OPERATION_DEFINITION: {
					let i = n.getRootType(t.operation)
					this._typeStack.push(Un(i) ? i : void 0)
					break
				}
				case oe.INLINE_FRAGMENT:
				case oe.FRAGMENT_DEFINITION: {
					let i = t.typeCondition,
						s = i ? br(n, i) : or(this.getType())
					this._typeStack.push(bi(s) ? s : void 0)
					break
				}
				case oe.VARIABLE_DEFINITION: {
					let i = br(n, t.type)
					this._inputTypeStack.push(Lr(i) ? i : void 0)
					break
				}
				case oe.ARGUMENT: {
					var r
					let i,
						s,
						o = (r = this.getDirective()) !== null && r !== void 0 ? r : this.getFieldDef()
					o && ((i = o.args.find((a) => a.name === t.name.value)), i && (s = i.type)),
						(this._argument = i),
						this._defaultValueStack.push(i ? i.defaultValue : void 0),
						this._inputTypeStack.push(Lr(s) ? s : void 0)
					break
				}
				case oe.LIST: {
					let i = Rs(this.getInputType()),
						s = Zn(i) ? i.ofType : i
					this._defaultValueStack.push(void 0), this._inputTypeStack.push(Lr(s) ? s : void 0)
					break
				}
				case oe.OBJECT_FIELD: {
					let i = or(this.getInputType()),
						s,
						o
					Yn(i) && ((o = i.getFields()[t.name.value]), o && (s = o.type)),
						this._defaultValueStack.push(o ? o.defaultValue : void 0),
						this._inputTypeStack.push(Lr(s) ? s : void 0)
					break
				}
				case oe.ENUM: {
					let i = or(this.getInputType()),
						s
					fr(i) && (s = i.getValue(t.value)), (this._enumValue = s)
					break
				}
				default:
			}
		}
		leave(t) {
			switch (t.kind) {
				case oe.SELECTION_SET:
					this._parentTypeStack.pop()
					break
				case oe.FIELD:
					this._fieldDefStack.pop(), this._typeStack.pop()
					break
				case oe.DIRECTIVE:
					this._directive = null
					break
				case oe.OPERATION_DEFINITION:
				case oe.INLINE_FRAGMENT:
				case oe.FRAGMENT_DEFINITION:
					this._typeStack.pop()
					break
				case oe.VARIABLE_DEFINITION:
					this._inputTypeStack.pop()
					break
				case oe.ARGUMENT:
					;(this._argument = null), this._defaultValueStack.pop(), this._inputTypeStack.pop()
					break
				case oe.LIST:
				case oe.OBJECT_FIELD:
					this._defaultValueStack.pop(), this._inputTypeStack.pop()
					break
				case oe.ENUM:
					this._enumValue = null
					break
				default:
			}
		}
	}
	function Ox(e, t, n) {
		let r = n.name.value
		if (r === Zi.name && e.getQueryType() === t) return Zi
		if (r === es.name && e.getQueryType() === t) return es
		if (r === ts.name && gr(t)) return ts
		if (Un(t) || qn(t)) return t.getFields()[r]
	}
	function xu(e, t) {
		return {
			enter(...n) {
				let r = n[0]
				e.enter(r)
				let i = Zs(t, r.kind).enter
				if (i) {
					let s = i.apply(t, n)
					return s !== void 0 && (e.leave(r), au(s) && e.enter(s)), s
				}
			},
			leave(...n) {
				let r = n[0],
					i = Zs(t, r.kind).leave,
					s
				return i && (s = i.apply(t, n)), e.leave(r), s
			}
		}
	}
	function Mf(e) {
		return e.kind === oe.OPERATION_DEFINITION || e.kind === oe.FRAGMENT_DEFINITION
	}
	function jf(e) {
		return e.kind === oe.SCHEMA_DEFINITION || ns(e) || e.kind === oe.DIRECTIVE_DEFINITION
	}
	function ns(e) {
		return (
			e.kind === oe.SCALAR_TYPE_DEFINITION ||
			e.kind === oe.OBJECT_TYPE_DEFINITION ||
			e.kind === oe.INTERFACE_TYPE_DEFINITION ||
			e.kind === oe.UNION_TYPE_DEFINITION ||
			e.kind === oe.ENUM_TYPE_DEFINITION ||
			e.kind === oe.INPUT_OBJECT_TYPE_DEFINITION
		)
	}
	function $f(e) {
		return e.kind === oe.SCHEMA_EXTENSION || ia(e)
	}
	function ia(e) {
		return (
			e.kind === oe.SCALAR_TYPE_EXTENSION ||
			e.kind === oe.OBJECT_TYPE_EXTENSION ||
			e.kind === oe.INTERFACE_TYPE_EXTENSION ||
			e.kind === oe.UNION_TYPE_EXTENSION ||
			e.kind === oe.ENUM_TYPE_EXTENSION ||
			e.kind === oe.INPUT_OBJECT_TYPE_EXTENSION
		)
	}
	function sa(e) {
		return {
			Document(t) {
				for (let n of t.definitions)
					if (!Mf(n)) {
						let r =
							n.kind === oe.SCHEMA_DEFINITION || n.kind === oe.SCHEMA_EXTENSION
								? 'schema'
								: '"' + n.name.value + '"'
						e.reportError(new et(`The ${r} definition is not executable.`, { nodes: n }))
					}
				return !1
			}
		}
	}
	function Vf(e) {
		return {
			Field(t) {
				let n = e.getParentType()
				if (n && !e.getFieldDef()) {
					let i = e.getSchema(),
						s = t.name.value,
						o = ci('to use an inline fragment on', Bx(i, n, s))
					o === '' && (o = ci(Px(n, s))),
						e.reportError(
							new et(`Cannot query field "${s}" on type "${n.name}".` + o, { nodes: t })
						)
				}
			}
		}
	}
	function Bx(e, t, n) {
		if (!Zr(t)) return []
		let r = new Set(),
			i = Object.create(null)
		for (let o of e.getPossibleTypes(t))
			if (o.getFields()[n]) {
				r.add(o), (i[o.name] = 1)
				for (let a of o.getInterfaces()) {
					var s
					a.getFields()[n] &&
						(r.add(a), (i[a.name] = ((s = i[a.name]) !== null && s !== void 0 ? s : 0) + 1))
				}
			}
		return [...r]
			.sort((o, a) => {
				let u = i[a.name] - i[o.name]
				return u !== 0
					? u
					: qn(o) && e.isSubType(o, a)
					? -1
					: qn(a) && e.isSubType(a, o)
					? 1
					: Qo(o.name, a.name)
			})
			.map((o) => o.name)
	}
	function Px(e, t) {
		if (Un(e) || qn(e)) {
			let n = Object.keys(e.getFields())
			return xi(t, n)
		}
		return []
	}
	function Uf(e) {
		return {
			InlineFragment(t) {
				let n = t.typeCondition
				if (n) {
					let r = br(e.getSchema(), n)
					if (r && !gr(r)) {
						let i = tr(n)
						e.reportError(
							new et(`Fragment cannot condition on non composite type "${i}".`, { nodes: n })
						)
					}
				}
			},
			FragmentDefinition(t) {
				let n = br(e.getSchema(), t.typeCondition)
				if (n && !gr(n)) {
					let r = tr(t.typeCondition)
					e.reportError(
						new et(`Fragment "${t.name.value}" cannot condition on non composite type "${r}".`, {
							nodes: t.typeCondition
						})
					)
				}
			}
		}
	}
	function qf(e) {
		return {
			...Gf(e),
			Argument(t) {
				let n = e.getArgument(),
					r = e.getFieldDef(),
					i = e.getParentType()
				if (!n && r && i) {
					let s = t.name.value,
						o = r.args.map((u) => u.name),
						a = xi(s, o)
					e.reportError(
						new et(`Unknown argument "${s}" on field "${i.name}.${r.name}".` + ci(a), { nodes: t })
					)
				}
			}
		}
	}
	function Gf(e) {
		let t = Object.create(null),
			n = e.getSchema(),
			r = n ? n.getDirectives() : Ci
		for (let o of r) t[o.name] = o.args.map((a) => a.name)
		let i = e.getDocument().definitions
		for (let o of i)
			if (o.kind === oe.DIRECTIVE_DEFINITION) {
				var s
				let a = (s = o.arguments) !== null && s !== void 0 ? s : []
				t[o.name.value] = a.map((u) => u.name.value)
			}
		return {
			Directive(o) {
				let a = o.name.value,
					u = t[a]
				if (o.arguments && u)
					for (let h of o.arguments) {
						let N = h.name.value
						if (!u.includes(N)) {
							let I = xi(N, u)
							e.reportError(
								new et(`Unknown argument "${N}" on directive "@${a}".` + ci(I), { nodes: h })
							)
						}
					}
				return !1
			}
		}
	}
	function io(e) {
		let t = Object.create(null),
			n = e.getSchema(),
			r = n ? n.getDirectives() : Ci
		for (let s of r) t[s.name] = s.locations
		let i = e.getDocument().definitions
		for (let s of i)
			s.kind === oe.DIRECTIVE_DEFINITION && (t[s.name.value] = s.locations.map((o) => o.value))
		return {
			Directive(s, o, a, u, h) {
				let N = s.name.value,
					I = t[N]
				if (!I) {
					e.reportError(new et(`Unknown directive "@${N}".`, { nodes: s }))
					return
				}
				let Q = Mx(h)
				Q &&
					!I.includes(Q) &&
					e.reportError(new et(`Directive "@${N}" may not be used on ${Q}.`, { nodes: s }))
			}
		}
	}
	function Mx(e) {
		let t = e[e.length - 1]
		switch (('kind' in t || xr(!1), t.kind)) {
			case oe.OPERATION_DEFINITION:
				return jx(t.operation)
			case oe.FIELD:
				return Jt.FIELD
			case oe.FRAGMENT_SPREAD:
				return Jt.FRAGMENT_SPREAD
			case oe.INLINE_FRAGMENT:
				return Jt.INLINE_FRAGMENT
			case oe.FRAGMENT_DEFINITION:
				return Jt.FRAGMENT_DEFINITION
			case oe.VARIABLE_DEFINITION:
				return Jt.VARIABLE_DEFINITION
			case oe.SCHEMA_DEFINITION:
			case oe.SCHEMA_EXTENSION:
				return Jt.SCHEMA
			case oe.SCALAR_TYPE_DEFINITION:
			case oe.SCALAR_TYPE_EXTENSION:
				return Jt.SCALAR
			case oe.OBJECT_TYPE_DEFINITION:
			case oe.OBJECT_TYPE_EXTENSION:
				return Jt.OBJECT
			case oe.FIELD_DEFINITION:
				return Jt.FIELD_DEFINITION
			case oe.INTERFACE_TYPE_DEFINITION:
			case oe.INTERFACE_TYPE_EXTENSION:
				return Jt.INTERFACE
			case oe.UNION_TYPE_DEFINITION:
			case oe.UNION_TYPE_EXTENSION:
				return Jt.UNION
			case oe.ENUM_TYPE_DEFINITION:
			case oe.ENUM_TYPE_EXTENSION:
				return Jt.ENUM
			case oe.ENUM_VALUE_DEFINITION:
				return Jt.ENUM_VALUE
			case oe.INPUT_OBJECT_TYPE_DEFINITION:
			case oe.INPUT_OBJECT_TYPE_EXTENSION:
				return Jt.INPUT_OBJECT
			case oe.INPUT_VALUE_DEFINITION: {
				let n = e[e.length - 3]
				return (
					'kind' in n || xr(!1),
					n.kind === oe.INPUT_OBJECT_TYPE_DEFINITION
						? Jt.INPUT_FIELD_DEFINITION
						: Jt.ARGUMENT_DEFINITION
				)
			}
			default:
				xr(!1, 'Unexpected kind: ' + yt(t.kind))
		}
	}
	function jx(e) {
		switch (e) {
			case Or.QUERY:
				return Jt.QUERY
			case Or.MUTATION:
				return Jt.MUTATION
			case Or.SUBSCRIPTION:
				return Jt.SUBSCRIPTION
		}
	}
	function oa(e) {
		return {
			FragmentSpread(t) {
				let n = t.name.value
				e.getFragment(n) || e.reportError(new et(`Unknown fragment "${n}".`, { nodes: t.name }))
			}
		}
	}
	function so(e) {
		let t = e.getSchema(),
			n = t ? t.getTypeMap() : Object.create(null),
			r = Object.create(null)
		for (let s of e.getDocument().definitions) ns(s) && (r[s.name.value] = !0)
		let i = [...Object.keys(n), ...Object.keys(r)]
		return {
			NamedType(s, o, a, u, h) {
				let N = s.name.value
				if (!n[N] && !r[N]) {
					var I
					let Q = (I = h[2]) !== null && I !== void 0 ? I : a,
						K = Q != null && $x(Q)
					if (K && Ym.includes(N)) return
					let ue = xi(N, K ? Ym.concat(i) : i)
					e.reportError(new et(`Unknown type "${N}".` + ci(ue), { nodes: s }))
				}
			}
		}
	}
	var Ym = [...fs, ...ds].map((e) => e.name)
	function $x(e) {
		return 'kind' in e && (jf(e) || $f(e))
	}
	function Wf(e) {
		let t = 0
		return {
			Document(n) {
				t = n.definitions.filter((r) => r.kind === oe.OPERATION_DEFINITION).length
			},
			OperationDefinition(n) {
				!n.name &&
					t > 1 &&
					e.reportError(
						new et('This anonymous operation must be the only defined operation.', { nodes: n })
					)
			}
		}
	}
	function aa(e) {
		var t, n, r
		let i = e.getSchema(),
			s =
				(t =
					(n = (r = i?.astNode) !== null && r !== void 0 ? r : i?.getQueryType()) !== null &&
					n !== void 0
						? n
						: i?.getMutationType()) !== null && t !== void 0
					? t
					: i?.getSubscriptionType(),
			o = 0
		return {
			SchemaDefinition(a) {
				if (s) {
					e.reportError(
						new et('Cannot define a new schema within a schema extension.', { nodes: a })
					)
					return
				}
				o > 0 && e.reportError(new et('Must provide only one schema definition.', { nodes: a })),
					++o
			}
		}
	}
	function Hf(e) {
		let t = Object.create(null),
			n = [],
			r = Object.create(null)
		return {
			OperationDefinition: () => !1,
			FragmentDefinition(s) {
				return i(s), !1
			}
		}
		function i(s) {
			if (t[s.name.value]) return
			let o = s.name.value
			t[o] = !0
			let a = e.getFragmentSpreads(s.selectionSet)
			if (a.length !== 0) {
				r[o] = n.length
				for (let u of a) {
					let h = u.name.value,
						N = r[h]
					if ((n.push(u), N === void 0)) {
						let I = e.getFragment(h)
						I && i(I)
					} else {
						let I = n.slice(N),
							Q = I.slice(0, -1)
								.map((K) => '"' + K.name.value + '"')
								.join(', ')
						e.reportError(
							new et(
								`Cannot spread fragment "${h}" within itself` + (Q !== '' ? ` via ${Q}.` : '.'),
								{ nodes: I }
							)
						)
					}
					n.pop()
				}
				r[o] = void 0
			}
		}
	}
	function Jf(e) {
		let t = Object.create(null)
		return {
			OperationDefinition: {
				enter() {
					t = Object.create(null)
				},
				leave(n) {
					let r = e.getRecursiveVariableUsages(n)
					for (let { node: i } of r) {
						let s = i.name.value
						t[s] !== !0 &&
							e.reportError(
								new et(
									n.name
										? `Variable "$${s}" is not defined by operation "${n.name.value}".`
										: `Variable "$${s}" is not defined.`,
									{ nodes: [i, n] }
								)
							)
					}
				}
			},
			VariableDefinition(n) {
				t[n.variable.name.value] = !0
			}
		}
	}
	function ua(e) {
		let t = [],
			n = []
		return {
			OperationDefinition(r) {
				return t.push(r), !1
			},
			FragmentDefinition(r) {
				return n.push(r), !1
			},
			Document: {
				leave() {
					let r = Object.create(null)
					for (let i of t)
						for (let s of e.getRecursivelyReferencedFragments(i)) r[s.name.value] = !0
					for (let i of n) {
						let s = i.name.value
						r[s] !== !0 && e.reportError(new et(`Fragment "${s}" is never used.`, { nodes: i }))
					}
				}
			}
		}
	}
	function zf(e) {
		let t = []
		return {
			OperationDefinition: {
				enter() {
					t = []
				},
				leave(n) {
					let r = Object.create(null),
						i = e.getRecursiveVariableUsages(n)
					for (let { node: s } of i) r[s.name.value] = !0
					for (let s of t) {
						let o = s.variable.name.value
						r[o] !== !0 &&
							e.reportError(
								new et(
									n.name
										? `Variable "$${o}" is never used in operation "${n.name.value}".`
										: `Variable "$${o}" is never used.`,
									{ nodes: s }
								)
							)
					}
				}
			},
			VariableDefinition(n) {
				t.push(n)
			}
		}
	}
	function yc(e) {
		switch (e.kind) {
			case oe.OBJECT:
				return { ...e, fields: Vx(e.fields) }
			case oe.LIST:
				return { ...e, values: e.values.map(yc) }
			case oe.INT:
			case oe.FLOAT:
			case oe.STRING:
			case oe.BOOLEAN:
			case oe.NULL:
			case oe.ENUM:
			case oe.VARIABLE:
				return e
		}
	}
	function Vx(e) {
		return e
			.map((t) => ({ ...t, value: yc(t.value) }))
			.sort((t, n) => Qo(t.name.value, n.name.value))
	}
	function Km(e) {
		return Array.isArray(e)
			? e.map(([t, n]) => `subfields "${t}" conflict because ` + Km(n)).join(' and ')
			: e
	}
	function Kf(e) {
		let t = new Xf(),
			n = new Map()
		return {
			SelectionSet(r) {
				let i = Ux(e, n, t, e.getParentType(), r)
				for (let [[s, o], a, u] of i) {
					let h = Km(o)
					e.reportError(
						new et(
							`Fields "${s}" conflict because ${h}. Use different aliases on the fields to fetch both if this was intentional.`,
							{ nodes: a.concat(u) }
						)
					)
				}
			}
		}
	}
	function Ux(e, t, n, r, i) {
		let s = [],
			[o, a] = xc(e, t, r, i)
		if ((Gx(e, s, t, n, o), a.length !== 0))
			for (let u = 0; u < a.length; u++) {
				Ec(e, s, t, n, !1, o, a[u])
				for (let h = u + 1; h < a.length; h++) vc(e, s, t, n, !1, a[u], a[h])
			}
		return s
	}
	function Ec(e, t, n, r, i, s, o) {
		let a = e.getFragment(o)
		if (!a) return
		let [u, h] = Yf(e, n, a)
		if (s !== u) {
			Zf(e, t, n, r, i, s, u)
			for (let N of h) r.has(N, o, i) || (r.add(N, o, i), Ec(e, t, n, r, i, s, N))
		}
	}
	function vc(e, t, n, r, i, s, o) {
		if (s === o || r.has(s, o, i)) return
		r.add(s, o, i)
		let a = e.getFragment(s),
			u = e.getFragment(o)
		if (!a || !u) return
		let [h, N] = Yf(e, n, a),
			[I, Q] = Yf(e, n, u)
		Zf(e, t, n, r, i, h, I)
		for (let K of Q) vc(e, t, n, r, i, s, K)
		for (let K of N) vc(e, t, n, r, i, K, o)
	}
	function qx(e, t, n, r, i, s, o, a) {
		let u = [],
			[h, N] = xc(e, t, i, s),
			[I, Q] = xc(e, t, o, a)
		Zf(e, u, t, n, r, h, I)
		for (let K of Q) Ec(e, u, t, n, r, h, K)
		for (let K of N) Ec(e, u, t, n, r, I, K)
		for (let K of N) for (let ue of Q) vc(e, u, t, n, r, K, ue)
		return u
	}
	function Gx(e, t, n, r, i) {
		for (let [s, o] of Object.entries(i))
			if (o.length > 1)
				for (let a = 0; a < o.length; a++)
					for (let u = a + 1; u < o.length; u++) {
						let h = Zm(e, n, r, !1, s, o[a], o[u])
						h && t.push(h)
					}
	}
	function Zf(e, t, n, r, i, s, o) {
		for (let [a, u] of Object.entries(s)) {
			let h = o[a]
			if (h)
				for (let N of u)
					for (let I of h) {
						let Q = Zm(e, n, r, i, a, N, I)
						Q && t.push(Q)
					}
		}
	}
	function Zm(e, t, n, r, i, s, o) {
		let [a, u, h] = s,
			[N, I, Q] = o,
			K = r || (a !== N && Un(a) && Un(N))
		if (!K) {
			let Ae = u.name.value,
				ze = I.name.value
			if (Ae !== ze) return [[i, `"${Ae}" and "${ze}" are different fields`], [u], [I]]
			if (!Wx(u, I)) return [[i, 'they have differing arguments'], [u], [I]]
		}
		let ue = h?.type,
			de = Q?.type
		if (ue && de && Qf(ue, de))
			return [[i, `they return conflicting types "${yt(ue)}" and "${yt(de)}"`], [u], [I]]
		let Pe = u.selectionSet,
			Ze = I.selectionSet
		if (Pe && Ze) {
			let Ae = qx(e, t, n, K, or(ue), Pe, or(de), Ze)
			return Hx(Ae, i, u, I)
		}
	}
	function Wx(e, t) {
		let n = e.arguments,
			r = t.arguments
		if (n === void 0 || n.length === 0) return r === void 0 || r.length === 0
		if (r === void 0 || r.length === 0 || n.length !== r.length) return !1
		let i = new Map(r.map(({ name: s, value: o }) => [s.value, o]))
		return n.every((s) => {
			let o = s.value,
				a = i.get(s.name.value)
			return a === void 0 ? !1 : Xm(o) === Xm(a)
		})
	}
	function Xm(e) {
		return tr(yc(e))
	}
	function Qf(e, t) {
		return Zn(e)
			? Zn(t)
				? Qf(e.ofType, t.ofType)
				: !0
			: Zn(t)
			? !0
			: Nn(e)
			? Nn(t)
				? Qf(e.ofType, t.ofType)
				: !0
			: Nn(t)
			? !0
			: Ti(e) || Ti(t)
			? e !== t
			: !1
	}
	function xc(e, t, n, r) {
		let i = t.get(r)
		if (i) return i
		let s = Object.create(null),
			o = Object.create(null)
		eg(e, n, r, s, o)
		let a = [s, Object.keys(o)]
		return t.set(r, a), a
	}
	function Yf(e, t, n) {
		let r = t.get(n.selectionSet)
		if (r) return r
		let i = br(e.getSchema(), n.typeCondition)
		return xc(e, t, i, n.selectionSet)
	}
	function eg(e, t, n, r, i) {
		for (let s of n.selections)
			switch (s.kind) {
				case oe.FIELD: {
					let o = s.name.value,
						a
					;(Un(t) || qn(t)) && (a = t.getFields()[o])
					let u = s.alias ? s.alias.value : o
					r[u] || (r[u] = []), r[u].push([t, s, a])
					break
				}
				case oe.FRAGMENT_SPREAD:
					i[s.name.value] = !0
					break
				case oe.INLINE_FRAGMENT: {
					let o = s.typeCondition,
						a = o ? br(e.getSchema(), o) : t
					eg(e, a, s.selectionSet, r, i)
					break
				}
			}
	}
	function Hx(e, t, n, r) {
		if (e.length > 0)
			return [
				[t, e.map(([i]) => i)],
				[n, ...e.map(([, i]) => i).flat()],
				[r, ...e.map(([, , i]) => i).flat()]
			]
	}
	var Xf = class {
		constructor() {
			this._data = new Map()
		}
		has(t, n, r) {
			var i
			let [s, o] = t < n ? [t, n] : [n, t],
				a = (i = this._data.get(s)) === null || i === void 0 ? void 0 : i.get(o)
			return a === void 0 ? !1 : r ? !0 : r === a
		}
		add(t, n, r) {
			let [i, s] = t < n ? [t, n] : [n, t],
				o = this._data.get(i)
			o === void 0 ? this._data.set(i, new Map([[s, r]])) : o.set(s, r)
		}
	}
	function ed(e) {
		return {
			InlineFragment(t) {
				let n = e.getType(),
					r = e.getParentType()
				if (gr(n) && gr(r) && !eo(e.getSchema(), n, r)) {
					let i = yt(r),
						s = yt(n)
					e.reportError(
						new et(
							`Fragment cannot be spread here as objects of type "${i}" can never be of type "${s}".`,
							{ nodes: t }
						)
					)
				}
			},
			FragmentSpread(t) {
				let n = t.name.value,
					r = Jx(e, n),
					i = e.getParentType()
				if (r && i && !eo(e.getSchema(), r, i)) {
					let s = yt(i),
						o = yt(r)
					e.reportError(
						new et(
							`Fragment "${n}" cannot be spread here as objects of type "${s}" can never be of type "${o}".`,
							{ nodes: t }
						)
					)
				}
			}
		}
	}
	function Jx(e, t) {
		let n = e.getFragment(t)
		if (n) {
			let r = br(e.getSchema(), n.typeCondition)
			if (gr(r)) return r
		}
	}
	function la(e) {
		let t = e.getSchema(),
			n = Object.create(null)
		for (let i of e.getDocument().definitions) ns(i) && (n[i.name.value] = i)
		return {
			ScalarTypeExtension: r,
			ObjectTypeExtension: r,
			InterfaceTypeExtension: r,
			UnionTypeExtension: r,
			EnumTypeExtension: r,
			InputObjectTypeExtension: r
		}
		function r(i) {
			let s = i.name.value,
				o = n[s],
				a = t?.getType(s),
				u
			if ((o ? (u = zx[o.kind]) : a && (u = Qx(a)), u)) {
				if (u !== i.kind) {
					let h = Yx(i.kind)
					e.reportError(new et(`Cannot extend non-${h} type "${s}".`, { nodes: o ? [o, i] : i }))
				}
			} else {
				let h = Object.keys({ ...n, ...t?.getTypeMap() }),
					N = xi(s, h)
				e.reportError(
					new et(`Cannot extend type "${s}" because it is not defined.` + ci(N), { nodes: i.name })
				)
			}
		}
	}
	var zx = {
		[oe.SCALAR_TYPE_DEFINITION]: oe.SCALAR_TYPE_EXTENSION,
		[oe.OBJECT_TYPE_DEFINITION]: oe.OBJECT_TYPE_EXTENSION,
		[oe.INTERFACE_TYPE_DEFINITION]: oe.INTERFACE_TYPE_EXTENSION,
		[oe.UNION_TYPE_DEFINITION]: oe.UNION_TYPE_EXTENSION,
		[oe.ENUM_TYPE_DEFINITION]: oe.ENUM_TYPE_EXTENSION,
		[oe.INPUT_OBJECT_TYPE_DEFINITION]: oe.INPUT_OBJECT_TYPE_EXTENSION
	}
	function Qx(e) {
		if (Vr(e)) return oe.SCALAR_TYPE_EXTENSION
		if (Un(e)) return oe.OBJECT_TYPE_EXTENSION
		if (qn(e)) return oe.INTERFACE_TYPE_EXTENSION
		if (wr(e)) return oe.UNION_TYPE_EXTENSION
		if (fr(e)) return oe.ENUM_TYPE_EXTENSION
		if (Yn(e)) return oe.INPUT_OBJECT_TYPE_EXTENSION
		xr(!1, 'Unexpected type: ' + yt(e))
	}
	function Yx(e) {
		switch (e) {
			case oe.SCALAR_TYPE_EXTENSION:
				return 'scalar'
			case oe.OBJECT_TYPE_EXTENSION:
				return 'object'
			case oe.INTERFACE_TYPE_EXTENSION:
				return 'interface'
			case oe.UNION_TYPE_EXTENSION:
				return 'union'
			case oe.ENUM_TYPE_EXTENSION:
				return 'enum'
			case oe.INPUT_OBJECT_TYPE_EXTENSION:
				return 'input object'
			default:
				xr(!1, 'Unexpected kind: ' + yt(e))
		}
	}
	function td(e) {
		return {
			...nd(e),
			Field: {
				leave(t) {
					var n
					let r = e.getFieldDef()
					if (!r) return !1
					let i = new Set(
						(n = t.arguments) === null || n === void 0 ? void 0 : n.map((s) => s.name.value)
					)
					for (let s of r.args)
						if (!i.has(s.name) && ps(s)) {
							let o = yt(s.type)
							e.reportError(
								new et(
									`Field "${r.name}" argument "${s.name}" of type "${o}" is required, but it was not provided.`,
									{ nodes: t }
								)
							)
						}
				}
			}
		}
	}
	function nd(e) {
		var t
		let n = Object.create(null),
			r = e.getSchema(),
			i = (t = r?.getDirectives()) !== null && t !== void 0 ? t : Ci
		for (let a of i) n[a.name] = vi(a.args.filter(ps), (u) => u.name)
		let s = e.getDocument().definitions
		for (let a of s)
			if (a.kind === oe.DIRECTIVE_DEFINITION) {
				var o
				let u = (o = a.arguments) !== null && o !== void 0 ? o : []
				n[a.name.value] = vi(u.filter(Xx), (h) => h.name.value)
			}
		return {
			Directive: {
				leave(a) {
					let u = a.name.value,
						h = n[u]
					if (h) {
						var N
						let I = (N = a.arguments) !== null && N !== void 0 ? N : [],
							Q = new Set(I.map((K) => K.name.value))
						for (let [K, ue] of Object.entries(h))
							if (!Q.has(K)) {
								let de = Xo(ue.type) ? yt(ue.type) : tr(ue.type)
								e.reportError(
									new et(
										`Directive "@${u}" argument "${K}" of type "${de}" is required, but it was not provided.`,
										{ nodes: a }
									)
								)
							}
					}
				}
			}
		}
	}
	function Xx(e) {
		return e.type.kind === oe.NON_NULL_TYPE && e.defaultValue == null
	}
	function rd(e) {
		return {
			Field(t) {
				let n = e.getType(),
					r = t.selectionSet
				if (n) {
					if (Ti(or(n))) {
						if (r) {
							let i = t.name.value,
								s = yt(n)
							e.reportError(
								new et(
									`Field "${i}" must not have a selection since type "${s}" has no subfields.`,
									{ nodes: r }
								)
							)
						}
					} else if (!r) {
						let i = t.name.value,
							s = yt(n)
						e.reportError(
							new et(
								`Field "${i}" of type "${s}" must have a selection of subfields. Did you mean "${i} { ... }"?`,
								{ nodes: t }
							)
						)
					}
				}
			}
		}
	}
	function Ii(e, t, n) {
		if (e) {
			if (e.kind === oe.VARIABLE) {
				let r = e.name.value
				if (n == null || n[r] === void 0) return
				let i = n[r]
				return i === null && Nn(t) ? void 0 : i
			}
			if (Nn(t)) return e.kind === oe.NULL ? void 0 : Ii(e, t.ofType, n)
			if (e.kind === oe.NULL) return null
			if (Zn(t)) {
				let r = t.ofType
				if (e.kind === oe.LIST) {
					let s = []
					for (let o of e.values)
						if (tg(o, n)) {
							if (Nn(r)) return
							s.push(null)
						} else {
							let a = Ii(o, r, n)
							if (a === void 0) return
							s.push(a)
						}
					return s
				}
				let i = Ii(e, r, n)
				return i === void 0 ? void 0 : [i]
			}
			if (Yn(t)) {
				if (e.kind !== oe.OBJECT) return
				let r = Object.create(null),
					i = vi(e.fields, (s) => s.name.value)
				for (let s of Object.values(t.getFields())) {
					let o = i[s.name]
					if (!o || tg(o.value, n)) {
						if (s.defaultValue !== void 0) r[s.name] = s.defaultValue
						else if (Nn(s.type)) return
						continue
					}
					let a = Ii(o.value, s.type, n)
					if (a === void 0) return
					r[s.name] = a
				}
				return r
			}
			if (Ti(t)) {
				let r
				try {
					r = t.parseLiteral(e, n)
				} catch {
					return
				}
				return r === void 0 ? void 0 : r
			}
			xr(!1, 'Unexpected input type: ' + yt(t))
		}
	}
	function tg(e, t) {
		return e.kind === oe.VARIABLE && (t == null || t[e.name.value] === void 0)
	}
	function Kx(e, t, n) {
		var r
		let i = {},
			s = (r = t.arguments) !== null && r !== void 0 ? r : [],
			o = vi(s, (a) => a.name.value)
		for (let a of e.args) {
			let u = a.name,
				h = a.type,
				N = o[u]
			if (!N) {
				if (a.defaultValue !== void 0) i[u] = a.defaultValue
				else if (Nn(h))
					throw new et(`Argument "${u}" of required type "${yt(h)}" was not provided.`, {
						nodes: t
					})
				continue
			}
			let I = N.value,
				Q = I.kind === oe.NULL
			if (I.kind === oe.VARIABLE) {
				let ue = I.name.value
				if (n == null || !Zx(n, ue)) {
					if (a.defaultValue !== void 0) i[u] = a.defaultValue
					else if (Nn(h))
						throw new et(
							`Argument "${u}" of required type "${yt(
								h
							)}" was provided the variable "$${ue}" which was not provided a runtime value.`,
							{ nodes: I }
						)
					continue
				}
				Q = n[ue] == null
			}
			if (Q && Nn(h))
				throw new et(`Argument "${u}" of non-null type "${yt(h)}" must not be null.`, { nodes: I })
			let K = Ii(I, h, n)
			if (K === void 0) throw new et(`Argument "${u}" has invalid value ${tr(I)}.`, { nodes: I })
			i[u] = K
		}
		return i
	}
	function ca(e, t, n) {
		var r
		let i =
			(r = t.directives) === null || r === void 0 ? void 0 : r.find((s) => s.name.value === e.name)
		if (i) return Kx(e, i, n)
	}
	function Zx(e, t) {
		return Object.prototype.hasOwnProperty.call(e, t)
	}
	function rg(e, t, n, r, i) {
		let s = new Map()
		return sd(e, t, n, r, i, s, new Set()), s
	}
	function sd(e, t, n, r, i, s, o) {
		for (let a of i.selections)
			switch (a.kind) {
				case oe.FIELD: {
					if (!id(n, a)) continue
					let u = eb(a),
						h = s.get(u)
					h !== void 0 ? h.push(a) : s.set(u, [a])
					break
				}
				case oe.INLINE_FRAGMENT: {
					if (!id(n, a) || !ng(e, a, r)) continue
					sd(e, t, n, r, a.selectionSet, s, o)
					break
				}
				case oe.FRAGMENT_SPREAD: {
					let u = a.name.value
					if (o.has(u) || !id(n, a)) continue
					o.add(u)
					let h = t[u]
					if (!h || !ng(e, h, r)) continue
					sd(e, t, n, r, h.selectionSet, s, o)
					break
				}
			}
	}
	function id(e, t) {
		let n = ca(pc, t, e)
		if (n?.if === !0) return !1
		let r = ca(cc, t, e)
		return r?.if !== !1
	}
	function ng(e, t, n) {
		let r = t.typeCondition
		if (!r) return !0
		let i = br(e, r)
		return i === n ? !0 : Zr(i) ? e.isSubType(i, n) : !1
	}
	function eb(e) {
		return e.alias ? e.alias.value : e.name.value
	}
	function od(e) {
		return {
			OperationDefinition(t) {
				if (t.operation === 'subscription') {
					let n = e.getSchema(),
						r = n.getSubscriptionType()
					if (r) {
						let i = t.name ? t.name.value : null,
							s = Object.create(null),
							o = e.getDocument(),
							a = Object.create(null)
						for (let h of o.definitions) h.kind === oe.FRAGMENT_DEFINITION && (a[h.name.value] = h)
						let u = rg(n, a, s, r, t.selectionSet)
						if (u.size > 1) {
							let I = [...u.values()].slice(1).flat()
							e.reportError(
								new et(
									i != null
										? `Subscription "${i}" must select only one top level field.`
										: 'Anonymous Subscription must select only one top level field.',
									{ nodes: I }
								)
							)
						}
						for (let h of u.values())
							h[0].name.value.startsWith('__') &&
								e.reportError(
									new et(
										i != null
											? `Subscription "${i}" must not select an introspection top level field.`
											: 'Anonymous Subscription must not select an introspection top level field.',
										{ nodes: h }
									)
								)
					}
				}
			}
		}
	}
	function pa(e, t) {
		let n = new Map()
		for (let r of e) {
			let i = t(r),
				s = n.get(i)
			s === void 0 ? n.set(i, [r]) : s.push(r)
		}
		return n
	}
	function ad(e) {
		return {
			DirectiveDefinition(r) {
				var i
				let s = (i = r.arguments) !== null && i !== void 0 ? i : []
				return n(`@${r.name.value}`, s)
			},
			InterfaceTypeDefinition: t,
			InterfaceTypeExtension: t,
			ObjectTypeDefinition: t,
			ObjectTypeExtension: t
		}
		function t(r) {
			var i
			let s = r.name.value,
				o = (i = r.fields) !== null && i !== void 0 ? i : []
			for (let u of o) {
				var a
				let h = u.name.value,
					N = (a = u.arguments) !== null && a !== void 0 ? a : []
				n(`${s}.${h}`, N)
			}
			return !1
		}
		function n(r, i) {
			let s = pa(i, (o) => o.name.value)
			for (let [o, a] of s)
				a.length > 1 &&
					e.reportError(
						new et(`Argument "${r}(${o}:)" can only be defined once.`, {
							nodes: a.map((u) => u.name)
						})
					)
			return !1
		}
	}
	function oo(e) {
		return { Field: t, Directive: t }
		function t(n) {
			var r
			let i = (r = n.arguments) !== null && r !== void 0 ? r : [],
				s = pa(i, (o) => o.name.value)
			for (let [o, a] of s)
				a.length > 1 &&
					e.reportError(
						new et(`There can be only one argument named "${o}".`, { nodes: a.map((u) => u.name) })
					)
		}
	}
	function fa(e) {
		let t = Object.create(null),
			n = e.getSchema()
		return {
			DirectiveDefinition(r) {
				let i = r.name.value
				if (n != null && n.getDirective(i)) {
					e.reportError(
						new et(`Directive "@${i}" already exists in the schema. It cannot be redefined.`, {
							nodes: r.name
						})
					)
					return
				}
				return (
					t[i]
						? e.reportError(
								new et(`There can be only one directive named "@${i}".`, { nodes: [t[i], r.name] })
						  )
						: (t[i] = r.name),
					!1
				)
			}
		}
	}
	function ao(e) {
		let t = Object.create(null),
			n = e.getSchema(),
			r = n ? n.getDirectives() : Ci
		for (let a of r) t[a.name] = !a.isRepeatable
		let i = e.getDocument().definitions
		for (let a of i) a.kind === oe.DIRECTIVE_DEFINITION && (t[a.name.value] = !a.repeatable)
		let s = Object.create(null),
			o = Object.create(null)
		return {
			enter(a) {
				if (!('directives' in a) || !a.directives) return
				let u
				if (a.kind === oe.SCHEMA_DEFINITION || a.kind === oe.SCHEMA_EXTENSION) u = s
				else if (ns(a) || ia(a)) {
					let h = a.name.value
					;(u = o[h]), u === void 0 && (o[h] = u = Object.create(null))
				} else u = Object.create(null)
				for (let h of a.directives) {
					let N = h.name.value
					t[N] &&
						(u[N]
							? e.reportError(
									new et(`The directive "@${N}" can only be used once at this location.`, {
										nodes: [u[N], h]
									})
							  )
							: (u[N] = h))
				}
			}
		}
	}
	function da(e) {
		let t = e.getSchema(),
			n = t ? t.getTypeMap() : Object.create(null),
			r = Object.create(null)
		return { EnumTypeDefinition: i, EnumTypeExtension: i }
		function i(s) {
			var o
			let a = s.name.value
			r[a] || (r[a] = Object.create(null))
			let u = (o = s.values) !== null && o !== void 0 ? o : [],
				h = r[a]
			for (let N of u) {
				let I = N.name.value,
					Q = n[a]
				fr(Q) && Q.getValue(I)
					? e.reportError(
							new et(
								`Enum value "${a}.${I}" already exists in the schema. It cannot also be defined in this type extension.`,
								{ nodes: N.name }
							)
					  )
					: h[I]
					? e.reportError(
							new et(`Enum value "${a}.${I}" can only be defined once.`, { nodes: [h[I], N.name] })
					  )
					: (h[I] = N.name)
			}
			return !1
		}
	}
	function ha(e) {
		let t = e.getSchema(),
			n = t ? t.getTypeMap() : Object.create(null),
			r = Object.create(null)
		return {
			InputObjectTypeDefinition: i,
			InputObjectTypeExtension: i,
			InterfaceTypeDefinition: i,
			InterfaceTypeExtension: i,
			ObjectTypeDefinition: i,
			ObjectTypeExtension: i
		}
		function i(s) {
			var o
			let a = s.name.value
			r[a] || (r[a] = Object.create(null))
			let u = (o = s.fields) !== null && o !== void 0 ? o : [],
				h = r[a]
			for (let N of u) {
				let I = N.name.value
				tb(n[a], I)
					? e.reportError(
							new et(
								`Field "${a}.${I}" already exists in the schema. It cannot also be defined in this type extension.`,
								{ nodes: N.name }
							)
					  )
					: h[I]
					? e.reportError(
							new et(`Field "${a}.${I}" can only be defined once.`, { nodes: [h[I], N.name] })
					  )
					: (h[I] = N.name)
			}
			return !1
		}
	}
	function tb(e, t) {
		return Un(e) || qn(e) || Yn(e) ? e.getFields()[t] != null : !1
	}
	function ud(e) {
		let t = Object.create(null)
		return {
			OperationDefinition: () => !1,
			FragmentDefinition(n) {
				let r = n.name.value
				return (
					t[r]
						? e.reportError(
								new et(`There can be only one fragment named "${r}".`, { nodes: [t[r], n.name] })
						  )
						: (t[r] = n.name),
					!1
				)
			}
		}
	}
	function uo(e) {
		let t = [],
			n = Object.create(null)
		return {
			ObjectValue: {
				enter() {
					t.push(n), (n = Object.create(null))
				},
				leave() {
					let r = t.pop()
					r || xr(!1), (n = r)
				}
			},
			ObjectField(r) {
				let i = r.name.value
				n[i]
					? e.reportError(
							new et(`There can be only one input field named "${i}".`, { nodes: [n[i], r.name] })
					  )
					: (n[i] = r.name)
			}
		}
	}
	function ld(e) {
		let t = Object.create(null)
		return {
			OperationDefinition(n) {
				let r = n.name
				return (
					r &&
						(t[r.value]
							? e.reportError(
									new et(`There can be only one operation named "${r.value}".`, {
										nodes: [t[r.value], r]
									})
							  )
							: (t[r.value] = r)),
					!1
				)
			},
			FragmentDefinition: () => !1
		}
	}
	function ma(e) {
		let t = e.getSchema(),
			n = Object.create(null),
			r = t
				? {
						query: t.getQueryType(),
						mutation: t.getMutationType(),
						subscription: t.getSubscriptionType()
				  }
				: {}
		return { SchemaDefinition: i, SchemaExtension: i }
		function i(s) {
			var o
			let a = (o = s.operationTypes) !== null && o !== void 0 ? o : []
			for (let u of a) {
				let h = u.operation,
					N = n[h]
				r[h]
					? e.reportError(
							new et(`Type for ${h} already defined in the schema. It cannot be redefined.`, {
								nodes: u
							})
					  )
					: N
					? e.reportError(new et(`There can be only one ${h} type in schema.`, { nodes: [N, u] }))
					: (n[h] = u)
			}
			return !1
		}
	}
	function ga(e) {
		let t = Object.create(null),
			n = e.getSchema()
		return {
			ScalarTypeDefinition: r,
			ObjectTypeDefinition: r,
			InterfaceTypeDefinition: r,
			UnionTypeDefinition: r,
			EnumTypeDefinition: r,
			InputObjectTypeDefinition: r
		}
		function r(i) {
			let s = i.name.value
			if (n != null && n.getType(s)) {
				e.reportError(
					new et(
						`Type "${s}" already exists in the schema. It cannot also be defined in this type definition.`,
						{ nodes: i.name }
					)
				)
				return
			}
			return (
				t[s]
					? e.reportError(
							new et(`There can be only one type named "${s}".`, { nodes: [t[s], i.name] })
					  )
					: (t[s] = i.name),
				!1
			)
		}
	}
	function cd(e) {
		return {
			OperationDefinition(t) {
				var n
				let r = (n = t.variableDefinitions) !== null && n !== void 0 ? n : [],
					i = pa(r, (s) => s.variable.name.value)
				for (let [s, o] of i)
					o.length > 1 &&
						e.reportError(
							new et(`There can be only one variable named "$${s}".`, {
								nodes: o.map((a) => a.variable.name)
							})
						)
			}
		}
	}
	function pd(e) {
		return {
			ListValue(t) {
				let n = Rs(e.getParentInputType())
				if (!Zn(n)) return lo(e, t), !1
			},
			ObjectValue(t) {
				let n = or(e.getInputType())
				if (!Yn(n)) return lo(e, t), !1
				let r = vi(t.fields, (i) => i.name.value)
				for (let i of Object.values(n.getFields()))
					if (!r[i.name] && Ko(i)) {
						let o = yt(i.type)
						e.reportError(
							new et(`Field "${n.name}.${i.name}" of required type "${o}" was not provided.`, {
								nodes: t
							})
						)
					}
			},
			ObjectField(t) {
				let n = or(e.getParentInputType())
				if (!e.getInputType() && Yn(n)) {
					let i = xi(t.name.value, Object.keys(n.getFields()))
					e.reportError(
						new et(`Field "${t.name.value}" is not defined by type "${n.name}".` + ci(i), {
							nodes: t
						})
					)
				}
			},
			NullValue(t) {
				let n = e.getInputType()
				Nn(n) &&
					e.reportError(new et(`Expected value of type "${yt(n)}", found ${tr(t)}.`, { nodes: t }))
			},
			EnumValue: (t) => lo(e, t),
			IntValue: (t) => lo(e, t),
			FloatValue: (t) => lo(e, t),
			StringValue: (t) => lo(e, t),
			BooleanValue: (t) => lo(e, t)
		}
	}
	function lo(e, t) {
		let n = e.getInputType()
		if (!n) return
		let r = or(n)
		if (!Ti(r)) {
			let i = yt(n)
			e.reportError(new et(`Expected value of type "${i}", found ${tr(t)}.`, { nodes: t }))
			return
		}
		try {
			if (r.parseLiteral(t, void 0) === void 0) {
				let s = yt(n)
				e.reportError(new et(`Expected value of type "${s}", found ${tr(t)}.`, { nodes: t }))
			}
		} catch (i) {
			let s = yt(n)
			i instanceof et
				? e.reportError(i)
				: e.reportError(
						new et(`Expected value of type "${s}", found ${tr(t)}; ` + i.message, {
							nodes: t,
							originalError: i
						})
				  )
		}
	}
	function fd(e) {
		return {
			VariableDefinition(t) {
				let n = br(e.getSchema(), t.type)
				if (n !== void 0 && !Lr(n)) {
					let r = t.variable.name.value,
						i = tr(t.type)
					e.reportError(
						new et(`Variable "$${r}" cannot be non-input type "${i}".`, { nodes: t.type })
					)
				}
			}
		}
	}
	function dd(e) {
		let t = Object.create(null)
		return {
			OperationDefinition: {
				enter() {
					t = Object.create(null)
				},
				leave(n) {
					let r = e.getRecursiveVariableUsages(n)
					for (let { node: i, type: s, defaultValue: o } of r) {
						let a = i.name.value,
							u = t[a]
						if (u && s) {
							let h = e.getSchema(),
								N = br(h, u.type)
							if (N && !nb(h, N, u.defaultValue, s, o)) {
								let I = yt(N),
									Q = yt(s)
								e.reportError(
									new et(
										`Variable "$${a}" of type "${I}" used in position expecting type "${Q}".`,
										{ nodes: [u, i] }
									)
								)
							}
						}
					}
				}
			},
			VariableDefinition(n) {
				t[n.variable.name.value] = n
			}
		}
	}
	function nb(e, t, n, r, i) {
		if (Nn(r) && !Nn(t)) {
			if (!(n != null && n.kind !== oe.NULL) && !(i !== void 0)) return !1
			let a = r.ofType
			return Ki(e, t, a)
		}
		return Ki(e, t, r)
	}
	var Da = Object.freeze([
			sa,
			ld,
			Wf,
			od,
			so,
			Uf,
			fd,
			rd,
			Vf,
			ud,
			oa,
			ua,
			ed,
			Hf,
			cd,
			Jf,
			zf,
			io,
			ao,
			qf,
			oo,
			pd,
			td,
			dd,
			Kf,
			uo
		]),
		ig = Object.freeze([aa, ma, ga, da, ha, ad, fa, so, io, ao, la, Gf, oo, uo, nd])
	var bc = class {
			constructor(t, n) {
				;(this._ast = t),
					(this._fragments = void 0),
					(this._fragmentSpreads = new Map()),
					(this._recursivelyReferencedFragments = new Map()),
					(this._onError = n)
			}
			get [Symbol.toStringTag]() {
				return 'ASTValidationContext'
			}
			reportError(t) {
				this._onError(t)
			}
			getDocument() {
				return this._ast
			}
			getFragment(t) {
				let n
				if (this._fragments) n = this._fragments
				else {
					n = Object.create(null)
					for (let r of this.getDocument().definitions)
						r.kind === oe.FRAGMENT_DEFINITION && (n[r.name.value] = r)
					this._fragments = n
				}
				return n[t]
			}
			getFragmentSpreads(t) {
				let n = this._fragmentSpreads.get(t)
				if (!n) {
					n = []
					let r = [t],
						i
					for (; (i = r.pop()); )
						for (let s of i.selections)
							s.kind === oe.FRAGMENT_SPREAD ? n.push(s) : s.selectionSet && r.push(s.selectionSet)
					this._fragmentSpreads.set(t, n)
				}
				return n
			}
			getRecursivelyReferencedFragments(t) {
				let n = this._recursivelyReferencedFragments.get(t)
				if (!n) {
					n = []
					let r = Object.create(null),
						i = [t.selectionSet],
						s
					for (; (s = i.pop()); )
						for (let o of this.getFragmentSpreads(s)) {
							let a = o.name.value
							if (r[a] !== !0) {
								r[a] = !0
								let u = this.getFragment(a)
								u && (n.push(u), i.push(u.selectionSet))
							}
						}
					this._recursivelyReferencedFragments.set(t, n)
				}
				return n
			}
		},
		Tc = class extends bc {
			constructor(t, n, r) {
				super(t, r), (this._schema = n)
			}
			get [Symbol.toStringTag]() {
				return 'SDLValidationContext'
			}
			getSchema() {
				return this._schema
			}
		},
		bu = class extends bc {
			constructor(t, n, r, i) {
				super(n, i),
					(this._schema = t),
					(this._typeInfo = r),
					(this._variableUsages = new Map()),
					(this._recursiveVariableUsages = new Map())
			}
			get [Symbol.toStringTag]() {
				return 'ValidationContext'
			}
			getSchema() {
				return this._schema
			}
			getVariableUsages(t) {
				let n = this._variableUsages.get(t)
				if (!n) {
					let r = [],
						i = new ro(this._schema)
					Jr(
						t,
						xu(i, {
							VariableDefinition: () => !1,
							Variable(s) {
								r.push({ node: s, type: i.getInputType(), defaultValue: i.getDefaultValue() })
							}
						})
					),
						(n = r),
						this._variableUsages.set(t, n)
				}
				return n
			}
			getRecursiveVariableUsages(t) {
				let n = this._recursiveVariableUsages.get(t)
				if (!n) {
					n = this.getVariableUsages(t)
					for (let r of this.getRecursivelyReferencedFragments(t))
						n = n.concat(this.getVariableUsages(r))
					this._recursiveVariableUsages.set(t, n)
				}
				return n
			}
			getType() {
				return this._typeInfo.getType()
			}
			getParentType() {
				return this._typeInfo.getParentType()
			}
			getInputType() {
				return this._typeInfo.getInputType()
			}
			getParentInputType() {
				return this._typeInfo.getParentInputType()
			}
			getFieldDef() {
				return this._typeInfo.getFieldDef()
			}
			getDirective() {
				return this._typeInfo.getDirective()
			}
			getArgument() {
				return this._typeInfo.getArgument()
			}
			getEnumValue() {
				return this._typeInfo.getEnumValue()
			}
		}
	function ya(e, t, n = Da, r, i = new ro(e)) {
		var s
		let o = (s = r?.maxErrors) !== null && s !== void 0 ? s : 100
		t || On(!1, 'Must provide document.'), Bf(e)
		let a = Object.freeze({}),
			u = [],
			h = new bu(e, t, i, (I) => {
				if (u.length >= o)
					throw (
						(u.push(new et('Too many validation errors, error limit reached. Validation aborted.')),
						a)
					)
				u.push(I)
			}),
			N = pu(n.map((I) => I(h)))
		try {
			Jr(t, xu(i, N))
		} catch (I) {
			if (I !== a) throw I
		}
		return u
	}
	function rb(e, t, n = ig) {
		let r = [],
			i = new Tc(e, t, (o) => {
				r.push(o)
			}),
			s = n.map((o) => o(i))
		return Jr(e, pu(s)), r
	}
	function sg(e) {
		let t = rb(e)
		if (t.length !== 0)
			throw new Error(
				t.map((n) => n.message).join(`

`)
			)
	}
	function Ac(e) {
		return {
			Field(t) {
				let n = e.getFieldDef(),
					r = n?.deprecationReason
				if (n && r != null) {
					let i = e.getParentType()
					i != null || xr(!1),
						e.reportError(new et(`The field ${i.name}.${n.name} is deprecated. ${r}`, { nodes: t }))
				}
			},
			Argument(t) {
				let n = e.getArgument(),
					r = n?.deprecationReason
				if (n && r != null) {
					let i = e.getDirective()
					if (i != null)
						e.reportError(
							new et(`Directive "@${i.name}" argument "${n.name}" is deprecated. ${r}`, {
								nodes: t
							})
						)
					else {
						let s = e.getParentType(),
							o = e.getFieldDef()
						;(s != null && o != null) || xr(!1),
							e.reportError(
								new et(`Field "${s.name}.${o.name}" argument "${n.name}" is deprecated. ${r}`, {
									nodes: t
								})
							)
					}
				}
			},
			ObjectField(t) {
				let n = or(e.getParentInputType())
				if (Yn(n)) {
					let r = n.getFields()[t.name.value],
						i = r?.deprecationReason
					i != null &&
						e.reportError(
							new et(`The input field ${n.name}.${r.name} is deprecated. ${i}`, { nodes: t })
						)
				}
			},
			EnumValue(t) {
				let n = e.getEnumValue(),
					r = n?.deprecationReason
				if (n && r != null) {
					let i = or(e.getInputType())
					i != null || xr(!1),
						e.reportError(
							new et(`The enum value "${i.name}.${n.name}" is deprecated. ${r}`, { nodes: t })
						)
				}
			}
		}
	}
	function Tu(e, t) {
		;(Yr(e) && Yr(e.__schema)) ||
			On(
				!1,
				`Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${yt(
					e
				)}.`
			)
		let n = e.__schema,
			r = Yi(
				n.types,
				(Je) => Je.name,
				(Je) => Q(Je)
			)
		for (let Je of [...fs, ...ds]) r[Je.name] && (r[Je.name] = Je)
		let i = n.queryType ? N(n.queryType) : null,
			s = n.mutationType ? N(n.mutationType) : null,
			o = n.subscriptionType ? N(n.subscriptionType) : null,
			a = n.directives ? n.directives.map(St) : []
		return new Os({
			description: n.description,
			query: i,
			mutation: s,
			subscription: o,
			types: Object.values(r),
			directives: a,
			assumeValid: t?.assumeValid
		})
		function u(Je) {
			if (Je.kind === nr.LIST) {
				let Ve = Je.ofType
				if (!Ve) throw new Error('Decorated type deeper than introspection query.')
				return new cr(u(Ve))
			}
			if (Je.kind === nr.NON_NULL) {
				let Ve = Je.ofType
				if (!Ve) throw new Error('Decorated type deeper than introspection query.')
				let Qt = u(Ve)
				return new An(sc(Qt))
			}
			return h(Je)
		}
		function h(Je) {
			let Ve = Je.name
			if (!Ve) throw new Error(`Unknown type reference: ${yt(Je)}.`)
			let Qt = r[Ve]
			if (!Qt)
				throw new Error(
					`Invalid or incomplete schema, unknown type: ${Ve}. Ensure that a full introspection query is used in order to build a client schema.`
				)
			return Qt
		}
		function N(Je) {
			return tc(h(Je))
		}
		function I(Je) {
			return nc(h(Je))
		}
		function Q(Je) {
			if (Je != null && Je.name != null && Je.kind != null)
				switch (Je.kind) {
					case nr.SCALAR:
						return K(Je)
					case nr.OBJECT:
						return de(Je)
					case nr.INTERFACE:
						return Pe(Je)
					case nr.UNION:
						return Ze(Je)
					case nr.ENUM:
						return Ae(Je)
					case nr.INPUT_OBJECT:
						return ze(Je)
				}
			let Ve = yt(Je)
			throw new Error(
				`Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${Ve}.`
			)
		}
		function K(Je) {
			return new Xr({
				name: Je.name,
				description: Je.description,
				specifiedByURL: Je.specifiedByURL
			})
		}
		function ue(Je) {
			if (Je.interfaces === null && Je.kind === nr.INTERFACE) return []
			if (!Je.interfaces) {
				let Ve = yt(Je)
				throw new Error(`Introspection result missing interfaces: ${Ve}.`)
			}
			return Je.interfaces.map(I)
		}
		function de(Je) {
			return new Pr({
				name: Je.name,
				description: Je.description,
				interfaces: () => ue(Je),
				fields: () => it(Je)
			})
		}
		function Pe(Je) {
			return new ri({
				name: Je.name,
				description: Je.description,
				interfaces: () => ue(Je),
				fields: () => it(Je)
			})
		}
		function Ze(Je) {
			if (!Je.possibleTypes) {
				let Ve = yt(Je)
				throw new Error(`Introspection result missing possibleTypes: ${Ve}.`)
			}
			return new Xi({
				name: Je.name,
				description: Je.description,
				types: () => Je.possibleTypes.map(N)
			})
		}
		function Ae(Je) {
			if (!Je.enumValues) {
				let Ve = yt(Je)
				throw new Error(`Introspection result missing enumValues: ${Ve}.`)
			}
			return new Kr({
				name: Je.name,
				description: Je.description,
				values: Yi(
					Je.enumValues,
					(Ve) => Ve.name,
					(Ve) => ({ description: Ve.description, deprecationReason: Ve.deprecationReason })
				)
			})
		}
		function ze(Je) {
			if (!Je.inputFields) {
				let Ve = yt(Je)
				throw new Error(`Introspection result missing inputFields: ${Ve}.`)
			}
			return new Li({
				name: Je.name,
				description: Je.description,
				fields: () => _t(Je.inputFields)
			})
		}
		function it(Je) {
			if (!Je.fields) throw new Error(`Introspection result missing fields: ${yt(Je)}.`)
			return Yi(Je.fields, (Ve) => Ve.name, Et)
		}
		function Et(Je) {
			let Ve = u(Je.type)
			if (!bi(Ve)) {
				let Qt = yt(Ve)
				throw new Error(`Introspection must provide output type for fields, but received: ${Qt}.`)
			}
			if (!Je.args) {
				let Qt = yt(Je)
				throw new Error(`Introspection result missing field args: ${Qt}.`)
			}
			return {
				description: Je.description,
				deprecationReason: Je.deprecationReason,
				type: Ve,
				args: _t(Je.args)
			}
		}
		function _t(Je) {
			return Yi(Je, (Ve) => Ve.name, ct)
		}
		function ct(Je) {
			let Ve = u(Je.type)
			if (!Lr(Ve)) {
				let qt = yt(Ve)
				throw new Error(`Introspection must provide input type for arguments, but received: ${qt}.`)
			}
			let Qt = Je.defaultValue != null ? Ii(Xl(Je.defaultValue), Ve) : void 0
			return {
				description: Je.description,
				type: Ve,
				defaultValue: Qt,
				deprecationReason: Je.deprecationReason
			}
		}
		function St(Je) {
			if (!Je.args) {
				let Ve = yt(Je)
				throw new Error(`Introspection result missing directive args: ${Ve}.`)
			}
			if (!Je.locations) {
				let Ve = yt(Je)
				throw new Error(`Introspection result missing directive locations: ${Ve}.`)
			}
			return new Ai({
				name: Je.name,
				description: Je.description,
				isRepeatable: Je.isRepeatable,
				locations: Je.locations.slice(),
				args: _t(Je.args)
			})
		}
	}
	function ug(e, t, n) {
		var r, i, s, o
		let a = [],
			u = Object.create(null),
			h = [],
			N,
			I = []
		for (let rt of t.definitions)
			if (rt.kind === oe.SCHEMA_DEFINITION) N = rt
			else if (rt.kind === oe.SCHEMA_EXTENSION) I.push(rt)
			else if (ns(rt)) a.push(rt)
			else if (ia(rt)) {
				let Wt = rt.name.value,
					Ot = u[Wt]
				u[Wt] = Ot ? Ot.concat([rt]) : [rt]
			} else rt.kind === oe.DIRECTIVE_DEFINITION && h.push(rt)
		if (
			Object.keys(u).length === 0 &&
			a.length === 0 &&
			h.length === 0 &&
			I.length === 0 &&
			N == null
		)
			return e
		let Q = Object.create(null)
		for (let rt of e.types) Q[rt.name] = Ae(rt)
		for (let rt of a) {
			var K
			let Wt = rt.name.value
			Q[Wt] = (K = og[Wt]) !== null && K !== void 0 ? K : rr(rt)
		}
		let ue = {
			query: e.query && Pe(e.query),
			mutation: e.mutation && Pe(e.mutation),
			subscription: e.subscription && Pe(e.subscription),
			...(N && Qt([N])),
			...Qt(I)
		}
		return {
			description:
				(r = N) === null || r === void 0 || (i = r.description) === null || i === void 0
					? void 0
					: i.value,
			...ue,
			types: Object.values(Q),
			directives: [...e.directives.map(Ze), ...h.map(Te)],
			extensions: Object.create(null),
			astNode: (s = N) !== null && s !== void 0 ? s : e.astNode,
			extensionASTNodes: e.extensionASTNodes.concat(I),
			assumeValid: (o = n?.assumeValid) !== null && o !== void 0 ? o : !1
		}
		function de(rt) {
			return Zn(rt) ? new cr(de(rt.ofType)) : Nn(rt) ? new An(de(rt.ofType)) : Pe(rt)
		}
		function Pe(rt) {
			return Q[rt.name]
		}
		function Ze(rt) {
			let Wt = rt.toConfig()
			return new Ai({ ...Wt, args: Mi(Wt.args, Ve) })
		}
		function Ae(rt) {
			if (ra(rt) || lc(rt)) return rt
			if (Vr(rt)) return Et(rt)
			if (Un(rt)) return _t(rt)
			if (qn(rt)) return ct(rt)
			if (wr(rt)) return St(rt)
			if (fr(rt)) return it(rt)
			if (Yn(rt)) return ze(rt)
			xr(!1, 'Unexpected type: ' + yt(rt))
		}
		function ze(rt) {
			var Wt
			let Ot = rt.toConfig(),
				vt = (Wt = u[Ot.name]) !== null && Wt !== void 0 ? Wt : []
			return new Li({
				...Ot,
				fields: () => ({ ...Mi(Ot.fields, (He) => ({ ...He, type: de(He.type) })), ...Ct(vt) }),
				extensionASTNodes: Ot.extensionASTNodes.concat(vt)
			})
		}
		function it(rt) {
			var Wt
			let Ot = rt.toConfig(),
				vt = (Wt = u[rt.name]) !== null && Wt !== void 0 ? Wt : []
			return new Kr({
				...Ot,
				values: { ...Ot.values, ...pn(vt) },
				extensionASTNodes: Ot.extensionASTNodes.concat(vt)
			})
		}
		function Et(rt) {
			var Wt
			let Ot = rt.toConfig(),
				vt = (Wt = u[Ot.name]) !== null && Wt !== void 0 ? Wt : [],
				He = Ot.specifiedByURL
			for (let be of vt) {
				var dt
				He = (dt = ag(be)) !== null && dt !== void 0 ? dt : He
			}
			return new Xr({
				...Ot,
				specifiedByURL: He,
				extensionASTNodes: Ot.extensionASTNodes.concat(vt)
			})
		}
		function _t(rt) {
			var Wt
			let Ot = rt.toConfig(),
				vt = (Wt = u[Ot.name]) !== null && Wt !== void 0 ? Wt : []
			return new Pr({
				...Ot,
				interfaces: () => [...rt.getInterfaces().map(Pe), ...xn(vt)],
				fields: () => ({ ...Mi(Ot.fields, Je), ...Ne(vt) }),
				extensionASTNodes: Ot.extensionASTNodes.concat(vt)
			})
		}
		function ct(rt) {
			var Wt
			let Ot = rt.toConfig(),
				vt = (Wt = u[Ot.name]) !== null && Wt !== void 0 ? Wt : []
			return new ri({
				...Ot,
				interfaces: () => [...rt.getInterfaces().map(Pe), ...xn(vt)],
				fields: () => ({ ...Mi(Ot.fields, Je), ...Ne(vt) }),
				extensionASTNodes: Ot.extensionASTNodes.concat(vt)
			})
		}
		function St(rt) {
			var Wt
			let Ot = rt.toConfig(),
				vt = (Wt = u[Ot.name]) !== null && Wt !== void 0 ? Wt : []
			return new Xi({
				...Ot,
				types: () => [...rt.getTypes().map(Pe), ...zn(vt)],
				extensionASTNodes: Ot.extensionASTNodes.concat(vt)
			})
		}
		function Je(rt) {
			return { ...rt, type: de(rt.type), args: rt.args && Mi(rt.args, Ve) }
		}
		function Ve(rt) {
			return { ...rt, type: de(rt.type) }
		}
		function Qt(rt) {
			let Wt = {}
			for (let vt of rt) {
				var Ot
				let He = (Ot = vt.operationTypes) !== null && Ot !== void 0 ? Ot : []
				for (let dt of He) Wt[dt.operation] = qt(dt.type)
			}
			return Wt
		}
		function qt(rt) {
			var Wt
			let Ot = rt.name.value,
				vt = (Wt = og[Ot]) !== null && Wt !== void 0 ? Wt : Q[Ot]
			if (vt === void 0) throw new Error(`Unknown type: "${Ot}".`)
			return vt
		}
		function Bt(rt) {
			return rt.kind === oe.LIST_TYPE
				? new cr(Bt(rt.type))
				: rt.kind === oe.NON_NULL_TYPE
				? new An(Bt(rt.type))
				: qt(rt)
		}
		function Te(rt) {
			var Wt
			return new Ai({
				name: rt.name.value,
				description: (Wt = rt.description) === null || Wt === void 0 ? void 0 : Wt.value,
				locations: rt.locations.map(({ value: Ot }) => Ot),
				isRepeatable: rt.repeatable,
				args: Lt(rt.arguments),
				astNode: rt
			})
		}
		function Ne(rt) {
			let Wt = Object.create(null)
			for (let He of rt) {
				var Ot
				let dt = (Ot = He.fields) !== null && Ot !== void 0 ? Ot : []
				for (let be of dt) {
					var vt
					Wt[be.name.value] = {
						type: Bt(be.type),
						description: (vt = be.description) === null || vt === void 0 ? void 0 : vt.value,
						args: Lt(be.arguments),
						deprecationReason: Cc(be),
						astNode: be
					}
				}
			}
			return Wt
		}
		function Lt(rt) {
			let Wt = rt ?? [],
				Ot = Object.create(null)
			for (let He of Wt) {
				var vt
				let dt = Bt(He.type)
				Ot[He.name.value] = {
					type: dt,
					description: (vt = He.description) === null || vt === void 0 ? void 0 : vt.value,
					defaultValue: Ii(He.defaultValue, dt),
					deprecationReason: Cc(He),
					astNode: He
				}
			}
			return Ot
		}
		function Ct(rt) {
			let Wt = Object.create(null)
			for (let He of rt) {
				var Ot
				let dt = (Ot = He.fields) !== null && Ot !== void 0 ? Ot : []
				for (let be of dt) {
					var vt
					let tt = Bt(be.type)
					Wt[be.name.value] = {
						type: tt,
						description: (vt = be.description) === null || vt === void 0 ? void 0 : vt.value,
						defaultValue: Ii(be.defaultValue, tt),
						deprecationReason: Cc(be),
						astNode: be
					}
				}
			}
			return Wt
		}
		function pn(rt) {
			let Wt = Object.create(null)
			for (let He of rt) {
				var Ot
				let dt = (Ot = He.values) !== null && Ot !== void 0 ? Ot : []
				for (let be of dt) {
					var vt
					Wt[be.name.value] = {
						description: (vt = be.description) === null || vt === void 0 ? void 0 : vt.value,
						deprecationReason: Cc(be),
						astNode: be
					}
				}
			}
			return Wt
		}
		function xn(rt) {
			return rt.flatMap((Wt) => {
				var Ot, vt
				return (Ot = (vt = Wt.interfaces) === null || vt === void 0 ? void 0 : vt.map(qt)) !==
					null && Ot !== void 0
					? Ot
					: []
			})
		}
		function zn(rt) {
			return rt.flatMap((Wt) => {
				var Ot, vt
				return (Ot = (vt = Wt.types) === null || vt === void 0 ? void 0 : vt.map(qt)) !== null &&
					Ot !== void 0
					? Ot
					: []
			})
		}
		function rr(rt) {
			var Wt
			let Ot = rt.name.value,
				vt = (Wt = u[Ot]) !== null && Wt !== void 0 ? Wt : []
			switch (rt.kind) {
				case oe.OBJECT_TYPE_DEFINITION: {
					var He
					let Nt = [rt, ...vt]
					return new Pr({
						name: Ot,
						description: (He = rt.description) === null || He === void 0 ? void 0 : He.value,
						interfaces: () => xn(Nt),
						fields: () => Ne(Nt),
						astNode: rt,
						extensionASTNodes: vt
					})
				}
				case oe.INTERFACE_TYPE_DEFINITION: {
					var dt
					let Nt = [rt, ...vt]
					return new ri({
						name: Ot,
						description: (dt = rt.description) === null || dt === void 0 ? void 0 : dt.value,
						interfaces: () => xn(Nt),
						fields: () => Ne(Nt),
						astNode: rt,
						extensionASTNodes: vt
					})
				}
				case oe.ENUM_TYPE_DEFINITION: {
					var be
					let Nt = [rt, ...vt]
					return new Kr({
						name: Ot,
						description: (be = rt.description) === null || be === void 0 ? void 0 : be.value,
						values: pn(Nt),
						astNode: rt,
						extensionASTNodes: vt
					})
				}
				case oe.UNION_TYPE_DEFINITION: {
					var tt
					let Nt = [rt, ...vt]
					return new Xi({
						name: Ot,
						description: (tt = rt.description) === null || tt === void 0 ? void 0 : tt.value,
						types: () => zn(Nt),
						astNode: rt,
						extensionASTNodes: vt
					})
				}
				case oe.SCALAR_TYPE_DEFINITION: {
					var Ee
					return new Xr({
						name: Ot,
						description: (Ee = rt.description) === null || Ee === void 0 ? void 0 : Ee.value,
						specifiedByURL: ag(rt),
						astNode: rt,
						extensionASTNodes: vt
					})
				}
				case oe.INPUT_OBJECT_TYPE_DEFINITION: {
					var xt
					let Nt = [rt, ...vt]
					return new Li({
						name: Ot,
						description: (xt = rt.description) === null || xt === void 0 ? void 0 : xt.value,
						fields: () => Ct(Nt),
						astNode: rt,
						extensionASTNodes: vt
					})
				}
			}
		}
	}
	var og = vi([...fs, ...ds], (e) => e.name)
	function Cc(e) {
		let t = ca(ea, e)
		return t?.reason
	}
	function ag(e) {
		let t = ca(fc, e)
		return t?.url
	}
	function Au(e, t) {
		;(e != null && e.kind === oe.DOCUMENT) || On(!1, 'Must provide valid Document AST.'),
			t?.assumeValid !== !0 && t?.assumeValidSDL !== !0 && sg(e)
		let r = ug(
			{
				description: void 0,
				types: [],
				directives: [],
				extensions: Object.create(null),
				extensionASTNodes: [],
				assumeValid: !1
			},
			e,
			t
		)
		if (r.astNode == null)
			for (let s of r.types)
				switch (s.name) {
					case 'Query':
						r.query = s
						break
					case 'Mutation':
						r.mutation = s
						break
					case 'Subscription':
						r.subscription = s
						break
				}
		let i = [...r.directives, ...Ci.filter((s) => r.directives.every((o) => o.name !== s.name))]
		return new Os({ ...r, directives: i })
	}
	function md(e) {
		let t
		return (
			gd(e, (n) => {
				switch (n.kind) {
					case 'Query':
					case 'ShortQuery':
					case 'Mutation':
					case 'Subscription':
					case 'FragmentDefinition':
						t = n
						break
				}
			}),
			t
		)
	}
	function Sc(e, t, n) {
		return n === Zi.name && e.getQueryType() === t
			? Zi
			: n === es.name && e.getQueryType() === t
			? es
			: n === ts.name && gr(t)
			? ts
			: 'getFields' in t
			? t.getFields()[n]
			: null
	}
	function gd(e, t) {
		let n = [],
			r = e
		for (; r?.kind; ) n.push(r), (r = r.prevState)
		for (let i = n.length - 1; i >= 0; i--) t(n[i])
	}
	function Bs(e) {
		let t = Object.keys(e),
			n = t.length,
			r = new Array(n)
		for (let i = 0; i < n; ++i) r[i] = e[t[i]]
		return r
	}
	function Dr(e, t) {
		return Tb(t, lg(e.string))
	}
	function Tb(e, t) {
		if (!t) return hd(e, (r) => !r.isDeprecated)
		let n = e.map((r) => ({ proximity: Ab(lg(r.label), t), entry: r }))
		return hd(
			hd(n, (r) => r.proximity <= 2),
			(r) => !r.entry.isDeprecated
		)
			.sort(
				(r, i) =>
					(r.entry.isDeprecated ? 1 : 0) - (i.entry.isDeprecated ? 1 : 0) ||
					r.proximity - i.proximity ||
					r.entry.label.length - i.entry.label.length
			)
			.map((r) => r.entry)
	}
	function hd(e, t) {
		let n = e.filter(t)
		return n.length === 0 ? e : n
	}
	function lg(e) {
		return e.toLowerCase().replaceAll(/\W/g, '')
	}
	function Ab(e, t) {
		let n = Cb(t, e)
		return (
			e.length > t.length && ((n -= e.length - t.length - 1), (n += e.indexOf(t) === 0 ? 0 : 0.5)),
			n
		)
	}
	function Cb(e, t) {
		let n,
			r,
			i = [],
			s = e.length,
			o = t.length
		for (n = 0; n <= s; n++) i[n] = [n]
		for (r = 1; r <= o; r++) i[0][r] = r
		for (n = 1; n <= s; n++)
			for (r = 1; r <= o; r++) {
				let a = e[n - 1] === t[r - 1] ? 0 : 1
				;(i[n][r] = Math.min(i[n - 1][r] + 1, i[n][r - 1] + 1, i[n - 1][r - 1] + a)),
					n > 1 &&
						r > 1 &&
						e[n - 1] === t[r - 2] &&
						e[n - 2] === t[r - 1] &&
						(i[n][r] = Math.min(i[n][r], i[n - 2][r - 2] + a))
			}
		return i[s][o]
	}
	var cg
	;(function (e) {
		function t(n) {
			return typeof n == 'string'
		}
		e.is = t
	})(cg || (cg = {}))
	var Dd
	;(function (e) {
		function t(n) {
			return typeof n == 'string'
		}
		e.is = t
	})(Dd || (Dd = {}))
	var pg
	;(function (e) {
		;(e.MIN_VALUE = -2147483648), (e.MAX_VALUE = 2147483647)
		function t(n) {
			return typeof n == 'number' && e.MIN_VALUE <= n && n <= e.MAX_VALUE
		}
		e.is = t
	})(pg || (pg = {}))
	var Nc
	;(function (e) {
		;(e.MIN_VALUE = 0), (e.MAX_VALUE = 2147483647)
		function t(n) {
			return typeof n == 'number' && e.MIN_VALUE <= n && n <= e.MAX_VALUE
		}
		e.is = t
	})(Nc || (Nc = {}))
	var Vi
	;(function (e) {
		function t(r, i) {
			return (
				r === Number.MAX_VALUE && (r = Nc.MAX_VALUE),
				i === Number.MAX_VALUE && (i = Nc.MAX_VALUE),
				{ line: r, character: i }
			)
		}
		e.create = t
		function n(r) {
			let i = r
			return Qe.objectLiteral(i) && Qe.uinteger(i.line) && Qe.uinteger(i.character)
		}
		e.is = n
	})(Vi || (Vi = {}))
	var Ir
	;(function (e) {
		function t(r, i, s, o) {
			if (Qe.uinteger(r) && Qe.uinteger(i) && Qe.uinteger(s) && Qe.uinteger(o))
				return { start: Vi.create(r, i), end: Vi.create(s, o) }
			if (Vi.is(r) && Vi.is(i)) return { start: r, end: i }
			throw new Error(`Range#create called with invalid arguments[${r}, ${i}, ${s}, ${o}]`)
		}
		e.create = t
		function n(r) {
			let i = r
			return Qe.objectLiteral(i) && Vi.is(i.start) && Vi.is(i.end)
		}
		e.is = n
	})(Ir || (Ir = {}))
	var Fc
	;(function (e) {
		function t(r, i) {
			return { uri: r, range: i }
		}
		e.create = t
		function n(r) {
			let i = r
			return Qe.objectLiteral(i) && Ir.is(i.range) && (Qe.string(i.uri) || Qe.undefined(i.uri))
		}
		e.is = n
	})(Fc || (Fc = {}))
	var fg
	;(function (e) {
		function t(r, i, s, o) {
			return { targetUri: r, targetRange: i, targetSelectionRange: s, originSelectionRange: o }
		}
		e.create = t
		function n(r) {
			let i = r
			return (
				Qe.objectLiteral(i) &&
				Ir.is(i.targetRange) &&
				Qe.string(i.targetUri) &&
				Ir.is(i.targetSelectionRange) &&
				(Ir.is(i.originSelectionRange) || Qe.undefined(i.originSelectionRange))
			)
		}
		e.is = n
	})(fg || (fg = {}))
	var yd
	;(function (e) {
		function t(r, i, s, o) {
			return { red: r, green: i, blue: s, alpha: o }
		}
		e.create = t
		function n(r) {
			let i = r
			return (
				Qe.objectLiteral(i) &&
				Qe.numberRange(i.red, 0, 1) &&
				Qe.numberRange(i.green, 0, 1) &&
				Qe.numberRange(i.blue, 0, 1) &&
				Qe.numberRange(i.alpha, 0, 1)
			)
		}
		e.is = n
	})(yd || (yd = {}))
	var dg
	;(function (e) {
		function t(r, i) {
			return { range: r, color: i }
		}
		e.create = t
		function n(r) {
			let i = r
			return Qe.objectLiteral(i) && Ir.is(i.range) && yd.is(i.color)
		}
		e.is = n
	})(dg || (dg = {}))
	var hg
	;(function (e) {
		function t(r, i, s) {
			return { label: r, textEdit: i, additionalTextEdits: s }
		}
		e.create = t
		function n(r) {
			let i = r
			return (
				Qe.objectLiteral(i) &&
				Qe.string(i.label) &&
				(Qe.undefined(i.textEdit) || va.is(i)) &&
				(Qe.undefined(i.additionalTextEdits) || Qe.typedArray(i.additionalTextEdits, va.is))
			)
		}
		e.is = n
	})(hg || (hg = {}))
	var mg
	;(function (e) {
		;(e.Comment = 'comment'), (e.Imports = 'imports'), (e.Region = 'region')
	})(mg || (mg = {}))
	var gg
	;(function (e) {
		function t(r, i, s, o, a, u) {
			let h = { startLine: r, endLine: i }
			return (
				Qe.defined(s) && (h.startCharacter = s),
				Qe.defined(o) && (h.endCharacter = o),
				Qe.defined(a) && (h.kind = a),
				Qe.defined(u) && (h.collapsedText = u),
				h
			)
		}
		e.create = t
		function n(r) {
			let i = r
			return (
				Qe.objectLiteral(i) &&
				Qe.uinteger(i.startLine) &&
				Qe.uinteger(i.startLine) &&
				(Qe.undefined(i.startCharacter) || Qe.uinteger(i.startCharacter)) &&
				(Qe.undefined(i.endCharacter) || Qe.uinteger(i.endCharacter)) &&
				(Qe.undefined(i.kind) || Qe.string(i.kind))
			)
		}
		e.is = n
	})(gg || (gg = {}))
	var Ed
	;(function (e) {
		function t(r, i) {
			return { location: r, message: i }
		}
		e.create = t
		function n(r) {
			let i = r
			return Qe.defined(i) && Fc.is(i.location) && Qe.string(i.message)
		}
		e.is = n
	})(Ed || (Ed = {}))
	var Dg
	;(function (e) {
		;(e.Error = 1), (e.Warning = 2), (e.Information = 3), (e.Hint = 4)
	})(Dg || (Dg = {}))
	var yg
	;(function (e) {
		;(e.Unnecessary = 1), (e.Deprecated = 2)
	})(yg || (yg = {}))
	var Eg
	;(function (e) {
		function t(n) {
			let r = n
			return Qe.objectLiteral(r) && Qe.string(r.href)
		}
		e.is = t
	})(Eg || (Eg = {}))
	var _c
	;(function (e) {
		function t(r, i, s, o, a, u) {
			let h = { range: r, message: i }
			return (
				Qe.defined(s) && (h.severity = s),
				Qe.defined(o) && (h.code = o),
				Qe.defined(a) && (h.source = a),
				Qe.defined(u) && (h.relatedInformation = u),
				h
			)
		}
		e.create = t
		function n(r) {
			var i
			let s = r
			return (
				Qe.defined(s) &&
				Ir.is(s.range) &&
				Qe.string(s.message) &&
				(Qe.number(s.severity) || Qe.undefined(s.severity)) &&
				(Qe.integer(s.code) || Qe.string(s.code) || Qe.undefined(s.code)) &&
				(Qe.undefined(s.codeDescription) ||
					Qe.string((i = s.codeDescription) === null || i === void 0 ? void 0 : i.href)) &&
				(Qe.string(s.source) || Qe.undefined(s.source)) &&
				(Qe.undefined(s.relatedInformation) || Qe.typedArray(s.relatedInformation, Ed.is))
			)
		}
		e.is = n
	})(_c || (_c = {}))
	var Ea
	;(function (e) {
		function t(r, i, ...s) {
			let o = { title: r, command: i }
			return Qe.defined(s) && s.length > 0 && (o.arguments = s), o
		}
		e.create = t
		function n(r) {
			let i = r
			return Qe.defined(i) && Qe.string(i.title) && Qe.string(i.command)
		}
		e.is = n
	})(Ea || (Ea = {}))
	var va
	;(function (e) {
		function t(s, o) {
			return { range: s, newText: o }
		}
		e.replace = t
		function n(s, o) {
			return { range: { start: s, end: s }, newText: o }
		}
		e.insert = n
		function r(s) {
			return { range: s, newText: '' }
		}
		e.del = r
		function i(s) {
			let o = s
			return Qe.objectLiteral(o) && Qe.string(o.newText) && Ir.is(o.range)
		}
		e.is = i
	})(va || (va = {}))
	var vd
	;(function (e) {
		function t(r, i, s) {
			let o = { label: r }
			return i !== void 0 && (o.needsConfirmation = i), s !== void 0 && (o.description = s), o
		}
		e.create = t
		function n(r) {
			let i = r
			return (
				Qe.objectLiteral(i) &&
				Qe.string(i.label) &&
				(Qe.boolean(i.needsConfirmation) || i.needsConfirmation === void 0) &&
				(Qe.string(i.description) || i.description === void 0)
			)
		}
		e.is = n
	})(vd || (vd = {}))
	var xa
	;(function (e) {
		function t(n) {
			let r = n
			return Qe.string(r)
		}
		e.is = t
	})(xa || (xa = {}))
	var vg
	;(function (e) {
		function t(s, o, a) {
			return { range: s, newText: o, annotationId: a }
		}
		e.replace = t
		function n(s, o, a) {
			return { range: { start: s, end: s }, newText: o, annotationId: a }
		}
		e.insert = n
		function r(s, o) {
			return { range: s, newText: '', annotationId: o }
		}
		e.del = r
		function i(s) {
			let o = s
			return va.is(o) && (vd.is(o.annotationId) || xa.is(o.annotationId))
		}
		e.is = i
	})(vg || (vg = {}))
	var xd
	;(function (e) {
		function t(r, i) {
			return { textDocument: r, edits: i }
		}
		e.create = t
		function n(r) {
			let i = r
			return Qe.defined(i) && Sd.is(i.textDocument) && Array.isArray(i.edits)
		}
		e.is = n
	})(xd || (xd = {}))
	var bd
	;(function (e) {
		function t(r, i, s) {
			let o = { kind: 'create', uri: r }
			return (
				i !== void 0 && (i.overwrite !== void 0 || i.ignoreIfExists !== void 0) && (o.options = i),
				s !== void 0 && (o.annotationId = s),
				o
			)
		}
		e.create = t
		function n(r) {
			let i = r
			return (
				i &&
				i.kind === 'create' &&
				Qe.string(i.uri) &&
				(i.options === void 0 ||
					((i.options.overwrite === void 0 || Qe.boolean(i.options.overwrite)) &&
						(i.options.ignoreIfExists === void 0 || Qe.boolean(i.options.ignoreIfExists)))) &&
				(i.annotationId === void 0 || xa.is(i.annotationId))
			)
		}
		e.is = n
	})(bd || (bd = {}))
	var Td
	;(function (e) {
		function t(r, i, s, o) {
			let a = { kind: 'rename', oldUri: r, newUri: i }
			return (
				s !== void 0 && (s.overwrite !== void 0 || s.ignoreIfExists !== void 0) && (a.options = s),
				o !== void 0 && (a.annotationId = o),
				a
			)
		}
		e.create = t
		function n(r) {
			let i = r
			return (
				i &&
				i.kind === 'rename' &&
				Qe.string(i.oldUri) &&
				Qe.string(i.newUri) &&
				(i.options === void 0 ||
					((i.options.overwrite === void 0 || Qe.boolean(i.options.overwrite)) &&
						(i.options.ignoreIfExists === void 0 || Qe.boolean(i.options.ignoreIfExists)))) &&
				(i.annotationId === void 0 || xa.is(i.annotationId))
			)
		}
		e.is = n
	})(Td || (Td = {}))
	var Ad
	;(function (e) {
		function t(r, i, s) {
			let o = { kind: 'delete', uri: r }
			return (
				i !== void 0 &&
					(i.recursive !== void 0 || i.ignoreIfNotExists !== void 0) &&
					(o.options = i),
				s !== void 0 && (o.annotationId = s),
				o
			)
		}
		e.create = t
		function n(r) {
			let i = r
			return (
				i &&
				i.kind === 'delete' &&
				Qe.string(i.uri) &&
				(i.options === void 0 ||
					((i.options.recursive === void 0 || Qe.boolean(i.options.recursive)) &&
						(i.options.ignoreIfNotExists === void 0 || Qe.boolean(i.options.ignoreIfNotExists)))) &&
				(i.annotationId === void 0 || xa.is(i.annotationId))
			)
		}
		e.is = n
	})(Ad || (Ad = {}))
	var Cd
	;(function (e) {
		function t(n) {
			let r = n
			return (
				r &&
				(r.changes !== void 0 || r.documentChanges !== void 0) &&
				(r.documentChanges === void 0 ||
					r.documentChanges.every((i) =>
						Qe.string(i.kind) ? bd.is(i) || Td.is(i) || Ad.is(i) : xd.is(i)
					))
			)
		}
		e.is = t
	})(Cd || (Cd = {}))
	var xg
	;(function (e) {
		function t(r) {
			return { uri: r }
		}
		e.create = t
		function n(r) {
			let i = r
			return Qe.defined(i) && Qe.string(i.uri)
		}
		e.is = n
	})(xg || (xg = {}))
	var bg
	;(function (e) {
		function t(r, i) {
			return { uri: r, version: i }
		}
		e.create = t
		function n(r) {
			let i = r
			return Qe.defined(i) && Qe.string(i.uri) && Qe.integer(i.version)
		}
		e.is = n
	})(bg || (bg = {}))
	var Sd
	;(function (e) {
		function t(r, i) {
			return { uri: r, version: i }
		}
		e.create = t
		function n(r) {
			let i = r
			return Qe.defined(i) && Qe.string(i.uri) && (i.version === null || Qe.integer(i.version))
		}
		e.is = n
	})(Sd || (Sd = {}))
	var Tg
	;(function (e) {
		function t(r, i, s, o) {
			return { uri: r, languageId: i, version: s, text: o }
		}
		e.create = t
		function n(r) {
			let i = r
			return (
				Qe.defined(i) &&
				Qe.string(i.uri) &&
				Qe.string(i.languageId) &&
				Qe.integer(i.version) &&
				Qe.string(i.text)
			)
		}
		e.is = n
	})(Tg || (Tg = {}))
	var Nd
	;(function (e) {
		;(e.PlainText = 'plaintext'), (e.Markdown = 'markdown')
		function t(n) {
			let r = n
			return r === e.PlainText || r === e.Markdown
		}
		e.is = t
	})(Nd || (Nd = {}))
	var Cu
	;(function (e) {
		function t(n) {
			let r = n
			return Qe.objectLiteral(n) && Nd.is(r.kind) && Qe.string(r.value)
		}
		e.is = t
	})(Cu || (Cu = {}))
	var Ag
	;(function (e) {
		;(e.Text = 1),
			(e.Method = 2),
			(e.Function = 3),
			(e.Constructor = 4),
			(e.Field = 5),
			(e.Variable = 6),
			(e.Class = 7),
			(e.Interface = 8),
			(e.Module = 9),
			(e.Property = 10),
			(e.Unit = 11),
			(e.Value = 12),
			(e.Enum = 13),
			(e.Keyword = 14),
			(e.Snippet = 15),
			(e.Color = 16),
			(e.File = 17),
			(e.Reference = 18),
			(e.Folder = 19),
			(e.EnumMember = 20),
			(e.Constant = 21),
			(e.Struct = 22),
			(e.Event = 23),
			(e.Operator = 24),
			(e.TypeParameter = 25)
	})(Ag || (Ag = {}))
	var Su
	;(function (e) {
		;(e.PlainText = 1), (e.Snippet = 2)
	})(Su || (Su = {}))
	var Cg
	;(function (e) {
		e.Deprecated = 1
	})(Cg || (Cg = {}))
	var Sg
	;(function (e) {
		function t(r, i, s) {
			return { newText: r, insert: i, replace: s }
		}
		e.create = t
		function n(r) {
			let i = r
			return i && Qe.string(i.newText) && Ir.is(i.insert) && Ir.is(i.replace)
		}
		e.is = n
	})(Sg || (Sg = {}))
	var Ng
	;(function (e) {
		;(e.asIs = 1), (e.adjustIndentation = 2)
	})(Ng || (Ng = {}))
	var Fg
	;(function (e) {
		function t(n) {
			let r = n
			return (
				r &&
				(Qe.string(r.detail) || r.detail === void 0) &&
				(Qe.string(r.description) || r.description === void 0)
			)
		}
		e.is = t
	})(Fg || (Fg = {}))
	var _g
	;(function (e) {
		function t(n) {
			return { label: n }
		}
		e.create = t
	})(_g || (_g = {}))
	var wg
	;(function (e) {
		function t(n, r) {
			return { items: n || [], isIncomplete: !!r }
		}
		e.create = t
	})(wg || (wg = {}))
	var wc
	;(function (e) {
		function t(r) {
			return r.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&')
		}
		e.fromPlainText = t
		function n(r) {
			let i = r
			return Qe.string(i) || (Qe.objectLiteral(i) && Qe.string(i.language) && Qe.string(i.value))
		}
		e.is = n
	})(wc || (wc = {}))
	var Lg
	;(function (e) {
		function t(n) {
			let r = n
			return (
				!!r &&
				Qe.objectLiteral(r) &&
				(Cu.is(r.contents) || wc.is(r.contents) || Qe.typedArray(r.contents, wc.is)) &&
				(n.range === void 0 || Ir.is(n.range))
			)
		}
		e.is = t
	})(Lg || (Lg = {}))
	var Ig
	;(function (e) {
		function t(n, r) {
			return r ? { label: n, documentation: r } : { label: n }
		}
		e.create = t
	})(Ig || (Ig = {}))
	var kg
	;(function (e) {
		function t(n, r, ...i) {
			let s = { label: n }
			return (
				Qe.defined(r) && (s.documentation = r),
				Qe.defined(i) ? (s.parameters = i) : (s.parameters = []),
				s
			)
		}
		e.create = t
	})(kg || (kg = {}))
	var Rg
	;(function (e) {
		;(e.Text = 1), (e.Read = 2), (e.Write = 3)
	})(Rg || (Rg = {}))
	var Og
	;(function (e) {
		function t(n, r) {
			let i = { range: n }
			return Qe.number(r) && (i.kind = r), i
		}
		e.create = t
	})(Og || (Og = {}))
	var Bg
	;(function (e) {
		;(e.File = 1),
			(e.Module = 2),
			(e.Namespace = 3),
			(e.Package = 4),
			(e.Class = 5),
			(e.Method = 6),
			(e.Property = 7),
			(e.Field = 8),
			(e.Constructor = 9),
			(e.Enum = 10),
			(e.Interface = 11),
			(e.Function = 12),
			(e.Variable = 13),
			(e.Constant = 14),
			(e.String = 15),
			(e.Number = 16),
			(e.Boolean = 17),
			(e.Array = 18),
			(e.Object = 19),
			(e.Key = 20),
			(e.Null = 21),
			(e.EnumMember = 22),
			(e.Struct = 23),
			(e.Event = 24),
			(e.Operator = 25),
			(e.TypeParameter = 26)
	})(Bg || (Bg = {}))
	var Pg
	;(function (e) {
		e.Deprecated = 1
	})(Pg || (Pg = {}))
	var Mg
	;(function (e) {
		function t(n, r, i, s, o) {
			let a = { name: n, kind: r, location: { uri: s, range: i } }
			return o && (a.containerName = o), a
		}
		e.create = t
	})(Mg || (Mg = {}))
	var jg
	;(function (e) {
		function t(n, r, i, s) {
			return s !== void 0
				? { name: n, kind: r, location: { uri: i, range: s } }
				: { name: n, kind: r, location: { uri: i } }
		}
		e.create = t
	})(jg || (jg = {}))
	var $g
	;(function (e) {
		function t(r, i, s, o, a, u) {
			let h = { name: r, detail: i, kind: s, range: o, selectionRange: a }
			return u !== void 0 && (h.children = u), h
		}
		e.create = t
		function n(r) {
			let i = r
			return (
				i &&
				Qe.string(i.name) &&
				Qe.number(i.kind) &&
				Ir.is(i.range) &&
				Ir.is(i.selectionRange) &&
				(i.detail === void 0 || Qe.string(i.detail)) &&
				(i.deprecated === void 0 || Qe.boolean(i.deprecated)) &&
				(i.children === void 0 || Array.isArray(i.children)) &&
				(i.tags === void 0 || Array.isArray(i.tags))
			)
		}
		e.is = n
	})($g || ($g = {}))
	var Vg
	;(function (e) {
		;(e.Empty = ''),
			(e.QuickFix = 'quickfix'),
			(e.Refactor = 'refactor'),
			(e.RefactorExtract = 'refactor.extract'),
			(e.RefactorInline = 'refactor.inline'),
			(e.RefactorRewrite = 'refactor.rewrite'),
			(e.Source = 'source'),
			(e.SourceOrganizeImports = 'source.organizeImports'),
			(e.SourceFixAll = 'source.fixAll')
	})(Vg || (Vg = {}))
	var Lc
	;(function (e) {
		;(e.Invoked = 1), (e.Automatic = 2)
	})(Lc || (Lc = {}))
	var Ug
	;(function (e) {
		function t(r, i, s) {
			let o = { diagnostics: r }
			return i != null && (o.only = i), s != null && (o.triggerKind = s), o
		}
		e.create = t
		function n(r) {
			let i = r
			return (
				Qe.defined(i) &&
				Qe.typedArray(i.diagnostics, _c.is) &&
				(i.only === void 0 || Qe.typedArray(i.only, Qe.string)) &&
				(i.triggerKind === void 0 || i.triggerKind === Lc.Invoked || i.triggerKind === Lc.Automatic)
			)
		}
		e.is = n
	})(Ug || (Ug = {}))
	var qg
	;(function (e) {
		function t(r, i, s) {
			let o = { title: r },
				a = !0
			return (
				typeof i == 'string' ? ((a = !1), (o.kind = i)) : Ea.is(i) ? (o.command = i) : (o.edit = i),
				a && s !== void 0 && (o.kind = s),
				o
			)
		}
		e.create = t
		function n(r) {
			let i = r
			return (
				i &&
				Qe.string(i.title) &&
				(i.diagnostics === void 0 || Qe.typedArray(i.diagnostics, _c.is)) &&
				(i.kind === void 0 || Qe.string(i.kind)) &&
				(i.edit !== void 0 || i.command !== void 0) &&
				(i.command === void 0 || Ea.is(i.command)) &&
				(i.isPreferred === void 0 || Qe.boolean(i.isPreferred)) &&
				(i.edit === void 0 || Cd.is(i.edit))
			)
		}
		e.is = n
	})(qg || (qg = {}))
	var Gg
	;(function (e) {
		function t(r, i) {
			let s = { range: r }
			return Qe.defined(i) && (s.data = i), s
		}
		e.create = t
		function n(r) {
			let i = r
			return Qe.defined(i) && Ir.is(i.range) && (Qe.undefined(i.command) || Ea.is(i.command))
		}
		e.is = n
	})(Gg || (Gg = {}))
	var Wg
	;(function (e) {
		function t(r, i) {
			return { tabSize: r, insertSpaces: i }
		}
		e.create = t
		function n(r) {
			let i = r
			return Qe.defined(i) && Qe.uinteger(i.tabSize) && Qe.boolean(i.insertSpaces)
		}
		e.is = n
	})(Wg || (Wg = {}))
	var Hg
	;(function (e) {
		function t(r, i, s) {
			return { range: r, target: i, data: s }
		}
		e.create = t
		function n(r) {
			let i = r
			return Qe.defined(i) && Ir.is(i.range) && (Qe.undefined(i.target) || Qe.string(i.target))
		}
		e.is = n
	})(Hg || (Hg = {}))
	var Jg
	;(function (e) {
		function t(r, i) {
			return { range: r, parent: i }
		}
		e.create = t
		function n(r) {
			let i = r
			return Qe.objectLiteral(i) && Ir.is(i.range) && (i.parent === void 0 || e.is(i.parent))
		}
		e.is = n
	})(Jg || (Jg = {}))
	var zg
	;(function (e) {
		;(e.namespace = 'namespace'),
			(e.type = 'type'),
			(e.class = 'class'),
			(e.enum = 'enum'),
			(e.interface = 'interface'),
			(e.struct = 'struct'),
			(e.typeParameter = 'typeParameter'),
			(e.parameter = 'parameter'),
			(e.variable = 'variable'),
			(e.property = 'property'),
			(e.enumMember = 'enumMember'),
			(e.event = 'event'),
			(e.function = 'function'),
			(e.method = 'method'),
			(e.macro = 'macro'),
			(e.keyword = 'keyword'),
			(e.modifier = 'modifier'),
			(e.comment = 'comment'),
			(e.string = 'string'),
			(e.number = 'number'),
			(e.regexp = 'regexp'),
			(e.operator = 'operator'),
			(e.decorator = 'decorator')
	})(zg || (zg = {}))
	var Qg
	;(function (e) {
		;(e.declaration = 'declaration'),
			(e.definition = 'definition'),
			(e.readonly = 'readonly'),
			(e.static = 'static'),
			(e.deprecated = 'deprecated'),
			(e.abstract = 'abstract'),
			(e.async = 'async'),
			(e.modification = 'modification'),
			(e.documentation = 'documentation'),
			(e.defaultLibrary = 'defaultLibrary')
	})(Qg || (Qg = {}))
	var Yg
	;(function (e) {
		function t(n) {
			let r = n
			return (
				Qe.objectLiteral(r) &&
				(r.resultId === void 0 || typeof r.resultId == 'string') &&
				Array.isArray(r.data) &&
				(r.data.length === 0 || typeof r.data[0] == 'number')
			)
		}
		e.is = t
	})(Yg || (Yg = {}))
	var Xg
	;(function (e) {
		function t(r, i) {
			return { range: r, text: i }
		}
		e.create = t
		function n(r) {
			let i = r
			return i != null && Ir.is(i.range) && Qe.string(i.text)
		}
		e.is = n
	})(Xg || (Xg = {}))
	var Kg
	;(function (e) {
		function t(r, i, s) {
			return { range: r, variableName: i, caseSensitiveLookup: s }
		}
		e.create = t
		function n(r) {
			let i = r
			return (
				i != null &&
				Ir.is(i.range) &&
				Qe.boolean(i.caseSensitiveLookup) &&
				(Qe.string(i.variableName) || i.variableName === void 0)
			)
		}
		e.is = n
	})(Kg || (Kg = {}))
	var Zg
	;(function (e) {
		function t(r, i) {
			return { range: r, expression: i }
		}
		e.create = t
		function n(r) {
			let i = r
			return i != null && Ir.is(i.range) && (Qe.string(i.expression) || i.expression === void 0)
		}
		e.is = n
	})(Zg || (Zg = {}))
	var e2
	;(function (e) {
		function t(r, i) {
			return { frameId: r, stoppedLocation: i }
		}
		e.create = t
		function n(r) {
			let i = r
			return Qe.defined(i) && Ir.is(r.stoppedLocation)
		}
		e.is = n
	})(e2 || (e2 = {}))
	var Fd
	;(function (e) {
		;(e.Type = 1), (e.Parameter = 2)
		function t(n) {
			return n === 1 || n === 2
		}
		e.is = t
	})(Fd || (Fd = {}))
	var _d
	;(function (e) {
		function t(r) {
			return { value: r }
		}
		e.create = t
		function n(r) {
			let i = r
			return (
				Qe.objectLiteral(i) &&
				(i.tooltip === void 0 || Qe.string(i.tooltip) || Cu.is(i.tooltip)) &&
				(i.location === void 0 || Fc.is(i.location)) &&
				(i.command === void 0 || Ea.is(i.command))
			)
		}
		e.is = n
	})(_d || (_d = {}))
	var t2
	;(function (e) {
		function t(r, i, s) {
			let o = { position: r, label: i }
			return s !== void 0 && (o.kind = s), o
		}
		e.create = t
		function n(r) {
			let i = r
			return (
				(Qe.objectLiteral(i) &&
					Vi.is(i.position) &&
					(Qe.string(i.label) || Qe.typedArray(i.label, _d.is)) &&
					(i.kind === void 0 || Fd.is(i.kind)) &&
					i.textEdits === void 0) ||
				(Qe.typedArray(i.textEdits, va.is) &&
					(i.tooltip === void 0 || Qe.string(i.tooltip) || Cu.is(i.tooltip)) &&
					(i.paddingLeft === void 0 || Qe.boolean(i.paddingLeft)) &&
					(i.paddingRight === void 0 || Qe.boolean(i.paddingRight)))
			)
		}
		e.is = n
	})(t2 || (t2 = {}))
	var n2
	;(function (e) {
		function t(n) {
			return { kind: 'snippet', value: n }
		}
		e.createSnippet = t
	})(n2 || (n2 = {}))
	var r2
	;(function (e) {
		function t(n, r, i, s) {
			return { insertText: n, filterText: r, range: i, command: s }
		}
		e.create = t
	})(r2 || (r2 = {}))
	var i2
	;(function (e) {
		function t(n) {
			return { items: n }
		}
		e.create = t
	})(i2 || (i2 = {}))
	var s2
	;(function (e) {
		;(e.Invoked = 0), (e.Automatic = 1)
	})(s2 || (s2 = {}))
	var o2
	;(function (e) {
		function t(n, r) {
			return { range: n, text: r }
		}
		e.create = t
	})(o2 || (o2 = {}))
	var a2
	;(function (e) {
		function t(n, r) {
			return { triggerKind: n, selectedCompletionInfo: r }
		}
		e.create = t
	})(a2 || (a2 = {}))
	var u2
	;(function (e) {
		function t(n) {
			let r = n
			return Qe.objectLiteral(r) && Dd.is(r.uri) && Qe.string(r.name)
		}
		e.is = t
	})(u2 || (u2 = {}))
	var l2
	;(function (e) {
		function t(s, o, a, u) {
			return new wd(s, o, a, u)
		}
		e.create = t
		function n(s) {
			let o = s
			return !!(
				Qe.defined(o) &&
				Qe.string(o.uri) &&
				(Qe.undefined(o.languageId) || Qe.string(o.languageId)) &&
				Qe.uinteger(o.lineCount) &&
				Qe.func(o.getText) &&
				Qe.func(o.positionAt) &&
				Qe.func(o.offsetAt)
			)
		}
		e.is = n
		function r(s, o) {
			let a = s.getText(),
				u = i(o, (N, I) => {
					let Q = N.range.start.line - I.range.start.line
					return Q === 0 ? N.range.start.character - I.range.start.character : Q
				}),
				h = a.length
			for (let N = u.length - 1; N >= 0; N--) {
				let I = u[N],
					Q = s.offsetAt(I.range.start),
					K = s.offsetAt(I.range.end)
				if (K <= h) a = a.substring(0, Q) + I.newText + a.substring(K, a.length)
				else throw new Error('Overlapping edit')
				h = Q
			}
			return a
		}
		e.applyEdits = r
		function i(s, o) {
			if (s.length <= 1) return s
			let a = (s.length / 2) | 0,
				u = s.slice(0, a),
				h = s.slice(a)
			i(u, o), i(h, o)
			let N = 0,
				I = 0,
				Q = 0
			for (; N < u.length && I < h.length; )
				o(u[N], h[I]) <= 0 ? (s[Q++] = u[N++]) : (s[Q++] = h[I++])
			for (; N < u.length; ) s[Q++] = u[N++]
			for (; I < h.length; ) s[Q++] = h[I++]
			return s
		}
	})(l2 || (l2 = {}))
	var wd = class {
			constructor(t, n, r, i) {
				;(this._uri = t),
					(this._languageId = n),
					(this._version = r),
					(this._content = i),
					(this._lineOffsets = void 0)
			}
			get uri() {
				return this._uri
			}
			get languageId() {
				return this._languageId
			}
			get version() {
				return this._version
			}
			getText(t) {
				if (t) {
					let n = this.offsetAt(t.start),
						r = this.offsetAt(t.end)
					return this._content.substring(n, r)
				}
				return this._content
			}
			update(t, n) {
				;(this._content = t.text), (this._version = n), (this._lineOffsets = void 0)
			}
			getLineOffsets() {
				if (this._lineOffsets === void 0) {
					let t = [],
						n = this._content,
						r = !0
					for (let i = 0; i < n.length; i++) {
						r && (t.push(i), (r = !1))
						let s = n.charAt(i)
						;(r =
							s === '\r' ||
							s ===
								`
`),
							s === '\r' &&
								i + 1 < n.length &&
								n.charAt(i + 1) ===
									`
` &&
								i++
					}
					r && n.length > 0 && t.push(n.length), (this._lineOffsets = t)
				}
				return this._lineOffsets
			}
			positionAt(t) {
				t = Math.max(Math.min(t, this._content.length), 0)
				let n = this.getLineOffsets(),
					r = 0,
					i = n.length
				if (i === 0) return Vi.create(0, t)
				for (; r < i; ) {
					let o = Math.floor((r + i) / 2)
					n[o] > t ? (i = o) : (r = o + 1)
				}
				let s = r - 1
				return Vi.create(s, t - n[s])
			}
			offsetAt(t) {
				let n = this.getLineOffsets()
				if (t.line >= n.length) return this._content.length
				if (t.line < 0) return 0
				let r = n[t.line],
					i = t.line + 1 < n.length ? n[t.line + 1] : this._content.length
				return Math.max(Math.min(r + t.character, i), r)
			}
			get lineCount() {
				return this.getLineOffsets().length
			}
		},
		Qe
	;(function (e) {
		let t = Object.prototype.toString
		function n(K) {
			return typeof K < 'u'
		}
		e.defined = n
		function r(K) {
			return typeof K > 'u'
		}
		e.undefined = r
		function i(K) {
			return K === !0 || K === !1
		}
		e.boolean = i
		function s(K) {
			return t.call(K) === '[object String]'
		}
		e.string = s
		function o(K) {
			return t.call(K) === '[object Number]'
		}
		e.number = o
		function a(K, ue, de) {
			return t.call(K) === '[object Number]' && ue <= K && K <= de
		}
		e.numberRange = a
		function u(K) {
			return t.call(K) === '[object Number]' && -2147483648 <= K && K <= 2147483647
		}
		e.integer = u
		function h(K) {
			return t.call(K) === '[object Number]' && 0 <= K && K <= 2147483647
		}
		e.uinteger = h
		function N(K) {
			return t.call(K) === '[object Function]'
		}
		e.func = N
		function I(K) {
			return K !== null && typeof K == 'object'
		}
		e.objectLiteral = I
		function Q(K, ue) {
			return Array.isArray(K) && K.every(ue)
		}
		e.typedArray = Q
	})(Qe || (Qe = {}))
	var Rn
	;(function (e) {
		;(e.Text = 1),
			(e.Method = 2),
			(e.Function = 3),
			(e.Constructor = 4),
			(e.Field = 5),
			(e.Variable = 6),
			(e.Class = 7),
			(e.Interface = 8),
			(e.Module = 9),
			(e.Property = 10),
			(e.Unit = 11),
			(e.Value = 12),
			(e.Enum = 13),
			(e.Keyword = 14),
			(e.Snippet = 15),
			(e.Color = 16),
			(e.File = 17),
			(e.Reference = 18),
			(e.Folder = 19),
			(e.EnumMember = 20),
			(e.Constant = 21),
			(e.Struct = 22),
			(e.Event = 23),
			(e.Operator = 24),
			(e.TypeParameter = 25)
	})(Rn || (Rn = {}))
	var rs = class {
		constructor(t) {
			;(this._start = 0),
				(this._pos = 0),
				(this.getStartOfToken = () => this._start),
				(this.getCurrentPosition = () => this._pos),
				(this.eol = () => this._sourceText.length === this._pos),
				(this.sol = () => this._pos === 0),
				(this.peek = () => this._sourceText.charAt(this._pos) || null),
				(this.next = () => {
					let n = this._sourceText.charAt(this._pos)
					return this._pos++, n
				}),
				(this.eat = (n) => {
					if (this._testNextCharacter(n))
						return (this._start = this._pos), this._pos++, this._sourceText.charAt(this._pos - 1)
				}),
				(this.eatWhile = (n) => {
					let r = this._testNextCharacter(n),
						i = !1
					for (r && ((i = r), (this._start = this._pos)); r; )
						this._pos++, (r = this._testNextCharacter(n)), (i = !0)
					return i
				}),
				(this.eatSpace = () => this.eatWhile(/[\s\u00a0]/)),
				(this.skipToEnd = () => {
					this._pos = this._sourceText.length
				}),
				(this.skipTo = (n) => {
					this._pos = n
				}),
				(this.match = (n, r = !0, i = !1) => {
					let s = null,
						o = null
					return (
						typeof n == 'string'
							? ((o = new RegExp(n, i ? 'i' : 'g').test(
									this._sourceText.slice(this._pos, this._pos + n.length)
							  )),
							  (s = n))
							: n instanceof RegExp &&
							  ((o = this._sourceText.slice(this._pos).match(n)), (s = o?.[0])),
						o != null &&
						(typeof n == 'string' ||
							(o instanceof Array && this._sourceText.startsWith(o[0], this._pos)))
							? (r && ((this._start = this._pos), s && s.length && (this._pos += s.length)), o)
							: !1
					)
				}),
				(this.backUp = (n) => {
					this._pos -= n
				}),
				(this.column = () => this._pos),
				(this.indentation = () => {
					let n = this._sourceText.match(/\s*/),
						r = 0
					if (n && n.length !== 0) {
						let i = n[0],
							s = 0
						for (; i.length > s; ) i.charCodeAt(s) === 9 ? (r += 2) : r++, s++
					}
					return r
				}),
				(this.current = () => this._sourceText.slice(this._start, this._pos)),
				(this._sourceText = t)
		}
		_testNextCharacter(t) {
			let n = this._sourceText.charAt(this._pos),
				r = !1
			return typeof t == 'string' ? (r = n === t) : (r = t instanceof RegExp ? t.test(n) : t(n)), r
		}
	}
	function yr(e) {
		return { ofRule: e }
	}
	function Jn(e, t) {
		return { ofRule: e, isList: !0, separator: t }
	}
	function Ld(e, t) {
		let n = e.match
		return (
			(e.match = (r) => {
				let i = !1
				return n && (i = n(r)), i && t.every((s) => s.match && !s.match(r))
			}),
			e
		)
	}
	function ba(e, t) {
		return { style: t, match: (n) => n.kind === e }
	}
	function Fn(e, t) {
		return { style: t || 'punctuation', match: (n) => n.kind === 'Punctuation' && n.value === e }
	}
	var Ic = (e) =>
			e === ' ' ||
			e === '	' ||
			e === ',' ||
			e ===
				`
` ||
			e === '\r' ||
			e === '\uFEFF' ||
			e === '\xA0',
		kc = {
			Name: /^[_A-Za-z][_0-9A-Za-z]*/,
			Punctuation: /^(?:!|\$|\(|\)|\.\.\.|:|=|&|@|\[|]|\{|\||\})/,
			Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,
			String:
				/^(?:"""(?:\\"""|[^"]|"[^"]|""[^"])*(?:""")?|"(?:[^"\\]|\\(?:"|\/|\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*"?)/,
			Comment: /^#.*/
		},
		Rc = {
			Document: [Jn('Definition')],
			Definition(e) {
				switch (e.value) {
					case '{':
						return 'ShortQuery'
					case 'query':
						return 'Query'
					case 'mutation':
						return 'Mutation'
					case 'subscription':
						return 'Subscription'
					case 'fragment':
						return oe.FRAGMENT_DEFINITION
					case 'schema':
						return 'SchemaDef'
					case 'scalar':
						return 'ScalarDef'
					case 'type':
						return 'ObjectTypeDef'
					case 'interface':
						return 'InterfaceDef'
					case 'union':
						return 'UnionDef'
					case 'enum':
						return 'EnumDef'
					case 'input':
						return 'InputDef'
					case 'extend':
						return 'ExtendDef'
					case 'directive':
						return 'DirectiveDef'
				}
			},
			ShortQuery: ['SelectionSet'],
			Query: [
				zr('query'),
				yr(dr('def')),
				yr('VariableDefinitions'),
				Jn('Directive'),
				'SelectionSet'
			],
			Mutation: [
				zr('mutation'),
				yr(dr('def')),
				yr('VariableDefinitions'),
				Jn('Directive'),
				'SelectionSet'
			],
			Subscription: [
				zr('subscription'),
				yr(dr('def')),
				yr('VariableDefinitions'),
				Jn('Directive'),
				'SelectionSet'
			],
			VariableDefinitions: [Fn('('), Jn('VariableDefinition'), Fn(')')],
			VariableDefinition: ['Variable', Fn(':'), 'Type', yr('DefaultValue')],
			Variable: [Fn('$', 'variable'), dr('variable')],
			DefaultValue: [Fn('='), 'Value'],
			SelectionSet: [Fn('{'), Jn('Selection'), Fn('}')],
			Selection(e, t) {
				return e.value === '...'
					? t.match(/[\s\u00a0,]*(on\b|@|{)/, !1)
						? 'InlineFragment'
						: 'FragmentSpread'
					: t.match(/[\s\u00a0,]*:/, !1)
					? 'AliasedField'
					: 'Field'
			},
			AliasedField: [
				dr('property'),
				Fn(':'),
				dr('qualifier'),
				yr('Arguments'),
				Jn('Directive'),
				yr('SelectionSet')
			],
			Field: [dr('property'), yr('Arguments'), Jn('Directive'), yr('SelectionSet')],
			Arguments: [Fn('('), Jn('Argument'), Fn(')')],
			Argument: [dr('attribute'), Fn(':'), 'Value'],
			FragmentSpread: [Fn('...'), dr('def'), Jn('Directive')],
			InlineFragment: [Fn('...'), yr('TypeCondition'), Jn('Directive'), 'SelectionSet'],
			FragmentDefinition: [
				zr('fragment'),
				yr(Ld(dr('def'), [zr('on')])),
				'TypeCondition',
				Jn('Directive'),
				'SelectionSet'
			],
			TypeCondition: [zr('on'), 'NamedType'],
			Value(e) {
				switch (e.kind) {
					case 'Number':
						return 'NumberValue'
					case 'String':
						return 'StringValue'
					case 'Punctuation':
						switch (e.value) {
							case '[':
								return 'ListValue'
							case '{':
								return 'ObjectValue'
							case '$':
								return 'Variable'
							case '&':
								return 'NamedType'
						}
						return null
					case 'Name':
						switch (e.value) {
							case 'true':
							case 'false':
								return 'BooleanValue'
						}
						return e.value === 'null' ? 'NullValue' : 'EnumValue'
				}
			},
			NumberValue: [ba('Number', 'number')],
			StringValue: [
				{
					style: 'string',
					match: (e) => e.kind === 'String',
					update(e, t) {
						t.value.startsWith('"""') && (e.inBlockstring = !t.value.slice(3).endsWith('"""'))
					}
				}
			],
			BooleanValue: [ba('Name', 'builtin')],
			NullValue: [ba('Name', 'keyword')],
			EnumValue: [dr('string-2')],
			ListValue: [Fn('['), Jn('Value'), Fn(']')],
			ObjectValue: [Fn('{'), Jn('ObjectField'), Fn('}')],
			ObjectField: [dr('attribute'), Fn(':'), 'Value'],
			Type(e) {
				return e.value === '[' ? 'ListType' : 'NonNullType'
			},
			ListType: [Fn('['), 'Type', Fn(']'), yr(Fn('!'))],
			NonNullType: ['NamedType', yr(Fn('!'))],
			NamedType: [Sb('atom')],
			Directive: [Fn('@', 'meta'), dr('meta'), yr('Arguments')],
			DirectiveDef: [
				zr('directive'),
				Fn('@', 'meta'),
				dr('meta'),
				yr('ArgumentsDef'),
				zr('on'),
				Jn('DirectiveLocation', Fn('|'))
			],
			InterfaceDef: [
				zr('interface'),
				dr('atom'),
				yr('Implements'),
				Jn('Directive'),
				Fn('{'),
				Jn('FieldDef'),
				Fn('}')
			],
			Implements: [zr('implements'), Jn('NamedType', Fn('&'))],
			DirectiveLocation: [dr('string-2')],
			SchemaDef: [zr('schema'), Jn('Directive'), Fn('{'), Jn('OperationTypeDef'), Fn('}')],
			OperationTypeDef: [dr('keyword'), Fn(':'), dr('atom')],
			ScalarDef: [zr('scalar'), dr('atom'), Jn('Directive')],
			ObjectTypeDef: [
				zr('type'),
				dr('atom'),
				yr('Implements'),
				Jn('Directive'),
				Fn('{'),
				Jn('FieldDef'),
				Fn('}')
			],
			FieldDef: [dr('property'), yr('ArgumentsDef'), Fn(':'), 'Type', Jn('Directive')],
			ArgumentsDef: [Fn('('), Jn('InputValueDef'), Fn(')')],
			InputValueDef: [dr('attribute'), Fn(':'), 'Type', yr('DefaultValue'), Jn('Directive')],
			UnionDef: [zr('union'), dr('atom'), Jn('Directive'), Fn('='), Jn('UnionMember', Fn('|'))],
			UnionMember: ['NamedType'],
			EnumDef: [zr('enum'), dr('atom'), Jn('Directive'), Fn('{'), Jn('EnumValueDef'), Fn('}')],
			EnumValueDef: [dr('string-2'), Jn('Directive')],
			InputDef: [zr('input'), dr('atom'), Jn('Directive'), Fn('{'), Jn('InputValueDef'), Fn('}')],
			ExtendDef: [zr('extend'), 'ExtensionDefinition'],
			ExtensionDefinition(e) {
				switch (e.value) {
					case 'schema':
						return oe.SCHEMA_EXTENSION
					case 'scalar':
						return oe.SCALAR_TYPE_EXTENSION
					case 'type':
						return oe.OBJECT_TYPE_EXTENSION
					case 'interface':
						return oe.INTERFACE_TYPE_EXTENSION
					case 'union':
						return oe.UNION_TYPE_EXTENSION
					case 'enum':
						return oe.ENUM_TYPE_EXTENSION
					case 'input':
						return oe.INPUT_OBJECT_TYPE_EXTENSION
				}
			},
			[oe.SCHEMA_EXTENSION]: ['SchemaDef'],
			[oe.SCALAR_TYPE_EXTENSION]: ['ScalarDef'],
			[oe.OBJECT_TYPE_EXTENSION]: ['ObjectTypeDef'],
			[oe.INTERFACE_TYPE_EXTENSION]: ['InterfaceDef'],
			[oe.UNION_TYPE_EXTENSION]: ['UnionDef'],
			[oe.ENUM_TYPE_EXTENSION]: ['EnumDef'],
			[oe.INPUT_OBJECT_TYPE_EXTENSION]: ['InputDef']
		}
	function zr(e) {
		return { style: 'keyword', match: (t) => t.kind === 'Name' && t.value === e }
	}
	function dr(e) {
		return {
			style: e,
			match: (t) => t.kind === 'Name',
			update(t, n) {
				t.name = n.value
			}
		}
	}
	function Sb(e) {
		return {
			style: e,
			match: (t) => t.kind === 'Name',
			update(t, n) {
				var r
				!((r = t.prevState) === null || r === void 0) &&
					r.prevState &&
					((t.name = n.value), (t.prevState.prevState.type = n.value))
			}
		}
	}
	function co(
		e = { eatWhitespace: (t) => t.eatWhile(Ic), lexRules: kc, parseRules: Rc, editorConfig: {} }
	) {
		return {
			startState() {
				let t = {
					level: 0,
					step: 0,
					name: null,
					kind: null,
					type: null,
					rule: null,
					needsSeparator: !1,
					prevState: null
				}
				return Nu(e.parseRules, t, oe.DOCUMENT), t
			},
			token(t, n) {
				return Nb(t, n, e)
			}
		}
	}
	function Nb(e, t, n) {
		var r
		if (t.inBlockstring)
			return e.match(/.*"""/) ? ((t.inBlockstring = !1), 'string') : (e.skipToEnd(), 'string')
		let { lexRules: i, parseRules: s, eatWhitespace: o, editorConfig: a } = n
		if (
			(t.rule && t.rule.length === 0 ? Rd(t) : t.needsAdvance && ((t.needsAdvance = !1), kd(t, !0)),
			e.sol())
		) {
			let N = a?.tabSize || 2
			t.indentLevel = Math.floor(e.indentation() / N)
		}
		if (o(e)) return 'ws'
		let u = _b(i, e)
		if (!u) return e.match(/\S+/) || e.match(/\s/), Nu(Id, t, 'Invalid'), 'invalidchar'
		if (u.kind === 'Comment') return Nu(Id, t, 'Comment'), 'comment'
		let h = c2({}, t)
		if (u.kind === 'Punctuation') {
			if (/^[{([]/.test(u.value))
				t.indentLevel !== void 0 && (t.levels = (t.levels || []).concat(t.indentLevel + 1))
			else if (/^[})\]]/.test(u.value)) {
				let N = (t.levels = (t.levels || []).slice(0, -1))
				t.indentLevel && N.length > 0 && N.at(-1) < t.indentLevel && (t.indentLevel = N.at(-1))
			}
		}
		for (; t.rule; ) {
			let N = typeof t.rule == 'function' ? (t.step === 0 ? t.rule(u, e) : null) : t.rule[t.step]
			if ((t.needsSeparator && (N = N?.separator), N)) {
				if ((N.ofRule && (N = N.ofRule), typeof N == 'string')) {
					Nu(s, t, N)
					continue
				}
				if (!((r = N.match) === null || r === void 0) && r.call(N, u))
					return (
						N.update && N.update(t, u),
						u.kind === 'Punctuation' ? kd(t, !0) : (t.needsAdvance = !0),
						N.style
					)
			}
			Fb(t)
		}
		return c2(t, h), Nu(Id, t, 'Invalid'), 'invalidchar'
	}
	function c2(e, t) {
		let n = Object.keys(t)
		for (let r = 0; r < n.length; r++) e[n[r]] = t[n[r]]
		return e
	}
	var Id = { Invalid: [], Comment: [] }
	function Nu(e, t, n) {
		if (!e[n]) throw new TypeError('Unknown rule: ' + n)
		;(t.prevState = Object.assign({}, t)),
			(t.kind = n),
			(t.name = null),
			(t.type = null),
			(t.rule = e[n]),
			(t.step = 0),
			(t.needsSeparator = !1)
	}
	function Rd(e) {
		e.prevState &&
			((e.kind = e.prevState.kind),
			(e.name = e.prevState.name),
			(e.type = e.prevState.type),
			(e.rule = e.prevState.rule),
			(e.step = e.prevState.step),
			(e.needsSeparator = e.prevState.needsSeparator),
			(e.prevState = e.prevState.prevState))
	}
	function kd(e, t) {
		var n
		if (p2(e) && e.rule) {
			let r = e.rule[e.step]
			if (r.separator) {
				let { separator: i } = r
				if (((e.needsSeparator = !e.needsSeparator), !e.needsSeparator && i.ofRule)) return
			}
			if (t) return
		}
		for (
			e.needsSeparator = !1, e.step++;
			e.rule && !(Array.isArray(e.rule) && e.step < e.rule.length);

		)
			Rd(e),
				e.rule &&
					(p2(e)
						? !((n = e.rule) === null || n === void 0) &&
						  n[e.step].separator &&
						  (e.needsSeparator = !e.needsSeparator)
						: ((e.needsSeparator = !1), e.step++))
	}
	function p2(e) {
		let t = Array.isArray(e.rule) && typeof e.rule[e.step] != 'string' && e.rule[e.step]
		return t && t.isList
	}
	function Fb(e) {
		for (; e.rule && !(Array.isArray(e.rule) && e.rule[e.step].ofRule); ) Rd(e)
		e.rule && kd(e, !1)
	}
	function _b(e, t) {
		let n = Object.keys(e)
		for (let r = 0; r < n.length; r++) {
			let i = t.match(e[n[r]])
			if (i && i instanceof Array) return { kind: n[r], value: i[0] }
		}
	}
	var wb = {
			ALIASED_FIELD: 'AliasedField',
			ARGUMENTS: 'Arguments',
			SHORT_QUERY: 'ShortQuery',
			QUERY: 'Query',
			MUTATION: 'Mutation',
			SUBSCRIPTION: 'Subscription',
			TYPE_CONDITION: 'TypeCondition',
			INVALID: 'Invalid',
			COMMENT: 'Comment',
			SCHEMA_DEF: 'SchemaDef',
			SCALAR_DEF: 'ScalarDef',
			OBJECT_TYPE_DEF: 'ObjectTypeDef',
			OBJECT_VALUE: 'ObjectValue',
			LIST_VALUE: 'ListValue',
			INTERFACE_DEF: 'InterfaceDef',
			UNION_DEF: 'UnionDef',
			ENUM_DEF: 'EnumDef',
			ENUM_VALUE: 'EnumValue',
			FIELD_DEF: 'FieldDef',
			INPUT_DEF: 'InputDef',
			INPUT_VALUE_DEF: 'InputValueDef',
			ARGUMENTS_DEF: 'ArgumentsDef',
			EXTEND_DEF: 'ExtendDef',
			EXTENSION_DEFINITION: 'ExtensionDefinition',
			DIRECTIVE_DEF: 'DirectiveDef',
			IMPLEMENTS: 'Implements',
			VARIABLE_DEFINITIONS: 'VariableDefinitions',
			TYPE: 'Type'
		},
		kt = Object.assign(Object.assign({}, oe), wb)
	var Od = { command: 'editor.action.triggerSuggest', title: 'Suggestions' },
		Lb = (e) => {
			let t = []
			if (e)
				try {
					Jr(Pi(e), {
						FragmentDefinition(n) {
							t.push(n)
						}
					})
				} catch {
					return []
				}
			return t
		},
		Ib = [
			oe.SCHEMA_DEFINITION,
			oe.OPERATION_TYPE_DEFINITION,
			oe.SCALAR_TYPE_DEFINITION,
			oe.OBJECT_TYPE_DEFINITION,
			oe.INTERFACE_TYPE_DEFINITION,
			oe.UNION_TYPE_DEFINITION,
			oe.ENUM_TYPE_DEFINITION,
			oe.INPUT_OBJECT_TYPE_DEFINITION,
			oe.DIRECTIVE_DEFINITION,
			oe.SCHEMA_EXTENSION,
			oe.SCALAR_TYPE_EXTENSION,
			oe.OBJECT_TYPE_EXTENSION,
			oe.INTERFACE_TYPE_EXTENSION,
			oe.UNION_TYPE_EXTENSION,
			oe.ENUM_TYPE_EXTENSION,
			oe.INPUT_OBJECT_TYPE_EXTENSION
		],
		kb = (e) => {
			let t = !1
			if (e)
				try {
					Jr(Pi(e), {
						enter(n) {
							if (n.kind !== 'Document') return Ib.includes(n.kind) ? ((t = !0), cs) : !1
						}
					})
				} catch {
					return t
				}
			return t
		}
	function Bd(e, t, n, r, i, s) {
		var o
		let a = Object.assign(Object.assign({}, s), { schema: e }),
			u = r || Bc(t, n, 1),
			h = u.state.kind === 'Invalid' ? u.state.prevState : u.state,
			N = s?.mode || Hb(t, s?.uri)
		if (!h) return []
		let { kind: I, step: Q, prevState: K } = h,
			ue = Mc(e, u.state)
		if (I === kt.DOCUMENT) return N === po.TYPE_SYSTEM ? Ob(u) : Bb(u)
		if (I === kt.EXTEND_DEF) return Pb(u)
		if (
			((o = K?.prevState) === null || o === void 0 ? void 0 : o.kind) === kt.EXTENSION_DEFINITION &&
			h.name
		)
			return Dr(u, [])
		if (K?.kind === oe.SCALAR_TYPE_EXTENSION)
			return Dr(
				u,
				Object.values(e.getTypeMap())
					.filter(Vr)
					.map((Pe) => ({ label: Pe.name, kind: Rn.Function }))
			)
		if (K?.kind === oe.OBJECT_TYPE_EXTENSION)
			return Dr(
				u,
				Object.values(e.getTypeMap())
					.filter((Pe) => Un(Pe) && !Pe.name.startsWith('__'))
					.map((Pe) => ({ label: Pe.name, kind: Rn.Function }))
			)
		if (K?.kind === oe.INTERFACE_TYPE_EXTENSION)
			return Dr(
				u,
				Object.values(e.getTypeMap())
					.filter(qn)
					.map((Pe) => ({ label: Pe.name, kind: Rn.Function }))
			)
		if (K?.kind === oe.UNION_TYPE_EXTENSION)
			return Dr(
				u,
				Object.values(e.getTypeMap())
					.filter(wr)
					.map((Pe) => ({ label: Pe.name, kind: Rn.Function }))
			)
		if (K?.kind === oe.ENUM_TYPE_EXTENSION)
			return Dr(
				u,
				Object.values(e.getTypeMap())
					.filter((Pe) => fr(Pe) && !Pe.name.startsWith('__'))
					.map((Pe) => ({ label: Pe.name, kind: Rn.Function }))
			)
		if (K?.kind === oe.INPUT_OBJECT_TYPE_EXTENSION)
			return Dr(
				u,
				Object.values(e.getTypeMap())
					.filter(Yn)
					.map((Pe) => ({ label: Pe.name, kind: Rn.Function }))
			)
		if (I === kt.IMPLEMENTS || (I === kt.NAMED_TYPE && K?.kind === kt.IMPLEMENTS))
			return $b(u, h, e, t, ue)
		if (I === kt.SELECTION_SET || I === kt.FIELD || I === kt.ALIASED_FIELD) return Mb(u, ue, a)
		if (I === kt.ARGUMENTS || (I === kt.ARGUMENT && Q === 0)) {
			let { argDefs: Pe } = ue
			if (Pe)
				return Dr(
					u,
					Pe.map((Ze) => {
						var Ae
						return {
							label: Ze.name,
							insertText: Ze.name + ': ',
							command: Od,
							detail: String(Ze.type),
							documentation: (Ae = Ze.description) !== null && Ae !== void 0 ? Ae : void 0,
							kind: Rn.Variable,
							type: Ze.type
						}
					})
				)
		}
		if ((I === kt.OBJECT_VALUE || (I === kt.OBJECT_FIELD && Q === 0)) && ue.objectFieldDefs) {
			let Pe = Bs(ue.objectFieldDefs),
				Ze = I === kt.OBJECT_VALUE ? Rn.Value : Rn.Field
			return Dr(
				u,
				Pe.map((Ae) => {
					var ze
					return {
						label: Ae.name,
						detail: String(Ae.type),
						documentation: (ze = Ae.description) !== null && ze !== void 0 ? ze : void 0,
						kind: Ze,
						type: Ae.type
					}
				})
			)
		}
		if (
			I === kt.ENUM_VALUE ||
			(I === kt.LIST_VALUE && Q === 1) ||
			(I === kt.OBJECT_FIELD && Q === 2) ||
			(I === kt.ARGUMENT && Q === 2)
		)
			return jb(u, ue, t, e)
		if (I === kt.VARIABLE && Q === 1) {
			let Pe = or(ue.inputType),
				Ze = Pd(t, e, u)
			return Dr(
				u,
				Ze.filter((Ae) => Ae.detail === Pe?.name)
			)
		}
		if (
			(I === kt.TYPE_CONDITION && Q === 1) ||
			(I === kt.NAMED_TYPE && K != null && K.kind === kt.TYPE_CONDITION)
		)
			return Vb(u, ue, e, I)
		if (I === kt.FRAGMENT_SPREAD && Q === 1) return Ub(u, ue, e, t, Array.isArray(i) ? i : Lb(i))
		let de = h2(h)
		if ((N === po.TYPE_SYSTEM && !de.needsAdvance && I === kt.NAMED_TYPE) || I === kt.LIST_TYPE) {
			if (de.kind === kt.FIELD_DEF)
				return Dr(
					u,
					Object.values(e.getTypeMap())
						.filter((Pe) => bi(Pe) && !Pe.name.startsWith('__'))
						.map((Pe) => ({ label: Pe.name, kind: Rn.Function }))
				)
			if (de.kind === kt.INPUT_VALUE_DEF)
				return Dr(
					u,
					Object.values(e.getTypeMap())
						.filter((Pe) => Lr(Pe) && !Pe.name.startsWith('__'))
						.map((Pe) => ({ label: Pe.name, kind: Rn.Function }))
				)
		}
		return (I === kt.VARIABLE_DEFINITION && Q === 2) ||
			(I === kt.LIST_TYPE && Q === 1) ||
			(I === kt.NAMED_TYPE &&
				K &&
				(K.kind === kt.VARIABLE_DEFINITION ||
					K.kind === kt.LIST_TYPE ||
					K.kind === kt.NON_NULL_TYPE))
			? Gb(u, e, I)
			: I === kt.DIRECTIVE
			? Wb(u, h, e, I)
			: []
	}
	var Oc = ` {
  $1
}`,
		Rb = (e) => {
			let { type: t } = e
			return gr(t) ||
				(Zn(t) && gr(t.ofType)) ||
				(Nn(t) && (gr(t.ofType) || (Zn(t.ofType) && gr(t.ofType.ofType))))
				? Oc
				: null
		}
	function Ob(e) {
		return Dr(e, [
			{ label: 'extend', kind: Rn.Function },
			{ label: 'type', kind: Rn.Function },
			{ label: 'interface', kind: Rn.Function },
			{ label: 'union', kind: Rn.Function },
			{ label: 'input', kind: Rn.Function },
			{ label: 'scalar', kind: Rn.Function },
			{ label: 'schema', kind: Rn.Function }
		])
	}
	function Bb(e) {
		return Dr(e, [
			{ label: 'query', kind: Rn.Function },
			{ label: 'mutation', kind: Rn.Function },
			{ label: 'subscription', kind: Rn.Function },
			{ label: 'fragment', kind: Rn.Function },
			{ label: '{', kind: Rn.Constructor }
		])
	}
	function Pb(e) {
		return Dr(e, [
			{ label: 'type', kind: Rn.Function },
			{ label: 'interface', kind: Rn.Function },
			{ label: 'union', kind: Rn.Function },
			{ label: 'input', kind: Rn.Function },
			{ label: 'scalar', kind: Rn.Function },
			{ label: 'schema', kind: Rn.Function }
		])
	}
	function Mb(e, t, n) {
		var r
		if (t.parentType) {
			let { parentType: i } = t,
				s = []
			return (
				'getFields' in i && (s = Bs(i.getFields())),
				gr(i) && s.push(ts),
				i === ((r = n?.schema) === null || r === void 0 ? void 0 : r.getQueryType()) &&
					s.push(Zi, es),
				Dr(
					e,
					s.map((o, a) => {
						var u
						let h = {
							sortText: String(a) + o.name,
							label: o.name,
							detail: String(o.type),
							documentation: (u = o.description) !== null && u !== void 0 ? u : void 0,
							deprecated: !!o.deprecationReason,
							isDeprecated: !!o.deprecationReason,
							deprecationReason: o.deprecationReason,
							kind: Rn.Field,
							type: o.type
						}
						if (n?.fillLeafsOnComplete) {
							let N = Rb(o)
							N &&
								((h.insertText = o.name + N), (h.insertTextFormat = Su.Snippet), (h.command = Od))
						}
						return h
					})
				)
			)
		}
		return []
	}
	function jb(e, t, n, r) {
		let i = or(t.inputType),
			s = Pd(n, r, e).filter((o) => o.detail === i.name)
		if (i instanceof Kr) {
			let o = i.getValues()
			return Dr(
				e,
				o
					.map((a) => {
						var u
						return {
							label: a.name,
							detail: String(i),
							documentation: (u = a.description) !== null && u !== void 0 ? u : void 0,
							deprecated: !!a.deprecationReason,
							isDeprecated: !!a.deprecationReason,
							deprecationReason: a.deprecationReason,
							kind: Rn.EnumMember,
							type: i
						}
					})
					.concat(s)
			)
		}
		return i === Cr
			? Dr(
					e,
					s.concat([
						{
							label: 'true',
							detail: String(Cr),
							documentation: 'Not false.',
							kind: Rn.Variable,
							type: Cr
						},
						{
							label: 'false',
							detail: String(Cr),
							documentation: 'Not true.',
							kind: Rn.Variable,
							type: Cr
						}
					])
			  )
			: s
	}
	function $b(e, t, n, r, i) {
		if (t.needsSeparator) return []
		let s = n.getTypeMap(),
			o = Bs(s).filter(qn),
			a = o.map(({ name: K }) => K),
			u = new Set()
		Pc(r, (K, ue) => {
			var de, Pe, Ze, Ae, ze
			if (
				ue.name &&
				(ue.kind === kt.INTERFACE_DEF && !a.includes(ue.name) && u.add(ue.name),
				ue.kind === kt.NAMED_TYPE &&
					((de = ue.prevState) === null || de === void 0 ? void 0 : de.kind) === kt.IMPLEMENTS)
			) {
				if (i.interfaceDef) {
					if (
						(Pe = i.interfaceDef) === null || Pe === void 0
							? void 0
							: Pe.getInterfaces().find(({ name: ct }) => ct === ue.name)
					)
						return
					let Et = n.getType(ue.name),
						_t = (Ze = i.interfaceDef) === null || Ze === void 0 ? void 0 : Ze.toConfig()
					i.interfaceDef = new ri(
						Object.assign(Object.assign({}, _t), {
							interfaces: [..._t.interfaces, Et || new ri({ name: ue.name, fields: {} })]
						})
					)
				} else if (i.objectTypeDef) {
					if (
						(Ae = i.objectTypeDef) === null || Ae === void 0
							? void 0
							: Ae.getInterfaces().find(({ name: ct }) => ct === ue.name)
					)
						return
					let Et = n.getType(ue.name),
						_t = (ze = i.objectTypeDef) === null || ze === void 0 ? void 0 : ze.toConfig()
					i.objectTypeDef = new Pr(
						Object.assign(Object.assign({}, _t), {
							interfaces: [..._t.interfaces, Et || new ri({ name: ue.name, fields: {} })]
						})
					)
				}
			}
		})
		let h = i.interfaceDef || i.objectTypeDef,
			I = (h?.getInterfaces() || []).map(({ name: K }) => K),
			Q = o
				.concat([...u].map((K) => ({ name: K })))
				.filter(({ name: K }) => K !== h?.name && !I.includes(K))
		return Dr(
			e,
			Q.map((K) => {
				let ue = { label: K.name, kind: Rn.Interface, type: K }
				return K?.description && (ue.documentation = K.description), ue
			})
		)
	}
	function Vb(e, t, n, r) {
		let i
		if (t.parentType)
			if (Zr(t.parentType)) {
				let s = rc(t.parentType),
					o = n.getPossibleTypes(s),
					a = Object.create(null)
				for (let u of o) for (let h of u.getInterfaces()) a[h.name] = h
				i = o.concat(Bs(a))
			} else i = [t.parentType]
		else {
			let s = n.getTypeMap()
			i = Bs(s).filter((o) => gr(o) && !o.name.startsWith('__'))
		}
		return Dr(
			e,
			i.map((s) => {
				let o = or(s)
				return { label: String(s), documentation: o?.description || '', kind: Rn.Field }
			})
		)
	}
	function Ub(e, t, n, r, i) {
		if (!r) return []
		let s = n.getTypeMap(),
			o = md(e.state),
			a = f2(r)
		i && i.length > 0 && a.push(...i)
		let u = a.filter(
			(h) =>
				s[h.typeCondition.name.value] &&
				!(o && o.kind === kt.FRAGMENT_DEFINITION && o.name === h.name.value) &&
				gr(t.parentType) &&
				gr(s[h.typeCondition.name.value]) &&
				eo(n, t.parentType, s[h.typeCondition.name.value])
		)
		return Dr(
			e,
			u.map((h) => ({
				label: h.name.value,
				detail: String(s[h.typeCondition.name.value]),
				documentation: `fragment ${h.name.value} on ${h.typeCondition.name.value}`,
				kind: Rn.Field,
				type: s[h.typeCondition.name.value]
			}))
		)
	}
	var qb = (e, t) => {
		var n, r, i, s, o, a, u, h, N, I
		if (((n = e.prevState) === null || n === void 0 ? void 0 : n.kind) === t) return e.prevState
		if (
			((i = (r = e.prevState) === null || r === void 0 ? void 0 : r.prevState) === null ||
			i === void 0
				? void 0
				: i.kind) === t
		)
			return e.prevState.prevState
		if (
			((a =
				(o = (s = e.prevState) === null || s === void 0 ? void 0 : s.prevState) === null ||
				o === void 0
					? void 0
					: o.prevState) === null || a === void 0
				? void 0
				: a.kind) === t
		)
			return e.prevState.prevState.prevState
		if (
			((I =
				(N =
					(h = (u = e.prevState) === null || u === void 0 ? void 0 : u.prevState) === null ||
					h === void 0
						? void 0
						: h.prevState) === null || N === void 0
					? void 0
					: N.prevState) === null || I === void 0
				? void 0
				: I.kind) === t
		)
			return e.prevState.prevState.prevState.prevState
	}
	function Pd(e, t, n) {
		let r = null,
			i,
			s = Object.create({})
		return (
			Pc(e, (o, a) => {
				if ((a?.kind === kt.VARIABLE && a.name && (r = a.name), a?.kind === kt.NAMED_TYPE && r)) {
					let u = qb(a, kt.TYPE)
					u?.type && (i = t.getType(u?.type))
				}
				r &&
					i &&
					!s[r] &&
					((s[r] = {
						detail: i.toString(),
						insertText: n.string === '$' ? r : '$' + r,
						label: r,
						type: i,
						kind: Rn.Variable
					}),
					(r = null),
					(i = null))
			}),
			Bs(s)
		)
	}
	function f2(e) {
		let t = []
		return (
			Pc(e, (n, r) => {
				r.kind === kt.FRAGMENT_DEFINITION &&
					r.name &&
					r.type &&
					t.push({
						kind: kt.FRAGMENT_DEFINITION,
						name: { kind: oe.NAME, value: r.name },
						selectionSet: { kind: kt.SELECTION_SET, selections: [] },
						typeCondition: { kind: kt.NAMED_TYPE, name: { kind: oe.NAME, value: r.type } }
					})
			}),
			t
		)
	}
	function Gb(e, t, n) {
		let r = t.getTypeMap(),
			i = Bs(r).filter(Lr)
		return Dr(
			e,
			i.map((s) => ({ label: s.name, documentation: s.description, kind: Rn.Variable }))
		)
	}
	function Wb(e, t, n, r) {
		var i
		if (!((i = t.prevState) === null || i === void 0) && i.kind) {
			let s = n.getDirectives().filter((o) => d2(t.prevState, o))
			return Dr(
				e,
				s.map((o) => ({ label: o.name, documentation: o.description || '', kind: Rn.Function }))
			)
		}
		return []
	}
	function Bc(e, t, n = 0) {
		let r = null,
			i = null,
			s = null,
			o = Pc(e, (a, u, h, N) => {
				if (!(N !== t.line || a.getCurrentPosition() + n < t.character + 1))
					return (r = h), (i = Object.assign({}, u)), (s = a.current()), 'BREAK'
			})
		return {
			start: o.start,
			end: o.end,
			string: s || o.string,
			state: i || o.state,
			style: r || o.style
		}
	}
	function Pc(e, t) {
		let n = e.split(`
`),
			r = co(),
			i = r.startState(),
			s = '',
			o = new rs('')
		for (let a = 0; a < n.length; a++) {
			for (o = new rs(n[a]); !o.eol() && ((s = r.token(o, i)), t(o, i, s, a) !== 'BREAK'); );
			t(o, i, s, a), i.kind || (i = r.startState())
		}
		return {
			start: o.getStartOfToken(),
			end: o.getCurrentPosition(),
			string: o.current(),
			state: i,
			style: s
		}
	}
	function d2(e, t) {
		if (!e?.kind) return !1
		let { kind: n, prevState: r } = e,
			{ locations: i } = t
		switch (n) {
			case kt.QUERY:
				return i.includes(Jt.QUERY)
			case kt.MUTATION:
				return i.includes(Jt.MUTATION)
			case kt.SUBSCRIPTION:
				return i.includes(Jt.SUBSCRIPTION)
			case kt.FIELD:
			case kt.ALIASED_FIELD:
				return i.includes(Jt.FIELD)
			case kt.FRAGMENT_DEFINITION:
				return i.includes(Jt.FRAGMENT_DEFINITION)
			case kt.FRAGMENT_SPREAD:
				return i.includes(Jt.FRAGMENT_SPREAD)
			case kt.INLINE_FRAGMENT:
				return i.includes(Jt.INLINE_FRAGMENT)
			case kt.SCHEMA_DEF:
				return i.includes(Jt.SCHEMA)
			case kt.SCALAR_DEF:
				return i.includes(Jt.SCALAR)
			case kt.OBJECT_TYPE_DEF:
				return i.includes(Jt.OBJECT)
			case kt.FIELD_DEF:
				return i.includes(Jt.FIELD_DEFINITION)
			case kt.INTERFACE_DEF:
				return i.includes(Jt.INTERFACE)
			case kt.UNION_DEF:
				return i.includes(Jt.UNION)
			case kt.ENUM_DEF:
				return i.includes(Jt.ENUM)
			case kt.ENUM_VALUE:
				return i.includes(Jt.ENUM_VALUE)
			case kt.INPUT_DEF:
				return i.includes(Jt.INPUT_OBJECT)
			case kt.INPUT_VALUE_DEF:
				switch (r?.kind) {
					case kt.ARGUMENTS_DEF:
						return i.includes(Jt.ARGUMENT_DEFINITION)
					case kt.INPUT_DEF:
						return i.includes(Jt.INPUT_FIELD_DEFINITION)
				}
		}
		return !1
	}
	function Mc(e, t) {
		let n, r, i, s, o, a, u, h, N, I, Q
		return (
			gd(t, (K) => {
				var ue
				switch (K.kind) {
					case kt.QUERY:
					case 'ShortQuery':
						I = e.getQueryType()
						break
					case kt.MUTATION:
						I = e.getMutationType()
						break
					case kt.SUBSCRIPTION:
						I = e.getSubscriptionType()
						break
					case kt.INLINE_FRAGMENT:
					case kt.FRAGMENT_DEFINITION:
						K.type && (I = e.getType(K.type))
						break
					case kt.FIELD:
					case kt.ALIASED_FIELD: {
						!I || !K.name
							? (o = null)
							: ((o = N ? Sc(e, N, K.name) : null), (I = o ? o.type : null))
						break
					}
					case kt.SELECTION_SET:
						N = or(I)
						break
					case kt.DIRECTIVE:
						i = K.name ? e.getDirective(K.name) : null
						break
					case kt.INTERFACE_DEF:
						K.name && ((u = null), (Q = new ri({ name: K.name, interfaces: [], fields: {} })))
						break
					case kt.OBJECT_TYPE_DEF:
						K.name && ((Q = null), (u = new Pr({ name: K.name, interfaces: [], fields: {} })))
						break
					case kt.ARGUMENTS: {
						if (K.prevState)
							switch (K.prevState.kind) {
								case kt.FIELD:
									r = o && o.args
									break
								case kt.DIRECTIVE:
									r = i && i.args
									break
								case kt.ALIASED_FIELD: {
									let ze = (ue = K.prevState) === null || ue === void 0 ? void 0 : ue.name
									if (!ze) {
										r = null
										break
									}
									let it = N ? Sc(e, N, ze) : null
									if (!it) {
										r = null
										break
									}
									r = it.args
									break
								}
								default:
									r = null
									break
							}
						else r = null
						break
					}
					case kt.ARGUMENT:
						if (r) {
							for (let ze = 0; ze < r.length; ze++)
								if (r[ze].name === K.name) {
									n = r[ze]
									break
								}
						}
						a = n?.type
						break
					case kt.ENUM_VALUE:
						let de = or(a)
						s = de instanceof Kr ? de.getValues().find((ze) => ze.value === K.name) : null
						break
					case kt.LIST_VALUE:
						let Pe = Rs(a)
						a = Pe instanceof cr ? Pe.ofType : null
						break
					case kt.OBJECT_VALUE:
						let Ze = or(a)
						h = Ze instanceof Li ? Ze.getFields() : null
						break
					case kt.OBJECT_FIELD:
						let Ae = K.name && h ? h[K.name] : null
						a = Ae?.type
						break
					case kt.NAMED_TYPE:
						K.name && (I = e.getType(K.name))
						break
				}
			}),
			{
				argDef: n,
				argDefs: r,
				directiveDef: i,
				enumValue: s,
				fieldDef: o,
				inputType: a,
				objectFieldDefs: h,
				parentType: N,
				type: I,
				interfaceDef: Q,
				objectTypeDef: u
			}
		)
	}
	var po
	;(function (e) {
		;(e.TYPE_SYSTEM = 'TYPE_SYSTEM'), (e.EXECUTABLE = 'EXECUTABLE')
	})(po || (po = {}))
	function Hb(e, t) {
		return t?.endsWith('.graphqls') || kb(e) ? po.TYPE_SYSTEM : po.EXECUTABLE
	}
	function h2(e) {
		return e.prevState &&
			e.kind &&
			[kt.NAMED_TYPE, kt.LIST_TYPE, kt.TYPE, kt.NON_NULL_TYPE].includes(e.kind)
			? h2(e.prevState)
			: e
	}
	var Jb = el(g2())
	function ii(e, t) {
		e.push(t)
	}
	function Md(e, t) {
		Nn(t)
			? (Md(e, t.ofType), ii(e, '!'))
			: Zn(t)
			? (ii(e, '['), Md(e, t.ofType), ii(e, ']'))
			: ii(e, t.name)
	}
	function $c(e, t, n) {
		let r = [],
			i = 'type' in e ? e.type : e
		return (
			'type' in e &&
				e.description &&
				(ii(r, e.description),
				ii(
					r,
					`

`
				)),
			ii(r, zb(i, t)),
			n
				? (ii(
						r,
						`
`
				  ),
				  ii(r, n))
				: !Vr(i) && 'description' in i && i.description
				? (ii(
						r,
						`
`
				  ),
				  ii(r, i.description))
				: 'ofType' in i &&
				  !Vr(i.ofType) &&
				  'description' in i.ofType &&
				  i.ofType.description &&
				  (ii(
						r,
						`
`
				  ),
				  ii(r, i.ofType.description)),
			r.join('')
		)
	}
	function zb(e, t) {
		let n = []
		return t && ii(n, '```graphql\n'), Md(n, e), t && ii(n, '\n```'), n.join('')
	}
	var Qb = {
			Int: { type: 'integer' },
			String: { type: 'string' },
			Float: { type: 'number' },
			ID: { type: 'string' },
			Boolean: { type: 'boolean' },
			DateTime: { type: 'string' }
		},
		jd = class {
			constructor() {
				this.set = new Set()
			}
			mark(t) {
				return this.set.has(t) ? !1 : (this.set.add(t), !0)
			}
		}
	function $d(e, t) {
		var n, r
		let i = Object.create(null),
			s = Object.create(null),
			a = 'type' in e ? e.type : e,
			u = Nn(a) ? a.ofType : a,
			h = Nn(a)
		if (Vr(u))
			!((n = t?.scalarSchemas) === null || n === void 0) && n[u.name]
				? (i = JSON.parse(JSON.stringify(t.scalarSchemas[u.name])))
				: (i.type = ['string', 'number', 'boolean', 'integer']),
				h ||
					(Array.isArray(i.type)
						? i.type.push('null')
						: i.type
						? (i.type = [i.type, 'null'])
						: i.enum
						? i.enum.push(null)
						: i.oneOf
						? i.oneOf.push({ type: 'null' })
						: (i = { oneOf: [i, { type: 'null' }] }))
		else if (fr(u)) (i.enum = u.getValues().map((I) => I.name)), h || i.enum.push(null)
		else if (Zn(u)) {
			h ? (i.type = 'array') : (i.type = ['array', 'null'])
			let { definition: I, definitions: Q } = $d(u.ofType, t)
			if (((i.items = I), Q)) for (let K of Object.keys(Q)) s[K] = Q[K]
		} else if (
			Yn(u) &&
			(h
				? (i.$ref = `#/definitions/${u.name}`)
				: (i.oneOf = [{ $ref: `#/definitions/${u.name}` }, { type: 'null' }]),
			!((r = t?.definitionMarker) === null || r === void 0) && r.mark(u.name))
		) {
			let I = u.getFields(),
				Q = { type: 'object', properties: {}, required: [] }
			;(Q.description = $c(u)), t?.useMarkdownDescription && (Q.markdownDescription = $c(u, !0))
			for (let K of Object.keys(I)) {
				let ue = I[K],
					{ required: de, definition: Pe, definitions: Ze } = $d(ue, t)
				if (((Q.properties[K] = Pe), de && Q.required.push(K), Ze))
					for (let [Ae, ze] of Object.entries(Ze)) s[Ae] = ze
			}
			s[u.name] = Q
		}
		'defaultValue' in e && e.defaultValue !== void 0 && (i.default = e.defaultValue)
		let { description: N } = i
		return (
			(i.description = $c(e, !1, N)),
			t?.useMarkdownDescription && (i.markdownDescription = $c(e, !0, N)),
			{ required: h, definition: i, definitions: s }
		)
	}
	function Vc(e, t) {
		var n
		let r = {
				$schema: 'http://json-schema.org/draft-04/schema',
				type: 'object',
				properties: {},
				required: []
			},
			i = Object.assign(Object.assign({}, t), {
				definitionMarker: new jd(),
				scalarSchemas: Object.assign(Object.assign({}, Qb), t?.scalarSchemas)
			})
		if (e)
			for (let [s, o] of Object.entries(e)) {
				let { definition: a, required: u, definitions: h } = $d(o, i)
				;(r.properties[s] = a),
					u && ((n = r.required) === null || n === void 0 || n.push(s)),
					h && (r.definitions = Object.assign(Object.assign({}, r?.definitions), h))
			}
		return r
	}
	var fo = class {
			constructor(t, n) {
				;(this.containsPosition = (r) =>
					this.start.line === r.line
						? this.start.character <= r.character
						: this.end.line === r.line
						? this.end.character >= r.character
						: this.start.line <= r.line && this.end.line >= r.line),
					(this.start = t),
					(this.end = n)
			}
			setStart(t, n) {
				this.start = new Ni(t, n)
			}
			setEnd(t, n) {
				this.end = new Ni(t, n)
			}
		},
		Ni = class {
			constructor(t, n) {
				;(this.lessThanOrEqualTo = (r) =>
					this.line < r.line || (this.line === r.line && this.character <= r.character)),
					(this.line = t),
					(this.character = n)
			}
			setLine(t) {
				this.line = t
			}
			setCharacter(t) {
				this.character = t
			}
		}
	var Yb = [aa, ma, ga, da, ha, fa, so, io, ao, la, oo, uo]
	function Uc(e, t, n, r, i) {
		let s = Da.filter((a) => !(a === ua || a === sa || (r && a === oa)))
		return (
			n && Array.prototype.push.apply(s, n),
			i && Array.prototype.push.apply(s, Yb),
			ya(e, t, s).filter((a) => {
				if (a.message.includes('Unknown directive') && a.nodes) {
					let u = a.nodes[0]
					if (u && u.kind === oe.DIRECTIVE) {
						let h = u.name.value
						if (h === 'arguments' || h === 'argumentDefinitions') return !1
					}
				}
				return !0
			})
		)
	}
	function qc(e, t) {
		let n = Object.create(null)
		for (let r of t.definitions)
			if (r.kind === 'OperationDefinition') {
				let { variableDefinitions: i } = r
				if (i)
					for (let { variable: s, type: o } of i) {
						let a = br(e, o)
						a
							? (n[s.name.value] = a)
							: o.kind === oe.NAMED_TYPE && o.name.value === 'Float' && (n[s.name.value] = gu)
					}
			}
		return n
	}
	function Gc(e, t) {
		let n = t ? qc(t, e) : void 0,
			r = []
		return (
			Jr(e, {
				OperationDefinition(i) {
					r.push(i)
				}
			}),
			{ variableToType: n, operations: r }
		)
	}
	var Fu = { Error: 'Error', Warning: 'Warning', Information: 'Information', Hint: 'Hint' },
		Wc = { [Fu.Error]: 1, [Fu.Warning]: 2, [Fu.Information]: 3, [Fu.Hint]: 4 },
		Hc = (e, t) => {
			if (!e) throw new Error(t)
		}
	function Ud(e, t = null, n, r, i) {
		var s, o
		let a = null,
			u = ''
		i &&
			(u =
				typeof i == 'string'
					? i
					: i.reduce(
							(N, I) =>
								N +
								tr(I) +
								`

`,
							''
					  ))
		let h = u
			? `${e}

${u}`
			: e
		try {
			a = Pi(h)
		} catch (N) {
			if (N instanceof et) {
				let I = Jc(
					(o = (s = N.locations) === null || s === void 0 ? void 0 : s[0]) !== null && o !== void 0
						? o
						: { line: 0, column: 0 },
					h
				)
				return [{ severity: Wc.Error, message: N.message, source: 'GraphQL: Syntax', range: I }]
			}
			throw N
		}
		return y2(a, t, n, r)
	}
	function y2(e, t = null, n, r) {
		if (!t) return []
		let i = Uc(t, e, n, r).flatMap((o) => D2(o, Wc.Error, 'Validation')),
			s = ya(t, e, [Ac]).flatMap((o) => D2(o, Wc.Warning, 'Deprecation'))
		return i.concat(s)
	}
	function D2(e, t, n) {
		if (!e.nodes) return []
		let r = []
		for (let [i, s] of e.nodes.entries()) {
			let o =
				s.kind !== 'Variable' && 'name' in s && s.name !== void 0
					? s.name
					: 'variable' in s && s.variable !== void 0
					? s.variable
					: s
			if (o) {
				Hc(e.locations, 'GraphQL validation error requires locations.')
				let a = e.locations[i],
					u = i5(o),
					h = a.column + (u.end - u.start)
				r.push({
					source: `GraphQL: ${n}`,
					message: e.message,
					severity: t,
					range: new fo(new Ni(a.line - 1, a.column - 1), new Ni(a.line - 1, h))
				})
			}
		}
		return r
	}
	function Jc(e, t) {
		let n = co(),
			r = n.startState(),
			i = t.split(`
`)
		Hc(i.length >= e.line, 'Query text must have more lines than where the error happened')
		let s = null
		for (let h = 0; h < e.line; h++)
			for (s = new rs(i[h]); !s.eol() && n.token(s, r) !== 'invalidchar'; );
		Hc(s, 'Expected Parser stream to be available.')
		let o = e.line - 1,
			a = s.getStartOfToken(),
			u = s.getCurrentPosition()
		return new fo(new Ni(o, a), new Ni(o, u))
	}
	function i5(e) {
		let n = e.loc
		return Hc(n, 'Expected ASTNode to have a location.'), n
	}
	var { INLINE_FRAGMENT: zL } = oe
	function zc(e, t, n, r, i) {
		let s = r || Bc(t, n)
		if (!e || !s || !s.state) return ''
		let { kind: o, step: a } = s.state,
			u = Mc(e, s.state),
			h = Object.assign(Object.assign({}, i), { schema: e })
		if (
			(o === 'Field' && a === 0 && u.fieldDef) ||
			(o === 'AliasedField' && a === 2 && u.fieldDef)
		) {
			let N = []
			return _u(N, h), s5(N, u, h), wu(N, h), Lu(N, h, u.fieldDef), N.join('').trim()
		}
		if (o === 'Directive' && a === 1 && u.directiveDef) {
			let N = []
			return _u(N, h), v2(N, u, h), wu(N, h), Lu(N, h, u.directiveDef), N.join('').trim()
		}
		if (o === 'Argument' && a === 0 && u.argDef) {
			let N = []
			return _u(N, h), o5(N, u, h), wu(N, h), Lu(N, h, u.argDef), N.join('').trim()
		}
		if (o === 'EnumValue' && u.enumValue && 'description' in u.enumValue) {
			let N = []
			return _u(N, h), a5(N, u, h), wu(N, h), Lu(N, h, u.enumValue), N.join('').trim()
		}
		if (o === 'NamedType' && u.type && 'description' in u.type) {
			let N = []
			return _u(N, h), Ta(N, u, h, u.type), wu(N, h), Lu(N, h, u.type), N.join('').trim()
		}
		return ''
	}
	function _u(e, t) {
		t.useMarkdown && Mr(e, '```graphql\n')
	}
	function wu(e, t) {
		t.useMarkdown && Mr(e, '\n```')
	}
	function s5(e, t, n) {
		E2(e, t, n), x2(e, t, n, t.type)
	}
	function E2(e, t, n) {
		if (!t.fieldDef) return
		let r = t.fieldDef.name
		r.slice(0, 2) !== '__' && (Ta(e, t, n, t.parentType), Mr(e, '.')), Mr(e, r)
	}
	function v2(e, t, n) {
		if (!t.directiveDef) return
		let r = '@' + t.directiveDef.name
		Mr(e, r)
	}
	function o5(e, t, n) {
		if ((t.directiveDef ? v2(e, t, n) : t.fieldDef && E2(e, t, n), !t.argDef)) return
		let { name: r } = t.argDef
		Mr(e, '('), Mr(e, r), x2(e, t, n, t.inputType), Mr(e, ')')
	}
	function x2(e, t, n, r) {
		Mr(e, ': '), Ta(e, t, n, r)
	}
	function a5(e, t, n) {
		if (!t.enumValue) return
		let { name: r } = t.enumValue
		Ta(e, t, n, t.inputType), Mr(e, '.'), Mr(e, r)
	}
	function Ta(e, t, n, r) {
		r &&
			(r instanceof An
				? (Ta(e, t, n, r.ofType), Mr(e, '!'))
				: r instanceof cr
				? (Mr(e, '['), Ta(e, t, n, r.ofType), Mr(e, ']'))
				: Mr(e, r.name))
	}
	function Lu(e, t, n) {
		if (!n) return
		let r = typeof n.description == 'string' ? n.description : null
		r &&
			(Mr(
				e,
				`

`
			),
			Mr(e, r)),
			u5(e, t, n)
	}
	function u5(e, t, n) {
		if (!n) return
		let r = n.deprecationReason || null
		r &&
			(Mr(
				e,
				`

`
			),
			Mr(e, 'Deprecated: '),
			Mr(e, r))
	}
	function Mr(e, t) {
		e.push(t)
	}
	var W2 = el(G2())
	var Yd = (e, t) => {
		let {
			schema: n,
			documentAST: r,
			introspectionJSON: i,
			introspectionJSONString: s,
			buildSchemaOptions: o,
			documentString: a
		} = e
		if (n) return n
		if (s) {
			let u = JSON.parse(s)
			return Tu(u, o)
		}
		if (a && t) {
			let u = t(a)
			return Au(u, o)
		}
		if (i) return Tu(i, o)
		if (r) return Au(r, o)
		throw new Error('no schema supplied')
	}
	var $5 = new Map(),
		Zc = class {
			_parser = Pi
			_schemas = []
			_schemaCache = $5
			_schemaLoader = Yd
			_parseOptions = void 0
			_customValidationRules = void 0
			_externalFragmentDefinitionNodes = null
			_externalFragmentDefinitionsString = null
			_fillLeafsOnComplete = !1
			constructor({
				parser: t,
				schemas: n,
				parseOptions: r,
				externalFragmentDefinitions: i,
				customValidationRules: s,
				fillLeafsOnComplete: o
			}) {
				;(this._schemaLoader = Yd),
					n && ((this._schemas = n), this._cacheSchemas()),
					t && (this._parser = t),
					(this._fillLeafsOnComplete = o),
					r && (this._parseOptions = r),
					s && (this._customValidationRules = s),
					i &&
						(Array.isArray(i)
							? (this._externalFragmentDefinitionNodes = i)
							: (this._externalFragmentDefinitionsString = i))
			}
			_cacheSchemas() {
				for (let t of this._schemas) this._cacheSchema(t)
			}
			_cacheSchema(t) {
				let n = this._schemaLoader(t, this.parse.bind(this))
				return this._schemaCache.set(t.uri, { ...t, schema: n })
			}
			getSchemaForFile(t) {
				if (!this._schemas?.length) return
				if (this._schemas.length === 1) return this._schemaCache.get(this._schemas[0].uri)
				let n = this._schemas.find((r) =>
					r.fileMatch ? r.fileMatch.some((i) => (0, W2.default)(i)(t)) : !1
				)
				if (n) {
					let r = this._schemaCache.get(n.uri)
					return r || this._cacheSchema(n).get(n.uri)
				}
			}
			getExternalFragmentDefinitions() {
				if (!this._externalFragmentDefinitionNodes && this._externalFragmentDefinitionsString) {
					let t = []
					try {
						Jr(this._parser(this._externalFragmentDefinitionsString), {
							FragmentDefinition(n) {
								t.push(n)
							}
						})
					} catch {
						throw new Error(`Failed parsing externalFragmentDefinitions string:
${this._externalFragmentDefinitionsString}`)
					}
					this._externalFragmentDefinitionNodes = t
				}
				return this._externalFragmentDefinitionNodes
			}
			async updateSchemas(t) {
				;(this._schemas = t), this._cacheSchemas()
			}
			updateSchema(t) {
				let n = this._schemas.findIndex((r) => r.uri === t.uri)
				if (n < 0) {
					console.warn('updateSchema could not find a schema in your config by that URI', t.uri)
					return
				}
				;(this._schemas[n] = t), this._cacheSchema(t)
			}
			addSchema(t) {
				this._schemas.push(t), this._cacheSchema(t)
			}
			parse(t, n) {
				return this._parser(t, n || this._parseOptions)
			}
			getCompletion = (t, n, r) => {
				let i = this.getSchemaForFile(t)
				return !n || n.length < 1 || !i?.schema
					? []
					: Bd(i.schema, n, r, void 0, this.getExternalFragmentDefinitions(), {
							uri: t,
							fillLeafsOnComplete: this._fillLeafsOnComplete
					  })
			}
			getDiagnostics = (t, n, r) => {
				let i = this.getSchemaForFile(t)
				return !n || n.trim().length < 2 || !i?.schema
					? []
					: Ud(
							n,
							i.schema,
							r ?? this._customValidationRules,
							!1,
							this.getExternalFragmentDefinitions()
					  )
			}
			getHover = (t, n, r, i) => {
				let s = this.getSchemaForFile(t)
				if (s && n?.length > 3) return zc(s.schema, n, r, void 0, { useMarkdown: !0, ...i })
			}
			getVariablesJSONSchema = (t, n, r) => {
				let i = this.getSchemaForFile(t)
				if (i && n.length > 3)
					try {
						let s = this.parse(n),
							o = Gc(s, i.schema)
						if (o?.variableToType)
							return Vc(o.variableToType, { ...r, scalarSchemas: i.customScalarSchemas })
					} catch {}
				return null
			}
		}
	function Xd(e) {
		return {
			startLineNumber: e.start.line + 1,
			startColumn: e.start.character + 1,
			endLineNumber: e.end.line + 1,
			endColumn: e.end.character + 1
		}
	}
	function Kd(e) {
		return new Ni(e.lineNumber - 1, e.column - 1)
	}
	function H2(e, t) {
		let n = {
			label: e.label,
			insertText: e.insertText,
			insertTextFormat: e.insertTextFormat,
			sortText: e.sortText,
			filterText: e.filterText,
			documentation: e.documentation,
			detail: e.detail,
			range: t ? Xd(t) : void 0,
			kind: e.kind
		}
		return (
			e.insertTextFormat && (n.insertTextFormat = e.insertTextFormat),
			e.command && (n.command = { ...e.command, id: e.command.command }),
			n
		)
	}
	function J2(e) {
		return {
			startLineNumber: e.range.start.line + 1,
			endLineNumber: e.range.end.line + 1,
			startColumn: e.range.start.character + 1,
			endColumn: e.range.end.character,
			message: e.message,
			severity: 5,
			code: e.code || void 0
		}
	}
	var ep = class {
		_ctx
		_languageService
		_formattingOptions
		constructor(t, n) {
			;(this._ctx = t),
				(this._languageService = new Zc(n.languageConfig)),
				(this._formattingOptions = n.formattingOptions)
		}
		async doValidation(t) {
			try {
				let r = this._getTextModel(t)?.getValue()
				return r ? this._languageService.getDiagnostics(t, r).map(J2) : []
			} catch (n) {
				return console.error(n), []
			}
		}
		async doComplete(t, n) {
			try {
				let i = this._getTextModel(t)?.getValue()
				if (!i) return []
				let s = Kd(n)
				return this._languageService.getCompletion(t, i, s).map((a) => H2(a))
			} catch (r) {
				return console.error(r), []
			}
		}
		async doHover(t, n) {
			try {
				let i = this._getTextModel(t)?.getValue()
				if (!i) return null
				let s = Kd(n)
				return {
					content: this._languageService.getHover(t, i, s),
					range: Xd(Jc({ column: s.character, line: s.line }, i))
				}
			} catch (r) {
				return console.error(r), null
			}
		}
		async doGetVariablesJSONSchema(t) {
			let n = this._getTextModel(t),
				r = n?.getValue()
			if (!n || !r) return null
			let i = this._languageService.getVariablesJSONSchema(t, r, { useMarkdownDescription: !0 })
			return i
				? ((i.$id = 'monaco://variables-schema.json'), (i.title = 'GraphQL Variables'), i)
				: null
		}
		async doFormat(t) {
			let n = this._getTextModel(t),
				r = n?.getValue()
			if (!n || !r) return null
			let i = await Promise.resolve().then(() => el(Q2())),
				s = await Promise.resolve().then(() => el(X2()))
			return i.format(r, {
				parser: 'graphql',
				plugins: [s],
				...this._formattingOptions?.prettierConfig
			})
		}
		_getTextModel(t) {
			let n = this._ctx.getMirrorModels()
			for (let r of n) if (r.uri.toString() === t) return r
			return null
		}
		doUpdateSchema(t) {
			return this._languageService.updateSchema(t)
		}
		doUpdateSchemas(t) {
			return this._languageService.updateSchemas(t)
		}
	}
	self.onmessage = () => {
		bf((e, t) => new ep(e, t))
	}
})()
