import { z } from "zod/v3"

export const flowModuleSchema = z.object({ "id": z.string(), "value": z.discriminatedUnion("type", [z.object({ "input_transforms": z.record(z.discriminatedUnion("type", [z.object({ "value": z.any().optional(), "type": z.literal("static") }), z.object({ "expr": z.string(), "type": z.literal("javascript") })])), "content": z.string(), "language": z.enum(["deno","bun","python3","go","bash","powershell","postgresql","mysql","bigquery","snowflake","mssql","oracledb","graphql","nativets","php"]), "path": z.string().optional(), "lock": z.string().optional(), "type": z.literal("rawscript"), "tag": z.string().optional(), "concurrent_limit": z.number().optional(), "concurrency_time_window_s": z.number().optional(), "custom_concurrency_key": z.string().optional(), "is_trigger": z.boolean().optional(), "assets": z.array(z.object({ "path": z.string(), "kind": z.enum(["s3object","resource","ducklake"]), "access_type": z.enum(["r","w","rw"]).optional(), "alt_access_type": z.enum(["r","w","rw"]).optional() })).optional() }), z.object({ "input_transforms": z.record(z.discriminatedUnion("type", [z.object({ "value": z.any().optional(), "type": z.literal("static") }), z.object({ "expr": z.string(), "type": z.literal("javascript") })])), "path": z.string(), "hash": z.string().optional(), "type": z.literal("script"), "tag_override": z.string().optional(), "is_trigger": z.boolean().optional() }), z.object({ "input_transforms": z.record(z.discriminatedUnion("type", [z.object({ "value": z.any().optional(), "type": z.literal("static") }), z.object({ "expr": z.string(), "type": z.literal("javascript") })])), "path": z.string(), "type": z.literal("flow") }), z.object({ "modules": z.array(z.record(z.any())), "iterator": z.discriminatedUnion("type", [z.object({ "value": z.any().optional(), "type": z.literal("static") }), z.object({ "expr": z.string(), "type": z.literal("javascript") })]), "skip_failures": z.boolean(), "type": z.literal("forloopflow"), "parallel": z.boolean().optional(), "parallelism": z.discriminatedUnion("type", [z.object({ "value": z.any().optional(), "type": z.literal("static") }), z.object({ "expr": z.string(), "type": z.literal("javascript") })]).optional() }), z.object({ "modules": z.array(z.record(z.any())), "skip_failures": z.boolean(), "type": z.literal("whileloopflow"), "parallel": z.boolean().optional(), "parallelism": z.discriminatedUnion("type", [z.object({ "value": z.any().optional(), "type": z.literal("static") }), z.object({ "expr": z.string(), "type": z.literal("javascript") })]).optional() }), z.object({ "branches": z.array(z.object({ "summary": z.string().optional(), "expr": z.string(), "modules": z.array(z.record(z.any())) })), "default": z.array(z.record(z.any())), "type": z.literal("branchone") }), z.object({ "branches": z.array(z.object({ "summary": z.string().optional(), "skip_failure": z.boolean().optional(), "modules": z.array(z.record(z.any())) })), "type": z.literal("branchall"), "parallel": z.boolean().optional() }), z.object({ "type": z.literal("identity"), "flow": z.boolean().optional() }), z.object({ "input_transforms": z.record(z.discriminatedUnion("type", [z.object({ "value": z.any().optional(), "type": z.literal("static") }), z.object({ "expr": z.string(), "type": z.literal("javascript") })])), "tools": z.array(z.object({ "id": z.string(), "summary": z.string().optional(), "value": z.any().superRefine((x, ctx) => {
    const schemas = [z.intersection(z.object({ "tool_type": z.literal("flowmodule") }), z.record(z.any())), z.object({ "tool_type": z.literal("mcp"), "resource_path": z.string(), "include_tools": z.array(z.string()).optional(), "exclude_tools": z.array(z.string()).optional() })];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  }) })), "type": z.literal("aiagent"), "parallel": z.boolean().optional() })]), "stop_after_if": z.object({ "skip_if_stopped": z.boolean().optional(), "expr": z.string(), "error_message": z.string().optional() }).optional(), "stop_after_all_iters_if": z.object({ "skip_if_stopped": z.boolean().optional(), "expr": z.string(), "error_message": z.string().optional() }).optional(), "skip_if": z.object({ "expr": z.string() }).optional(), "sleep": z.discriminatedUnion("type", [z.object({ "value": z.any().optional(), "type": z.literal("static") }), z.object({ "expr": z.string(), "type": z.literal("javascript") })]).optional(), "cache_ttl": z.number().optional(), "timeout": z.discriminatedUnion("type", [z.object({ "value": z.any().optional(), "type": z.literal("static") }), z.object({ "expr": z.string(), "type": z.literal("javascript") })]).optional(), "delete_after_use": z.boolean().optional(), "summary": z.string().optional(), "mock": z.object({ "enabled": z.boolean().optional(), "return_value": z.any().optional() }).optional(), "suspend": z.object({ "required_events": z.number().int().optional(), "timeout": z.number().int().optional(), "resume_form": z.object({ "schema": z.record(z.any()).optional() }).optional(), "user_auth_required": z.boolean().optional(), "user_groups_required": z.discriminatedUnion("type", [z.object({ "value": z.any().optional(), "type": z.literal("static") }), z.object({ "expr": z.string(), "type": z.literal("javascript") })]).optional(), "self_approval_disabled": z.boolean().optional(), "hide_cancel": z.boolean().optional(), "continue_on_disapprove_timeout": z.boolean().optional() }).optional(), "priority": z.number().optional(), "continue_on_error": z.boolean().optional(), "retry": z.object({ "constant": z.object({ "attempts": z.number().int().optional(), "seconds": z.number().int().optional() }).optional(), "exponential": z.object({ "attempts": z.number().int().optional(), "multiplier": z.number().int().optional(), "seconds": z.number().int().optional(), "random_factor": z.number().int().gte(0).lte(100).optional() }).optional(), "retry_if": z.object({ "expr": z.string() }).optional() }).optional() })


export const flowModulesSchema = z.array(flowModuleSchema)
