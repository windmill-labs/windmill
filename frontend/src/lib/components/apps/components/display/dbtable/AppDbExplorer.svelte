<script lang="ts">
	import type {
		AppEditorContext,
		AppViewerContext,
		ComponentCustomCSS,
		RichConfigurations
	} from '../../../types'
	import { components } from '$lib/components/apps/editor/component'
	import ResolveConfig from '../../helpers/ResolveConfig.svelte'
	import { findGridItem, initConfig, initOutput } from '$lib/components/apps/editor/appUtils'
	import {
		ColumnIdentity,
		createPostgresInput,
		getDbSchemas,
		insertRow,
		loadTableMetaData,
		type ColumnMetadata,
		type TableMetadata
	} from './utils'
	import { getContext, tick } from 'svelte'
	import UpdateCell from './UpdateCell.svelte'
	import { workspaceStore, type DBSchemas } from '$lib/stores'
	import Button from '$lib/components/common/button/Button.svelte'
	import { Plus } from 'lucide-svelte'
	import { Drawer, DrawerContent } from '$lib/components/common'
	import InsertRow from './InsertRow.svelte'
	import Portal from 'svelte-portal'
	import { sendUserToast } from '$lib/toast'
	import type { AppInput, StaticInput } from '$lib/components/apps/inputType'
	import DbExplorerCount from './DbExplorerCount.svelte'
	import AppAggridExplorerTable from '../table/AppAggridExplorerTable.svelte'
	import type { IDatasource } from 'ag-grid-community'
	import { RunnableWrapper } from '../../helpers'
	import type RunnableComponent from '../../helpers/RunnableComponent.svelte'

	export let id: string
	export let configuration: RichConfigurations
	export let customCss: ComponentCustomCSS<'dbexplorercomponent'> | undefined = undefined
	export let render: boolean
	export let initializing: boolean = true

	const resolvedConfig = initConfig(
		components['dbexplorercomponent'].initialData.configuration,
		configuration
	)

	const { app, worldStore, mode, selectedComponent } =
		getContext<AppViewerContext>('AppViewerContext')
	const editorContext = getContext<AppEditorContext>('AppEditorContext')

	let input: AppInput | undefined = undefined

	$: editorContext != undefined && $mode == 'dnd' && resolvedConfig.type && listTableIfAvailable()

	$: editorContext != undefined &&
		$mode == 'dnd' &&
		resolvedConfig.type.configuration?.postgresql?.table &&
		listColumnsIfAvailable()

	initializing = false

	let updateCell: UpdateCell
	let explorerCount: DbExplorerCount

	let renderCount = 0
	let insertDrawer: Drawer | undefined = undefined
	let componentContainerHeight: number | undefined = undefined
	let buttonContainerHeight: number | undefined = undefined

	function onUpdate(
		e: CustomEvent<{
			row: number
			columnDef: ColumnMetadata
			column: string
			value: any
			data: any
			oldValue: string | undefined
		}>
	) {
		const { row, columnDef, value, data, oldValue } = e.detail

		updateCell?.triggerUpdate(
			resolvedConfig.type.configuration.postgresql.resource,
			resolvedConfig.type.configuration.postgresql.table ?? 'unknown',
			row,
			columnDef,
			resolvedConfig.columnDefs,
			value,
			data,
			oldValue
		)
	}

	let args: Record<string, any> = {}

	let outputs = initOutput($worldStore, id, {
		selectedRowIndex: 0,
		selectedRow: {},
		selectedRows: [] as any[],
		result: [] as any[],
		loading: false,
		page: 0,
		newChange: { row: 0, column: '', value: undefined },
		ready: undefined as boolean | undefined
	})

	let lastResource: string | undefined = undefined
	async function listTableIfAvailable() {
		let resource = resolvedConfig.type.configuration?.postgresql?.resource
		if (lastResource === resource) return
		lastResource = resource
		const gridItem = findGridItem($app, id)

		if (!gridItem) {
			return
		}

		if (
			'configuration' in gridItem.data?.configuration?.type &&
			'selectOptions' in gridItem.data?.configuration?.type?.configuration?.postgresql?.table
		) {
			gridItem.data.configuration.type.configuration.postgresql.table.selectOptions = []
		}

		if (!resolvedConfig.type?.configuration?.postgresql?.resource) {
			$app = {
				...$app
			}
			return
		}

		if (
			'configuration' in gridItem.data?.configuration?.type &&
			gridItem.data.configuration.type.configuration.postgresql.table
		) {
			gridItem.data.configuration.type.configuration.postgresql.table.loading = true
		}

		try {
			const dbSchemas: DBSchemas = {}

			await getDbSchemas(
				'postgresql',
				resolvedConfig.type.configuration.postgresql.resource.split(':')[1],
				$workspaceStore,
				dbSchemas,
				(message: string) => {}
			)

			if ('configuration' in gridItem.data.configuration.type) {
				gridItem.data.configuration.type.configuration.postgresql.table['selectOptions'] = dbSchemas
					? // @ts-ignore
					  Object.keys(Object.values(dbSchemas)?.[0]?.schema?.public ?? {})
					: []
			}

			$app = {
				...$app
			}
		} catch (e) {}
		if (
			'configuration' in gridItem.data?.configuration?.type &&
			gridItem.data.configuration.type.configuration.postgresql.table
		) {
			gridItem.data.configuration.type.configuration.postgresql.table.loading = false
		}
	}

	let datasource: IDatasource = {
		rowCount: 0,
		getRows: function (params) {
			console.log('asking for ' + params.startRow + ' to ' + params.endRow)
			runnableComponent?.executeComponent(
				{
					...params,
					...extraQueryParams,
					...resolvedConfig.type.configuration.postgresql
				},
				{
					id: `${id}_count`,
					result: outputs.result,
					loading: outputs.loading
				}
			)
			params.successCallback([], 0)
		}
	}

	$: resolvedConfig.type.configuration.postgresql.table && computeCount()

	async function computeCount() {
		let table = resolvedConfig.type.configuration.postgresql.table
		if (table) {
			await explorerCount?.getCount(resolvedConfig.type.configuration.postgresql.resource, table)
		}
	}

	let lastTable: string | undefined = undefined
	async function listColumnsIfAvailable() {
		let table = resolvedConfig.type.configuration?.postgresql?.table
		if (lastTable === table) return
		lastTable = table

		let tableMetadata = await loadTableMetaData(
			resolvedConfig.type.configuration.postgresql.resource,
			$workspaceStore,
			resolvedConfig.type.configuration.postgresql.table
		)
		if (!tableMetadata) return

		const gridItem = findGridItem($app, id)
		if (!gridItem) return

		let columnDefs = gridItem.data.configuration.columnDefs as StaticInput<TableMetadata>

		let old: TableMetadata = (columnDefs?.value as TableMetadata) ?? []
		if (!Array.isArray(old)) {
			console.log('old is not an array RESET')
			old = []
		}
		// console.log('OLD', old)
		// console.log(tableMetadata)
		const oldMap = Object.fromEntries(old.filter((x) => x != undefined).map((x) => [x.field, x]))
		const newMap = Object.fromEntries(tableMetadata?.map((x) => [x.field, x]) ?? [])

		let ncols: any[] = []
		Object.entries(oldMap).forEach(([key, value]) => {
			if (newMap[key]) {
				ncols.push({
					...value,
					...newMap[key]
				})
			}
		})
		Object.entries(newMap).forEach(([key, value]) => {
			if (!oldMap[key]) {
				ncols.push(value)
			}
		})

		console.log(ncols, tableMetadata)
		//@ts-ignore
		gridItem.data.configuration.columnDefs = { value: ncols, type: 'static' }
		gridItem.data = gridItem.data
		$app = $app
		let oldS = $selectedComponent
		$selectedComponent = []
		await tick()
		$selectedComponent = oldS
		renderCount++
	}

	function extractDefaultValue(defaultValue: string | undefined): string | undefined {
		if (defaultValue && defaultValue.includes('::')) {
			const val = defaultValue.split('::')[0]
			if (val.startsWith("'") && val.endsWith("'")) {
				return val.slice(1, -1)
			}
			return val
		}
		return defaultValue
	}

	let isInsertable: boolean = false

	async function insert() {
		try {
			const defaultValue = resolvedConfig.columnDefs.reduce((acc, column) => {
				const hasValue =
					args[column.field] !== undefined &&
					args[column.field] !== null &&
					args[column.field] !== ''
				const hasDefaultValue = column.defaultValue || extractDefaultValue(column?.defaultvalue)

				if (
					column.insert &&
					!column?.isnullable &&
					!hasValue &&
					!hasDefaultValue &&
					column?.isidentity !== ColumnIdentity.Always
				) {
					throw new Error(
						`Column ${column.field} requires a default value as it is non-nullable and no value is provided.`
					)
				}

				// Set the default value for columns with insert true, if no value is provided
				if (column.insert && !hasValue) {
					acc[column.field] = column.defaultValue || extractDefaultValue(column?.defaultvalue)
				}

				return acc
			}, {})

			const allArgs = { ...args, ...defaultValue }

			Object.keys(allArgs).forEach((key) => {
				if (allArgs[key] === null || allArgs[key] === undefined) {
					delete allArgs[key]
				}
			})

			await insertRow(
				resolvedConfig.type.configuration.postgresql.resource,
				$workspaceStore,
				resolvedConfig.type.configuration.postgresql.table,
				allArgs
			)

			insertDrawer?.closeDrawer()
			renderCount++
		} catch (e) {
			sendUserToast(e.message, true)
		}

		args = {}
	}

	$: $worldStore && connectToComponents()

	function connectToComponents() {
		if ($worldStore) {
			const outputs = $worldStore.outputsById[`${id}_count`]
			if (outputs) {
				outputs.result.subscribe(
					{
						id: 'dbexplorer-count-' + id,
						next: (value) => {
							datasource.rowCount = value?.[0]?.count
						}
					},
					datasource.rowCount
				)
			}
		}
	}

	let runnableComponent: RunnableComponent
	let state: any = undefined
</script>

{#each Object.keys(components['dbexplorercomponent'].initialData.configuration) as key (key)}
	<ResolveConfig
		{id}
		extraKey="db_explorer"
		{key}
		bind:resolvedConfig={resolvedConfig[key]}
		configuration={configuration[key]}
	/>
{/each}

<UpdateCell {id} bind:this={updateCell} />
<DbExplorerCount {id} bind:this={explorerCount} />

{datasource.rowCount}
<RunnableWrapper
	noInitialize
	bind:runnableComponent
	recomputeIds={[id]}
	componentInput={input}
	autoRefresh={false}
	{render}
	id={`${id}_count`}
	{outputs}
>
	<div class="h-full" bind:clientHeight={componentContainerHeight}>
		<div class="flex flex-start justify-end p-2" bind:clientHeight={buttonContainerHeight}>
			<Button
				startIcon={{ icon: Plus }}
				color="dark"
				size="xs2"
				on:click={() => {
					insertDrawer?.openDrawer()
				}}
			>
				Insert
			</Button>
		</div>
		{#if resolvedConfig.type.configuration?.postgresql?.resource && resolvedConfig.type.configuration?.postgresql?.table}
			<!-- {JSON.stringify(lastInput)} -->
			<!-- <span class="text-xs">{JSON.stringify(configuration.columnDefs)}</span> -->
			{#key resolvedConfig}
				<AppAggridExplorerTable
					bind:state
					{id}
					{datasource}
					{resolvedConfig}
					{customCss}
					{outputs}
					containerHeight={componentContainerHeight - buttonContainerHeight}
					on:update={onUpdate}
				/>
			{/key}
		{/if}
	</div>
</RunnableWrapper>
<Portal>
	<Drawer bind:this={insertDrawer} size="800px">
		<DrawerContent title="Insert row" on:close={insertDrawer.closeDrawer}>
			<svelte:fragment slot="actions">
				<Button color="dark" size="xs" on:click={insert} disabled={!isInsertable}>Insert</Button>
			</svelte:fragment>

			<InsertRow bind:args bind:isInsertable columnDefs={resolvedConfig.columnDefs} />
		</DrawerContent>
	</Drawer>
</Portal>
