{"version":3,"file":"binding.cjs","sources":["../delta/t3.test.js","../delta/binding.js"],"sourcesContent":["/* eslint-disable */\n// @ts-nocheck\nimport * as t from '../testing.js'\nimport * as delta from './delta.js'\nimport * as s from '../schema.js'\nimport * as array from '../array.js'\n\n/**\n * @template {delta.Delta?} DeltaA\n * @template {delta.Delta?} DeltaB\n * @typedef {{ a: DeltaA?, b: DeltaB? }} TransformResult\n */\n\n/**\n * @template {delta.DeltaBuilder?} DeltaA\n * @template {delta.DeltaBuilder?} DeltaB\n * @param {DeltaA} a\n * @param {DeltaB} b\n * @return {TransformResult<DeltaA?,DeltaB?>}\n */\nexport const transformResult = (a, b) => ({ a, b })\nexport const transformResultEmpty = transformResult(null, null)\n\nlet x = transformResult(delta.create('x'), null)\nx = transformResult(null, null)\n\n/**\n * @template {delta.DeltaAny} DeltaA\n * @template {delta.DeltaAny} DeltaB\n * @typedef {(t:{a:DeltaA?,b:DeltaB?})=>({a:DeltaA?,b:DeltaB?})} DeltaTransformer\n */\n\n/**\n * @template {delta.Delta<string,any,any,any>} A\n * @template {(A extends delta.Delta<infer NodeName,infer Attrs,infer Children,infer Text> ? delta.Delta<`x-${NodeName}`,Attrs,Children,Text> : never)} B\n * @param {TransformResult<A,B>} t\n * @return {TransformResult<A,B>}\n */\nconst rename = t => {\n  /**\n   * @type {any}\n   */\n  const tout = /** @type {any} */ (transformResult(null, null))\n  if (t.a) {\n    const c = /** @type {delta.Delta} */ (t.a.clone())\n    c.name = 'x-' + c.name\n    // @ts-ignore\n    tout.b = c\n  }\n  if (t.b) {\n    const c = /** @type {delta.Delta} */ (t.b.clone())\n    c.name = c.name.slice(2)\n    // @ts-ignore\n    tout.a = c\n  }\n  return tout\n}\n\n/**\n * @param {Set<string>} allowed\n */\nconst filter = (allowed) => {\n  /**\n   * contains inserted items that didn't make it into t.b\n   */\n  const diff = delta.create()\n  /**\n   * @template {delta.Delta<string,any,any,any>?} A\n   * @template {(A extends delta.Delta<infer NodeName,infer Attrs,infer Children,infer Text> ? delta.Delta<`x-${NodeName}`,Attrs,Children,Text> : never)} B\n   * @param {{ a: A?, b: B? }} t\n   * @return {{ a: A?, b: B? }}\n   */\n  return t => {\n    /**\n     * @type {any}\n     */\n    const tout = /** @type {any} */ (transformResult(null, null))\n    if (t.a) {\n      const c = delta.create()\n      let index = 0\n      /**\n       * Split delta into two parts: hidden and visible. hidden contains all \"hidden\" changes (filtered inserts).\n       * visible everything else.\n       *\n       * return visible.rebaseAgainstInverse(diff)\n       * apply `diff.apply(merge)`\n       *\n       */\n      for (const child of t.a.children) {\n        if (delta.$insertOp.check(child)) {\n          for (let i = 0; i < child.insert.length; i++) {\n            const ins = child.insert[i]\n            if (delta.$deltaAny.check(ins) && allowed.has(ins.name)) {\n              ins\n            } else {\n\n            }\n            ins\n          }\n        }\n        if (!delta.$deleteOp.check(child)) {\n          index += child.length\n        }\n      }\n    }\n    if (t.b) {\n    }\n    return tout\n  }\n}\n\nconst dd = delta.create('x', { x: 'dtrn' })\nconst y = rename({ a: delta.create('x', { x: 'dtrn' }), b: null })\n\n/**\n * @template {delta.DeltaAny} DeltaA\n * @template {delta.DeltaAny} Delta_\n * @template {delta.DeltaAny} DeltaB\n * @param {(t:TransformResult<DeltaA,Delta_>)=>TransformResult<DeltaA,Delta_>} t1\n * @param {(t:TransformResult<Delta_,DeltaB>)=>TransformResult<Delta_,DeltaB>} t2\n * @return {(dx:TransformResult<DeltaA,DeltaB>)=>TransformResult<Delta_,DeltaB>}\n */\nconst pipe = (t1, t2) => (dx) => {\n  return /** @type {any} */ (null)\n}\n\n// next idea: Transform object that changes typings\n\n/**\n * Transforms should..\n * - transform from a->b->c->b->a\n * - extendable mod(Transform<A,B>):Transform<A,C>\n * - i can start with id: mod(Id($d))\n */\n\n/**\n * @template {delta.Delta} DeltaA\n * @template {delta.Delta} DeltaB\n * @typedef {{ applyA: (da:DeltaA)=>TransformResult<DeltaA,DeltaB>, applyB: (db:DeltaB)=>TransformResult<DeltaA,DeltaB> }} Transform\n */\n\n/**\n * @template {delta.DeltaBuilder} A\n * @template {delta.DeltaBuilder} B\n */\nclass Transformer {\n  /**\n   * @param {s.Schema<A>} $da\n   */\n  constructor ($da) {\n    this.$da = $da\n    /**\n     * @type {Array<Transform<any,any>>}\n     */\n    this._tr = []\n  }\n\n  /**\n   * @param {TransformResult<A,B>} d\n   * @return {TransformResult<A?,B?>}\n   */\n  apply ({ a, b }) {\n    if (a == null && b == null) return transformResult(null, null)\n    /**\n     * @type {Array<{ a: delta.DeltaBuilder?, b: delta.DeltaBuilder? }>}\n     */\n    const pendingApply = array.unfold(this._tr.length + 2, () => ({ a: null, b: null }))\n    pendingApply[1].a = a\n    pendingApply[pendingApply.length - 2].b = b\n    /**\n     * @param {number} i\n     */\n    const applyTransformI = i => {\n      const p = pendingApply[i + 1]\n      const t = this._tr[i]\n      const aout = p.a !== null ? t.applyA(p.a) : transformResult(null, null)\n      if (p.b !== null) {\n        if (aout.b !== null) {\n          p.b = p.b.rebase(aout.b, true)\n        }\n        const bout = t.applyB(p.b)\n        aout.a = delta.mergeDeltas(aout.a, bout.a)\n        aout.b = delta.mergeDeltas(aout.b, bout.b)\n      }\n      // write out.a into prev.b, and out.b into next.a\n      pendingApply[i].b = delta.mergeDeltas(pendingApply[i].b, aout.a)\n      pendingApply[i + 2].a = delta.mergeDeltas(pendingApply[i + 2].a, aout.b)\n      return aout\n    }\n    let needsBackwardTransform = a != null\n    let needsForwardTransform = b != null\n    while (needsBackwardTransform || needsForwardTransform) {\n      if (needsForwardTransform) {\n        for (let i = 0; i < this._tr.length; i++) {\n          const r = applyTransformI(i)\n          if (i != null) {\n            needsBackwardTransform = needsBackwardTransform || r.a != null\n          }\n        }\n        needsForwardTransform = false\n      }\n      if (needsBackwardTransform) {\n        for (let i = this._tr.length - 1; i >= 0; i--) {\n          const r = applyTransformI(i)\n          if (i != null) {\n            needsForwardTransform = needsForwardTransform || r.b != null\n          }\n        }\n        needsBackwardTransform = false\n      }\n    }\n    return /** @type {TransformResult<A,B>} */ (transformResult(pendingApply[0].b, pendingApply[pendingApply.length - 1].a))\n  }\n}\n//\n// /**\n//  * @template {delta.Delta} D\n//  * @param {s.Schema<D>} $d\n//  * @return {Transformer<D,D>}\n//  */\n// const id = ($d) => /** @type {Transformer<D,D>} */ (new Transformer($d))\n//\n// const q = id(delta.$delta({ name: 'div' }))\n// const q2 = id(delta.$delta({ name: 'div', attrs: { a: s.$string } })).pipe(t.delta('h1', { color: t => query('a')(t), name:'mystuff' }, t => [query('b')(t)]))\n// const q3 = t.delta('h1', { color: t => query('a')(t), name:'mystuff' }, t => [query('b')(t)])(id(delta.$delta({ name: 'div', attrs: { a: s.$string } }))))\n//\n//\n// /**\n//  * @param {Transformer<delta.Delta<any,{ a: string, name: string }>>} t\n//  */\n// const dataToH1 = t => t.delta('h1', { color: t => query('a')(t), name:'mystuff' }, t => [query('b')(t)])(t)\n// const q4 = dataToH1(id(delta.$delta({ name: 'div', attrs: { a: s.$string } })))\n//\n// const dataToH1_2 = t => rename('h1')(renameAttr({ a: 'color' })(static(delta.create('h1', { name: 'mystuff' }, 'some content!'))(t)))\n","/* eslint-disable */\n// @ts-nocheck\n// @todo remove all @ts-nocheck and eslint-disable\n/* global MutationObserver */\nimport { ObservableV2 } from '../observable.js'\nimport * as delta from './delta.js'\nimport * as dt from './t3.test.js' // eslint-disable-line\nimport * as dom from '../dom.js'\nimport * as set from '../set.js'\nimport * as map from '../map.js'\nimport * as error from '../error.js'\nimport * as math from '../math.js'\nimport * as mux from '../mutex.js'\nimport * as s from '../schema.js'\n\n/**\n * @template T\n * @typedef {import('../schema.js').Schema<T>} Schema\n */\n\n/**\n * @template {delta.AbstractDelta} DeltaA\n * @template {delta.AbstractDelta} DeltaB\n */\nexport class Binding {\n  /**\n   * @param {RDT<DeltaA>} a\n   * @param {RDT<DeltaB>} b\n   * @param {dt.Template<any,DeltaA,DeltaB>} template\n   */\n  constructor (a, b, template) {\n    /**\n     * @type {dt.Transformer<any,DeltaA,DeltaB>}\n     */\n    this.t = template.init()\n    this.a = a\n    this.b = b\n    this._mux = mux.createMutex()\n    this._achanged = this.a.on('change', d => this._mux(() => {\n      const tres = this.t.applyA(d)\n      if (tres.a) {\n        a.update(tres.a)\n      }\n      if (tres.b) {\n        b.update(tres.b)\n      }\n    }))\n    this._bchanged = this.b.on('change', d => this._mux(() => {\n      const tres = this.t.applyB(d)\n      if (tres.b) {\n        this.b.update(tres.b)\n      }\n      if (tres.a) {\n        a.update(tres.a)\n      }\n    }))\n  }\n\n  destroy = () => {\n    this.a.off('destroy', this.destroy)\n    this.b.off('destroy', this.destroy)\n    this.a.off('change', this._achanged)\n    this.b.off('change', this._bchanged)\n  }\n}\n\n/**\n * Abstract Interface for a delta-based Replicated Data Type.\n *\n * @template {delta.AbstractDelta} Delta\n * @typedef {ObservableV2<{ 'change': (delta: Delta) => void, 'destroy': (rdt:RDT<Delta>)=>void }> & { update: (delta: Delta) => any, destroy: () => void }} RDT\n */\n\n/**\n * @template {delta.AbstractDelta} DeltaA\n * @template {dt.Template<any,DeltaA,any>} Transformer\n * @param {RDT<DeltaA>} a\n * @param {RDT<Transformer extends dt.Template<any,DeltaA,infer DeltaB> ? DeltaB : never>} b\n * @param {dt.Template<any,DeltaA,any>} template\n */\nexport const bind = (a, b, template) => new Binding(a, b, template)\n\n/**\n * @template {delta.AbstractDelta} Delta\n * @implements RDT<Delta>\n * @extends {ObservableV2<{ change: (delta: Delta) => void, 'destroy': (rdt:DeltaRDT<Delta>)=>void }>}\n */\nclass DeltaRDT extends ObservableV2 {\n  /**\n   * @param {Schema<Delta>} $delta\n   */\n  constructor ($delta) {\n    super()\n    this.$delta = $delta\n    /**\n     * @type {Delta?}\n     */\n    this.state = null\n    this._mux = mux.createMutex()\n  }\n\n  /**\n   * @param {Delta} delta\n   */\n  update = delta => delta.isEmpty() || this._mux(() => {\n    if (this.state != null) {\n      this.state.apply(delta)\n    } else {\n      this.state = delta\n    }\n    this.emit('change', [delta])\n  })\n\n  destroy () {\n    this.emit('destroy', [this])\n    super.destroy()\n  }\n}\n\n/**\n * @template {delta.AbstractDelta} Delta\n * @param {Schema<Delta>} $delta\n */\nexport const deltaRDT = $delta => new DeltaRDT($delta)\n\n/**\n * @param {Node} domNode\n */\nconst domToDelta = domNode => {\n  if (dom.$element.check(domNode)) {\n    const d = delta.node(domNode.nodeName.toLowerCase())\n    for (let i = 0; i < domNode.attributes.length; i++) {\n      const attr = /** @type {Attr} */ (domNode.attributes.item(i))\n      d.attributes.set(attr.nodeName, attr.value)\n    }\n    domNode.childNodes.forEach(child => {\n      d.children.insert(dom.$text.check(child) ? child.textContent : [domToDelta(child)])\n    })\n    return d\n  }\n  error.unexpectedCase()\n}\n\n/**\n * @param {DomDelta} d\n */\nconst deltaToDom = d => {\n  if (delta.$nodeAny.check(d)) {\n    const n = dom.element(d.name)\n    d.attributes.forEach(change => {\n      if (delta.$insertOp.check(change)) {\n        n.setAttribute(change.key, change.value)\n      }\n    })\n    d.children.forEach(child => {\n      if (delta.$insertOp.check(child)) {\n        n.append(...child.insert.map(deltaToDom))\n      } else if (delta.$textOp.check(child)) {\n        n.append(dom.text(child.insert))\n      }\n    })\n    return n\n  }\n  error.unexpectedCase()\n}\n\n/**\n * @param {Element} el\n * @param {delta.Node<string,any,any,any>} d\n */\nconst applyDeltaToDom = (el, d) => {\n  d.attributes.forEach(change => {\n    if (delta.$deleteOp.check(change)) {\n      el.removeAttribute(change.key)\n    } else {\n      el.setAttribute(change.key, change.value)\n    }\n  })\n  let childIndex = 0\n  let childOffset = 0\n  d.children.forEach(change => {\n    let child = el.childNodes[childIndex] || null\n    if (delta.$deleteOp.check(change)) {\n      let len = change.length\n      while (len > 0) {\n        if (dom.$element.check(child)) {\n          child.remove()\n          len--\n        } else if (dom.$text.check(child)) {\n          const childLen = child.length\n          if (childOffset === 0 && childLen <= len) {\n            child.remove()\n            len -= childLen\n          } else {\n            const spliceLen = math.min(len, childLen - childOffset)\n            child.deleteData(childOffset, spliceLen)\n            if (child.length <= childOffset) {\n              childOffset = 0\n              childIndex++\n            }\n          }\n        }\n      }\n    } else if (delta.$insertOp.check(change)) {\n      if (childOffset > 0) {\n        const tchild = dom.$text.cast(child)\n        child = tchild.splitText(childOffset)\n        childIndex++\n        childOffset = 0\n      }\n      el.insertBefore(dom.fragment(change.insert.map(deltaToDom)), child)\n    } else if (delta.$modifyOp.check(change)) {\n      applyDeltaToDom(dom.$element.cast(child), change.modify)\n    } else if (delta.$textOp.check(change)) {\n      el.insertBefore(dom.text(change.insert), child)\n    } else {\n      error.unexpectedCase()\n    }\n  })\n}\n\nexport const $domDelta = delta.$node(s.$string, s.$record(s.$string, s.$string), s.$never, { recursive: true, withText: true })\n\n/**\n * @param {Element} observedNode\n * @param {MutationRecord[]} mutations\n * @param {any} origin assign this origin to the generated delta\n */\nconst _mutationsToDelta = (observedNode, mutations, origin) => {\n  /**\n   * @typedef {{ removedBefore: Map<Node?,number>, added: Set<Node>, modified: number, d: delta.Node }} ChangedNodeInfo\n   */\n  /**\n   * Compute all deltas without recursion.\n   *\n   * 1. mark all changed parents in parentsChanged\n   * 2. fill out necessary information for each changed parent ()\n   */\n  //\n  /**\n   * @type {Map<Node,ChangedNodeInfo>}\n   */\n  const changedNodes = map.create()\n  /**\n   * @param {Node} node\n   * @return {ChangedNodeInfo}\n   */\n  const getChangedNodeInfo = node => map.setIfUndefined(changedNodes, node, () => ({ removedBefore: map.create(), added: set.create(), modified: 0, d: delta.node(node.nodeName.toLowerCase()) }))\n  const observedNodeInfo = getChangedNodeInfo(observedNode)\n  mutations.forEach(mutation => {\n    const target = /** @type {HTMLElement} */ (mutation.target)\n    const parent = target.parentNode\n    const attrName = /** @type {string} */ (mutation.attributeName)\n    const newVal = target.getAttribute(attrName)\n    const info = getChangedNodeInfo(target)\n    const d = info.d\n    // go up the tree and mark that a child has been modified\n    for (let changedParent = parent; changedParent != null && getChangedNodeInfo(changedParent).modified++ > 1 && changedParent !== observedNode; changedParent = changedParent.parentNode) {\n      // nop\n    }\n    switch (mutation.type) {\n      case 'attributes': {\n        const attrs = /** @type {delta.Node<any,any,any>} */ (d).attributes\n        if (newVal == null) {\n          attrs.delete(attrName)\n        } else {\n          attrs.set(/** @type {string} */ (attrName), newVal)\n        }\n        break\n      }\n      case 'characterData': {\n        error.methodUnimplemented()\n        break\n      }\n      case 'childList': {\n        const targetInfo = getChangedNodeInfo(target)\n        mutation.addedNodes.forEach(node => {\n          targetInfo.added.add(node)\n        })\n        const removed = mutation.removedNodes.length\n        if (removed > 0) {\n          // @todo this can't work because next can be null\n          targetInfo.removedBefore.set(mutation.nextSibling, removed)\n        }\n        break\n      }\n    }\n  })\n  changedNodes.forEach((info, node) => {\n    const numOfChildChanges = info.modified + info.removedBefore.size + info.added.size\n    const d = /** @type {delta.Node<any,any,any>} */ (info.d)\n    if (numOfChildChanges > 0) {\n      node.childNodes.forEach(nchild => {\n        if (info.removedBefore.has(nchild)) { // can happen separately\n          d.children.delete(/** @type {number} */ (info.removedBefore.get(nchild)))\n        }\n        if (info.added.has(nchild)) {\n          d.children.insert(dom.$text.check(nchild) ? nchild.textContent : [domToDelta(nchild)])\n        } else if (changedNodes.has(nchild)) {\n          d.children.modify(getChangedNodeInfo(nchild).d)\n        }\n      })\n      // remove items to the end, if necessary\n      d.children.delete(info.removedBefore.get(null) ?? 0)\n    }\n    d.done()\n  })\n  observedNodeInfo.d.origin = origin\n  return observedNodeInfo.d\n}\n\n/**\n * @typedef {delta.RecursiveNode<string, { [key:string]: string }, never, true>} DomDelta\n */\n\n/**\n * @template {DomDelta} [D=DomDelta]\n * @implements RDT<D>\n * @extends {ObservableV2<{ change: (delta: D)=>void, destroy: (rdt:DomRDT<D>)=>void }>}>}\n */\nclass DomRDT extends ObservableV2 {\n  /**\n   * @param {Element} observedNode\n   */\n  constructor (observedNode) {\n    super()\n    this.observedNode = observedNode\n    this._mux = mux.createMutex()\n    this.observer = new MutationObserver(this._mutationHandler)\n    this.observer.observe(observedNode, {\n      subtree: true,\n      childList: true,\n      attributes: true,\n      characterDataOldValue: true\n    })\n  }\n\n  /**\n   * @param {MutationRecord[]} mutations\n   */\n  _mutationHandler = mutations =>\n    mutations.length > 0 && this._mux(() => {\n      this.emit('change', [/** @type {D} */(_mutationsToDelta(this.observedNode, mutations, this))])\n    })\n\n  /**\n   * @param {D} delta\n   */\n  update = delta => {\n    if (delta.origin !== this) {\n      // @todo the retrieved changes must be transformed agains the updated changes. need a proper\n      // transaction system\n      this._mutationHandler(this.observer.takeRecords())\n      this._mux(() => {\n        applyDeltaToDom(this.observedNode, delta)\n        const mutations = this.observer.takeRecords()\n        this.emit('change', [/** @type {D} */(_mutationsToDelta(this.observedNode, mutations, delta.origin))])\n      })\n    }\n  }\n\n  destroy () {\n    this.emit('destroy', [this])\n    super.destroy()\n    this.observer.disconnect()\n  }\n}\n\n/**\n * @param {Element} dom\n */\nexport const domRDT = dom => new DomRDT(dom)\n"],"names":["delta.create","mux.createMutex","ObservableV2","dom.$element","delta.node","dom.$text","error.unexpectedCase","delta.$nodeAny.check","dom.element","delta.$insertOp","delta.$textOp","dom.text","delta.$deleteOp","math.min","dom.fragment","delta.$modifyOp","delta.$node","s.$string","s.$record","s.$never","map.create","map.setIfUndefined","set.create","error.methodUnimplemented"],"mappings":"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"}