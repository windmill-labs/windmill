{"version":3,"file":"ecdsa.cjs","sources":["../crypto/ecdsa.js"],"sourcesContent":["/**\n * ECDSA is an asymmetric key for signing\n */\n\nimport * as webcrypto from 'lib0/webcrypto'\nexport { exportKeyJwk, exportKeyRaw } from './common.js'\n\n/**\n * @typedef {Array<'sign'|'verify'>} Usages\n */\n\n/**\n * @type {Usages}\n */\nconst defaultUsages = ['sign', 'verify']\n\nconst defaultSignAlgorithm = {\n  name: 'ECDSA',\n  hash: 'SHA-384'\n}\n\n/**\n * @experimental The API is not final!\n *\n * Sign a message\n *\n * @param {CryptoKey} key\n * @param {Uint8Array<ArrayBuffer>} data\n * @return {PromiseLike<Uint8Array<ArrayBuffer>>} signature\n */\nexport const sign = (key, data) =>\n  webcrypto.subtle.sign(\n    defaultSignAlgorithm,\n    key,\n    data\n  ).then(signature => new Uint8Array(signature))\n\n/**\n * @experimental The API is not final!\n *\n * Sign a message\n *\n * @param {CryptoKey} key\n * @param {Uint8Array<ArrayBuffer>} signature\n * @param {Uint8Array<ArrayBuffer>} data\n * @return {PromiseLike<boolean>} signature\n */\nexport const verify = (key, signature, data) =>\n  webcrypto.subtle.verify(\n    defaultSignAlgorithm,\n    key,\n    signature,\n    data\n  )\n\nconst defaultKeyAlgorithm = {\n  name: 'ECDSA',\n  namedCurve: 'P-384'\n}\n\n/* c8 ignore next */\n/**\n * @param {Object} opts\n * @param {boolean} [opts.extractable]\n * @param {Usages} [opts.usages]\n */\nexport const generateKeyPair = ({ extractable = false, usages = defaultUsages } = {}) =>\n  webcrypto.subtle.generateKey(\n    defaultKeyAlgorithm,\n    extractable,\n    usages\n  )\n\n/**\n * @param {any} jwk\n * @param {Object} opts\n * @param {boolean} [opts.extractable]\n * @param {Usages} [opts.usages]\n */\nexport const importKeyJwk = (jwk, { extractable = false, usages } = {}) => {\n  if (usages == null) {\n    /* c8 ignore next 2 */\n    usages = jwk.key_ops || defaultUsages\n  }\n  return webcrypto.subtle.importKey('jwk', jwk, defaultKeyAlgorithm, extractable, /** @type {Usages} */ (usages))\n}\n\n/**\n * Only suited for importing public keys.\n *\n * @param {any} raw\n * @param {Object} opts\n * @param {boolean} [opts.extractable]\n * @param {Usages} [opts.usages]\n */\nexport const importKeyRaw = (raw, { extractable = false, usages = defaultUsages } = {}) =>\n  webcrypto.subtle.importKey('raw', raw, defaultKeyAlgorithm, extractable, usages)\n"],"names":["webcrypto"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,aAAa,GAAG,CAAC,MAAM,EAAE,QAAQ,EAAC;AACxC;AACA,MAAM,oBAAoB,GAAG;AAC7B,EAAE,IAAI,EAAE,OAAO;AACf,EAAE,IAAI,EAAE,SAAS;AACjB,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,IAAI,GAAG,CAAC,GAAG,EAAE,IAAI;AAC9B,EAAEA,oBAAS,CAAC,MAAM,CAAC,IAAI;AACvB,IAAI,oBAAoB;AACxB,IAAI,GAAG;AACP,IAAI,IAAI;AACR,GAAG,CAAC,IAAI,CAAC,SAAS,IAAI,IAAI,UAAU,CAAC,SAAS,CAAC,EAAC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,MAAM,GAAG,CAAC,GAAG,EAAE,SAAS,EAAE,IAAI;AAC3C,EAAEA,oBAAS,CAAC,MAAM,CAAC,MAAM;AACzB,IAAI,oBAAoB;AACxB,IAAI,GAAG;AACP,IAAI,SAAS;AACb,IAAI,IAAI;AACR,IAAG;AACH;AACA,MAAM,mBAAmB,GAAG;AAC5B,EAAE,IAAI,EAAE,OAAO;AACf,EAAE,UAAU,EAAE,OAAO;AACrB,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,eAAe,GAAG,CAAC,EAAE,WAAW,GAAG,KAAK,EAAE,MAAM,GAAG,aAAa,EAAE,GAAG,EAAE;AACpF,EAAEA,oBAAS,CAAC,MAAM,CAAC,WAAW;AAC9B,IAAI,mBAAmB;AACvB,IAAI,WAAW;AACf,IAAI,MAAM;AACV,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,YAAY,GAAG,CAAC,GAAG,EAAE,EAAE,WAAW,GAAG,KAAK,EAAE,MAAM,EAAE,GAAG,EAAE,KAAK;AAC3E,EAAE,IAAI,MAAM,IAAI,IAAI,EAAE;AACtB;AACA,IAAI,MAAM,GAAG,GAAG,CAAC,OAAO,IAAI,cAAa;AACzC,GAAG;AACH,EAAE,OAAOA,oBAAS,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,EAAE,GAAG,EAAE,mBAAmB,EAAE,WAAW,yBAAyB,MAAM,EAAE;AACjH,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAAC,YAAY,GAAG,CAAC,GAAG,EAAE,EAAE,WAAW,GAAG,KAAK,EAAE,MAAM,GAAG,aAAa,EAAE,GAAG,EAAE;AACtF,EAAEA,oBAAS,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,EAAE,GAAG,EAAE,mBAAmB,EAAE,WAAW,EAAE,MAAM;;;;;;;;;;"}