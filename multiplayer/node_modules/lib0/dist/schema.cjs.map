{"version":3,"file":"schema.cjs","sources":["../schema.js"],"sourcesContent":["/**\n * @experimental WIP\n *\n * Simple & efficient schemas for your data.\n */\n\nimport * as obj from './object.js'\nimport * as arr from './array.js'\nimport * as error from './error.js'\nimport * as env from './environment.js'\nimport * as equalityTraits from './trait/equality.js'\nimport * as fun from './function.js'\nimport * as string from './string.js'\nimport * as prng from './prng.js'\nimport * as number from './number.js'\n\n/**\n * @typedef {string|number|bigint|boolean|null|undefined|symbol} Primitive\n */\n\n/**\n * @typedef {{ [k:string|number|symbol]: any }} AnyObject\n */\n\n/**\n * @template T\n * @typedef {T extends Schema<infer X> ? X : T} Unwrap\n */\n\n/**\n * @template T\n * @typedef {T extends Schema<infer X> ? X : T} TypeOf\n */\n\n/**\n * @template {readonly unknown[]} T\n * @typedef {T extends readonly [Schema<infer First>, ...infer Rest] ? [First, ...UnwrapArray<Rest>] : [] } UnwrapArray\n */\n\n/**\n * @template T\n * @typedef {T extends Schema<infer S> ? Schema<S> : never} CastToSchema\n */\n\n/**\n * @template {unknown[]} Arr\n * @typedef {Arr extends [...unknown[], infer L] ? L : never} TupleLast\n */\n\n/**\n * @template {unknown[]} Arr\n * @typedef {Arr extends [...infer Fs, unknown] ? Fs : never} TuplePop\n */\n\n/**\n * @template {readonly unknown[]} T\n * @typedef {T extends []\n *   ? {}\n *   : T extends [infer First]\n *   ? First\n *   : T extends [infer First, ...infer Rest]\n *   ? First & Intersect<Rest>\n *   : never\n * } Intersect\n */\n\nconst schemaSymbol = Symbol('0schema')\n\nexport class ValidationError {\n  constructor () {\n    /**\n     * Reverse errors\n     * @type {Array<{ path: string?, expected: string, has: string, message: string? }>}\n     */\n    this._rerrs = []\n  }\n\n  /**\n   * @param {string?} path\n   * @param {string} expected\n   * @param {string} has\n   * @param {string?} message\n   */\n  extend (path, expected, has, message = null) {\n    this._rerrs.push({ path, expected, has, message })\n  }\n\n  toString () {\n    const s = []\n    for (let i = this._rerrs.length - 1; i > 0; i--) {\n      const r = this._rerrs[i]\n      /* c8 ignore next */\n      s.push(string.repeat(' ', (this._rerrs.length - i) * 2) + `${r.path != null ? `[${r.path}] ` : ''}${r.has} doesn't match ${r.expected}. ${r.message}`)\n    }\n    return s.join('\\n')\n  }\n}\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nconst shapeExtends = (a, b) => {\n  if (a === b) return true\n  if (a == null || b == null || a.constructor !== b.constructor) return false\n  if (a[equalityTraits.EqualityTraitSymbol]) return equalityTraits.equals(a, b) // last resort: check equality (do this before array and obj check which don't implement the equality trait)\n  if (arr.isArray(a)) {\n    return arr.every(a, aitem =>\n      arr.some(b, bitem => shapeExtends(aitem, bitem))\n    )\n  } else if (obj.isObject(a)) {\n    return obj.every(a, (aitem, akey) =>\n      shapeExtends(aitem, b[akey])\n    )\n  }\n  /* c8 ignore next */\n  return false\n}\n\n/**\n * @template T\n * @implements {equalityTraits.EqualityTrait}\n */\nexport class Schema {\n  // this.shape must not be defined on Schema. Otherwise typecheck on metatypes (e.g. $$object) won't work as expected anymore\n  /**\n   * If true, the more things are added to the shape the more objects this schema will accept (e.g.\n   * union). By default, the more objects are added, the the fewer objects this schema will accept.\n   * @protected\n   */\n  static _dilutes = false\n\n  /**\n   * @param {Schema<any>} other\n   */\n  extends (other) {\n    let [a, b] = [/** @type {any} */(this).shape, /** @type {any} */ (other).shape]\n    if (/** @type {typeof Schema<any>} */ (this.constructor)._dilutes) [b, a] = [a, b]\n    return shapeExtends(a, b)\n  }\n\n  /**\n   * Overwrite this when necessary. By default, we only check the `shape` property which every shape\n   * should have.\n   * @param {Schema<any>} other\n   */\n  equals (other) {\n    // @ts-ignore\n    return this.constructor === other.constructor && fun.equalityDeep(this.shape, other.shape)\n  }\n\n  [schemaSymbol] () { return true }\n\n  /**\n   * @param {object} other\n   */\n  [equalityTraits.EqualityTraitSymbol] (other) {\n    return this.equals(/** @type {any} */ (other))\n  }\n\n  /**\n   * Use `schema.validate(obj)` with a typed parameter that is already of typed to be an instance of\n   * Schema. Validate will check the structure of the parameter and return true iff the instance\n   * really is an instance of Schema.\n   *\n   * @param {T} o\n   * @return {boolean}\n   */\n  validate (o) {\n    return this.check(o)\n  }\n\n  /* c8 ignore start */\n  /**\n   * Similar to validate, but this method accepts untyped parameters.\n   *\n   * @param {any} _o\n   * @param {ValidationError} [_err]\n   * @return {_o is T}\n   */\n  check (_o, _err) {\n    error.methodUnimplemented()\n  }\n  /* c8 ignore stop */\n\n  /**\n   * @type {Schema<T?>}\n   */\n  get nullable () {\n    // @ts-ignore\n    return $union(this, $null)\n  }\n\n  /**\n   * @type {$Optional<Schema<T>>}\n   */\n  get optional () {\n    return new $Optional(/** @type {Schema<T>} */ (this))\n  }\n\n  /**\n   * Cast a variable to a specific type. Returns the casted value, or throws an exception otherwise.\n   * Use this if you know that the type is of a specific type and you just want to convince the type\n   * system.\n   *\n   * **Do not rely on these error messages!**\n   * Performs an assertion check only if not in a production environment.\n   *\n   * @template OO\n   * @param {OO} o\n   * @return {Extract<OO, T> extends never ? T : (OO extends Array<never> ? T : Extract<OO,T>)}\n   */\n  cast (o) {\n    assert(o, this)\n    return /** @type {any} */ (o)\n  }\n\n  /**\n   * EXPECTO PATRONUM!! ðŸª„\n   * This function protects against type errors. Though it may not work in the real world.\n   *\n   * \"After all this time?\"\n   * \"Always.\" - Snape, talking about type safety\n   *\n   * Ensures that a variable is a a specific type. Returns the value, or throws an exception if the assertion check failed.\n   * Use this if you know that the type is of a specific type and you just want to convince the type\n   * system.\n   *\n   * Can be useful when defining lambdas: `s.lambda(s.$number, s.$void).expect((n) => n + 1)`\n   *\n   * **Do not rely on these error messages!**\n   * Performs an assertion check if not in a production environment.\n   *\n   * @param {T} o\n   * @return {o extends T ? T : never}\n   */\n  expect (o) {\n    assert(o, this)\n    return o\n  }\n}\n\n/**\n * @template {(new (...args:any[]) => any) | ((...args:any[]) => any)} Constr\n * @typedef {Constr extends ((...args:any[]) => infer T) ? T : (Constr extends (new (...args:any[]) => any) ? InstanceType<Constr> : never)} Instance\n */\n\n/**\n * @template {(new (...args:any[]) => any) | ((...args:any[]) => any)} C\n * @extends {Schema<Instance<C>>}\n */\nexport class $ConstructedBy extends Schema {\n  /**\n   * @param {C} c\n   * @param {((o:Instance<C>)=>boolean)|null} check\n   */\n  constructor (c, check) {\n    super()\n    this.shape = c\n    this._c = check\n  }\n\n  /**\n   * @param {any} o\n   * @param {ValidationError} [err]\n   * @return {o is C extends ((...args:any[]) => infer T) ? T : (C extends (new (...args:any[]) => any) ? InstanceType<C> : never)} o\n   */\n  check (o, err = undefined) {\n    const c = o?.constructor === this.shape && (this._c == null || this._c(o))\n    /* c8 ignore next */\n    !c && err?.extend(null, this.shape.name, o?.constructor.name, o?.constructor !== this.shape ? 'Constructor match failed' : 'Check failed')\n    return c\n  }\n}\n\n/**\n * @template {(new (...args:any[]) => any) | ((...args:any[]) => any)} C\n * @param {C} c\n * @param {((o:Instance<C>) => boolean)|null} check\n * @return {CastToSchema<$ConstructedBy<C>>}\n */\nexport const $constructedBy = (c, check = null) => new $ConstructedBy(c, check)\nexport const $$constructedBy = $constructedBy($ConstructedBy)\n\n/**\n * Check custom properties on any object. You may want to overwrite the generated Schema<any>.\n *\n * @extends {Schema<any>}\n */\nexport class $Custom extends Schema {\n  /**\n   * @param {(o:any) => boolean} check\n   */\n  constructor (check) {\n    super()\n    /**\n     * @type {(o:any) => boolean}\n     */\n    this.shape = check\n  }\n\n  /**\n   * @param {any} o\n   * @param {ValidationError} err\n   * @return {o is any}\n   */\n  check (o, err) {\n    const c = this.shape(o)\n    /* c8 ignore next */\n    !c && err?.extend(null, 'custom prop', o?.constructor.name, 'failed to check custom prop')\n    return c\n  }\n}\n\n/**\n * @param {(o:any) => boolean} check\n * @return {Schema<any>}\n */\nexport const $custom = (check) => new $Custom(check)\nexport const $$custom = $constructedBy($Custom)\n\n/**\n * @template {Primitive} T\n * @extends {Schema<T>}\n */\nexport class $Literal extends Schema {\n  /**\n   * @param {Array<T>} literals\n   */\n  constructor (literals) {\n    super()\n    this.shape = literals\n  }\n\n  /**\n   *\n   * @param {any} o\n   * @param {ValidationError} [err]\n   * @return {o is T}\n   */\n  check (o, err) {\n    const c = this.shape.some(a => a === o)\n    /* c8 ignore next */\n    !c && err?.extend(null, this.shape.join(' | '), o.toString())\n    return c\n  }\n}\n\n/**\n * @template {Primitive[]} T\n * @param {T} literals\n * @return {CastToSchema<$Literal<T[number]>>}\n */\nexport const $literal = (...literals) => new $Literal(literals)\nexport const $$literal = $constructedBy($Literal)\n\n/**\n * @template {Array<string|Schema<string|number>>} Ts\n * @typedef {Ts extends [] ? `` : (Ts extends [infer T] ? (Unwrap<T> extends (string|number) ? Unwrap<T> : never) : (Ts extends [infer T1, ...infer Rest] ? `${Unwrap<T1> extends (string|number) ? Unwrap<T1> : never}${Rest extends Array<string|Schema<string|number>> ? CastStringTemplateArgsToTemplate<Rest> : never}` : never))} CastStringTemplateArgsToTemplate\n */\n\n/**\n * @param {string} str\n * @return {string}\n */\nconst _regexEscape = /** @type {any} */ (RegExp).escape || /** @type {(str:string) => string} */ (str =>\n  str.replace(/[().|&,$^[\\]]/g, s => '\\\\' + s)\n)\n\n/**\n * @param {string|Schema<any>} s\n * @return {string[]}\n */\nconst _schemaStringTemplateToRegex = s => {\n  if ($string.check(s)) {\n    return [_regexEscape(s)]\n  }\n  if ($$literal.check(s)) {\n    return /** @type {Array<string|number>} */ (s.shape).map(v => v + '')\n  }\n  if ($$number.check(s)) {\n    return ['[+-]?\\\\d+.?\\\\d*']\n  }\n  if ($$string.check(s)) {\n    return ['.*']\n  }\n  if ($$union.check(s)) {\n    return s.shape.map(_schemaStringTemplateToRegex).flat(1)\n  }\n  /* c8 ignore next 2 */\n  // unexpected schema structure (only supports unions and string in literal types)\n  error.unexpectedCase()\n}\n\n/**\n * @template {Array<string|Schema<string|number>>} T\n * @extends {Schema<CastStringTemplateArgsToTemplate<T>>}\n */\nexport class $StringTemplate extends Schema {\n  /**\n   * @param {T} shape\n   */\n  constructor (shape) {\n    super()\n    this.shape = shape\n    this._r = new RegExp('^' + shape.map(_schemaStringTemplateToRegex).map(opts => `(${opts.join('|')})`).join('') + '$')\n  }\n\n  /**\n   * @param {any} o\n   * @param {ValidationError} [err]\n   * @return {o is CastStringTemplateArgsToTemplate<T>}\n   */\n  check (o, err) {\n    const c = this._r.exec(o) != null\n    /* c8 ignore next */\n    !c && err?.extend(null, this._r.toString(), o.toString(), 'String doesn\\'t match string template.')\n    return c\n  }\n}\n\n/**\n * @template {Array<string|Schema<string|number>>} T\n * @param {T} literals\n * @return {CastToSchema<$StringTemplate<T>>}\n */\nexport const $stringTemplate = (...literals) => new $StringTemplate(literals)\nexport const $$stringTemplate = $constructedBy($StringTemplate)\n\nconst isOptionalSymbol = Symbol('optional')\n/**\n * @template {Schema<any>} S\n * @extends Schema<Unwrap<S>|undefined>\n */\nclass $Optional extends Schema {\n  /**\n   * @param {S} shape\n   */\n  constructor (shape) {\n    super()\n    this.shape = shape\n  }\n\n  /**\n   * @param {any} o\n   * @param {ValidationError} [err]\n   * @return {o is (Unwrap<S>|undefined)}\n   */\n  check (o, err) {\n    const c = o === undefined || this.shape.check(o)\n    /* c8 ignore next */\n    !c && err?.extend(null, 'undefined (optional)', '()')\n    return c\n  }\n\n  get [isOptionalSymbol] () { return true }\n}\nexport const $$optional = $constructedBy($Optional)\n\n/**\n * @extends Schema<never>\n */\nclass $Never extends Schema {\n  /**\n   * @param {any} _o\n   * @param {ValidationError} [err]\n   * @return {_o is never}\n   */\n  check (_o, err) {\n    /* c8 ignore next */\n    err?.extend(null, 'never', typeof _o)\n    return false\n  }\n}\n\n/**\n * @type {Schema<never>}\n */\nexport const $never = new $Never()\nexport const $$never = $constructedBy($Never)\n\n/**\n * @template {{ [key: string|symbol|number]: Schema<any> }} S\n * @typedef {{ [Key in keyof S as S[Key] extends $Optional<Schema<any>> ? Key : never]?: S[Key] extends $Optional<Schema<infer Type>> ? Type : never } & { [Key in keyof S as S[Key] extends $Optional<Schema<any>> ? never : Key]: S[Key] extends Schema<infer Type> ? Type : never }} $ObjectToType\n */\n\n/**\n * @template {{[key:string|symbol|number]: Schema<any>}} S\n * @extends {Schema<$ObjectToType<S>>}\n */\nexport class $Object extends Schema {\n  /**\n   * @param {S} shape\n   * @param {boolean} partial\n   */\n  constructor (shape, partial = false) {\n    super()\n    /**\n     * @type {S}\n     */\n    this.shape = shape\n    this._isPartial = partial\n  }\n\n  static _dilutes = true\n\n  /**\n   * @type {Schema<Partial<$ObjectToType<S>>>}\n   */\n  get partial () {\n    return new $Object(this.shape, true)\n  }\n\n  /**\n   * @param {any} o\n   * @param {ValidationError} err\n   * @return {o is $ObjectToType<S>}\n   */\n  check (o, err) {\n    if (o == null) {\n      /* c8 ignore next */\n      err?.extend(null, 'object', 'null')\n      return false\n    }\n    return obj.every(this.shape, (vv, vk) => {\n      const c = (this._isPartial && !obj.hasProperty(o, vk)) || vv.check(o[vk], err)\n      !c && err?.extend(vk.toString(), vv.toString(), typeof o[vk], 'Object property does not match')\n      return c\n    })\n  }\n}\n\n/**\n * @template S\n * @typedef {Schema<{ [Key in keyof S as S[Key] extends $Optional<Schema<any>> ? Key : never]?: S[Key] extends $Optional<Schema<infer Type>> ? Type : never } & { [Key in keyof S as S[Key] extends $Optional<Schema<any>> ? never : Key]: S[Key] extends Schema<infer Type> ? Type : never }>} _ObjectDefToSchema\n */\n\n// I used an explicit type annotation instead of $ObjectToType, so that the user doesn't see the\n// weird type definitions when inspecting type definions.\n/**\n * @template {{ [key:string|symbol|number]: Schema<any> }} S\n * @param {S} def\n * @return {_ObjectDefToSchema<S> extends Schema<infer S> ? Schema<{ [K in keyof S]: S[K] }> : never}\n */\nexport const $object = def => /** @type {any} */ (new $Object(def))\nexport const $$object = $constructedBy($Object)\n/**\n * @type {Schema<{[key:string]: any}>}\n */\nexport const $objectAny = $custom(o => o != null && (o.constructor === Object || o.constructor == null))\n\n/**\n * @template {Schema<string|number|symbol>} Keys\n * @template {Schema<any>} Values\n * @extends {Schema<{ [key in Unwrap<Keys>]: Unwrap<Values> }>}\n */\nexport class $Record extends Schema {\n  /**\n   * @param {Keys} keys\n   * @param {Values} values\n   */\n  constructor (keys, values) {\n    super()\n    this.shape = {\n      keys, values\n    }\n  }\n\n  /**\n   * @param {any} o\n   * @param {ValidationError} err\n   * @return {o is { [key in Unwrap<Keys>]: Unwrap<Values> }}\n   */\n  check (o, err) {\n    return o != null && obj.every(o, (vv, vk) => {\n      const ck = this.shape.keys.check(vk, err)\n      /* c8 ignore next */\n      !ck && err?.extend(vk + '', 'Record', typeof o, ck ? 'Key doesn\\'t match schema' : 'Value doesn\\'t match value')\n      return ck && this.shape.values.check(vv, err)\n    })\n  }\n}\n\n/**\n * @template {Schema<string|number|symbol>} Keys\n * @template {Schema<any>} Values\n * @param {Keys} keys\n * @param {Values} values\n * @return {CastToSchema<$Record<Keys,Values>>}\n */\nexport const $record = (keys, values) => new $Record(keys, values)\nexport const $$record = $constructedBy($Record)\n\n/**\n * @template {Schema<any>[]} S\n * @extends {Schema<{ [Key in keyof S]: S[Key] extends Schema<infer Type> ? Type : never }>}\n */\nexport class $Tuple extends Schema {\n  /**\n   * @param {S} shape\n   */\n  constructor (shape) {\n    super()\n    this.shape = shape\n  }\n\n  /**\n   * @param {any} o\n   * @param {ValidationError} err\n   * @return {o is { [K in keyof S]: S[K] extends Schema<infer Type> ? Type : never }}\n   */\n  check (o, err) {\n    return o != null && obj.every(this.shape, (vv, vk) => {\n      const c = /** @type {Schema<any>} */ (vv).check(o[vk], err)\n      /* c8 ignore next */\n      !c && err?.extend(vk.toString(), 'Tuple', typeof vv)\n      return c\n    })\n  }\n}\n\n/**\n * @template {Array<Schema<any>>} T\n * @param {T} def\n * @return {CastToSchema<$Tuple<T>>}\n */\nexport const $tuple = (...def) => new $Tuple(def)\nexport const $$tuple = $constructedBy($Tuple)\n\n/**\n * @template {Schema<any>} S\n * @extends {Schema<Array<S extends Schema<infer T> ? T : never>>}\n */\nexport class $Array extends Schema {\n  /**\n   * @param {Array<S>} v\n   */\n  constructor (v) {\n    super()\n    /**\n     * @type {Schema<S extends Schema<infer T> ? T : never>}\n     */\n    this.shape = v.length === 1 ? v[0] : new $Union(v)\n  }\n\n  /**\n   * @param {any} o\n   * @param {ValidationError} [err]\n   * @return {o is Array<S extends Schema<infer T> ? T : never>} o\n   */\n  check (o, err) {\n    const c = arr.isArray(o) && arr.every(o, oi => this.shape.check(oi))\n    /* c8 ignore next */\n    !c && err?.extend(null, 'Array', '')\n    return c\n  }\n}\n\n/**\n * @template {Array<Schema<any>>} T\n * @param {T} def\n * @return {Schema<Array<T extends Array<Schema<infer S>> ? S : never>>}\n */\nexport const $array = (...def) => new $Array(def)\nexport const $$array = $constructedBy($Array)\n/**\n * @type {Schema<Array<any>>}\n */\nexport const $arrayAny = $custom(o => arr.isArray(o))\n\n/**\n * @template T\n * @extends {Schema<T>}\n */\nexport class $InstanceOf extends Schema {\n  /**\n   * @param {new (...args:any) => T} constructor\n   * @param {((o:T) => boolean)|null} check\n   */\n  constructor (constructor, check) {\n    super()\n    this.shape = constructor\n    this._c = check\n  }\n\n  /**\n   * @param {any} o\n   * @param {ValidationError} err\n   * @return {o is T}\n   */\n  check (o, err) {\n    const c = o instanceof this.shape && (this._c == null || this._c(o))\n    /* c8 ignore next */\n    !c && err?.extend(null, this.shape.name, o?.constructor.name)\n    return c\n  }\n}\n\n/**\n * @template T\n * @param {new (...args:any) => T} c\n * @param {((o:T) => boolean)|null} check\n * @return {Schema<T>}\n */\nexport const $instanceOf = (c, check = null) => new $InstanceOf(c, check)\nexport const $$instanceOf = $constructedBy($InstanceOf)\n\nexport const $$schema = $instanceOf(Schema)\n\n/**\n * @template {Schema<any>[]} Args\n * @typedef {(...args:UnwrapArray<TuplePop<Args>>)=>Unwrap<TupleLast<Args>>} _LArgsToLambdaDef\n */\n\n/**\n * @template {Array<Schema<any>>} Args\n * @extends {Schema<_LArgsToLambdaDef<Args>>}\n */\nexport class $Lambda extends Schema {\n  /**\n   * @param {Args} args\n   */\n  constructor (args) {\n    super()\n    this.len = args.length - 1\n    this.args = $tuple(...args.slice(-1))\n    this.res = args[this.len]\n  }\n\n  /**\n   * @param {any} f\n   * @param {ValidationError} err\n   * @return {f is _LArgsToLambdaDef<Args>}\n   */\n  check (f, err) {\n    const c = f.constructor === Function && f.length <= this.len\n    /* c8 ignore next */\n    !c && err?.extend(null, 'function', typeof f)\n    return c\n  }\n}\n\n/**\n * @template {Schema<any>[]} Args\n * @param {Args} args\n * @return {Schema<(...args:UnwrapArray<TuplePop<Args>>)=>Unwrap<TupleLast<Args>>>}\n */\nexport const $lambda = (...args) => new $Lambda(args.length > 0 ? args : [$void])\nexport const $$lambda = $constructedBy($Lambda)\n\n/**\n * @type {Schema<Function>}\n */\nexport const $function = $custom(o => typeof o === 'function')\n\n/**\n * @template {Array<Schema<any>>} T\n * @extends {Schema<Intersect<UnwrapArray<T>>>}\n */\nexport class $Intersection extends Schema {\n  /**\n   * @param {T} v\n   */\n  constructor (v) {\n    super()\n    /**\n     * @type {T}\n     */\n    this.shape = v\n  }\n\n  /**\n   * @param {any} o\n   * @param {ValidationError} [err]\n   * @return {o is Intersect<UnwrapArray<T>>}\n   */\n  check (o, err) {\n    // @ts-ignore\n    const c = arr.every(this.shape, check => check.check(o, err))\n    /* c8 ignore next */\n    !c && err?.extend(null, 'Intersectinon', typeof o)\n    return c\n  }\n}\n\n/**\n * @template {Schema<any>[]} T\n * @param {T} def\n * @return {CastToSchema<$Intersection<T>>}\n */\nexport const $intersect = (...def) => new $Intersection(def)\nexport const $$intersect = $constructedBy($Intersection, o => o.shape.length > 0) // Intersection with length=0 is considered \"any\"\n\n/**\n * @template S\n * @extends {Schema<S>}\n */\nexport class $Union extends Schema {\n  static _dilutes = true\n\n  /**\n   * @param {Array<Schema<S>>} v\n   */\n  constructor (v) {\n    super()\n    this.shape = v\n  }\n\n  /**\n   * @param {any} o\n   * @param {ValidationError} [err]\n   * @return {o is S}\n   */\n  check (o, err) {\n    const c = arr.some(this.shape, (vv) => vv.check(o, err))\n    err?.extend(null, 'Union', typeof o)\n    return c\n  }\n}\n\n/**\n * @template {Array<any>} T\n * @param {T} schemas\n * @return {CastToSchema<$Union<Unwrap<ReadSchema<T>>>>}\n */\nexport const $union = (...schemas) => schemas.findIndex($s => $$union.check($s)) >= 0\n  ? $union(...schemas.map($s => $($s)).map($s => $$union.check($s) ? $s.shape : [$s]).flat(1))\n  : (schemas.length === 1\n      ? schemas[0]\n      : new $Union(schemas))\nexport const $$union = /** @type {Schema<$Union<any>>} */ ($constructedBy($Union))\n\nconst _t = () => true\n/**\n * @type {Schema<any>}\n */\nexport const $any = $custom(_t)\nexport const $$any = /** @type {Schema<Schema<any>>} */ ($constructedBy($Custom, o => o.shape === _t))\n\n/**\n * @type {Schema<bigint>}\n */\nexport const $bigint = $custom(o => typeof o === 'bigint')\nexport const $$bigint = /** @type {Schema<Schema<BigInt>>} */ ($custom(o => o === $bigint))\n\n/**\n * @type {Schema<symbol>}\n */\nexport const $symbol = $custom(o => typeof o === 'symbol')\nexport const $$symbol = /** @type {Schema<Schema<Symbol>>} */ ($custom(o => o === $symbol))\n\n/**\n * @type {Schema<number>}\n */\nexport const $number = $custom(o => typeof o === 'number')\nexport const $$number = /** @type {Schema<Schema<number>>} */ ($custom(o => o === $number))\n\n/**\n * @type {Schema<string>}\n */\nexport const $string = $custom(o => typeof o === 'string')\nexport const $$string = /** @type {Schema<Schema<string>>} */ ($custom(o => o === $string))\n\n/**\n * @type {Schema<boolean>}\n */\nexport const $boolean = $custom(o => typeof o === 'boolean')\nexport const $$boolean = /** @type {Schema<Schema<Boolean>>} */ ($custom(o => o === $boolean))\n\n/**\n * @type {Schema<undefined>}\n */\nexport const $undefined = $literal(undefined)\nexport const $$undefined = /** @type {Schema<Schema<undefined>>} */ ($constructedBy($Literal, o => o.shape.length === 1 && o.shape[0] === undefined))\n\n/**\n * @type {Schema<void>}\n */\nexport const $void = $literal(undefined)\nexport const $$void = /** @type {Schema<Schema<void>>} */ ($$undefined)\n\nexport const $null = $literal(null)\nexport const $$null = /** @type {Schema<Schema<null>>} */ ($constructedBy($Literal, o => o.shape.length === 1 && o.shape[0] === null))\n\nexport const $uint8Array = $constructedBy(Uint8Array)\nexport const $$uint8Array = /** @type {Schema<Schema<Uint8Array>>} */ ($constructedBy($ConstructedBy, o => o.shape === Uint8Array))\n\n/**\n * @type {Schema<Primitive>}\n */\nexport const $primitive = $union($number, $string, $null, $undefined, $bigint, $boolean, $symbol)\n\n/**\n * @typedef {JSON[]} JSONArray\n */\n/**\n * @typedef {Primitive|JSONArray|{ [key:string]:JSON }} JSON\n */\n/**\n * @type {Schema<null|number|string|boolean|JSON[]|{[key:string]:JSON}>}\n */\nexport const $json = (() => {\n  const $jsonArr = /** @type {$Array<$any>} */ ($array($any))\n  const $jsonRecord = /** @type {$Record<$string,$any>} */ ($record($string, $any))\n  const $json = $union($number, $string, $null, $boolean, $jsonArr, $jsonRecord)\n  $jsonArr.shape = $json\n  $jsonRecord.shape.values = $json\n  return $json\n})()\n\n/**\n * @template {any} IN\n * @typedef {IN extends Schema<any> ? IN\n *   : (IN extends string|number|boolean|null ? Schema<IN>\n *     : (IN extends new (...args:any[])=>any ? Schema<InstanceType<IN>>\n *       : (IN extends any[] ? Schema<{ [K in keyof IN]: Unwrap<ReadSchema<IN[K]>> }[number]>\n   *       : (IN extends object ? (_ObjectDefToSchema<{[K in keyof IN]:ReadSchema<IN[K]>}> extends Schema<infer S> ? Schema<{ [K in keyof S]: S[K] }> : never)\n   *         : never)\n *         )\n *       )\n *     )\n * } ReadSchemaOld\n */\n\n/**\n * @template {any} IN\n * @typedef {[Extract<IN,Schema<any>>,Extract<IN,string|number|boolean|null>,Extract<IN,new (...args:any[])=>any>,Extract<IN,any[]>,Extract<Exclude<IN,Schema<any>|string|number|boolean|null|(new (...args:any[])=>any)|any[]>,object>] extends [infer Schemas, infer Primitives, infer Constructors, infer Arrs, infer Obj]\n *   ? Schema<\n *       (Schemas extends Schema<infer S> ? S : never)\n *     | Primitives\n *     | (Constructors extends new (...args:any[])=>any ? InstanceType<Constructors> : never)\n *     | (Arrs extends any[] ? { [K in keyof Arrs]: Unwrap<ReadSchema<Arrs[K]>> }[number] : never)\n *     | (Obj extends object ? Unwrap<(_ObjectDefToSchema<{[K in keyof Obj]:ReadSchema<Obj[K]>}> extends Schema<infer S> ? Schema<{ [K in keyof S]: S[K] }> : never)> : never)>\n *   : never\n * } ReadSchema\n */\n\n/**\n * @typedef {ReadSchema<{x:42}|{y:99}|Schema<string>|[1,2,{}]>} Q\n */\n\n/**\n * @template IN\n * @param {IN} o\n * @return {ReadSchema<IN>}\n */\nexport const $ = o => {\n  if ($$schema.check(o)) {\n    return /** @type {any} */ (o)\n  } else if ($objectAny.check(o)) {\n    /**\n     * @type {any}\n     */\n    const o2 = {}\n    for (const k in o) {\n      o2[k] = $(o[k])\n    }\n    return /** @type {any} */ ($object(o2))\n  } else if ($arrayAny.check(o)) {\n    return /** @type {any} */ ($union(...o.map($)))\n  } else if ($primitive.check(o)) {\n    return /** @type {any} */ ($literal(o))\n  } else if ($function.check(o)) {\n    return /** @type {any} */ ($constructedBy(/** @type {any} */ (o)))\n  }\n  /* c8 ignore next */\n  error.unexpectedCase()\n}\n\n/* c8 ignore start */\n/**\n * Assert that a variable is of this specific type.\n * The assertion check is only performed in non-production environments.\n *\n * @type {<T>(o:any,schema:Schema<T>) => asserts o is T}\n */\nexport const assert = env.production\n  ? () => {}\n  : (o, schema) => {\n      const err = new ValidationError()\n      if (!schema.check(o, err)) {\n        throw error.create(`Expected value to be of type ${schema.constructor.name}.\\n${err.toString()}`)\n      }\n    }\n/* c8 ignore end */\n\n/**\n * @template In\n * @template Out\n * @typedef {{ if: Schema<In>, h: (o:In,state?:any)=>Out }} Pattern\n */\n\n/**\n * @template {Pattern<any,any>} P\n * @template In\n * @typedef {ReturnType<Extract<P,Pattern<In extends number ? number : (In extends string ? string : In),any>>['h']>} PatternMatchResult\n */\n\n/**\n * @todo move this to separate library\n * @template {any} [State=undefined]\n * @template {Pattern<any,any>} [Patterns=never]\n */\nexport class PatternMatcher {\n  /**\n   * @param {Schema<State>} [$state]\n   */\n  constructor ($state) {\n    /**\n     * @type {Array<Patterns>}\n     */\n    this.patterns = []\n    this.$state = $state\n  }\n\n  /**\n   * @template P\n   * @template R\n   * @param {P} pattern\n   * @param {(o:NoInfer<Unwrap<ReadSchema<P>>>,s:State)=>R} handler\n   * @return {PatternMatcher<State,Patterns|Pattern<Unwrap<ReadSchema<P>>,R>>}\n   */\n  if (pattern, handler) {\n    // @ts-ignore\n    this.patterns.push({ if: $(pattern), h: handler })\n    // @ts-ignore\n    return this\n  }\n\n  /**\n   * @template R\n   * @param {(o:any,s:State)=>R} h\n   */\n  else (h) {\n    return this.if($any, h)\n  }\n\n  /**\n   * @return {State extends undefined\n   *   ? <In extends Unwrap<Patterns['if']>>(o:In,state?:undefined)=>PatternMatchResult<Patterns,In>\n   *   : <In extends Unwrap<Patterns['if']>>(o:In,state:State)=>PatternMatchResult<Patterns,In>}\n   */\n  done () {\n    // @ts-ignore\n    return /** @type {any} */ (o, s) => {\n      for (let i = 0; i < this.patterns.length; i++) {\n        const p = this.patterns[i]\n        if (p.if.check(o)) {\n          // @ts-ignore\n          return p.h(o, s)\n        }\n      }\n      throw error.create('Unhandled pattern')\n    }\n  }\n}\n\n/**\n * @template [State=undefined]\n * @param {State} [state]\n * @return {PatternMatcher<State extends undefined ? undefined : Unwrap<ReadSchema<State>>>}\n */\nexport const match = state => new PatternMatcher(/** @type {any} */ (state))\n\n/**\n * Helper function to generate a (non-exhaustive) sample set from a gives schema.\n *\n * @type {<T>(o:T,gen:prng.PRNG)=>T}\n */\nconst _random = /** @type {any} */ (match(/** @type {Schema<prng.PRNG>} */ ($any))\n  .if($$number, (_o, gen) => prng.int53(gen, number.MIN_SAFE_INTEGER, number.MAX_SAFE_INTEGER))\n  .if($$string, (_o, gen) => prng.word(gen))\n  .if($$boolean, (_o, gen) => prng.bool(gen))\n  .if($$bigint, (_o, gen) => BigInt(prng.int53(gen, number.MIN_SAFE_INTEGER, number.MAX_SAFE_INTEGER)))\n  .if($$union, (o, gen) => random(gen, prng.oneOf(gen, o.shape)))\n  .if($$object, (o, gen) => {\n    /**\n     * @type {any}\n     */\n    const res = {}\n    for (const k in o.shape) {\n      let prop = o.shape[k]\n      if ($$optional.check(prop)) {\n        if (prng.bool(gen)) { continue }\n        prop = prop.shape\n      }\n      res[k] = _random(prop, gen)\n    }\n    return res\n  })\n  .if($$array, (o, gen) => {\n    const arr = []\n    const n = prng.int32(gen, 0, 42)\n    for (let i = 0; i < n; i++) {\n      arr.push(random(gen, o.shape))\n    }\n    return arr\n  })\n  .if($$literal, (o, gen) => {\n    return prng.oneOf(gen, o.shape)\n  })\n  .if($$null, (o, gen) => {\n    return null\n  })\n  .if($$lambda, (o, gen) => {\n    const res = random(gen, o.res)\n    return () => res\n  })\n  .if($$any, (o, gen) => random(gen, prng.oneOf(gen, [\n    $number, $string, $null, $undefined, $bigint, $boolean,\n    $array($number),\n    $record($union('a', 'b', 'c'), $number)\n  ])))\n  .if($$record, (o, gen) => {\n    /**\n     * @type {any}\n     */\n    const res = {}\n    const keysN = prng.int53(gen, 0, 3)\n    for (let i = 0; i < keysN; i++) {\n      const key = random(gen, o.shape.keys)\n      const val = random(gen, o.shape.values)\n      res[key] = val\n    }\n    return res\n  })\n  .done())\n\n/**\n * @template S\n * @param {prng.PRNG} gen\n * @param {S} schema\n * @return {Unwrap<ReadSchema<S>>}\n */\nexport const random = (gen, schema) => /** @type {any} */ (_random($(schema), gen))\n"],"names":["string.repeat","equalityTraits.EqualityTraitSymbol","equalityTraits.equals","arr.isArray","arr.every","arr.some","obj.isObject","obj.every","fun.equalityDeep","error.methodUnimplemented","error.unexpectedCase","obj.hasProperty","env.production","error.create","prng.int53","number.MIN_SAFE_INTEGER","number.MAX_SAFE_INTEGER","prng.word","prng.bool","prng.oneOf","prng.int32"],"mappings":"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"}