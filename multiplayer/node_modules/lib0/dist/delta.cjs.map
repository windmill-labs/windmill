{"version":3,"file":"delta.cjs","sources":["../delta/delta.js"],"sourcesContent":["/**\n * @beta this API is about to change\n *\n * ## Mutability\n *\n * Deltas are mutable by default. But references are often shared, by marking a Delta as \"done\". You\n * may only modify deltas by applying other deltas to them. Casting a Delta to a DeltaBuilder\n * manually, will likely modify \"shared\" state.\n */\n\nimport * as list from '../list.js'\nimport * as object from '../object.js'\nimport * as equalityTrait from '../trait/equality.js'\nimport * as fingerprintTrait from '../trait/fingerprint.js'\nimport * as arr from '../array.js'\nimport * as fun from '../function.js'\nimport * as s from '../schema.js'\nimport * as error from '../error.js'\nimport * as math from '../math.js'\nimport * as rabin from '../hash/rabin.js'\nimport * as encoding from '../encoding.js'\nimport * as buffer from '../buffer.js'\nimport * as patience from '../diff/patience.js'\nimport * as prng from '../prng.js'\n\n/**\n * @typedef {{\n *   insert?: string[]\n *   insertAt?: number\n *   delete?: string[]\n *   deleteAt?: number\n *   format?: Record<string,string[]>\n *   formatAt?: number\n * }} Attribution\n */\n\n/**\n * @type {s.Schema<Attribution>}\n */\nexport const $attribution = s.$object({\n  insert: s.$array(s.$string).optional,\n  insertAt: s.$number.optional,\n  delete: s.$array(s.$string).optional,\n  deleteAt: s.$number.optional,\n  format: s.$record(s.$string, s.$array(s.$string)).optional,\n  formatAt: s.$number.optional\n})\n\n/**\n * @typedef {s.Unwrap<$anyOp>} DeltaOps\n */\n\n/**\n * @typedef {{ [key: string]: any }} FormattingAttributes\n */\n\n/**\n * @typedef {{\n *   type: 'delta',\n *   name?: string,\n *   attrs?: { [Key in string|number]: DeltaAttrOpJSON },\n *   children?: Array<DeltaListOpJSON>\n * }} DeltaJSON\n */\n\n/**\n * @typedef {{ type: 'insert', insert: string|Array<any>, format?: { [key: string]: any }, attribution?: Attribution } | { delete: number } | { type: 'retain', retain: number, format?: { [key:string]: any }, attribution?: Attribution } | { type: 'modify', value: object }} DeltaListOpJSON\n */\n\n/**\n * @typedef {{ type: 'insert', value: any, prevValue?: any, attribution?: Attribution } | { type: 'delete', prevValue?: any, attribution?: Attribution } | { type: 'modify', value: DeltaJSON }} DeltaAttrOpJSON\n */\n\n/**\n * @typedef {TextOp|InsertOp<any>|DeleteOp|RetainOp|ModifyOp<any>} ChildrenOpAny\n */\n\n/**\n * @typedef {AttrInsertOp<any>|AttrDeleteOp<any>|AttrModifyOp} AttrOpAny\n */\n\n/**\n * @typedef {ChildrenOpAny|AttrOpAny} _OpAny\n */\n\n/**\n * @type {s.Schema<DeltaAttrOpJSON>}\n */\nexport const $deltaMapChangeJson = s.$union(\n  s.$object({ type: s.$literal('insert'), value: s.$any, prevValue: s.$any.optional, attribution: $attribution.optional }),\n  s.$object({ type: s.$literal('modify'), value: s.$any }),\n  s.$object({ type: s.$literal('delete'), prevValue: s.$any.optional, attribution: $attribution.optional })\n)\n\n/**\n * @template {{[key:string]: any} | null} Attrs\n * @param {Attrs} attrs\n * @return {Attrs}\n */\nconst _cloneAttrs = attrs => attrs == null ? attrs : { ...attrs }\n/**\n * @template {any} MaybeDelta\n * @param {MaybeDelta} maybeDelta\n * @return {MaybeDelta}\n */\nconst _markMaybeDeltaAsDone = maybeDelta => $deltaAny.check(maybeDelta) ? /** @type {MaybeDelta} */ (maybeDelta.done()) : maybeDelta\n\nexport class TextOp extends list.ListNode {\n  /**\n   * @param {string} insert\n   * @param {FormattingAttributes|null} format\n   * @param {Attribution?} attribution\n   */\n  constructor (insert, format, attribution) {\n    super()\n    // Whenever this is modified, make sure to clear _fingerprint\n    /**\n     * @readonly\n     * @type {string}\n     */\n    this.insert = insert\n    /**\n     * @readonly\n     * @type {FormattingAttributes|null}\n     */\n    this.format = format\n    this.attribution = attribution\n    /**\n     * @type {string?}\n     */\n    this._fingerprint = null\n  }\n\n  /**\n   * @param {string} newVal\n   */\n  _updateInsert (newVal) {\n    // @ts-ignore\n    this.insert = newVal\n    this._fingerprint = null\n  }\n\n  /**\n   * @return {'insert'}\n   */\n  get type () {\n    return 'insert'\n  }\n\n  get length () {\n    return this.insert.length\n  }\n\n  get fingerprint () {\n    return this._fingerprint || (this._fingerprint = buffer.toBase64(encoding.encode(encoder => {\n      encoding.writeVarUint(encoder, 0) // textOp type: 0\n      encoding.writeVarString(encoder, this.insert)\n      encoding.writeAny(encoder, this.format)\n    })))\n  }\n\n  /**\n   * Remove a part of the operation (similar to Array.splice)\n   *\n   * @param {number} offset\n   * @param {number} len\n   */\n  _splice (offset, len) {\n    this._fingerprint = null\n    // @ts-ignore\n    this.insert = this.insert.slice(0, offset) + this.insert.slice(offset + len)\n    return this\n  }\n\n  /**\n   * @return {DeltaListOpJSON}\n   */\n  toJSON () {\n    const { insert, format, attribution } = this\n    return object.assign(/** @type {{type: 'insert', insert: string}} */ ({ type: 'insert', insert }), format != null ? { format } : ({}), attribution != null ? { attribution } : ({}))\n  }\n\n  /**\n   * @param {TextOp} other\n   */\n  [equalityTrait.EqualityTraitSymbol] (other) {\n    return fun.equalityDeep(this.insert, other.insert) && fun.equalityDeep(this.format, other.format) && fun.equalityDeep(this.attribution, other.attribution)\n  }\n\n  /**\n   * @return {TextOp}\n   */\n  clone (start = 0, end = this.length) {\n    return new TextOp(this.insert.slice(start, end), _cloneAttrs(this.format), _cloneAttrs(this.attribution))\n  }\n}\n\n/**\n * @template {fingerprintTrait.Fingerprintable} ArrayContent\n */\nexport class InsertOp extends list.ListNode {\n  /**\n   * @param {Array<ArrayContent>} insert\n   * @param {FormattingAttributes|null} format\n   * @param {Attribution?} attribution\n   */\n  constructor (insert, format, attribution) {\n    super()\n    /**\n     * @readonly\n     * @type {Array<ArrayContent>}\n     */\n    this.insert = insert\n    /**\n     * @readonly\n     * @type {FormattingAttributes?}\n     */\n    this.format = format\n    /**\n     * @readonly\n     * @type {Attribution?}\n     */\n    this.attribution = attribution\n    /**\n     * @type {string?}\n     */\n    this._fingerprint = null\n  }\n\n  /**\n   * @param {ArrayContent} newVal\n   */\n  _updateInsert (newVal) {\n    // @ts-ignore\n    this.insert = newVal\n    this._fingerprint = null\n  }\n\n  /**\n   * @return {'insert'}\n   */\n  get type () {\n    return 'insert'\n  }\n\n  get length () {\n    return this.insert.length\n  }\n\n  /**\n   * @param {number} i\n   * @return {Extract<ArrayContent,DeltaAny>}\n   */\n  _modValue (i) {\n    /**\n     * @type {any}\n     */\n    let d = this.insert[i]\n    this._fingerprint = null\n    $deltaAny.expect(d)\n    if (d.isDone) {\n      // @ts-ignore\n      this.insert[i] = (d = clone(d))\n      return d\n    }\n    return d\n  }\n\n  get fingerprint () {\n    return this._fingerprint || (this._fingerprint = buffer.toBase64(encoding.encode(encoder => {\n      encoding.writeVarUint(encoder, 1) // insertOp type: 1\n      encoding.writeVarUint(encoder, this.insert.length)\n      this.insert.forEach(ins => {\n        encoding.writeVarString(encoder, fingerprintTrait.fingerprint(ins))\n      })\n      encoding.writeAny(encoder, this.format)\n    })))\n  }\n\n  /**\n   * Remove a part of the operation (similar to Array.splice)\n   *\n   * @param {number} offset\n   * @param {number} len\n   */\n  _splice (offset, len) {\n    this._fingerprint = null\n    this.insert.splice(offset, len)\n    return this\n  }\n\n  /**\n   * @return {DeltaListOpJSON}\n   */\n  toJSON () {\n    const { insert, format, attribution } = this\n    return object.assign({ type: /** @type {'insert'} */ ('insert'), insert: insert.map(ins => $deltaAny.check(ins) ? ins.toJSON() : ins) }, format ? { format } : ({}), attribution != null ? { attribution } : ({}))\n  }\n\n  /**\n   * @param {InsertOp<ArrayContent>} other\n   */\n  [equalityTrait.EqualityTraitSymbol] (other) {\n    return fun.equalityDeep(this.insert, other.insert) && fun.equalityDeep(this.format, other.format) && fun.equalityDeep(this.attribution, other.attribution)\n  }\n\n  /**\n   * @return {InsertOp<ArrayContent>}\n   */\n  clone (start = 0, end = this.length) {\n    return new InsertOp(this.insert.slice(start, end).map(_markMaybeDeltaAsDone), _cloneAttrs(this.format), _cloneAttrs(this.attribution))\n  }\n}\n\n/**\n * @template {fingerprintTrait.Fingerprintable} [Children=never]\n * @template {string} [Text=never]\n */\nexport class DeleteOp extends list.ListNode {\n  /**\n   * @param {number} len\n   */\n  constructor (len) {\n    super()\n    this.delete = len\n    /**\n     * @type {(Children|Text) extends never ? null : (Delta<any,{},Children,Text>?)}\n     */\n    this.prevValue = null\n    /**\n     * @type {string|null}\n     */\n    this._fingerprint = null\n  }\n\n  /**\n   * @return {'delete'}\n   */\n  get type () {\n    return 'delete'\n  }\n\n  get length () {\n    return 0\n  }\n\n  get fingerprint () {\n    return this._fingerprint || (this._fingerprint = buffer.toBase64(encoding.encode(encoder => {\n      encoding.writeVarUint(encoder, 2) // deleteOp type: 2\n      encoding.writeVarUint(encoder, this.delete)\n    })))\n  }\n\n  /**\n   * Remove a part of the operation (similar to Array.splice)\n   *\n   * @param {number} _offset\n   * @param {number} len\n   */\n  _splice (_offset, len) {\n    this.prevValue = /** @type {any} */ (this.prevValue?.slice(_offset, len) || null)\n    this._fingerprint = null\n    this.delete -= len\n    return this\n  }\n\n  /**\n   * @return {DeltaListOpJSON}\n   */\n  toJSON () {\n    return { delete: this.delete }\n  }\n\n  /**\n   * @param {DeleteOp} other\n   */\n  [equalityTrait.EqualityTraitSymbol] (other) {\n    return this.delete === other.delete\n  }\n\n  clone (start = 0, end = this.delete) {\n    return new DeleteOp(end - start)\n  }\n}\n\nexport class RetainOp extends list.ListNode {\n  /**\n   * @param {number} retain\n   * @param {FormattingAttributes|null} format\n   * @param {Attribution?} attribution\n   */\n  constructor (retain, format, attribution) {\n    super()\n    /**\n     * @readonly\n     * @type {number}\n     */\n    this.retain = retain\n    /**\n     * @readonly\n     * @type {FormattingAttributes?}\n     */\n    this.format = format\n    /**\n     * @readonly\n     * @type {Attribution?}\n     */\n    this.attribution = attribution\n    /**\n     * @type {string|null}\n     */\n    this._fingerprint = null\n  }\n\n  /**\n   * @return {'retain'}\n   */\n  get type () {\n    return 'retain'\n  }\n\n  get length () {\n    return this.retain\n  }\n\n  get fingerprint () {\n    return this._fingerprint || (this._fingerprint = buffer.toBase64(encoding.encode(encoder => {\n      encoding.writeVarUint(encoder, 3) // retainOp type: 3\n      encoding.writeVarUint(encoder, this.retain)\n      encoding.writeAny(encoder, this.format)\n    })))\n  }\n\n  /**\n   * Remove a part of the operation (similar to Array.splice)\n   *\n   * @param {number} _offset\n   * @param {number} len\n   */\n  _splice (_offset, len) {\n    // @ts-ignore\n    this.retain -= len\n    this._fingerprint = null\n    return this\n  }\n\n  /**\n   * @return {DeltaListOpJSON}\n   */\n  toJSON () {\n    const { retain, format, attribution } = this\n    return object.assign({ type: /** @type {'retain'} */ ('retain'), retain }, format ? { format } : {}, attribution != null ? { attribution } : {})\n  }\n\n  /**\n   * @param {RetainOp} other\n   */\n  [equalityTrait.EqualityTraitSymbol] (other) {\n    return this.retain === other.retain && fun.equalityDeep(this.format, other.format) && fun.equalityDeep(this.attribution, other.attribution)\n  }\n\n  clone (start = 0, end = this.retain) {\n    return new RetainOp(end - start, _cloneAttrs(this.format), _cloneAttrs(this.attribution))\n  }\n}\n\n/**\n * Delta that can be applied on a YType Embed\n *\n * @template {DeltaAny} [DTypes=DeltaAny]\n */\nexport class ModifyOp extends list.ListNode {\n  /**\n   * @param {DTypes} delta\n   * @param {FormattingAttributes|null} format\n   * @param {Attribution?} attribution\n   */\n  constructor (delta, format, attribution) {\n    super()\n    /**\n     * @readonly\n     * @type {DTypes}\n     */\n    this.value = delta\n    /**\n     * @readonly\n     * @type {FormattingAttributes?}\n     */\n    this.format = format\n    /**\n     * @readonly\n     * @type {Attribution?}\n     */\n    this.attribution = attribution\n    /**\n     * @type {string|null}\n     */\n    this._fingerprint = null\n  }\n\n  /**\n   * @return {'modify'}\n   */\n  get type () {\n    return 'modify'\n  }\n\n  get length () {\n    return 1\n  }\n\n  /**\n   * @type {DeltaBuilderAny}\n   */\n  get _modValue () {\n    /**\n     * @type {any}\n     */\n    const d = this.value\n    this._fingerprint = null\n    if (d.isDone) {\n      // @ts-ignore\n      return (this.value = clone(d))\n    }\n    return d\n  }\n\n  get fingerprint () {\n    // don't cache fingerprint because we don't know when delta changes\n    return this._fingerprint || (this._fingerprint = buffer.toBase64(encoding.encode(encoder => {\n      encoding.writeVarUint(encoder, 4) // modifyOp type: 4\n      encoding.writeVarString(encoder, this.value.fingerprint)\n      encoding.writeAny(encoder, this.format)\n    })))\n  }\n\n  /**\n   * Remove a part of the operation (similar to Array.splice)\n   *\n   * @param {number} _offset\n   * @param {number} _len\n   */\n  _splice (_offset, _len) {\n    return this\n  }\n\n  /**\n   * @return {DeltaListOpJSON}\n   */\n  toJSON () {\n    const { value, attribution, format } = this\n    return object.assign({ type: /** @type {'modify'} */ ('modify'), value: value.toJSON() }, format ? { format } : {}, attribution != null ? { attribution } : {})\n  }\n\n  /**\n   * @param {ModifyOp<any>} other\n   */\n  [equalityTrait.EqualityTraitSymbol] (other) {\n    return this.value[equalityTrait.EqualityTraitSymbol](other.value) && fun.equalityDeep(this.format, other.format) && fun.equalityDeep(this.attribution, other.attribution)\n  }\n\n  /**\n   * @return {ModifyOp<DTypes>}\n   */\n  clone () {\n    return new ModifyOp(/** @type {DTypes} */ (this.value.done()), _cloneAttrs(this.format), _cloneAttrs(this.attribution))\n  }\n}\n\n/**\n * @template {fingerprintTrait.Fingerprintable} V\n * @template {string|number} [K=any]\n */\nexport class AttrInsertOp {\n  /**\n   * @param {K} key\n   * @param {V} value\n   * @param {V|undefined} prevValue\n   * @param {Attribution?} attribution\n   */\n  constructor (key, value, prevValue, attribution) {\n    /**\n     * @readonly\n     * @type {K}\n     */\n    this.key = key\n    /**\n     * @readonly\n     * @type {V}\n     */\n    this.value = value\n    /**\n     * @readonly\n     * @type {V|undefined}\n     */\n    this.prevValue = prevValue\n    /**\n     * @readonly\n     * @type {Attribution?}\n     */\n    this.attribution = attribution\n    /**\n     * @type {string|null}\n     */\n    this._fingerprint = null\n  }\n\n  /**\n   * @return {'insert'}\n   */\n  get type () { return 'insert' }\n\n  /**\n   * @type {DeltaBuilderAny}\n   */\n  get _modValue () {\n    /**\n     * @type {any}\n     */\n    const v = this.value\n    this._fingerprint = null\n    if ($deltaAny.check(v) && v.isDone) {\n      // @ts-ignore\n      return (this.value = clone(v))\n    }\n    return v\n  }\n\n  get fingerprint () {\n    return this._fingerprint || (this._fingerprint = buffer.toBase64(encoding.encode(encoder => {\n      encoding.writeVarUint(encoder, 5) // map insert type: 5\n      encoding.writeAny(encoder, this.key)\n      if ($deltaAny.check(this.value)) {\n        encoding.writeUint8(encoder, 0)\n        encoding.writeVarString(encoder, this.value.fingerprint)\n      } else {\n        encoding.writeUint8(encoder, 1)\n        encoding.writeAny(encoder, this.value)\n      }\n    })))\n  }\n\n  toJSON () {\n    const v = this.value\n    const prevValue = this.prevValue\n    const attribution = this.attribution\n    return object.assign({\n      type: this.type,\n      value: $deltaAny.check(v) ? v.toJSON() : v\n    }, attribution != null ? { attribution } : {}, prevValue !== undefined ? { prevValue } : {})\n  }\n\n  /**\n   * @param {AttrInsertOp<V>} other\n   */\n  [equalityTrait.EqualityTraitSymbol] (other) {\n    return this.key === other.key && fun.equalityDeep(this.value, other.value) && fun.equalityDeep(this.attribution, other.attribution)\n  }\n\n  /**\n   * @return {AttrInsertOp<V,K>}\n   */\n  clone () {\n    return new AttrInsertOp(this.key, _markMaybeDeltaAsDone(this.value), _markMaybeDeltaAsDone(this.prevValue), _cloneAttrs(this.attribution))\n  }\n}\n\n/**\n * @template V\n * @template {string|number} [K=string]\n */\nexport class AttrDeleteOp {\n  /**\n   * @param {K} key\n   * @param {V|undefined} prevValue\n   * @param {Attribution?} attribution\n   */\n  constructor (key, prevValue, attribution) {\n    /**\n     * @type {K}\n     */\n    this.key = key\n    /**\n     * @type {V|undefined}\n     */\n    this.prevValue = prevValue\n    this.attribution = attribution\n    /**\n     * @type {string|null}\n     */\n    this._fingerprint = null\n  }\n\n  get value () { return undefined }\n\n  /**\n   * @type {'delete'}\n   */\n  get type () { return 'delete' }\n\n  get fingerprint () {\n    return this._fingerprint || (this._fingerprint = buffer.toBase64(encoding.encode(encoder => {\n      encoding.writeVarUint(encoder, 6) // map delete type: 6\n      encoding.writeAny(encoder, this.key)\n    })))\n  }\n\n  /**\n   * @return {DeltaAttrOpJSON}\n   */\n  toJSON () {\n    const {\n      type, attribution, prevValue\n    } = this\n    return object.assign({ type }, attribution != null ? { attribution } : {}, prevValue !== undefined ? { prevValue } : {})\n  }\n\n  /**\n   * @param {AttrDeleteOp<V>} other\n   */\n  [equalityTrait.EqualityTraitSymbol] (other) {\n    return this.key === other.key && fun.equalityDeep(this.attribution, other.attribution)\n  }\n\n  clone () {\n    return new AttrDeleteOp(this.key, _markMaybeDeltaAsDone(this.prevValue), _cloneAttrs(this.attribution))\n  }\n}\n\n/**\n * @template {DeltaAny} [Modifier=DeltaAny]\n * @template {string|number} [K=string]\n */\nexport class AttrModifyOp {\n  /**\n   * @param {K} key\n   * @param {Modifier} delta\n   */\n  constructor (key, delta) {\n    /**\n     * @readonly\n     * @type {K}\n     */\n    this.key = key\n    /**\n     * @readonly\n     * @type {Modifier}\n     */\n    this.value = delta\n    /**\n     * @type {string|null}\n     */\n    this._fingerprint = null\n  }\n\n  /**\n   * @type {'modify'}\n   */\n  get type () { return 'modify' }\n\n  get fingerprint () {\n    return this._fingerprint || (this._fingerprint = buffer.toBase64(encoding.encode(encoder => {\n      encoding.writeVarUint(encoder, 7) // map modify type: 7\n      encoding.writeAny(encoder, this.key)\n      encoding.writeVarString(encoder, this.value.fingerprint)\n    })))\n  }\n\n  /**\n   * @return {DeltaBuilder}\n   */\n  get _modValue () {\n    this._fingerprint = null\n    if (this.value.isDone) {\n      // @ts-ignore\n      this.value = /** @type {any} */ (clone(this.value))\n    }\n    // @ts-ignore\n    return this.value\n  }\n\n  /**\n   * @return {DeltaAttrOpJSON}\n   */\n  toJSON () {\n    return {\n      type: this.type,\n      value: this.value.toJSON()\n    }\n  }\n\n  /**\n   * @param {AttrModifyOp<Modifier>} other\n   */\n  [equalityTrait.EqualityTraitSymbol] (other) {\n    return this.key === other.key && this.value[equalityTrait.EqualityTraitSymbol](other.value)\n  }\n\n  /**\n   * @return {AttrModifyOp<Modifier,K>}\n   */\n  clone () {\n    return new AttrModifyOp(this.key, /** @type {Modifier} */ (this.value.done()))\n  }\n}\n\n/**\n * @type {s.Schema<AttrDeleteOp<any> | DeleteOp>}\n */\nexport const $deleteOp = s.$custom(o => o != null && (o.constructor === DeleteOp || o.constructor === AttrDeleteOp))\n\n/**\n * @type {s.Schema<AttrInsertOp<any> | InsertOp<any>>}\n */\nexport const $insertOp = s.$custom(o => o != null && (o.constructor === AttrInsertOp || o.constructor === InsertOp))\n\n/**\n * @template {fingerprintTrait.Fingerprintable} Content\n * @param {s.Schema<Content>} $content\n * @return {s.Schema<AttrInsertOp<Content> | InsertOp<Content>>}\n */\nexport const $insertOpWith = $content => s.$custom(o =>\n  o != null && (\n    (o.constructor === AttrInsertOp && $content.check(/** @type {AttrInsertOp<Content>} */ (o).value)) ||\n      (o.constructor === InsertOp && /** @type {InsertOp<Content>} */ (o).insert.every(ins => $content.check(ins)))\n  )\n)\n\n/**\n * @type {s.Schema<TextOp>}\n */\nexport const $textOp = s.$constructedBy(TextOp)\n\n/**\n * @type {s.Schema<RetainOp>}\n */\nexport const $retainOp = s.$constructedBy(RetainOp)\n\n/**\n * @type {s.Schema<AttrModifyOp | ModifyOp>}\n */\nexport const $modifyOp = s.$custom(o => o != null && (o.constructor === AttrModifyOp || o.constructor === ModifyOp))\n\n/**\n * @template {DeltaAny} Modify\n * @param {s.Schema<Modify>} $content\n * @return {s.Schema<AttrModifyOp<Modify> | ModifyOp<Modify>>}\n */\nexport const $modifyOpWith = $content => s.$custom(o =>\n  o != null && (\n    (o.constructor === AttrModifyOp && $content.check(/** @type {AttrModifyOp<Modify>} */ (o).value)) ||\n      (o.constructor === ModifyOp && $content.check(/** @type {ModifyOp<Modify>} */ (o).value))\n  )\n)\n\nexport const $anyOp = s.$union($insertOp, $deleteOp, $textOp, $modifyOp)\n\n/**\n * @template {Array<any>|string} C1\n * @template {Array<any>|string} C2\n * @typedef {Extract<C1 | C2, Array<any>> extends never\n *   ? never\n *   : (Array<(Extract<C1 | C2,Array<any>> extends Array<infer AC1> ? (unknown extends AC1 ? never : AC1) : never)>)} MergeListArrays\n */\n\n/**\n * @template {{[Key in string|number]: any}} Attrs\n * @template {string|number} Key\n * @template {any} Val\n * @typedef {{ [K in (Key | keyof Attrs)]: (unknown extends Attrs[K] ? never : Attrs[K]) | (Key extends K ? Val : never) }} AddToAttrs\n */\n\n/**\n * @template {{[Key in string|number|symbol]: any}} Attrs\n * @template {{[Key in string|number|symbol]: any}} NewAttrs\n * @typedef {{ [K in (keyof NewAttrs | keyof Attrs)]: (unknown extends Attrs[K] ? never : Attrs[K]) | (unknown extends NewAttrs[K] ? never : NewAttrs[K]) }} MergeAttrs\n */\n\n/**\n * @template X\n * @typedef {0 extends (1 & X) ? null : X} _AnyToNull\n */\n\n/**\n * @template {s.Schema<Delta<any,any,any,any,any>>|null} Schema\n * @typedef {_AnyToNull<Schema> extends null ? Delta<any,{[key:string|number]:any},any,string> : (Schema extends s.Schema<infer D> ? D : never)} AllowedDeltaFromSchema\n */\n\n/**\n * @typedef {Delta<any,{ [k:string|number]: any },any,any,any>} DeltaAny\n */\n/**\n * @typedef {DeltaBuilder<any,{ [k:string|number]: any },any,any,any>} DeltaBuilderAny\n */\n\n/**\n * @template {string} [NodeName=any]\n * @template {{[k:string|number]:any}} [Attrs={}]\n * @template {fingerprintTrait.Fingerprintable} [Children=never]\n * @template {string} [Text=never]\n * @template {s.Schema<Delta<any,any,any,any,any>>|null} [Schema=any]\n */\nexport class Delta {\n  /**\n   * @param {NodeName} [name]\n   * @param {Schema} [$schema]\n   */\n  constructor (name, $schema) {\n    this.name = name || null\n    this.$schema = $schema || null\n    /**\n     * @type {{ [K in keyof Attrs]?: K extends string|number ? (AttrInsertOp<Attrs[K],K>|AttrDeleteOp<Attrs[K],K>|(Delta extends Attrs[K] ? AttrModifyOp<Extract<Attrs[K],DeltaAny>,K> : never)) : never }\n     *   & { [Symbol.iterator]: () => Iterator<{ [K in keyof Attrs]: K extends string|number ? (AttrInsertOp<Attrs[K],K>|AttrDeleteOp<Attrs[K],K>|(Delta extends Attrs[K] ? AttrModifyOp<Extract<Attrs[K],DeltaAny>,K> : never)) : never }[keyof Attrs]> }\n     * }\n     */\n    this.attrs = /** @type {any} */ ({\n      * [Symbol.iterator] () {\n        for (const k in this) {\n          yield this[k]\n        }\n      }\n    })\n\n    /**\n     * @type {list.List<\n     *   RetainOp\n     *   | DeleteOp\n     *   | (Text extends never ? never : TextOp)\n     *   | (Children extends never ? never : InsertOp<Children>)\n     *   | (Delta extends Children ? ModifyOp<Extract<Children,Delta<any,any,any,any,any>>> : never)\n     * >}\n     */\n    this.children = /** @type {any} */ (list.create())\n    this.childCnt = 0\n    /**\n     * @type {any}\n     */\n    this.origin = null\n    /**\n     * @type {string|null}\n     */\n    this._fingerprint = null\n    this.isDone = false\n  }\n\n  /**\n   * @type {string}\n   */\n  get fingerprint () {\n    return this._fingerprint || (this._fingerprint = buffer.toBase64(encoding.encode(encoder => {\n      encoding.writeUint32(encoder, 0xf2ae5680) // \"magic number\" that ensures that different types of content don't yield the same fingerprint\n      encoding.writeAny(encoder, this.name)\n      /**\n       * @type {Array<number|string>}\n       */\n      const keys = []\n      for (const attr of this.attrs) {\n        keys.push(attr.key)\n      }\n      keys.sort((a, b) => {\n        const aIsString = s.$string.check(a)\n        const bIsString = s.$string.check(b)\n        // numbers first\n        // in ascending order\n        return (aIsString && bIsString)\n          ? a.localeCompare(b)\n          : (aIsString ? 1 : (bIsString ? -1 : (a - b)))\n      })\n      encoding.writeVarUint(encoder, keys.length)\n      for (const key of keys) {\n        encoding.writeVarString(encoder, /** @type {any} */ (this.attrs[/** @type {keyof Attrs} */ (key)]).fingerprint)\n      }\n      encoding.writeVarUint(encoder, this.children.len)\n      for (const child of this.children) {\n        encoding.writeVarString(encoder, child.fingerprint)\n      }\n      return buffer.toBase64(rabin.fingerprint(rabin.StandardIrreducible128, encoding.toUint8Array(encoder)))\n    })))\n  }\n\n  [fingerprintTrait.FingerprintTraitSymbol] () {\n    return this.fingerprint\n  }\n\n  isEmpty () {\n    return object.isEmpty(this.attrs) && list.isEmpty(this.children)\n  }\n\n  /**\n   * @return {DeltaJSON}\n   */\n  toJSON () {\n    const name = this.name\n    /**\n     * @type {any}\n     */\n    const attrs = {}\n    /**\n     * @type {any}\n     */\n    const children = []\n    for (const attr of this.attrs) {\n      attrs[attr.key] = attr.toJSON()\n    }\n    this.children.forEach(val => {\n      children.push(val.toJSON())\n    })\n    return object.assign(\n      { type: /** @type {'delta'} */ ('delta') },\n      (name != null ? { name } : {}),\n      (object.isEmpty(attrs) ? {} : { attrs }),\n      (children.length > 0 ? { children } : {})\n    )\n  }\n\n  /**\n   * @param {Delta<any,any,any,any,any>} other\n   * @return {boolean}\n   */\n  equals (other) {\n    return this[equalityTrait.EqualityTraitSymbol](other)\n  }\n\n  /**\n   * @param {any} other\n   * @return {boolean}\n   */\n  [equalityTrait.EqualityTraitSymbol] (other) {\n    // @todo it is only necessary to compare finrerprints OR do a deep equality check (remove\n    // childCnt as well)\n    return this.name === other.name && fun.equalityDeep(this.attrs, other.attrs) && fun.equalityDeep(this.children, other.children) && this.childCnt === other.childCnt\n  }\n\n  /**\n   * @return {DeltaBuilder<NodeName,Attrs,Children,Text,Schema>}\n   */\n  clone () {\n    return this.slice(0, this.childCnt)\n  }\n\n  /**\n   * @param {number} start\n   * @param {number} end\n   * @return {DeltaBuilder<NodeName,Attrs,Children,Text,Schema>}\n   */\n  slice (start = 0, end = this.childCnt) {\n    const cpy = /** @type {DeltaAny} */ (new DeltaBuilder(/** @type {any} */ (this.name), this.$schema))\n    cpy.origin = this.origin\n    // copy attrs\n    for (const op of this.attrs) {\n      cpy.attrs[op.key] = /** @type {any} */ (op.clone())\n    }\n    // copy children\n    const slicedLen = end - start\n    let remainingLen = slicedLen\n    /**\n     * @type {ChildrenOpAny?}\n     */\n    let currNode = this.children.start\n    let currNodeOffset = 0\n    while (start > 0 && currNode != null) {\n      if (currNode.length <= start) {\n        start -= currNode.length\n        currNode = currNode.next\n      } else {\n        currNodeOffset = start\n        start = 0\n      }\n    }\n    if (currNodeOffset > 0 && currNode) {\n      const ncpy = currNode.clone(currNodeOffset, currNodeOffset + math.min(remainingLen, currNode.length - currNodeOffset))\n      list.pushEnd(cpy.children, ncpy)\n      remainingLen -= ncpy.length\n      currNode = currNode.next\n    }\n    while (currNode != null && currNode.length <= remainingLen) {\n      list.pushEnd(cpy.children, currNode.clone())\n      remainingLen -= currNode.length\n      currNode = currNode.next\n    }\n    if (currNode != null && remainingLen > 0) {\n      list.pushEnd(cpy.children, currNode.clone(0, remainingLen))\n      remainingLen -= math.min(currNode.length, remainingLen)\n    }\n    cpy.childCnt = slicedLen - remainingLen\n    // @ts-ignore\n    return cpy\n  }\n\n  /**\n   * Mark this delta as done and perform some cleanup (e.g. remove appended retains without\n   * formats&attributions). In the future, there might be additional merge operations that can be\n   * performed to result in smaller deltas. Set `markAsDone=false` to only perform the cleanup.\n   *\n   * @return {Delta<NodeName,Attrs,Children,Text,Schema>}\n   */\n  done (markAsDone = true) {\n    if (!this.isDone) {\n      this.isDone = markAsDone\n      const cs = this.children\n      for (let end = cs.end; end !== null && $retainOp.check(end) && end.format == null && end.attribution == null; end = cs.end) {\n        this.childCnt -= end.length\n        list.popEnd(cs)\n      }\n    }\n    return this\n  }\n}\n\n/**\n * @template {DeltaAny} D\n * @param {D} d\n * @return {D extends DeltaBuilder<infer NodeName,infer Attrs,infer Children,infer Text,infer Schema> ? DeltaBuilder<NodeName,Attrs,Children,Text,Schema> : never}\n */\nexport const clone = d => /** @type {any} */ (d.slice(0, d.childCnt))\n\n/**\n * Try merging this op with the previous op\n * @param {list.List<any>} parent\n * @param {InsertOp<any>|RetainOp|DeleteOp|TextOp|ModifyOp<any>} op\n */\nconst tryMergeWithPrev = (parent, op) => {\n  const prevOp = op.prev\n  if (\n    prevOp?.constructor !== op.constructor ||\n    (\n      (!$deleteOp.check(op) && !$modifyOp.check(op)) && (!fun.equalityDeep(op.format, /** @type {InsertOp<any>} */ (prevOp).format) || !fun.equalityDeep(op.attribution, /** @type {InsertOp<any>} */ (prevOp).attribution))\n    )\n  ) {\n    // constructor mismatch or format/attribution mismatch\n    return\n  }\n  // can be merged\n  if ($insertOp.check(op)) {\n    /** @type {InsertOp<any>} */ (prevOp).insert.push(...op.insert)\n  } else if ($retainOp.check(op)) {\n    // @ts-ignore\n    /** @type {RetainOp} */ (prevOp).retain += op.retain\n  } else if ($deleteOp.check(op)) {\n    /** @type {DeleteOp} */ (prevOp).delete += op.delete\n  } else if ($textOp.check(op)) {\n    /** @type {TextOp} */ (prevOp)._updateInsert(/** @type {TextOp} */ (prevOp).insert + op.insert)\n  } else {\n    error.unexpectedCase()\n  }\n  list.remove(parent, op)\n}\n\n/**\n * Ensures that the delta can be edited. clears _fingerprint cache.\n *\n * @param {any} d\n */\nconst modDeltaCheck = d => {\n  if (d.isDone) {\n    /**\n     * You tried to modify a delta after it has been marked as \"done\".\n     */\n    throw error.create(\"Readonly Delta can't be modified\")\n  }\n  d._fingerprint = null\n}\n\n/**\n * @template {string} [NodeName=any]\n * @template {{[key:string|number]:any}} [Attrs={}]\n * @template {fingerprintTrait.Fingerprintable} [Children=never]\n * @template {string} [Text=never]\n * @template {s.Schema<Delta<any,any,any,any,any>>|null} [Schema=any]\n * @extends {Delta<NodeName,Attrs,Children,Text,Schema>}\n */\nexport class DeltaBuilder extends Delta {\n  /**\n   * @param {NodeName} [name]\n   * @param {Schema} [$schema]\n   */\n  constructor (name, $schema) {\n    super(name, $schema)\n    /**\n     * @type {FormattingAttributes?}\n     */\n    this.usedAttributes = null\n    /**\n     * @type {Attribution?}\n     */\n    this.usedAttribution = null\n  }\n\n  /**\n   * @param {Attribution?} attribution\n   */\n  useAttribution (attribution) {\n    modDeltaCheck(this)\n    this.usedAttribution = attribution\n    return this\n  }\n\n  /**\n   * @param {FormattingAttributes?} attributes\n   * @return {this}\n   */\n  useAttributes (attributes) {\n    modDeltaCheck(this)\n    this.usedAttributes = attributes\n    return this\n  }\n\n  /**\n   * @param {string} name\n   * @param {any} value\n   */\n  updateUsedAttributes (name, value) {\n    modDeltaCheck(this)\n    if (value == null) {\n      this.usedAttributes = object.assign({}, this.usedAttributes)\n      delete this.usedAttributes?.[name]\n      if (object.isEmpty(this.usedAttributes)) {\n        this.usedAttributes = null\n      }\n    } else if (!fun.equalityDeep(this.usedAttributes?.[name], value)) {\n      this.usedAttributes = object.assign({}, this.usedAttributes)\n      this.usedAttributes[name] = value\n    }\n    return this\n  }\n\n  /**\n   * @template {keyof Attribution} NAME\n   * @param {NAME} name\n   * @param {Attribution[NAME]?} value\n   */\n  updateUsedAttribution (name, value) {\n    modDeltaCheck(this)\n    if (value == null) {\n      this.usedAttribution = object.assign({}, this.usedAttribution)\n      delete this.usedAttribution?.[name]\n      if (object.isEmpty(this.usedAttribution)) {\n        this.usedAttribution = null\n      }\n    } else if (!fun.equalityDeep(this.usedAttribution?.[name], value)) {\n      this.usedAttribution = object.assign({}, this.usedAttribution)\n      this.usedAttribution[name] = value\n    }\n    return this\n  }\n\n  /**\n   * @template {AllowedDeltaFromSchema<Schema> extends Delta<any,any,infer Children,infer Text,infer Schema> ? ((Children extends never ? never : Array<Children>) | Text) : never} NewContent\n   * @param {NewContent} insert\n   * @param {FormattingAttributes?} [formatting]\n   * @param {Attribution?} [attribution]\n   * @return {DeltaBuilder<\n   *   NodeName,\n   *   Attrs,\n   *   Exclude<NewContent,string>[number]|Children,\n   *   (Extract<NewContent,string>|Text) extends never ? never : string,\n   *   Schema\n   * >}\n   */\n  insert (insert, formatting = null, attribution = null) {\n    modDeltaCheck(this)\n    const mergedAttributes = mergeAttrs(this.usedAttributes, formatting)\n    const mergedAttribution = mergeAttrs(this.usedAttribution, attribution)\n    /**\n     * @param {TextOp | InsertOp<any>} lastOp\n     */\n    const checkMergedEquals = lastOp => (mergedAttributes === lastOp.format || fun.equalityDeep(mergedAttributes, lastOp.format)) && (mergedAttribution === lastOp.attribution || fun.equalityDeep(mergedAttribution, lastOp.attribution))\n    const end = this.children.end\n    if (s.$string.check(insert)) {\n      if ($textOp.check(end) && checkMergedEquals(end)) {\n        end._updateInsert(end.insert + insert)\n      } else if (insert.length > 0) {\n        list.pushEnd(this.children, new TextOp(insert, object.isEmpty(mergedAttributes) ? null : mergedAttributes, object.isEmpty(mergedAttribution) ? null : mergedAttribution))\n      }\n      this.childCnt += insert.length\n    } else if (arr.isArray(insert)) {\n      if ($insertOp.check(end) && checkMergedEquals(end)) {\n        // @ts-ignore\n        end.insert.push(...insert)\n        end._fingerprint = null\n      } else if (insert.length > 0) {\n        list.pushEnd(this.children, new InsertOp(insert, object.isEmpty(mergedAttributes) ? null : mergedAttributes, object.isEmpty(mergedAttribution) ? null : mergedAttribution))\n      }\n      this.childCnt += insert.length\n    }\n    return /** @type {any} */ (this)\n  }\n\n  /**\n   * @template {AllowedDeltaFromSchema<Schema> extends Delta<any,any,infer Children,any,any> ? Extract<Children,Delta<any,any,any,any,any>> : never} NewContent\n   * @param {NewContent} modify\n   * @param {FormattingAttributes?} formatting\n   * @param {Attribution?} attribution\n   * @return {DeltaBuilder<\n   *   NodeName,\n   *   Attrs,\n   *   Exclude<NewContent,string>[number]|Children,\n   *   (Extract<NewContent,string>|Text) extends string ? string : never,\n   *   Schema\n   * >}\n   */\n  modify (modify, formatting = null, attribution = null) {\n    modDeltaCheck(this)\n    const mergedAttributes = mergeAttrs(this.usedAttributes, formatting)\n    const mergedAttribution = mergeAttrs(this.usedAttribution, attribution)\n    list.pushEnd(this.children, new ModifyOp(modify, object.isEmpty(mergedAttributes) ? null : mergedAttributes, object.isEmpty(mergedAttribution) ? null : mergedAttribution))\n    this.childCnt += 1\n    return /** @type {any} */ (this)\n  }\n\n  /**\n   * @param {number} len\n   * @param {FormattingAttributes?} [format]\n   * @param {Attribution?} [attribution]\n   */\n  retain (len, format = null, attribution = null) {\n    modDeltaCheck(this)\n    const mergedFormats = mergeAttrs(this.usedAttributes, format)\n    const mergedAttribution = mergeAttrs(this.usedAttribution, attribution)\n    const lastOp = /** @type {RetainOp|InsertOp<any>} */ (this.children.end)\n    if (lastOp instanceof RetainOp && fun.equalityDeep(mergedFormats, lastOp.format) && fun.equalityDeep(mergedAttribution, lastOp.attribution)) {\n      // @ts-ignore\n      lastOp.retain += len\n    } else if (len > 0) {\n      list.pushEnd(this.children, new RetainOp(len, mergedFormats, mergedAttribution))\n    }\n    this.childCnt += len\n    return this\n  }\n\n  /**\n   * @param {number} len\n   */\n  delete (len) {\n    modDeltaCheck(this)\n    const lastOp = /** @type {DeleteOp|InsertOp<any>} */ (this.children.end)\n    if (lastOp instanceof DeleteOp) {\n      lastOp.delete += len\n    } else if (len > 0) {\n      list.pushEnd(this.children, new DeleteOp(len))\n    }\n    this.childCnt += len\n    return this\n  }\n\n  /**\n   * @template {AllowedDeltaFromSchema<Schema> extends Delta<any,infer Attrs,any,any,any> ? (keyof Attrs) : never} Key\n   * @template {AllowedDeltaFromSchema<Schema> extends Delta<any,infer Attrs,any,any,any> ? (Attrs[Key]) : never} Val\n   * @param {Key} key\n   * @param {Val} val\n   * @param {Attribution?} attribution\n   * @param {Val|undefined} [prevValue]\n   * @return {DeltaBuilder<\n   *   NodeName,\n   *   { [K in keyof AddToAttrs<Attrs,Key,Val>]: AddToAttrs<Attrs,Key,Val>[K]  },\n   *   Children,\n   *   Text,\n   *   Schema\n   * >}\n   */\n  set (key, val, attribution = null, prevValue) {\n    modDeltaCheck(this)\n    this.attrs[key] = /** @type {any} */ (new AttrInsertOp(key, val, prevValue, mergeAttrs(this.usedAttribution, attribution)))\n    return /** @type {any} */ (this)\n  }\n\n  /**\n   * @template {AllowedDeltaFromSchema<Schema> extends Delta<any,infer Attrs,any,any,any> ? Attrs : never} NewAttrs\n   * @param {NewAttrs} attrs\n   * @param {Attribution?} attribution\n   * @return {DeltaBuilder<\n   *   NodeName,\n   *   { [K in keyof MergeAttrs<Attrs,NewAttrs>]: MergeAttrs<Attrs,NewAttrs>[K] },\n   *   Children,\n   *   Text,\n   *   Schema\n   * >}\n   */\n  setMany (attrs, attribution = null) {\n    modDeltaCheck(this)\n    for (const k in attrs) {\n      this.set(/** @type {any} */ (k), attrs[k], attribution)\n    }\n    return /** @type {any} */ (this)\n  }\n\n  /**\n   * @template {AllowedDeltaFromSchema<Schema> extends Delta<any,infer As,any,any,any> ? keyof As : never} Key\n   * @param {Key} key\n   * @param {Attribution?} attribution\n   * @param {any} [prevValue]\n   * @return {DeltaBuilder<\n   *   NodeName,\n   *   { [K in keyof AddToAttrs<Attrs,Key,never>]: AddToAttrs<Attrs,Key,never>[K] },\n   *   Children,\n   *   Text,\n   *   Schema\n   * >}\n   */\n  unset (key, attribution = null, prevValue) {\n    modDeltaCheck(this)\n    this.attrs[key] = /** @type {any} */ (new AttrDeleteOp(key, prevValue, mergeAttrs(this.usedAttribution, attribution)))\n    return /** @type {any} */ (this)\n  }\n\n  /**\n   * @template {AllowedDeltaFromSchema<Schema> extends Delta<any,infer As,any,any,any> ? { [K in keyof As]: Extract<As[K],Delta<any,any,any,any,any>> extends never ? never : K }[keyof As] : never} Key\n   * @template {AllowedDeltaFromSchema<Schema> extends Delta<any,infer As,any,any,any> ? Extract<As[Key],Delta<any,any,any,any,any>> : never} D\n   * @param {Key} key\n   * @param {D} modify\n   * @return {DeltaBuilder<\n   *   NodeName,\n   *   { [K in keyof AddToAttrs<Attrs,Key,D>]: AddToAttrs<Attrs,Key,D>[K]  },\n   *   Children,\n   *   Text,\n   *   Schema\n   * >}\n   */\n  update (key, modify) {\n    modDeltaCheck(this)\n    this.attrs[key] = /** @type {any} */ (new AttrModifyOp(key, modify))\n    return /** @type {any} */ (this)\n  }\n\n  /**\n   * @param {Delta<NodeName,Attrs,Children,Text,any>} other\n   */\n  apply (other) {\n    modDeltaCheck(this)\n    this.$schema?.expect(other)\n    // apply attrs\n    for (const op of other.attrs) {\n      const c = /** @type {AttrInsertOp<any,any>|AttrDeleteOp<any>|AttrModifyOp<any,any>} */ (this.attrs[op.key])\n      if ($modifyOp.check(op)) {\n        if ($deltaAny.check(c?.value)) {\n          c._modValue.apply(op.value)\n        } else {\n          // then this is a simple modify\n          // @ts-ignore\n          this.attrs[op.key] = op.clone()\n        }\n      } else if ($insertOp.check(op)) {\n        // @ts-ignore\n        op.prevValue = c?.value\n        // @ts-ignore\n        this.attrs[op.key] = op.clone()\n      } else if ($deleteOp.check(op)) {\n        op.prevValue = c?.value\n        delete this.attrs[op.key]\n      }\n    }\n    // apply children\n    /**\n     * @type {ChildrenOpAny?}\n     */\n    let opsI = this.children.start\n    let offset = 0\n    /**\n     * At the end, we will try to merge this op, and op.next op with their respective previous op.\n     *\n     * Hence, anytime an op is cloned, deleted, or inserted (anytime list.* api is used) we must add\n     * an op to maybeMergeable.\n     *\n     * @type {Array<InsertOp<any>|RetainOp|DeleteOp|TextOp|ModifyOp<any>>}\n     */\n    const maybeMergeable = []\n    /**\n     * @template {InsertOp<any>|RetainOp|DeleteOp|TextOp|ModifyOp<any>|null} OP\n     * @param {OP} op\n     * @return {OP}\n     */\n    const scheduleForMerge = op => {\n      op && maybeMergeable.push(op)\n      return op\n    }\n    other.children.forEach(op => {\n      if ($textOp.check(op) || $insertOp.check(op)) {\n        if (offset === 0) {\n          list.insertBetween(this.children, opsI == null ? this.children.end : opsI.prev, opsI, scheduleForMerge(op.clone()))\n        } else {\n          // @todo inmplement \"splitHelper\" and \"insertHelper\" - I'm splitting all the time and\n          // forget to update opsI\n          if (opsI == null) error.unexpectedCase()\n          const cpy = scheduleForMerge(opsI.clone(offset))\n          opsI._splice(offset, opsI.length - offset)\n          list.insertBetween(this.children, opsI, opsI.next || null, cpy)\n          list.insertBetween(this.children, opsI, cpy || null, scheduleForMerge(op.clone()))\n          opsI = cpy\n          offset = 0\n        }\n        this.childCnt += op.insert.length\n      } else if ($retainOp.check(op)) {\n        let retainLen = op.length\n\n        if (offset > 0 && opsI != null && op.format != null && !$deleteOp.check(opsI) && !object.every(op.format, (v, k) => fun.equalityDeep(v, /** @type {InsertOp<any>|RetainOp|ModifyOp} */ (opsI).format?.[k] || null))) {\n          // need to split current op\n          const cpy = scheduleForMerge(opsI.clone(offset))\n          opsI._splice(offset, opsI.length - offset)\n          list.insertBetween(this.children, opsI, opsI.next || null, cpy)\n          opsI = cpy\n          offset = 0\n        }\n\n        while (opsI != null && opsI.length - offset <= retainLen) {\n          op.format != null && updateOpFormat(opsI, op.format)\n          retainLen -= opsI.length - offset\n          opsI = opsI?.next || null\n          offset = 0\n        }\n\n        if (opsI != null) {\n          if (op.format != null && retainLen > 0) {\n            // split current op and apply format\n            const cpy = scheduleForMerge(opsI.clone(retainLen))\n            opsI._splice(retainLen, opsI.length - retainLen)\n            list.insertBetween(this.children, opsI, opsI.next || null, cpy)\n            updateOpFormat(opsI, op.format)\n            opsI = cpy\n          } else {\n            offset += retainLen\n          }\n        } else if (retainLen > 0) {\n          list.pushEnd(this.children, scheduleForMerge(new RetainOp(retainLen, op.format, op.attribution)))\n          this.childCnt += retainLen\n        }\n      } else if ($deleteOp.check(op)) {\n        let remainingLen = op.delete\n        while (remainingLen > 0) {\n          if (opsI == null) {\n            list.pushEnd(this.children, scheduleForMerge(new DeleteOp(remainingLen)))\n            this.childCnt += remainingLen\n            break\n          } else if (opsI instanceof DeleteOp) {\n            const delLen = opsI.length - offset\n            // the same content can't be deleted twice, remove duplicated deletes\n            if (delLen >= remainingLen) {\n              offset = 0\n              opsI = opsI.next\n            } else {\n              offset += remainingLen\n            }\n            remainingLen -= delLen\n          } else { // insert / embed / retain / modify ⇒ replace\n            // case1: delete o fully\n            // case2: delete some part of beginning\n            // case3: delete some part of end\n            // case4: delete some part of center\n            const delLen = math.min(opsI.length - offset, remainingLen)\n            this.childCnt -= delLen\n            if (opsI.length === delLen) {\n              // case 1\n              offset = 0\n              scheduleForMerge(opsI.next)\n              list.remove(this.children, opsI)\n              opsI = opsI.next\n            } else if (offset === 0) {\n              // case 2\n              offset = 0\n              opsI._splice(0, delLen)\n            } else if (offset + delLen === opsI.length) {\n              // case 3\n              opsI._splice(offset, delLen)\n              offset = 0\n              opsI = opsI.next\n            } else {\n              // case 4\n              opsI._splice(offset, delLen)\n            }\n            remainingLen -= delLen\n          }\n        }\n      } else if ($modifyOp.check(op)) {\n        if (opsI == null) {\n          list.pushEnd(this.children, op.clone())\n          this.childCnt += 1\n          return\n        }\n        if ($modifyOp.check(opsI)) {\n          opsI._modValue.apply(op.value)\n        } else if ($insertOp.check(opsI)) {\n          opsI._modValue(offset).apply(op.value)\n        } else if ($retainOp.check(opsI)) {\n          if (offset > 0) {\n            const cpy = scheduleForMerge(opsI.clone(0, offset)) // skipped len\n            opsI._splice(0, offset) // new remainder\n            list.insertBetween(this.children, opsI.prev, opsI, cpy) // insert skipped len\n            offset = 0\n          }\n          list.insertBetween(this.children, opsI.prev, opsI, scheduleForMerge(op.clone())) // insert skipped len\n          if (opsI.length === 1) {\n            list.remove(this.children, opsI)\n          } else {\n            opsI._splice(0, 1)\n            scheduleForMerge(opsI)\n          }\n        } else if ($deleteOp.check(opsI)) {\n          // nop\n        } else {\n          error.unexpectedCase()\n        }\n      } else {\n        error.unexpectedCase()\n      }\n    })\n    maybeMergeable.forEach(op => {\n      // check if this is still integrated\n      if (op.prev?.next === op) {\n        tryMergeWithPrev(this.children, op)\n        op.next && tryMergeWithPrev(this.children, op.next)\n      }\n    })\n    return this\n  }\n\n  /**\n   * @param {DeltaAny} other\n   * @param {boolean} priority\n   */\n  rebase (other, priority) {\n    modDeltaCheck(this)\n    /**\n     * Rebase attributes\n     *\n     * - insert vs delete ⇒ insert takes precedence\n     * - insert vs modify ⇒ insert takes precedence\n     * - insert vs insert ⇒ priority decides\n     * - delete vs modify ⇒ delete takes precedence\n     * - delete vs delete ⇒ current delete op is removed because item has already been deleted\n     * - modify vs modify ⇒ rebase using priority\n     */\n    for (const op of this.attrs) {\n      if ($insertOp.check(op)) {\n        if ($insertOp.check(other.attrs[op.key]) && !priority) {\n          delete this.attrs[op.key]\n        }\n      } else if ($deleteOp.check(op)) {\n        const otherOp = other.attrs[/** @type {any} */ (op.key)]\n        if ($insertOp.check(otherOp)) {\n          delete this.attrs[otherOp.key]\n        }\n      } else if ($modifyOp.check(op)) {\n        const otherOp = other.attrs[/** @type {any} */ (op.key)]\n        if (otherOp == null) {\n          // nop\n        } else if ($modifyOp.check(otherOp)) {\n          op._modValue.rebase(otherOp.value, priority)\n        } else {\n          delete this.attrs[otherOp.key]\n        }\n      }\n    }\n    /**\n     * Rebase children.\n     *\n     * Precedence: insert with higher priority comes first. Op with less priority is transformed to\n     * be inserted later.\n     *\n     * @todo always check if inser OR text\n     */\n    /**\n     * @type {ChildrenOpAny?}\n     */\n    let currChild = this.children.start\n    let currOffset = 0\n    /**\n     * @type {ChildrenOpAny?}\n     */\n    let otherChild = other.children.start\n    let otherOffset = 0\n    while (currChild != null && otherChild != null) {\n      if ($insertOp.check(currChild) || $textOp.check(currChild)) {\n        /**\n         * Transforming *insert*. If other is..\n         * - insert: transform based on priority\n         * - retain/delete/modify: transform next op against other\n         */\n        if ($insertOp.check(otherChild) || $modifyOp.check(otherChild) || $textOp.check(otherChild)) {\n          if (!priority) {\n            list.insertBetween(this.children, currChild.prev, currChild, new RetainOp(otherChild.length, null, null))\n            this.childCnt += otherChild.length\n            // curr is transformed against other, transform curr against next\n            otherOffset = otherChild.length\n          } else {\n            // curr stays as is, transform next op\n            currOffset = currChild.length\n          }\n        } else { // otherChild = delete | retain | modify - curr stays as is, transform next op\n          currOffset = currChild.length\n        }\n      } else if ($modifyOp.check(currChild)) {\n        /**\n         * Transforming *modify*. If other is..\n         * - insert: adjust position\n         * - modify: rebase curr modify on other modify\n         * - delete: remove modify\n         * - retain: adjust offset\n         */\n        if ($insertOp.check(otherChild) || $textOp.check(otherChild)) {\n          // @todo: with all list changes (retain insertions, removal), try to merge the surrounding\n          // ops later\n          list.insertBetween(this.children, currChild.prev, currChild, new RetainOp(otherChild.length, null, null))\n          this.childCnt += otherChild.length\n          // curr is transformed against other, transform curr against next\n          otherOffset = otherChild.length\n        } else {\n          if ($modifyOp.check(otherChild)) {\n            /** @type {any} */ (currChild.value).rebase(otherChild, priority)\n          } else if ($deleteOp.check(otherChild)) {\n            list.remove(this.children, currChild)\n            this.childCnt -= 1\n          }\n          currOffset += 1\n          otherOffset += 1\n        }\n      } else { // DeleteOp | RetainOp\n        const maxCommonLen = math.min(currChild.length - currOffset, otherChild.length - otherOffset)\n        /**\n         * Transforming *retain* OR *delete*. If other is..\n         * - retain / modify: adjust offsets\n         * - delete: shorten curr op\n         * - insert: split curr op and insert retain\n         */\n        if ($retainOp.check(otherChild) || $modifyOp.check(otherChild)) {\n          currOffset += maxCommonLen\n          otherOffset += maxCommonLen\n        } else if ($deleteOp.check(otherChild)) {\n          if ($retainOp.check(currChild)) {\n            // @ts-ignore\n            currChild.retain -= maxCommonLen\n          } else if ($deleteOp.check(currChild)) {\n            currChild.delete -= maxCommonLen\n          }\n          this.childCnt -= maxCommonLen\n        } else { // insert/text.check(currOp)\n          if (currOffset > 0) {\n            const leftPart = currChild.clone(currOffset)\n            list.insertBetween(this.children, currChild.prev, currChild, leftPart)\n            currChild._splice(currOffset, currChild.length - currOffset)\n            currOffset = 0\n          }\n          list.insertBetween(this.children, currChild.prev, currChild, new RetainOp(otherChild.length, null, null))\n          this.childCnt += otherChild.length\n          otherOffset = otherChild.length\n        }\n      }\n      if (currOffset >= currChild.length) {\n        currChild = currChild.next\n        currOffset = 0\n      }\n      if (otherOffset >= otherChild.length) {\n        otherChild = otherChild.next\n        otherOffset = 0\n      }\n    }\n    return this\n  }\n\n  /**\n   * Same as doing `delta.rebase(other.inverse())`, without creating a temporary delta.\n   *\n   * @param {DeltaAny} other\n   * @param {boolean} priority\n   */\n  rebaseOnInverse (other, priority) {\n    modDeltaCheck(this)\n    // @todo\n    console.info('method rebaseOnInverse unimplemented')\n    return this\n  }\n\n  /**\n   * Append child ops from one op to the other.\n   *\n   *     delta.create().insert('a').append(delta.create().insert('b')) // => insert \"ab\"\n   *\n   * @template {DeltaAny} OtherDelta\n   * @param {OtherDelta} other\n   * @return {CastToDelta<OtherDelta> extends Delta<any,any,infer OtherChildren,infer OtherText,any> ? DeltaBuilder<NodeName,Attrs,Children|OtherChildren,Text|OtherText,Schema> : never}\n   */\n  append (other) {\n    const children = this.children\n    const prevLast = children.end\n    // @todo Investigate. Above is a typescript issue. It is necessary to cast OtherDelta to a Delta first before\n    // inferring type, otherwise Children will contain Text.\n    for (const child of other.children) {\n      list.pushEnd(children, child.clone())\n    }\n    this.childCnt += other.childCnt\n    prevLast?.next && tryMergeWithPrev(children, prevLast.next)\n    // @ts-ignore\n    return this\n  }\n}\n\n/**\n * @param {ChildrenOpAny} op\n * @param {{[k:string]:any}} formatUpdate\n */\nconst updateOpFormat = (op, formatUpdate) => {\n  if (!$deleteOp.check(op)) {\n    // apply formatting attributes\n    for (const k in formatUpdate) {\n      const v = formatUpdate[k]\n      if (v != null || $retainOp.check(op)) {\n        // never modify formats\n        /** @type {any} */ (op).format = object.assign({}, op.format, { [k]: v })\n      } else if (op.format != null) {\n        const { [k]: _, ...rest } = op.format\n        ;/** @type {any} */ (op).format = rest\n      }\n    }\n  }\n}\n\n/**\n * @template {DeltaAny} D\n * @typedef {D extends DeltaBuilder<infer N,infer Attrs,infer Children,infer Text,infer Schema> ? Delta<N,Attrs,Children,Text,Schema> : D} CastToDelta\n */\n\n/**\n * @template {string} NodeName\n * @template {{ [key: string|number]: any }} [Attrs={}]\n * @template {fingerprintTrait.Fingerprintable|never} [Children=never]\n * @template {string|never} [Text=never]\n * @typedef {Delta<NodeName,Attrs,Children|Delta<NodeName,Attrs,Children,Text>|RecursiveDelta<NodeName,Attrs,Children,Text>,Text>} RecursiveDelta\n */\n\n/**\n * @template {string} Name\n * @template {{[k:string|number]:any}} Attrs\n * @template {fingerprintTrait.Fingerprintable} Children\n * @template {boolean} HasText\n * @template {{ [k:string]:any }} Formats\n * @template {boolean} Recursive\n * @extends {s.Schema<Delta<\n *   Name,\n *   Attrs,\n *   Children|(Recursive extends true ? RecursiveDelta<Name,Attrs,Children,HasText extends true ? string : never> : never),\n *   HasText extends true ? string : never,\n *   any>>}\n */\nexport class $Delta extends s.Schema {\n  /**\n   * @param {s.Schema<Name>} $name\n   * @param {s.Schema<Attrs>} $attrs\n   * @param {s.Schema<Children>} $children\n   * @param {HasText} hasText\n   * @param {s.Schema<Formats>} $formats\n   * @param {Recursive} recursive\n   */\n  constructor ($name, $attrs, $children, hasText, $formats, recursive) {\n    super()\n    const $attrsPartial = s.$$object.check($attrs) ? $attrs.partial : $attrs\n    if (recursive) {\n      // @ts-ignore\n      $children = s.$union($children, this)\n    }\n    this.shape = { $name, $attrs: $attrsPartial, $children, hasText, $formats }\n  }\n\n  /**\n   * @param {any} o\n   * @param {s.ValidationError} [err]\n   * @return {o is Delta<\n   *   Name,\n   *   Attrs,\n   *   Children|(Recursive extends true ? RecursiveDelta<Name,Attrs,Children,HasText extends true ? string : never> : never),\n   *   HasText extends true ? string : never,\n   *   any>}\n   */\n  check (o, err = undefined) {\n    const { $name, $attrs, $children, hasText, $formats } = this.shape\n    if (!(o instanceof Delta)) {\n      err?.extend(null, 'Delta', o?.constructor.name, 'Constructor match failed')\n    } else if (o.name != null && !$name.check(o.name, err)) {\n      err?.extend('Delta.name', $name.toString(), o.name, 'Unexpected node name')\n    } else if (list.toArray(o.children).some(c => (!hasText && $textOp.check(c)) || (hasText && $textOp.check(c) && c.format != null && !$formats.check(c.format)) || ($insertOp.check(c) && !c.insert.every(ins => $children.check(ins))))) {\n      err?.extend('Delta.children', '', '', 'Children don\\'t match the schema')\n    } else if (object.some(o.attrs, (op, k) => $insertOp.check(op) && !$attrs.check({ [k]: op.value }, err))) {\n      err?.extend('Delta.attrs', '', '', 'Attrs don\\'t match the schema')\n    } else {\n      return true\n    }\n    return false\n  }\n}\n\n/**\n * @template {s.Schema<string>|string|Array<string>} [NodeNameSchema=s.Schema<any>]\n * @template {s.Schema<{ [key: string|number]: any }>|{ [key:string|number]:any }} [AttrsSchema=s.Schema<{}>]\n * @template {any} [ChildrenSchema=s.Schema<never>]\n * @template {boolean} [HasText=false]\n * @template {boolean} [Recursive=false]\n * @template {{ [k:string]:any }} [Formats={[k:string]:any}]\n * @param {object} opts\n * @param {NodeNameSchema?} [opts.name]\n * @param {AttrsSchema?} [opts.attrs] What key-value pairs are included.\n * @param {ChildrenSchema?} [opts.children] The type of content in `insertOp`\n * @param {HasText} [opts.text] Whether this delta contains text using `textOp`\n * @param {Formats} [opts.formats]\n * @param {Recursive} [opts.recursive]\n * @return {[s.Unwrap<s.ReadSchema<NodeNameSchema>>,s.Unwrap<s.ReadSchema<AttrsSchema>>,s.Unwrap<s.ReadSchema<ChildrenSchema>>] extends [infer NodeName, infer Attrs, infer Children] ? s.Schema<Delta<\n *     NodeName,\n *     Attrs,\n *     Children|(Recursive extends true ? RecursiveDelta<NodeName,Attrs,Children,HasText extends true ? string : never> : never),\n *     HasText extends true ? string : never\n * >> : never}\n */\nexport const $delta = ({ name, attrs, children, text, formats, recursive }) => /** @type {any} */ (new $Delta(\n  name == null ? s.$any : s.$(name),\n  /** @type {any} */ (attrs == null ? s.$object({}) : s.$(attrs)),\n  /** @type {any} */ (children == null ? s.$never : s.$(children)),\n  text ?? false,\n  formats == null ? s.$any : s.$(formats),\n  recursive ?? false\n))\n\nexport const $$delta = s.$constructedBy($Delta)\n\n/**\n * @todo remove this\n *\n * @template {s.Schema<string>|string|Array<string>} [NodeNameSchema=s.Schema<any>]\n * @template {s.Schema<{ [key: string|number]: any }>|{ [key:string|number]:any }} [AttrsSchema=s.Schema<{}>]\n * @template {any} [ChildrenSchema=s.Schema<never>]\n * @template {boolean} [HasText=false]\n * @template {boolean} [Recursive=false]\n * @param {object} opts\n * @param {NodeNameSchema?} [opts.name]\n * @param {AttrsSchema?} [opts.attrs]\n * @param {ChildrenSchema?} [opts.children]\n * @param {HasText} [opts.text]\n * @param {Recursive} [opts.recursive]\n * @return {[s.Unwrap<s.ReadSchema<NodeNameSchema>>,s.Unwrap<s.ReadSchema<AttrsSchema>>,s.Unwrap<s.ReadSchema<ChildrenSchema>>] extends [infer NodeName, infer Attrs, infer Children] ? s.Schema<Delta<\n *     NodeName,\n *     Attrs,\n *     Children|(Recursive extends true ? RecursiveDelta<NodeName,Attrs,Children,HasText extends true ? string : never> : never),\n *     HasText extends true ? string : never\n * >> : never}\n */\nexport const _$delta = ({ name, attrs, children, text, recursive }) => {\n  /**\n   * @type {s.Schema<Array<any>>}\n   */\n  let $arrContent = children == null ? s.$never : s.$array(s.$(children))\n  const $name = name == null ? s.$any : s.$(name)\n  const $attrsPartial = attrs == null ? s.$object({}) : (s.$$record.check(attrs) ? attrs : /** @type {any} */ (s.$(attrs)).partial)\n  const $d = s.$instanceOf(Delta, /** @param {Delta<any,any,any,any,any>} d */ d => {\n    if (\n      !$name.check(d.name) ||\n      object.some(d.attrs,\n        (op, k) => $insertOp.check(op) && !$attrsPartial.check({ [k]: op.value })\n      )\n    ) return false\n    for (const op of d.children) {\n      if ((!text && $textOp.check(op)) || ($insertOp.check(op) && !$arrContent.check(op.insert))) {\n        return false\n      }\n    }\n    return true\n  })\n  if (recursive) {\n    $arrContent = children == null ? s.$array($d) : s.$array(s.$(children), $d)\n  }\n  return /** @type {any} */ ($d)\n}\n\n/**\n * @type {s.Schema<DeltaAny>}\n */\nexport const $deltaAny = /** @type {any} */ (s.$instanceOf(Delta))\n\n/**\n * @type {s.Schema<DeltaBuilderAny>}\n */\nexport const $deltaBuilderAny = /** @type {any} */ (s.$instanceOf(DeltaBuilder))\n\n/**\n * Helper function to merge attribution and attributes. The latter input \"wins\".\n *\n * @template {{ [key: string]: any }} T\n * @param {T | null} a\n * @param {T | null} b\n */\nexport const mergeAttrs = (a, b) => object.isEmpty(a)\n  ? (object.isEmpty(b) ? null : b)\n  : (object.isEmpty(b) ? a : object.assign({}, a, b))\n\n/**\n * @template {DeltaAny|null} D\n * @param {D} a\n * @param {D} b\n * @return {D}\n */\nexport const mergeDeltas = (a, b) => {\n  if (a != null && b != null) {\n    const c = clone(a)\n    c.apply(b)\n    return /** @type {any} */ (c)\n  }\n  return a == null ? b : (a || null)\n}\n\n/**\n * @template {DeltaAny} D\n * @param {prng.PRNG} gen\n * @param {s.Schema<D>} $d\n * @return {D extends Delta<infer NodeName,infer Attrs,infer Children,infer Text,infer Schema> ? DeltaBuilder<NodeName,Attrs,Children,Text,Schema> : never}\n */\nexport const random = (gen, $d) => {\n  const { $name, $attrs, $children, hasText, $formats: $formats_ } = /** @type {$Delta<any,any,any,boolean,any,any>} */ (/** @type {any} */ ($d)).shape\n  const d = s.$$any.check($name) ? create($deltaAny) : create(s.random(gen, $name), $deltaAny)\n  const $formats = s.$$any.check($formats_) ? s.$null : $formats_\n  prng.bool(gen) && d.setMany(s.random(gen, $attrs))\n  for (let i = prng.uint32(gen, 0, 5); i > 0; i--) {\n    if (hasText && prng.bool(gen)) {\n      d.insert(prng.word(gen), s.random(gen, $formats))\n    } else if (!s.$$never.check($children)) {\n      /**\n       * @type {Array<any>}\n       */\n      const ins = []\n      let insN = prng.int32(gen, 0, 5)\n      while (insN--) {\n        ins.push(s.random(gen, $children))\n      }\n      d.insert(ins, s.random(gen, $formats))\n    }\n  }\n  return /** @type {any} */ (d)\n}\n\n/**\n * @overload\n * @return {DeltaBuilder<any,{},never,never,null>}\n */\n/**\n * @template {string} NodeName\n * @overload\n * @param {NodeName} nodeName\n * @return {DeltaBuilder<NodeName,{},never,never,null>}\n */\n/**\n * @template {string} NodeName\n * @template {s.Schema<DeltaAny>} Schema\n * @overload\n * @param {NodeName} nodeName\n * @param {Schema} schema\n * @return {Schema extends s.Schema<Delta<infer N,infer Attrs,infer Children,infer Text,any>> ? DeltaBuilder<NodeName,Attrs,Children,Text,Schema> : never}\n */\n/**\n * @template {s.Schema<DeltaAny>} Schema\n * @overload\n * @param {Schema} schema\n * @return {Schema extends s.Schema<Delta<infer N,infer Attrs,infer Children,infer Text,any>> ? DeltaBuilder<N,Attrs,Children,Text,Schema> : never}\n */\n/**\n * @template {string|null} NodeName\n * @template {{[k:string|number]:any}|null} Attrs\n * @template {Array<any>|string} [Children=never]\n * @overload\n * @param {NodeName} nodeName\n * @param {Attrs} attrs\n * @param {Children} [children]\n * @return {DeltaBuilder<\n *   NodeName extends null ? any : NodeName,\n *   Attrs extends null ? {} : Attrs,\n *   Extract<Children,Array<any>> extends Array<infer Ac> ? (unknown extends Ac ? never : Ac) : never,\n *   Extract<Children,string>,\n *   null\n * >}\n */\n/**\n * @param {string|s.Schema<DeltaAny>} [nodeNameOrSchema]\n * @param {{[K:string|number]:any}|s.Schema<DeltaAny>} [attrsOrSchema]\n * @param {(Array<any>|string)} [children]\n * @return {DeltaBuilder<any,any,any,any,any>}\n */\nexport const create = (nodeNameOrSchema, attrsOrSchema, children) => {\n  const nodeName = /** @type {any} */ (s.$string.check(nodeNameOrSchema) ? nodeNameOrSchema : null)\n  const schema = /** @type {any} */ (s.$$schema.check(nodeNameOrSchema) ? nodeNameOrSchema : (s.$$schema.check(attrsOrSchema) ? attrsOrSchema : null))\n  const d = /** @type {DeltaBuilder<any,any,any,string,null>} */ (new DeltaBuilder(nodeName, schema))\n  if (s.$objectAny.check(attrsOrSchema)) {\n    d.setMany(attrsOrSchema)\n  }\n  children && d.insert(children)\n  return d\n}\n\n// DELTA TEXT\n\n/**\n * @template {fingerprintTrait.Fingerprintable} [Embeds=never]\n * @typedef {Delta<any,{},Embeds,string>} TextDelta\n */\n\n/**\n * @template {fingerprintTrait.Fingerprintable} [Embeds=never]\n * @typedef {DeltaBuilder<any,{},Embeds,string>} TextDeltaBuilder\n */\n\n/**\n * @template {Array<s.Schema<any>>} [$Embeds=any]\n * @param {$Embeds} $embeds\n * @return {s.Schema<TextDelta<_AnyToNull<$Embeds> extends null ? never : ($Embeds extends Array<s.Schema<infer $C>> ? $C : never)>>}\n */\nexport const $text = (...$embeds) => /** @type {any} */ ($delta({ children: s.$union(...$embeds), text: true }))\nexport const $textOnly = $text()\n\n/**\n * @template {s.Schema<Delta<any,{},any,any,null>>} [Schema=s.Schema<Delta<any,{},never,string,null>>]\n * @param {Schema} [$schema]\n * @return {Schema extends s.Schema<Delta<infer N,infer Attrs,infer Children,infer Text,any>> ? DeltaBuilder<N,Attrs,Children,Text,Schema> : never}\n */\nexport const text = $schema => /** @type {any} */ (create($schema || $textOnly))\n\n/**\n * @template {fingerprintTrait.Fingerprintable} Children\n * @typedef {Delta<any,{},Children,never>} ArrayDelta\n */\n\n/**\n * @template {fingerprintTrait.Fingerprintable} Children\n * @typedef {DeltaBuilder<any,{},Children,never>} ArrayDeltaBuilder\n */\n\n/**\n * @template {any|s.Schema<any>} $Children\n * @param {$Children} [$children]\n * @return {s.Schema<ArrayDelta<s.Unwrap<s.ReadSchema<$Children>>>>}\n */\nexport const $array = $children => /** @type {any} */ ($delta({ children: $children }))\n\n/**\n * @template {s.Schema<ArrayDelta<any>>} [$Schema=never]\n * @param {$Schema} $schema\n * @return {$Schema extends never ? ArrayDeltaBuilder<never> : DeltaBuilder<any,{},never,never,$Schema>}\n */\nexport const array = $schema => /** @type {any} */ ($schema ? create($schema) : create())\n\n/**\n * @template {{ [K: string|number]: any }} Attrs\n * @typedef {Delta<any,Attrs,never,never>} MapDelta\n */\n\n/**\n * @template {{ [K: string|number]: any }} Attrs\n * @typedef {DeltaBuilder<any,Attrs,never,never>} MapDeltaBuilder\n */\n\n/**\n * @template {{ [K: string|number]: any }} $Attrs\n * @param {s.Schema<$Attrs>} $attrs\n * @return {s.Schema<MapDelta<$Attrs>>}\n */\nexport const $map = $attrs => /** @type {any} */ ($delta({ attrs: $attrs }))\n\n/**\n * @template {s.Schema<MapDelta<any>>|undefined} [$Schema=undefined]\n * @param {$Schema} [$schema]\n * @return {$Schema extends s.Schema<MapDelta<infer Attrs>> ? DeltaBuilder<any,Attrs,never,never,$Schema> : MapDeltaBuilder<{}>}\n */\nexport const map = $schema => /** @type {any} */ (create(/** @type {any} */ ($schema)))\n\n/**\n * @template {DeltaAny} D\n * @param {D} d1\n * @param {NoInfer<D>} d2\n * @return {D extends Delta<infer N,infer Attrs,infer Children,infer Text,any> ? DeltaBuilder<N,Attrs,Children,Text,null> : never}\n */\nexport const diff = (d1, d2) => {\n  /**\n   * @type {DeltaBuilderAny}\n   */\n  const d = create()\n  if (d1.fingerprint !== d2.fingerprint) {\n    let left1 = d1.children.start\n    let left2 = d2.children.start\n    let right1 = d1.children.end\n    let right2 = d2.children.end\n    let commonPrefixOffset = 0\n    // perform a patience sort\n    // 1) remove common prefix and suffix\n    while (left1 != null && left1.fingerprint === left2?.fingerprint) {\n      if (!$deleteOp.check(left1)) {\n        commonPrefixOffset += left1.length\n      }\n      left1 = left1.next\n      left2 = left2.next\n    }\n    while (right1 !== null && right1 !== left1 && right1.fingerprint === right2?.fingerprint) {\n      right1 = right1.prev\n      right2 = right2.prev\n    }\n    /**\n     * @type {Array<ChildrenOpAny>}\n     */\n    const ops1 = []\n    /**\n     * @type {Array<ChildrenOpAny>}\n     */\n    const ops2 = []\n    while (left1 !== null && left1 !== right1?.next) {\n      ops1.push(left1)\n      left1 = left1.next\n    }\n    while (left2 !== null && left2 !== right2?.next) {\n      ops2.push(left2)\n      left2 = left2.next\n    }\n    const fprints1 = ops1.map(op => op.fingerprint)\n    const fprints2 = ops2.map(op => op.fingerprint)\n    const changeset = patience.diff(fprints1, fprints2)\n    d.retain(commonPrefixOffset)\n    for (let i = 0, lastIndex1 = 0, currIndexOffset2 = 0; i < changeset.length; i++) {\n      const change = changeset[i]\n      d.retain(change.index - lastIndex1)\n      // insert minimal diff at curred position in d\n      /**\n       *\n       * @todo it would be better if these would be slices of delta (an actual delta)\n       *\n       * @param {ChildrenOpAny[]} opsIs\n       * @param {ChildrenOpAny[]} opsShould\n       */\n      const diffAndApply = (opsIs, opsShould) => {\n        const d = create()\n        // @todo unoptimized implementation. Convert content to array and diff that based on\n        // generated fingerprints. We probably could do better and cache more information.\n        // - benchmark\n        // - cache fingerprints in ops\n        /**\n         * @type {Array<string|DeltaAny|fingerprintTrait.Fingerprintable>}\n         */\n        const isContent = opsIs.flatMap(op => $insertOp.check(op) ? op.insert : ($textOp.check(op) ? op.insert.split('') : error.unexpectedCase()))\n        /**\n         * @type {Array<string|DeltaAny|fingerprintTrait.Fingerprintable>}\n         */\n        const shouldContent = opsShould.flatMap(op => $insertOp.check(op) ? op.insert : ($textOp.check(op) ? op.insert.split('') : error.unexpectedCase()))\n        const isContentFingerprinted = isContent.map(c => s.$string.check(c) ? c : fingerprintTrait.fingerprint(c))\n        const shouldContentFingerprinted = shouldContent.map(c => s.$string.check(c) ? c : fingerprintTrait.fingerprint(c))\n        const hasFormatting = opsIs.some(op => !$deleteOp.check(op) && op.format != null) || opsShould.some(op => !$deleteOp.check(op) && op.format != null)\n        /**\n         * @type {{ index: number, insert: Array<string|DeltaAny|fingerprintTrait.Fingerprintable>, remove: Array<string|DeltaAny|fingerprintTrait.Fingerprintable> }[]}\n         */\n        const cdiff = patience.diff(isContentFingerprinted, shouldContentFingerprinted)\n        // overwrite fingerprinted content with actual content\n        for (let i = 0, adj = 0; i < cdiff.length; i++) {\n          const cd = cdiff[i]\n          cd.remove = isContent.slice(cd.index, cd.index + cd.remove.length)\n          cd.insert = shouldContent.slice(cd.index + adj, cd.index + adj + cd.insert.length)\n          adj += cd.insert.length - cd.remove.length\n        }\n        for (let i = 0, lastIndex = 0; i < cdiff.length; i++) {\n          const cd = cdiff[i]\n          d.retain(cd.index - lastIndex)\n          lastIndex = cd.index\n          let cdii = 0\n          let cdri = 0\n          // try to match as much content as possible, preferring to skip over non-deltas\n          for (; cdii < cd.insert.length && cdri < cd.remove.length;) {\n            const a = cd.insert[cdii]\n            const b = cd.remove[cdri]\n            if ($deltaAny.check(a) && $deltaAny.check(b) && a.name === b.name) {\n              d.modify(diff(b, a))\n              cdii++\n              cdri++\n            } else if ($deltaAny.check(b)) {\n              d.insert(s.$string.check(a) ? a : [a])\n              cdii++\n            } else {\n              d.delete(1)\n              cdri++\n            }\n          }\n          for (; cdii < cd.insert.length; cdii++) {\n            const a = cd.insert[cdii]\n            d.insert(s.$string.check(a) ? a : [a])\n          }\n          d.delete(cd.remove.length - cdri)\n        }\n        // create the diff for formatting\n        if (hasFormatting) {\n          const formattingDiff = create()\n          // update opsIs with content diff. then we can figure out the formatting diff.\n          const isUpdated = create()\n          // copy opsIs to fresh delta\n          opsIs.forEach(op => {\n            isUpdated.childCnt += op.length\n            list.pushEnd(isUpdated.children, op.clone())\n          })\n          isUpdated.apply(d)\n          let shouldI = 0\n          let shouldOffset = 0\n          let isOp = isUpdated.children.start\n          let isOffset = 0\n          while (shouldI < opsShould.length && isOp != null) {\n            const shouldOp = opsShould[shouldI]\n            if (!$deleteOp.check(shouldOp) && !$deleteOp.check(isOp)) {\n              const isFormat = isOp.format\n              const minForward = math.min(shouldOp.length - shouldOffset, isOp.length - isOffset)\n              shouldOffset += minForward\n              isOffset += minForward\n              if (fun.equalityDeep(shouldOp.format, isFormat)) {\n                formattingDiff.retain(minForward)\n              } else {\n                /**\n                 * @type {FormattingAttributes}\n                 */\n                const fupdate = {}\n                shouldOp.format != null && object.forEach(shouldOp.format, (v, k) => {\n                  if (!fun.equalityDeep(v, isFormat?.[k] || null)) {\n                    fupdate[k] = v\n                  }\n                })\n                isFormat && object.forEach(isFormat, (_, k) => {\n                  if (shouldOp?.format?.[k] === undefined) {\n                    fupdate[k] = null\n                  }\n                })\n                formattingDiff.retain(minForward, fupdate)\n              }\n              // update offset and iterators\n              if (shouldOffset >= shouldOp.length) {\n                shouldI++\n                shouldOffset = 0\n              }\n              if (isOffset >= isOp.length) {\n                isOp = isOp.next\n                isOffset = 0\n              }\n            }\n          }\n          d.apply(formattingDiff)\n        }\n        return d\n      }\n      const subd = diffAndApply(ops1.slice(change.index, change.index + change.remove.length), ops2.slice(change.index + currIndexOffset2, change.index + currIndexOffset2 + change.insert.length))\n      d.append(subd)\n      lastIndex1 = change.index + change.remove.length\n      currIndexOffset2 += change.insert.length - change.remove.length\n    }\n    for (const attr2 of d2.attrs) {\n      const attr1 = d1.attrs[attr2.key]\n      if (attr1 == null || (attr1.fingerprint !== attr2.fingerprint)) {\n        /* c8 ignore else */\n        if ($insertOp.check(attr2)) {\n          d.set(attr2.key, attr2.value)\n        } else {\n          /* c8 ignore next 2 */\n          error.unexpectedCase()\n        }\n      }\n    }\n    for (const attr1 of d1.attrs) {\n      if (d2.attrs[attr1.key] == null) {\n        d.unset(attr1.key)\n      }\n    }\n  }\n  return /** @type {any} */ (d.done(false))\n}\n"],"names":["s.$object","s.$array","s.$string","s.$number","s.$record","s.$union","s.$literal","s.$any","list.ListNode","buffer.toBase64","encoding.encode","encoding.writeVarUint","encoding.writeVarString","encoding.writeAny","object.assign","equalityTrait.EqualityTraitSymbol","fun.equalityDeep","fingerprintTrait.fingerprint","encoding.writeUint8","s.$custom","s.$constructedBy","list.create","encoding.writeUint32","rabin.fingerprint","rabin.StandardIrreducible128","encoding.toUint8Array","fingerprintTrait.FingerprintTraitSymbol","object.isEmpty","list.isEmpty","math.min","list.pushEnd","list.popEnd","error.unexpectedCase","list.remove","error.create","arr.isArray","list.insertBetween","object.every","s.Schema","s.$$object","list.toArray","object.some","s.$","s.$never","s.$$record","s.$instanceOf","s.$$any","s.random","s.$null","prng.bool","prng.uint32","prng.word","s.$$never","prng.int32","schema","s.$$schema","s.$objectAny","patience.diff","object.forEach"],"mappings":"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"}