// Package windmill_api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package windmill_api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
	CookieAuthScopes = "cookieAuth.Scopes"
)

// Defines values for AuditLogActionKind.
const (
	AuditLogActionKindCreated AuditLogActionKind = "Created"
	AuditLogActionKindDelete  AuditLogActionKind = "Delete"
	AuditLogActionKindExecute AuditLogActionKind = "Execute"
	AuditLogActionKindUpdated AuditLogActionKind = "Updated"
)

// Defines values for AuditLogOperation.
const (
	JobsRun          AuditLogOperation = "jobs.run"
	ScriptsCreate    AuditLogOperation = "scripts.create"
	ScriptsUpdate    AuditLogOperation = "scripts.update"
	UsersCreate      AuditLogOperation = "users.create"
	UsersDelete      AuditLogOperation = "users.delete"
	UsersLogin       AuditLogOperation = "users.login"
	UsersSetpassword AuditLogOperation = "users.setpassword"
	UsersTokenCreate AuditLogOperation = "users.token.create"
	UsersTokenDelete AuditLogOperation = "users.token.delete"
	UsersUpdate      AuditLogOperation = "users.update"
	VariablesCreate  AuditLogOperation = "variables.create"
	VariablesDelete  AuditLogOperation = "variables.delete"
	VariablesUpdate  AuditLogOperation = "variables.update"
)

// Defines values for BranchAllType.
const (
	Branchall BranchAllType = "branchall"
)

// Defines values for BranchOneType.
const (
	Branchone BranchOneType = "branchone"
)

// Defines values for CompletedJobJobKind.
const (
	CompletedJobJobKindDependencies CompletedJobJobKind = "dependencies"
	CompletedJobJobKindFlow         CompletedJobJobKind = "flow"
	CompletedJobJobKindFlowpreview  CompletedJobJobKind = "flowpreview"
	CompletedJobJobKindPreview      CompletedJobJobKind = "preview"
	CompletedJobJobKindScript       CompletedJobJobKind = "script"
	CompletedJobJobKindScriptHub    CompletedJobJobKind = "script_hub"
)

// Defines values for CompletedJobLanguage.
const (
	CompletedJobLanguageDeno    CompletedJobLanguage = "deno"
	CompletedJobLanguageGo      CompletedJobLanguage = "go"
	CompletedJobLanguagePython3 CompletedJobLanguage = "python3"
)

// Defines values for FlowStatusModuleBranchChosenType.
const (
	Branch  FlowStatusModuleBranchChosenType = "branch"
	Default FlowStatusModuleBranchChosenType = "default"
)

// Defines values for FlowStatusModuleType.
const (
	FlowStatusModuleTypeFailure              FlowStatusModuleType = "Failure"
	FlowStatusModuleTypeInProgress           FlowStatusModuleType = "InProgress"
	FlowStatusModuleTypeSuccess              FlowStatusModuleType = "Success"
	FlowStatusModuleTypeWaitingForEvent      FlowStatusModuleType = "WaitingForEvent"
	FlowStatusModuleTypeWaitingForExecutor   FlowStatusModuleType = "WaitingForExecutor"
	FlowStatusModuleTypeWaitingForPriorSteps FlowStatusModuleType = "WaitingForPriorSteps"
)

// Defines values for ForloopFlowType.
const (
	Forloopflow ForloopFlowType = "forloopflow"
)

// Defines values for GlobalUserInfoLoginType.
const (
	Github   GlobalUserInfoLoginType = "github"
	Password GlobalUserInfoLoginType = "password"
)

// Defines values for JavascriptTransformType.
const (
	JavascriptTransformTypeJavascript JavascriptTransformType = "javascript"
)

// Defines values for PathScriptType.
const (
	PathScriptTypeScript PathScriptType = "script"
)

// Defines values for PreviewLanguage.
const (
	PreviewLanguageDeno    PreviewLanguage = "deno"
	PreviewLanguageGo      PreviewLanguage = "go"
	PreviewLanguagePython3 PreviewLanguage = "python3"
)

// Defines values for QueuedJobJobKind.
const (
	QueuedJobJobKindDependencies QueuedJobJobKind = "dependencies"
	QueuedJobJobKindFlow         QueuedJobJobKind = "flow"
	QueuedJobJobKindFlowpreview  QueuedJobJobKind = "flowpreview"
	QueuedJobJobKindPreview      QueuedJobJobKind = "preview"
	QueuedJobJobKindScript       QueuedJobJobKind = "script"
	QueuedJobJobKindScriptHub    QueuedJobJobKind = "script_hub"
)

// Defines values for QueuedJobLanguage.
const (
	QueuedJobLanguageDeno    QueuedJobLanguage = "deno"
	QueuedJobLanguageGo      QueuedJobLanguage = "go"
	QueuedJobLanguagePython3 QueuedJobLanguage = "python3"
)

// Defines values for RawScriptLanguage.
const (
	RawScriptLanguageDeno    RawScriptLanguage = "deno"
	RawScriptLanguageGo      RawScriptLanguage = "go"
	RawScriptLanguagePython3 RawScriptLanguage = "python3"
)

// Defines values for ScriptKind.
const (
	ScriptKindCommand ScriptKind = "command"
	ScriptKindFailure ScriptKind = "failure"
	ScriptKindScript  ScriptKind = "script"
	ScriptKindTrigger ScriptKind = "trigger"
)

// Defines values for ScriptLanguage.
const (
	Deno    ScriptLanguage = "deno"
	Go      ScriptLanguage = "go"
	Python3 ScriptLanguage = "python3"
)

// Defines values for StaticTransformType.
const (
	StaticTransformTypeJavascript StaticTransformType = "javascript"
)

// Defines values for ActionKind.
const (
	ActionKindCreate  ActionKind = "Create"
	ActionKindDelete  ActionKind = "Delete"
	ActionKindExecute ActionKind = "Execute"
	ActionKindUpdate  ActionKind = "Update"
)

// AuditLog defines model for AuditLog.
type AuditLog struct {
	ActionKind AuditLogActionKind      `json:"action_kind"`
	Id         int                     `json:"id"`
	Operation  AuditLogOperation       `json:"operation"`
	Parameters *map[string]interface{} `json:"parameters,omitempty"`
	Resource   *string                 `json:"resource,omitempty"`
	Timestamp  time.Time               `json:"timestamp"`
	Username   string                  `json:"username"`
}

// AuditLogActionKind defines model for AuditLog.ActionKind.
type AuditLogActionKind string

// AuditLogOperation defines model for AuditLog.Operation.
type AuditLogOperation string

// BranchAll defines model for BranchAll.
type BranchAll struct {
	Branches []struct {
		Modules []FlowModule `json:"modules"`
		Summary *string      `json:"summary,omitempty"`
	} `json:"branches"`
	Type BranchAllType `json:"type"`
}

// BranchAllType defines model for BranchAll.Type.
type BranchAllType string

// BranchOne defines model for BranchOne.
type BranchOne struct {
	Branches []struct {
		Expr    string       `json:"expr"`
		Modules []FlowModule `json:"modules"`
		Summary *string      `json:"summary,omitempty"`
	} `json:"branches"`
	Default []FlowModule  `json:"default"`
	Type    BranchOneType `json:"type"`
}

// BranchOneType defines model for BranchOne.Type.
type BranchOneType string

// CompletedJob defines model for CompletedJob.
type CompletedJob struct {
	Args           *ScriptArgs           `json:"args,omitempty"`
	Canceled       bool                  `json:"canceled"`
	CanceledBy     *string               `json:"canceled_by,omitempty"`
	CanceledReason *string               `json:"canceled_reason,omitempty"`
	CreatedAt      time.Time             `json:"created_at"`
	CreatedBy      string                `json:"created_by"`
	Deleted        *bool                 `json:"deleted,omitempty"`
	DurationMs     int                   `json:"duration_ms"`
	FlowStatus     *FlowStatus           `json:"flow_status,omitempty"`
	Id             openapi_types.UUID    `json:"id"`
	IsFlowStep     bool                  `json:"is_flow_step"`
	IsSkipped      bool                  `json:"is_skipped"`
	JobKind        CompletedJobJobKind   `json:"job_kind"`
	Language       *CompletedJobLanguage `json:"language,omitempty"`
	Logs           *string               `json:"logs,omitempty"`
	ParentJob      *openapi_types.UUID   `json:"parent_job,omitempty"`

	// The user (u/userfoo) or group (g/groupfoo) whom
	// the execution of this script will be permissioned_as and by extension its DT_TOKEN.
	PermissionedAs string                  `json:"permissioned_as"`
	RawCode        *string                 `json:"raw_code,omitempty"`
	RawFlow        *FlowValue              `json:"raw_flow,omitempty"`
	Result         *map[string]interface{} `json:"result,omitempty"`
	SchedulePath   *string                 `json:"schedule_path,omitempty"`
	ScriptHash     *string                 `json:"script_hash,omitempty"`
	ScriptPath     *string                 `json:"script_path,omitempty"`
	StartedAt      time.Time               `json:"started_at"`
	Success        bool                    `json:"success"`
	WorkspaceId    *string                 `json:"workspace_id,omitempty"`
}

// CompletedJobJobKind defines model for CompletedJob.JobKind.
type CompletedJobJobKind string

// CompletedJobLanguage defines model for CompletedJob.Language.
type CompletedJobLanguage string

// ContextualVariable defines model for ContextualVariable.
type ContextualVariable struct {
	Description string `json:"description"`
	Name        string `json:"name"`
	Value       string `json:"value"`
}

// CreateResource defines model for CreateResource.
type CreateResource struct {
	Description  *string                `json:"description,omitempty"`
	IsOauth      *bool                  `json:"is_oauth,omitempty"`
	Path         string                 `json:"path"`
	ResourceType string                 `json:"resource_type"`
	Value        map[string]interface{} `json:"value"`
}

// CreateVariable defines model for CreateVariable.
type CreateVariable struct {
	Account     *int   `json:"account,omitempty"`
	Description string `json:"description"`
	IsOauth     *bool  `json:"is_oauth,omitempty"`
	IsSecret    bool   `json:"is_secret"`
	Path        string `json:"path"`
	Value       string `json:"value"`
}

// CreateWorkspace defines model for CreateWorkspace.
type CreateWorkspace struct {
	Domain   string `json:"domain"`
	Id       string `json:"id"`
	Name     string `json:"name"`
	Username string `json:"username"`
}

// EditResource defines model for EditResource.
type EditResource struct {
	Description *string                 `json:"description,omitempty"`
	Path        *string                 `json:"path,omitempty"`
	Value       *map[string]interface{} `json:"value,omitempty"`
}

// EditResourceType defines model for EditResourceType.
type EditResourceType struct {
	Description *string `json:"description,omitempty"`
	Schema      *string `json:"schema,omitempty"`
}

// EditSchedule defines model for EditSchedule.
type EditSchedule struct {
	Args       ScriptArgs `json:"args"`
	IsFlow     bool       `json:"is_flow"`
	Schedule   string     `json:"schedule"`
	ScriptPath string     `json:"script_path"`
}

// EditVariable defines model for EditVariable.
type EditVariable struct {
	Description *string `json:"description,omitempty"`
	IsSecret    *bool   `json:"is_secret,omitempty"`
	Path        *string `json:"path,omitempty"`
	Value       *string `json:"value,omitempty"`
}

// EditWorkspaceUser defines model for EditWorkspaceUser.
type EditWorkspaceUser struct {
	IsAdmin *bool `json:"is_admin,omitempty"`
}

// Flow defines model for Flow.
type Flow struct {
	AdditionalProperties *bool                   `json:"additionalProperties,omitempty"`
	Archived             bool                    `json:"archived"`
	Description          *string                 `json:"description,omitempty"`
	EditedAt             time.Time               `json:"edited_at"`
	EditedBy             string                  `json:"edited_by"`
	ExtraPerms           map[string]interface{}  `json:"extra_perms"`
	Path                 string                  `json:"path"`
	Schema               *map[string]interface{} `json:"schema,omitempty"`
	Summary              string                  `json:"summary"`
	Value                FlowValue               `json:"value"`
	WorkspaceId          *string                 `json:"workspace_id,omitempty"`
}

// FlowMetadata defines model for FlowMetadata.
type FlowMetadata struct {
	AdditionalProperties *bool                  `json:"additionalProperties,omitempty"`
	Archived             bool                   `json:"archived"`
	EditedAt             time.Time              `json:"edited_at"`
	EditedBy             string                 `json:"edited_by"`
	ExtraPerms           map[string]interface{} `json:"extra_perms"`
	Path                 string                 `json:"path"`
	WorkspaceId          *string                `json:"workspace_id,omitempty"`
}

// FlowModule defines model for FlowModule.
type FlowModule struct {
	InputTransforms FlowModule_InputTransforms `json:"input_transforms"`
	Retry           *Retry                     `json:"retry,omitempty"`
	Sleep           *InputTransform            `json:"sleep,omitempty"`
	StopAfterIf     *struct {
		Expr          string `json:"expr"`
		SkipIfStopped *bool  `json:"skip_if_stopped,omitempty"`
	} `json:"stop_after_if,omitempty"`
	Summary *string `json:"summary,omitempty"`
	Suspend *struct {
		RequiredEvents *int `json:"required_events,omitempty"`
		Timeout        *int `json:"timeout,omitempty"`
	} `json:"suspend,omitempty"`
	Value FlowModuleValue `json:"value"`
}

// FlowModule_InputTransforms defines model for FlowModule.InputTransforms.
type FlowModule_InputTransforms struct {
	AdditionalProperties map[string]InputTransform `json:"-"`
}

// FlowModuleValue defines model for FlowModuleValue.
type FlowModuleValue interface{}

// FlowPreview defines model for FlowPreview.
type FlowPreview struct {
	Args  ScriptArgs `json:"args"`
	Path  *string    `json:"path,omitempty"`
	Value FlowValue  `json:"value"`
}

// FlowStatus defines model for FlowStatus.
type FlowStatus struct {
	FailureModule FlowStatusModule   `json:"failure_module"`
	Modules       []FlowStatusModule `json:"modules"`
	Retry         *struct {
		FailCount  *int                  `json:"fail_count,omitempty"`
		FailedJobs *[]openapi_types.UUID `json:"failed_jobs,omitempty"`
	} `json:"retry,omitempty"`
	Step int `json:"step"`
}

// FlowStatusModule defines model for FlowStatusModule.
type FlowStatusModule struct {
	BranchChosen *struct {
		Branch *int                              `json:"branch,omitempty"`
		Type   *FlowStatusModuleBranchChosenType `json:"type,omitempty"`
	} `json:"branch_chosen,omitempty"`
	Count       *int      `json:"count,omitempty"`
	ForloopJobs *[]string `json:"forloop_jobs,omitempty"`
	Iterator    *struct {
		Args   *interface{}   `json:"args,omitempty"`
		Index  *int           `json:"index,omitempty"`
		Itered *[]interface{} `json:"itered,omitempty"`
	} `json:"iterator,omitempty"`
	Job  *openapi_types.UUID  `json:"job,omitempty"`
	Type FlowStatusModuleType `json:"type"`
}

// FlowStatusModuleBranchChosenType defines model for FlowStatusModule.BranchChosen.Type.
type FlowStatusModuleBranchChosenType string

// FlowStatusModuleType defines model for FlowStatusModule.Type.
type FlowStatusModuleType string

// FlowValue defines model for FlowValue.
type FlowValue struct {
	FailureModule *FlowModule  `json:"failure_module,omitempty"`
	Modules       []FlowModule `json:"modules"`
	SameWorker    *bool        `json:"same_worker,omitempty"`
}

// ForloopFlow defines model for ForloopFlow.
type ForloopFlow struct {
	Iterator     InputTransform  `json:"iterator"`
	Modules      []FlowModule    `json:"modules"`
	SkipFailures bool            `json:"skip_failures"`
	Type         ForloopFlowType `json:"type"`
}

// ForloopFlowType defines model for ForloopFlow.Type.
type ForloopFlowType string

// GlobalUserInfo defines model for GlobalUserInfo.
type GlobalUserInfo struct {
	Company    *string                 `json:"company,omitempty"`
	Email      string                  `json:"email"`
	LoginType  GlobalUserInfoLoginType `json:"login_type"`
	Name       *string                 `json:"name,omitempty"`
	SuperAdmin bool                    `json:"super_admin"`
	Verified   bool                    `json:"verified"`
}

// GlobalUserInfoLoginType defines model for GlobalUserInfo.LoginType.
type GlobalUserInfoLoginType string

// Group defines model for Group.
type Group struct {
	ExtraPerms *Group_ExtraPerms `json:"extra_perms,omitempty"`
	Members    *[]string         `json:"members,omitempty"`
	Name       string            `json:"name"`
	Summary    *string           `json:"summary,omitempty"`
}

// Group_ExtraPerms defines model for Group.ExtraPerms.
type Group_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// InputTransform defines model for InputTransform.
type InputTransform interface{}

// JavascriptTransform defines model for JavascriptTransform.
type JavascriptTransform struct {
	Expr string                  `json:"expr"`
	Type JavascriptTransformType `json:"type"`
}

// JavascriptTransformType defines model for JavascriptTransform.Type.
type JavascriptTransformType string

// Job defines model for Job.
type Job interface{}

// ListableVariable defines model for ListableVariable.
type ListableVariable struct {
	Account     *string                     `json:"account,omitempty"`
	Description *string                     `json:"description,omitempty"`
	ExtraPerms  ListableVariable_ExtraPerms `json:"extra_perms"`
	IsOauth     *bool                       `json:"is_oauth,omitempty"`
	IsSecret    bool                        `json:"is_secret"`
	Path        string                      `json:"path"`
	Value       *string                     `json:"value,omitempty"`
	WorkspaceId string                      `json:"workspace_id"`
}

// ListableVariable_ExtraPerms defines model for ListableVariable.ExtraPerms.
type ListableVariable_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// Login defines model for Login.
type Login struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

// MainArgSignature defines model for MainArgSignature.
type MainArgSignature struct {
	Args []struct {
		Default    *interface{} `json:"default,omitempty"`
		HasDefault *bool        `json:"has_default,omitempty"`
		Name       string       `json:"name"`
		Typ        interface{}  `json:"typ"`
	} `json:"args"`
	StarArgs   bool  `json:"star_args"`
	StarKwargs *bool `json:"star_kwargs,omitempty"`
}

// NewSchedule defines model for NewSchedule.
type NewSchedule struct {
	Args       ScriptArgs `json:"args"`
	Enabled    *bool      `json:"enabled,omitempty"`
	IsFlow     bool       `json:"is_flow"`
	Offset     *int       `json:"offset,omitempty"`
	Path       string     `json:"path"`
	Schedule   string     `json:"schedule"`
	ScriptPath string     `json:"script_path"`
}

// NewToken defines model for NewToken.
type NewToken struct {
	Expiration *time.Time `json:"expiration,omitempty"`
	Label      *string    `json:"label,omitempty"`
}

// NewUser defines model for NewUser.
type NewUser struct {
	Email    string `json:"email"`
	IsAdmin  bool   `json:"is_admin"`
	Username string `json:"username"`
}

// OpenFlow defines model for OpenFlow.
type OpenFlow struct {
	Description *string                 `json:"description,omitempty"`
	Schema      *map[string]interface{} `json:"schema,omitempty"`
	Summary     string                  `json:"summary"`
	Value       FlowValue               `json:"value"`
}

// OpenFlowWPath defines model for OpenFlowWPath.
type OpenFlowWPath struct {
	Description *string                 `json:"description,omitempty"`
	Path        string                  `json:"path"`
	Schema      *map[string]interface{} `json:"schema,omitempty"`
	Summary     string                  `json:"summary"`
	Value       FlowValue               `json:"value"`
}

// PathScript defines model for PathScript.
type PathScript struct {
	Path string         `json:"path"`
	Type PathScriptType `json:"type"`
}

// PathScriptType defines model for PathScript.Type.
type PathScriptType string

// Preview defines model for Preview.
type Preview struct {
	Args     ScriptArgs      `json:"args"`
	Content  string          `json:"content"`
	Language PreviewLanguage `json:"language"`
	Path     *string         `json:"path,omitempty"`
}

// PreviewLanguage defines model for Preview.Language.
type PreviewLanguage string

// QueuedJob defines model for QueuedJob.
type QueuedJob struct {
	Args           *ScriptArgs         `json:"args,omitempty"`
	Canceled       bool                `json:"canceled"`
	CanceledBy     *string             `json:"canceled_by,omitempty"`
	CanceledReason *string             `json:"canceled_reason,omitempty"`
	CreatedAt      *time.Time          `json:"created_at,omitempty"`
	CreatedBy      *string             `json:"created_by,omitempty"`
	FlowStatus     *FlowStatus         `json:"flow_status,omitempty"`
	Id             openapi_types.UUID  `json:"id"`
	IsFlowStep     bool                `json:"is_flow_step"`
	JobKind        QueuedJobJobKind    `json:"job_kind"`
	Language       *QueuedJobLanguage  `json:"language,omitempty"`
	LastPing       *time.Time          `json:"last_ping,omitempty"`
	Logs           *string             `json:"logs,omitempty"`
	ParentJob      *openapi_types.UUID `json:"parent_job,omitempty"`

	// The user (u/userfoo) or group (g/groupfoo) whom
	// the execution of this script will be permissioned_as and by extension its DT_TOKEN.
	PermissionedAs string     `json:"permissioned_as"`
	RawCode        *string    `json:"raw_code,omitempty"`
	RawFlow        *FlowValue `json:"raw_flow,omitempty"`
	Running        bool       `json:"running"`
	SchedulePath   *string    `json:"schedule_path,omitempty"`
	ScheduledFor   *time.Time `json:"scheduled_for,omitempty"`
	ScriptHash     *string    `json:"script_hash,omitempty"`
	ScriptPath     *string    `json:"script_path,omitempty"`
	StartedAt      *time.Time `json:"started_at,omitempty"`
	WorkspaceId    *string    `json:"workspace_id,omitempty"`
}

// QueuedJobJobKind defines model for QueuedJob.JobKind.
type QueuedJobJobKind string

// QueuedJobLanguage defines model for QueuedJob.Language.
type QueuedJobLanguage string

// RawScript defines model for RawScript.
type RawScript struct {
	Content  string            `json:"content"`
	Language RawScriptLanguage `json:"language"`
	Path     *string           `json:"path,omitempty"`
	Type     string            `json:"type"`
}

// RawScriptLanguage defines model for RawScript.Language.
type RawScriptLanguage string

// Resource defines model for Resource.
type Resource struct {
	Description  *string                 `json:"description,omitempty"`
	ExtraPerms   *Resource_ExtraPerms    `json:"extra_perms,omitempty"`
	IsOauth      bool                    `json:"is_oauth"`
	Path         string                  `json:"path"`
	ResourceType string                  `json:"resource_type"`
	Value        *map[string]interface{} `json:"value,omitempty"`
	WorkspaceId  *string                 `json:"workspace_id,omitempty"`
}

// Resource_ExtraPerms defines model for Resource.ExtraPerms.
type Resource_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// ResourceType defines model for ResourceType.
type ResourceType struct {
	Description *string      `json:"description,omitempty"`
	Name        string       `json:"name"`
	Schema      *interface{} `json:"schema,omitempty"`
	WorkspaceId *string      `json:"workspace_id,omitempty"`
}

// Retry defines model for Retry.
type Retry struct {
	Constant *struct {
		Attempts *int `json:"attempts,omitempty"`
		Seconds  *int `json:"seconds,omitempty"`
	} `json:"constant,omitempty"`
	Exponential *struct {
		Attempts   *int `json:"attempts,omitempty"`
		Multiplier *int `json:"multiplier,omitempty"`
		Seconds    *int `json:"seconds,omitempty"`
	} `json:"exponential,omitempty"`
}

// Schedule defines model for Schedule.
type Schedule struct {
	Args       *ScriptArgs         `json:"args,omitempty"`
	EditedAt   time.Time           `json:"edited_at"`
	EditedBy   string              `json:"edited_by"`
	Enabled    bool                `json:"enabled"`
	ExtraPerms Schedule_ExtraPerms `json:"extra_perms"`
	IsFlow     bool                `json:"is_flow"`
	Offset     int                 `json:"offset_"`
	Path       string              `json:"path"`
	Schedule   string              `json:"schedule"`
	ScriptPath string              `json:"script_path"`
}

// Schedule_ExtraPerms defines model for Schedule.ExtraPerms.
type Schedule_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// Script defines model for Script.
type Script struct {
	Archived      bool              `json:"archived"`
	Content       string            `json:"content"`
	CreatedAt     time.Time         `json:"created_at"`
	CreatedBy     string            `json:"created_by"`
	Deleted       bool              `json:"deleted"`
	Description   *string           `json:"description,omitempty"`
	ExtraPerms    Script_ExtraPerms `json:"extra_perms"`
	Hash          string            `json:"hash"`
	IsTemplate    bool              `json:"is_template"`
	Kind          ScriptKind        `json:"kind"`
	Language      ScriptLanguage    `json:"language"`
	Lock          *string           `json:"lock,omitempty"`
	LockErrorLogs *string           `json:"lock_error_logs,omitempty"`

	// The first element is the direct parent of the script, the second is the parent of the first, etc
	ParentHashes *[]string               `json:"parent_hashes,omitempty"`
	Path         string                  `json:"path"`
	Schema       *map[string]interface{} `json:"schema,omitempty"`
	Summary      string                  `json:"summary"`
	WorkspaceId  *string                 `json:"workspace_id,omitempty"`
}

// Script_ExtraPerms defines model for Script.ExtraPerms.
type Script_ExtraPerms struct {
	AdditionalProperties map[string]bool `json:"-"`
}

// ScriptKind defines model for Script.Kind.
type ScriptKind string

// ScriptLanguage defines model for Script.Language.
type ScriptLanguage string

// ScriptArgs defines model for ScriptArgs.
type ScriptArgs struct {
	AdditionalProperties map[string]interface{} `json:"-"`
}

// SlackToken defines model for SlackToken.
type SlackToken struct {
	AccessToken string `json:"access_token"`
	Bot         struct {
		BotAccessToken *string `json:"bot_access_token,omitempty"`
	} `json:"bot"`
	TeamId   string `json:"team_id"`
	TeamName string `json:"team_name"`
}

// StaticTransform defines model for StaticTransform.
type StaticTransform struct {
	Type  StaticTransformType `json:"type"`
	Value *interface{}        `json:"value,omitempty"`
}

// StaticTransformType defines model for StaticTransform.Type.
type StaticTransformType string

// TokenResponse defines model for TokenResponse.
type TokenResponse struct {
	AccessToken  string    `json:"access_token"`
	ExpiresIn    *int      `json:"expires_in,omitempty"`
	RefreshToken *string   `json:"refresh_token,omitempty"`
	Scope        *[]string `json:"scope,omitempty"`
}

// TruncatedToken defines model for TruncatedToken.
type TruncatedToken struct {
	CreatedAt   time.Time  `json:"created_at"`
	Expiration  *time.Time `json:"expiration,omitempty"`
	Label       *string    `json:"label,omitempty"`
	LastUsedAt  time.Time  `json:"last_used_at"`
	TokenPrefix string     `json:"token_prefix"`
}

// Usage defines model for Usage.
type Usage struct {
	DurationMs *int `json:"duration_ms,omitempty"`
	Flows      *int `json:"flows,omitempty"`
	Jobs       *int `json:"jobs,omitempty"`
}

// User defines model for User.
type User struct {
	CreatedAt    time.Time `json:"created_at"`
	Disabled     bool      `json:"disabled"`
	Email        string    `json:"email"`
	Groups       *[]string `json:"groups,omitempty"`
	IsAdmin      bool      `json:"is_admin"`
	IsSuperAdmin bool      `json:"is_super_admin"`
	Operator     bool      `json:"operator"`
	Usage        *Usage    `json:"usage,omitempty"`
	Username     string    `json:"username"`
}

// UserWorkspaceList defines model for UserWorkspaceList.
type UserWorkspaceList struct {
	Email      string `json:"email"`
	Workspaces []struct {
		Id       string `json:"id"`
		Name     string `json:"name"`
		Username string `json:"username"`
	} `json:"workspaces"`
}

// WorkerPing defines model for WorkerPing.
type WorkerPing struct {
	Ip             string    `json:"ip"`
	JobsExecuted   int       `json:"jobs_executed"`
	PingAt         time.Time `json:"ping_at"`
	StartedAt      time.Time `json:"started_at"`
	Worker         string    `json:"worker"`
	WorkerInstance string    `json:"worker_instance"`
}

// Workspace defines model for Workspace.
type Workspace struct {
	Domain *string `json:"domain,omitempty"`
	Id     string  `json:"id"`
	Name   string  `json:"name"`
	Owner  string  `json:"owner"`
}

// WorkspaceInvite defines model for WorkspaceInvite.
type WorkspaceInvite struct {
	Email       string `json:"email"`
	IsAdmin     bool   `json:"is_admin"`
	WorkspaceId string `json:"workspace_id"`
}

// AccountId defines model for AccountId.
type AccountId = string

// ActionKind defines model for ActionKind.
type ActionKind string

// After defines model for After.
type After = time.Time

// Before defines model for Before.
type Before = time.Time

// ClientName defines model for ClientName.
type ClientName = string

// CreatedAfter defines model for CreatedAfter.
type CreatedAfter = time.Time

// CreatedBefore defines model for CreatedBefore.
type CreatedBefore = time.Time

// CreatedBy defines model for CreatedBy.
type CreatedBy = string

// JobId defines model for JobId.
type JobId = openapi_types.UUID

// JobKinds defines model for JobKinds.
type JobKinds = string

// Name defines model for Name.
type Name = string

// Operation defines model for Operation.
type Operation = string

// OrderDesc defines model for OrderDesc.
type OrderDesc = bool

// Page defines model for Page.
type Page = int

// ParentJob defines model for ParentJob.
type ParentJob = openapi_types.UUID

// Path defines model for Path.
type Path = string

// PathId defines model for PathId.
type PathId = int

// PerPage defines model for PerPage.
type PerPage = int

// ScriptExactHash defines model for ScriptExactHash.
type ScriptExactHash = string

// ScriptExactPath defines model for ScriptExactPath.
type ScriptExactPath = string

// ScriptHash defines model for ScriptHash.
type ScriptHash = string

// ScriptPath defines model for ScriptPath.
type ScriptPath = string

// ScriptStartPath defines model for ScriptStartPath.
type ScriptStartPath = string

// Success defines model for Success.
type Success = bool

// Username defines model for Username.
type Username = string

// WorkspaceId defines model for WorkspaceId.
type WorkspaceId = string

// LoginJSONBody defines parameters for Login.
type LoginJSONBody = Login

// ConnectCallbackJSONBody defines parameters for ConnectCallback.
type ConnectCallbackJSONBody struct {
	Code  string `json:"code"`
	State string `json:"state"`
}

// ConnectSlackCallbackJSONBody defines parameters for ConnectSlackCallback.
type ConnectSlackCallbackJSONBody struct {
	Code  string `json:"code"`
	State string `json:"state"`
}

// LoginWithOauthJSONBody defines parameters for LoginWithOauth.
type LoginWithOauthJSONBody struct {
	Code  *string `json:"code,omitempty"`
	State *string `json:"state,omitempty"`
}

// PreviewScheduleJSONBody defines parameters for PreviewSchedule.
type PreviewScheduleJSONBody struct {
	Offset   *int   `json:"offset,omitempty"`
	Schedule string `json:"schedule"`
}

// DenoToJsonschemaJSONBody defines parameters for DenoToJsonschema.
type DenoToJsonschemaJSONBody = string

// GoToJsonschemaJSONBody defines parameters for GoToJsonschema.
type GoToJsonschemaJSONBody = string

// PythonToJsonschemaJSONBody defines parameters for PythonToJsonschema.
type PythonToJsonschemaJSONBody = string

// AcceptInviteJSONBody defines parameters for AcceptInvite.
type AcceptInviteJSONBody struct {
	Username    string `json:"username"`
	WorkspaceId string `json:"workspace_id"`
}

// CreateUserGloballyJSONBody defines parameters for CreateUserGlobally.
type CreateUserGloballyJSONBody struct {
	Company    *string `json:"company,omitempty"`
	Email      string  `json:"email"`
	Name       *string `json:"name,omitempty"`
	Password   string  `json:"password"`
	SuperAdmin bool    `json:"super_admin"`
}

// DeclineInviteJSONBody defines parameters for DeclineInvite.
type DeclineInviteJSONBody struct {
	WorkspaceId string `json:"workspace_id"`
}

// ListUsersAsSuperAdminParams defines parameters for ListUsersAsSuperAdmin.
type ListUsersAsSuperAdminParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// SetPasswordJSONBody defines parameters for SetPassword.
type SetPasswordJSONBody struct {
	Password string `json:"password"`
}

// CreateTokenJSONBody defines parameters for CreateToken.
type CreateTokenJSONBody = NewToken

// GlobalUserUpdateJSONBody defines parameters for GlobalUserUpdate.
type GlobalUserUpdateJSONBody struct {
	IsSuperAdmin *bool `json:"is_super_admin,omitempty"`
}

// AddGranularAclsJSONBody defines parameters for AddGranularAcls.
type AddGranularAclsJSONBody struct {
	Owner string `json:"owner"`
	Write *bool  `json:"write,omitempty"`
}

// AddGranularAclsParamsKind defines parameters for AddGranularAcls.
type AddGranularAclsParamsKind string

// GetGranularAclsParamsKind defines parameters for GetGranularAcls.
type GetGranularAclsParamsKind string

// RemoveGranularAclsJSONBody defines parameters for RemoveGranularAcls.
type RemoveGranularAclsJSONBody struct {
	Owner string `json:"owner"`
}

// RemoveGranularAclsParamsKind defines parameters for RemoveGranularAcls.
type RemoveGranularAclsParamsKind string

// ListAuditLogsParams defines parameters for ListAuditLogs.
type ListAuditLogsParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// filter on created before (exclusive) timestamp
	Before *Before `form:"before,omitempty" json:"before,omitempty"`

	// filter on created after (exclusive) timestamp
	After *After `form:"after,omitempty" json:"after,omitempty"`

	// filter on exact username of user
	Username *Username `form:"username,omitempty" json:"username,omitempty"`

	// filter on exact or prefix name of operation
	Operation *Operation `form:"operation,omitempty" json:"operation,omitempty"`

	// filter on exact or prefix name of resource
	Resource *Resource `form:"resource,omitempty" json:"resource,omitempty"`

	// filter on type of operation
	ActionKind *ListAuditLogsParamsActionKind `form:"action_kind,omitempty" json:"action_kind,omitempty"`
}

// ListAuditLogsParamsActionKind defines parameters for ListAuditLogs.
type ListAuditLogsParamsActionKind string

// CreateFlowJSONBody defines parameters for CreateFlow.
type CreateFlowJSONBody = OpenFlowWPath

// ListFlowsParams defines parameters for ListFlows.
type ListFlowsParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// order by desc order (default true)
	OrderDesc *OrderDesc `form:"order_desc,omitempty" json:"order_desc,omitempty"`

	// mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// mask to filter matching starting path
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`

	// mask to filter exact matching path
	PathExact *string `form:"path_exact,omitempty" json:"path_exact,omitempty"`

	// (default false)
	// show also the archived files.
	// when multiple archived hash share the same path, only the ones with the latest create_at
	// are displayed.
	ShowArchived *bool `form:"show_archived,omitempty" json:"show_archived,omitempty"`
}

// UpdateFlowJSONBody defines parameters for UpdateFlow.
type UpdateFlowJSONBody = OpenFlowWPath

// AddUserToGroupJSONBody defines parameters for AddUserToGroup.
type AddUserToGroupJSONBody struct {
	Username *string `json:"username,omitempty"`
}

// CreateGroupJSONBody defines parameters for CreateGroup.
type CreateGroupJSONBody struct {
	Name    string  `json:"name"`
	Summary *string `json:"summary,omitempty"`
}

// ListGroupsParams defines parameters for ListGroups.
type ListGroupsParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// RemoveUserToGroupJSONBody defines parameters for RemoveUserToGroup.
type RemoveUserToGroupJSONBody struct {
	Username *string `json:"username,omitempty"`
}

// UpdateGroupJSONBody defines parameters for UpdateGroup.
type UpdateGroupJSONBody struct {
	Summary *string `json:"summary,omitempty"`
}

// CancelSuspendedJobGetParams defines parameters for CancelSuspendedJobGet.
type CancelSuspendedJobGetParams struct {
	Payload *map[string]interface{} `form:"payload,omitempty" json:"payload,omitempty"`
}

// CancelSuspendedJobPostJSONBody defines parameters for CancelSuspendedJobPost.
type CancelSuspendedJobPostJSONBody = map[string]interface{}

// ListCompletedJobsParams defines parameters for ListCompletedJobs.
type ListCompletedJobsParams struct {
	// order by desc order (default true)
	OrderDesc *OrderDesc `form:"order_desc,omitempty" json:"order_desc,omitempty"`

	// mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// mask to filter exact matching path
	ScriptPathExact *ScriptExactPath `form:"script_path_exact,omitempty" json:"script_path_exact,omitempty"`

	// mask to filter matching starting path
	ScriptPathStart *ScriptStartPath `form:"script_path_start,omitempty" json:"script_path_start,omitempty"`

	// mask to filter exact matching path
	ScriptHash *ScriptExactHash `form:"script_hash,omitempty" json:"script_hash,omitempty"`

	// filter on created before (inclusive) timestamp
	CreatedBefore *CreatedBefore `form:"created_before,omitempty" json:"created_before,omitempty"`

	// filter on created after (exclusive) timestamp
	CreatedAfter *CreatedAfter `form:"created_after,omitempty" json:"created_after,omitempty"`

	// filter on successful jobs
	Success *Success `form:"success,omitempty" json:"success,omitempty"`

	// filter on job kind (values 'preview', 'script', 'dependencies', 'flow') separated by,
	JobKinds *JobKinds `form:"job_kinds,omitempty" json:"job_kinds,omitempty"`

	// is the job skipped
	IsSkipped *bool `form:"is_skipped,omitempty" json:"is_skipped,omitempty"`

	// is the job a flow step
	IsFlowStep *bool `form:"is_flow_step,omitempty" json:"is_flow_step,omitempty"`
}

// GetJobUpdatesParams defines parameters for GetJobUpdates.
type GetJobUpdatesParams struct {
	Running   *bool `form:"running,omitempty" json:"running,omitempty"`
	LogOffset *int  `form:"log_offset,omitempty" json:"log_offset,omitempty"`
}

// ListJobsParams defines parameters for ListJobs.
type ListJobsParams struct {
	// mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// mask to filter exact matching path
	ScriptPathExact *ScriptExactPath `form:"script_path_exact,omitempty" json:"script_path_exact,omitempty"`

	// mask to filter matching starting path
	ScriptPathStart *ScriptStartPath `form:"script_path_start,omitempty" json:"script_path_start,omitempty"`

	// mask to filter exact matching path
	ScriptHash *ScriptExactHash `form:"script_hash,omitempty" json:"script_hash,omitempty"`

	// filter on created before (inclusive) timestamp
	CreatedBefore *CreatedBefore `form:"created_before,omitempty" json:"created_before,omitempty"`

	// filter on created after (exclusive) timestamp
	CreatedAfter *CreatedAfter `form:"created_after,omitempty" json:"created_after,omitempty"`

	// filter on job kind (values 'preview', 'script', 'dependencies', 'flow') separated by,
	JobKinds *JobKinds `form:"job_kinds,omitempty" json:"job_kinds,omitempty"`

	// is the job skipped
	IsSkipped *bool `form:"is_skipped,omitempty" json:"is_skipped,omitempty"`

	// is the job a flow step
	IsFlowStep *bool `form:"is_flow_step,omitempty" json:"is_flow_step,omitempty"`

	// filter on successful jobs
	Success *bool `form:"success,omitempty" json:"success,omitempty"`
}

// CancelQueuedJobJSONBody defines parameters for CancelQueuedJob.
type CancelQueuedJobJSONBody struct {
	Reason *string `json:"reason,omitempty"`
}

// ListQueueParams defines parameters for ListQueue.
type ListQueueParams struct {
	// order by desc order (default true)
	OrderDesc *OrderDesc `form:"order_desc,omitempty" json:"order_desc,omitempty"`

	// mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`

	// mask to filter exact matching path
	ScriptPathExact *ScriptExactPath `form:"script_path_exact,omitempty" json:"script_path_exact,omitempty"`

	// mask to filter matching starting path
	ScriptPathStart *ScriptStartPath `form:"script_path_start,omitempty" json:"script_path_start,omitempty"`

	// mask to filter exact matching path
	ScriptHash *ScriptExactHash `form:"script_hash,omitempty" json:"script_hash,omitempty"`

	// filter on created before (inclusive) timestamp
	CreatedBefore *CreatedBefore `form:"created_before,omitempty" json:"created_before,omitempty"`

	// filter on created after (exclusive) timestamp
	CreatedAfter *CreatedAfter `form:"created_after,omitempty" json:"created_after,omitempty"`

	// filter on successful jobs
	Success *Success `form:"success,omitempty" json:"success,omitempty"`

	// filter on job kind (values 'preview', 'script', 'dependencies', 'flow') separated by,
	JobKinds *JobKinds `form:"job_kinds,omitempty" json:"job_kinds,omitempty"`
}

// ResumeSuspendedJobGetParams defines parameters for ResumeSuspendedJobGet.
type ResumeSuspendedJobGetParams struct {
	Payload *map[string]interface{} `form:"payload,omitempty" json:"payload,omitempty"`
}

// ResumeSuspendedJobPostJSONBody defines parameters for ResumeSuspendedJobPost.
type ResumeSuspendedJobPostJSONBody = map[string]interface{}

// RunFlowByPathJSONBody defines parameters for RunFlowByPath.
type RunFlowByPathJSONBody = ScriptArgs

// RunFlowByPathParams defines parameters for RunFlowByPath.
type RunFlowByPathParams struct {
	// when to schedule this job (leave empty for immediate run)
	ScheduledFor *time.Time `form:"scheduled_for,omitempty" json:"scheduled_for,omitempty"`

	// schedule the script to execute in the number of seconds starting now
	ScheduledInSecs *int `form:"scheduled_in_secs,omitempty" json:"scheduled_in_secs,omitempty"`

	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`
}

// RunScriptByHashJSONBody defines parameters for RunScriptByHash.
type RunScriptByHashJSONBody = map[string]interface{}

// RunScriptByHashParams defines parameters for RunScriptByHash.
type RunScriptByHashParams struct {
	// when to schedule this job (leave empty for immediate run)
	ScheduledFor *time.Time `form:"scheduled_for,omitempty" json:"scheduled_for,omitempty"`

	// schedule the script to execute in the number of seconds starting now
	ScheduledInSecs *int `form:"scheduled_in_secs,omitempty" json:"scheduled_in_secs,omitempty"`

	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`
}

// RunScriptByPathJSONBody defines parameters for RunScriptByPath.
type RunScriptByPathJSONBody = ScriptArgs

// RunScriptByPathParams defines parameters for RunScriptByPath.
type RunScriptByPathParams struct {
	// when to schedule this job (leave empty for immediate run)
	ScheduledFor *time.Time `form:"scheduled_for,omitempty" json:"scheduled_for,omitempty"`

	// schedule the script to execute in the number of seconds starting now
	ScheduledInSecs *int `form:"scheduled_in_secs,omitempty" json:"scheduled_in_secs,omitempty"`

	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`
}

// RunScriptPreviewJSONBody defines parameters for RunScriptPreview.
type RunScriptPreviewJSONBody = Preview

// RunFlowPreviewJSONBody defines parameters for RunFlowPreview.
type RunFlowPreviewJSONBody = FlowPreview

// RunWaitResultScriptByPathJSONBody defines parameters for RunWaitResultScriptByPath.
type RunWaitResultScriptByPathJSONBody = ScriptArgs

// RunWaitResultScriptByPathParams defines parameters for RunWaitResultScriptByPath.
type RunWaitResultScriptByPathParams struct {
	// when to schedule this job (leave empty for immediate run)
	ScheduledFor *time.Time `form:"scheduled_for,omitempty" json:"scheduled_for,omitempty"`

	// schedule the script to execute in the number of seconds starting now
	ScheduledInSecs *int `form:"scheduled_in_secs,omitempty" json:"scheduled_in_secs,omitempty"`

	// The parent job that is at the origin and responsible for the execution of this script if any
	ParentJob *ParentJob `form:"parent_job,omitempty" json:"parent_job,omitempty"`
}

// CreateAccountJSONBody defines parameters for CreateAccount.
type CreateAccountJSONBody struct {
	Client       string `json:"client"`
	ExpiresIn    int    `json:"expires_in"`
	Owner        string `json:"owner"`
	RefreshToken string `json:"refresh_token"`
}

// RefreshTokenJSONBody defines parameters for RefreshToken.
type RefreshTokenJSONBody struct {
	Path string `json:"path"`
}

// SetWorkspaceSlackJSONBody defines parameters for SetWorkspaceSlack.
type SetWorkspaceSlackJSONBody = SlackToken

// CreateResourceJSONBody defines parameters for CreateResource.
type CreateResourceJSONBody = CreateResource

// ListResourceParams defines parameters for ListResource.
type ListResourceParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// resource_type to list from
	ResourceType *string `form:"resource_type,omitempty" json:"resource_type,omitempty"`
}

// CreateResourceTypeJSONBody defines parameters for CreateResourceType.
type CreateResourceTypeJSONBody = ResourceType

// UpdateResourceTypeJSONBody defines parameters for UpdateResourceType.
type UpdateResourceTypeJSONBody = EditResourceType

// UpdateResourceJSONBody defines parameters for UpdateResource.
type UpdateResourceJSONBody = EditResource

// CreateScheduleJSONBody defines parameters for CreateSchedule.
type CreateScheduleJSONBody = NewSchedule

// ListSchedulesParams defines parameters for ListSchedules.
type ListSchedulesParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// SetScheduleEnabledJSONBody defines parameters for SetScheduleEnabled.
type SetScheduleEnabledJSONBody struct {
	Enabled bool `json:"enabled"`
}

// UpdateScheduleJSONBody defines parameters for UpdateSchedule.
type UpdateScheduleJSONBody = EditSchedule

// CreateScriptJSONBody defines parameters for CreateScript.
type CreateScriptJSONBody struct {
	Content     string                       `json:"content"`
	Description string                       `json:"description"`
	IsTemplate  *bool                        `json:"is_template,omitempty"`
	Kind        *CreateScriptJSONBodyKind    `json:"kind,omitempty"`
	Language    CreateScriptJSONBodyLanguage `json:"language"`
	Lock        *[]string                    `json:"lock,omitempty"`
	ParentHash  *string                      `json:"parent_hash,omitempty"`
	Path        string                       `json:"path"`
	Schema      *map[string]interface{}      `json:"schema,omitempty"`
	Summary     string                       `json:"summary"`
}

// CreateScriptJSONBodyKind defines parameters for CreateScript.
type CreateScriptJSONBodyKind string

// CreateScriptJSONBodyLanguage defines parameters for CreateScript.
type CreateScriptJSONBodyLanguage string

// ListScriptsParams defines parameters for ListScripts.
type ListScriptsParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// order by desc order (default true)
	OrderDesc *OrderDesc `form:"order_desc,omitempty" json:"order_desc,omitempty"`

	// mask to filter exact matching user creator
	CreatedBy *CreatedBy `form:"created_by,omitempty" json:"created_by,omitempty"`

	// mask to filter matching starting path
	PathStart *string `form:"path_start,omitempty" json:"path_start,omitempty"`

	// mask to filter exact matching path
	PathExact *string `form:"path_exact,omitempty" json:"path_exact,omitempty"`

	// mask to filter scripts whom first direct parent has exact hash
	FirstParentHash *string `form:"first_parent_hash,omitempty" json:"first_parent_hash,omitempty"`

	// mask to filter scripts whom last parent in the chain has exact hash.
	// Beware that each script stores only a limited number of parents. Hence
	// the last parent hash for a script is not necessarily its top-most parent.
	// To find the top-most parent you will have to jump from last to last hash
	//  until finding the parent
	LastParentHash *string `form:"last_parent_hash,omitempty" json:"last_parent_hash,omitempty"`

	// is the hash present in the array of stored parent hashes for this script.
	// The same warning applies than for last_parent_hash. A script only store a
	// limited number of direct parent
	ParentHash *string `form:"parent_hash,omitempty" json:"parent_hash,omitempty"`

	// (default false)
	// show also the archived files.
	// when multiple archived hash share the same path, only the ones with the latest create_at
	// are displayed.
	ShowArchived *bool `form:"show_archived,omitempty" json:"show_archived,omitempty"`

	// (default regardless)
	// if true show only the templates
	// if false show only the non templates
	// if not defined, show all regardless of if the script is a template
	IsTemplate *bool `form:"is_template,omitempty" json:"is_template,omitempty"`

	// (default regardless)
	// script kind
	Kind *string `form:"kind,omitempty" json:"kind,omitempty"`
}

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody = NewUser

// UpdateUserJSONBody defines parameters for UpdateUser.
type UpdateUserJSONBody = EditWorkspaceUser

// CreateVariableJSONBody defines parameters for CreateVariable.
type CreateVariableJSONBody = CreateVariable

// GetVariableParams defines parameters for GetVariable.
type GetVariableParams struct {
	// ask to decrypt secret if this variable is secret
	// (if not secret no effect, default: true)
	DecryptSecret *bool `form:"decrypt_secret,omitempty" json:"decrypt_secret,omitempty"`
}

// UpdateVariableJSONBody defines parameters for UpdateVariable.
type UpdateVariableJSONBody = EditVariable

// DeleteInviteJSONBody defines parameters for DeleteInvite.
type DeleteInviteJSONBody struct {
	Email   string `json:"email"`
	IsAdmin bool   `json:"is_admin"`
}

// EditSlackCommandJSONBody defines parameters for EditSlackCommand.
type EditSlackCommandJSONBody struct {
	SlackCommandScript *string `json:"slack_command_script,omitempty"`
}

// InviteUserJSONBody defines parameters for InviteUser.
type InviteUserJSONBody struct {
	Email   string `json:"email"`
	IsAdmin bool   `json:"is_admin"`
}

// ListWorkersParams defines parameters for ListWorkers.
type ListWorkersParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// CreateWorkspaceJSONBody defines parameters for CreateWorkspace.
type CreateWorkspaceJSONBody = CreateWorkspace

// ExistsWorkspaceJSONBody defines parameters for ExistsWorkspace.
type ExistsWorkspaceJSONBody struct {
	Id string `json:"id"`
}

// ExistsUsernameJSONBody defines parameters for ExistsUsername.
type ExistsUsernameJSONBody struct {
	Id       string `json:"id"`
	Username string `json:"username"`
}

// ListWorkspacesAsSuperAdminParams defines parameters for ListWorkspacesAsSuperAdmin.
type ListWorkspacesAsSuperAdminParams struct {
	// which page to return (start at 1, default 1)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// number of items to return for a given page (default 30, max 100)
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody = LoginJSONBody

// ConnectCallbackJSONRequestBody defines body for ConnectCallback for application/json ContentType.
type ConnectCallbackJSONRequestBody ConnectCallbackJSONBody

// ConnectSlackCallbackJSONRequestBody defines body for ConnectSlackCallback for application/json ContentType.
type ConnectSlackCallbackJSONRequestBody ConnectSlackCallbackJSONBody

// LoginWithOauthJSONRequestBody defines body for LoginWithOauth for application/json ContentType.
type LoginWithOauthJSONRequestBody LoginWithOauthJSONBody

// PreviewScheduleJSONRequestBody defines body for PreviewSchedule for application/json ContentType.
type PreviewScheduleJSONRequestBody PreviewScheduleJSONBody

// DenoToJsonschemaJSONRequestBody defines body for DenoToJsonschema for application/json ContentType.
type DenoToJsonschemaJSONRequestBody = DenoToJsonschemaJSONBody

// GoToJsonschemaJSONRequestBody defines body for GoToJsonschema for application/json ContentType.
type GoToJsonschemaJSONRequestBody = GoToJsonschemaJSONBody

// PythonToJsonschemaJSONRequestBody defines body for PythonToJsonschema for application/json ContentType.
type PythonToJsonschemaJSONRequestBody = PythonToJsonschemaJSONBody

// AcceptInviteJSONRequestBody defines body for AcceptInvite for application/json ContentType.
type AcceptInviteJSONRequestBody AcceptInviteJSONBody

// CreateUserGloballyJSONRequestBody defines body for CreateUserGlobally for application/json ContentType.
type CreateUserGloballyJSONRequestBody CreateUserGloballyJSONBody

// DeclineInviteJSONRequestBody defines body for DeclineInvite for application/json ContentType.
type DeclineInviteJSONRequestBody DeclineInviteJSONBody

// SetPasswordJSONRequestBody defines body for SetPassword for application/json ContentType.
type SetPasswordJSONRequestBody SetPasswordJSONBody

// CreateTokenJSONRequestBody defines body for CreateToken for application/json ContentType.
type CreateTokenJSONRequestBody = CreateTokenJSONBody

// GlobalUserUpdateJSONRequestBody defines body for GlobalUserUpdate for application/json ContentType.
type GlobalUserUpdateJSONRequestBody GlobalUserUpdateJSONBody

// AddGranularAclsJSONRequestBody defines body for AddGranularAcls for application/json ContentType.
type AddGranularAclsJSONRequestBody AddGranularAclsJSONBody

// RemoveGranularAclsJSONRequestBody defines body for RemoveGranularAcls for application/json ContentType.
type RemoveGranularAclsJSONRequestBody RemoveGranularAclsJSONBody

// CreateFlowJSONRequestBody defines body for CreateFlow for application/json ContentType.
type CreateFlowJSONRequestBody = CreateFlowJSONBody

// UpdateFlowJSONRequestBody defines body for UpdateFlow for application/json ContentType.
type UpdateFlowJSONRequestBody = UpdateFlowJSONBody

// AddUserToGroupJSONRequestBody defines body for AddUserToGroup for application/json ContentType.
type AddUserToGroupJSONRequestBody AddUserToGroupJSONBody

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody CreateGroupJSONBody

// RemoveUserToGroupJSONRequestBody defines body for RemoveUserToGroup for application/json ContentType.
type RemoveUserToGroupJSONRequestBody RemoveUserToGroupJSONBody

// UpdateGroupJSONRequestBody defines body for UpdateGroup for application/json ContentType.
type UpdateGroupJSONRequestBody UpdateGroupJSONBody

// CancelSuspendedJobPostJSONRequestBody defines body for CancelSuspendedJobPost for application/json ContentType.
type CancelSuspendedJobPostJSONRequestBody = CancelSuspendedJobPostJSONBody

// CancelQueuedJobJSONRequestBody defines body for CancelQueuedJob for application/json ContentType.
type CancelQueuedJobJSONRequestBody CancelQueuedJobJSONBody

// ResumeSuspendedJobPostJSONRequestBody defines body for ResumeSuspendedJobPost for application/json ContentType.
type ResumeSuspendedJobPostJSONRequestBody = ResumeSuspendedJobPostJSONBody

// RunFlowByPathJSONRequestBody defines body for RunFlowByPath for application/json ContentType.
type RunFlowByPathJSONRequestBody = RunFlowByPathJSONBody

// RunScriptByHashJSONRequestBody defines body for RunScriptByHash for application/json ContentType.
type RunScriptByHashJSONRequestBody = RunScriptByHashJSONBody

// RunScriptByPathJSONRequestBody defines body for RunScriptByPath for application/json ContentType.
type RunScriptByPathJSONRequestBody = RunScriptByPathJSONBody

// RunScriptPreviewJSONRequestBody defines body for RunScriptPreview for application/json ContentType.
type RunScriptPreviewJSONRequestBody = RunScriptPreviewJSONBody

// RunFlowPreviewJSONRequestBody defines body for RunFlowPreview for application/json ContentType.
type RunFlowPreviewJSONRequestBody = RunFlowPreviewJSONBody

// RunWaitResultScriptByPathJSONRequestBody defines body for RunWaitResultScriptByPath for application/json ContentType.
type RunWaitResultScriptByPathJSONRequestBody = RunWaitResultScriptByPathJSONBody

// CreateAccountJSONRequestBody defines body for CreateAccount for application/json ContentType.
type CreateAccountJSONRequestBody CreateAccountJSONBody

// RefreshTokenJSONRequestBody defines body for RefreshToken for application/json ContentType.
type RefreshTokenJSONRequestBody RefreshTokenJSONBody

// SetWorkspaceSlackJSONRequestBody defines body for SetWorkspaceSlack for application/json ContentType.
type SetWorkspaceSlackJSONRequestBody = SetWorkspaceSlackJSONBody

// CreateResourceJSONRequestBody defines body for CreateResource for application/json ContentType.
type CreateResourceJSONRequestBody = CreateResourceJSONBody

// CreateResourceTypeJSONRequestBody defines body for CreateResourceType for application/json ContentType.
type CreateResourceTypeJSONRequestBody = CreateResourceTypeJSONBody

// UpdateResourceTypeJSONRequestBody defines body for UpdateResourceType for application/json ContentType.
type UpdateResourceTypeJSONRequestBody = UpdateResourceTypeJSONBody

// UpdateResourceJSONRequestBody defines body for UpdateResource for application/json ContentType.
type UpdateResourceJSONRequestBody = UpdateResourceJSONBody

// CreateScheduleJSONRequestBody defines body for CreateSchedule for application/json ContentType.
type CreateScheduleJSONRequestBody = CreateScheduleJSONBody

// SetScheduleEnabledJSONRequestBody defines body for SetScheduleEnabled for application/json ContentType.
type SetScheduleEnabledJSONRequestBody SetScheduleEnabledJSONBody

// UpdateScheduleJSONRequestBody defines body for UpdateSchedule for application/json ContentType.
type UpdateScheduleJSONRequestBody = UpdateScheduleJSONBody

// CreateScriptJSONRequestBody defines body for CreateScript for application/json ContentType.
type CreateScriptJSONRequestBody CreateScriptJSONBody

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody = CreateUserJSONBody

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = UpdateUserJSONBody

// CreateVariableJSONRequestBody defines body for CreateVariable for application/json ContentType.
type CreateVariableJSONRequestBody = CreateVariableJSONBody

// UpdateVariableJSONRequestBody defines body for UpdateVariable for application/json ContentType.
type UpdateVariableJSONRequestBody = UpdateVariableJSONBody

// DeleteInviteJSONRequestBody defines body for DeleteInvite for application/json ContentType.
type DeleteInviteJSONRequestBody DeleteInviteJSONBody

// EditSlackCommandJSONRequestBody defines body for EditSlackCommand for application/json ContentType.
type EditSlackCommandJSONRequestBody EditSlackCommandJSONBody

// InviteUserJSONRequestBody defines body for InviteUser for application/json ContentType.
type InviteUserJSONRequestBody InviteUserJSONBody

// CreateWorkspaceJSONRequestBody defines body for CreateWorkspace for application/json ContentType.
type CreateWorkspaceJSONRequestBody = CreateWorkspaceJSONBody

// ExistsWorkspaceJSONRequestBody defines body for ExistsWorkspace for application/json ContentType.
type ExistsWorkspaceJSONRequestBody ExistsWorkspaceJSONBody

// ExistsUsernameJSONRequestBody defines body for ExistsUsername for application/json ContentType.
type ExistsUsernameJSONRequestBody ExistsUsernameJSONBody

// Getter for additional properties for FlowModule_InputTransforms. Returns the specified
// element and whether it was found
func (a FlowModule_InputTransforms) Get(fieldName string) (value InputTransform, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for FlowModule_InputTransforms
func (a *FlowModule_InputTransforms) Set(fieldName string, value InputTransform) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]InputTransform)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for FlowModule_InputTransforms to handle AdditionalProperties
func (a *FlowModule_InputTransforms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]InputTransform)
		for fieldName, fieldBuf := range object {
			var fieldVal InputTransform
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for FlowModule_InputTransforms to handle AdditionalProperties
func (a FlowModule_InputTransforms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Group_ExtraPerms. Returns the specified
// element and whether it was found
func (a Group_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Group_ExtraPerms
func (a *Group_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Group_ExtraPerms to handle AdditionalProperties
func (a *Group_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Group_ExtraPerms to handle AdditionalProperties
func (a Group_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ListableVariable_ExtraPerms. Returns the specified
// element and whether it was found
func (a ListableVariable_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ListableVariable_ExtraPerms
func (a *ListableVariable_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ListableVariable_ExtraPerms to handle AdditionalProperties
func (a *ListableVariable_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ListableVariable_ExtraPerms to handle AdditionalProperties
func (a ListableVariable_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Resource_ExtraPerms. Returns the specified
// element and whether it was found
func (a Resource_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Resource_ExtraPerms
func (a *Resource_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Resource_ExtraPerms to handle AdditionalProperties
func (a *Resource_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Resource_ExtraPerms to handle AdditionalProperties
func (a Resource_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Schedule_ExtraPerms. Returns the specified
// element and whether it was found
func (a Schedule_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Schedule_ExtraPerms
func (a *Schedule_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Schedule_ExtraPerms to handle AdditionalProperties
func (a *Schedule_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Schedule_ExtraPerms to handle AdditionalProperties
func (a Schedule_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Script_ExtraPerms. Returns the specified
// element and whether it was found
func (a Script_ExtraPerms) Get(fieldName string) (value bool, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Script_ExtraPerms
func (a *Script_ExtraPerms) Set(fieldName string, value bool) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]bool)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Script_ExtraPerms to handle AdditionalProperties
func (a *Script_ExtraPerms) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]bool)
		for fieldName, fieldBuf := range object {
			var fieldVal bool
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Script_ExtraPerms to handle AdditionalProperties
func (a Script_ExtraPerms) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ScriptArgs. Returns the specified
// element and whether it was found
func (a ScriptArgs) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ScriptArgs
func (a *ScriptArgs) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ScriptArgs to handle AdditionalProperties
func (a *ScriptArgs) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ScriptArgs to handle AdditionalProperties
func (a ScriptArgs) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// login with password
	// (POST /auth/login)
	Login(ctx echo.Context) error
	// get hub flow by id
	// (GET /flows/hub/get/{id})
	GetHubFlowById(ctx echo.Context, id PathId) error
	// list all available hub flows
	// (GET /flows/hub/list)
	ListHubFlows(ctx echo.Context) error
	// connect callback
	// (POST /oauth/connect_callback/{client_name})
	ConnectCallback(ctx echo.Context, clientName ClientName) error
	// connect slack callback
	// (POST /oauth/connect_slack_callback)
	ConnectSlackCallback(ctx echo.Context) error
	// list oauth connects
	// (GET /oauth/list_connects)
	ListOAuthConnects(ctx echo.Context) error
	// list oauth logins
	// (GET /oauth/list_logins)
	ListOAuthLogins(ctx echo.Context) error
	// login with oauth authorization flow
	// (POST /oauth/login_callback/{client_name})
	LoginWithOauth(ctx echo.Context, clientName ClientName) error
	// get openapi yaml spec
	// (GET /openapi.yaml)
	GetOpenApiYaml(ctx echo.Context) error
	// preview schedule
	// (POST /schedules/preview)
	PreviewSchedule(ctx echo.Context) error
	// inspect deno code to infer jsonschema of arguments
	// (POST /scripts/deno/tojsonschema)
	DenoToJsonschema(ctx echo.Context) error
	// inspect go code to infer jsonschema of arguments
	// (POST /scripts/go/tojsonschema)
	GoToJsonschema(ctx echo.Context) error
	// get hub script content by path
	// (GET /scripts/hub/get/{path})
	GetHubScriptContentByPath(ctx echo.Context, path ScriptPath) error
	// list all available hub scripts
	// (GET /scripts/hub/list)
	ListHubScripts(ctx echo.Context) error
	// inspect python code to infer jsonschema of arguments
	// (POST /scripts/python/tojsonschema)
	PythonToJsonschema(ctx echo.Context) error
	// accept invite to workspace
	// (POST /users/accept_invite)
	AcceptInvite(ctx echo.Context) error
	// create user
	// (POST /users/create)
	CreateUserGlobally(ctx echo.Context) error
	// decline invite to workspace
	// (POST /users/decline_invite)
	DeclineInvite(ctx echo.Context) error
	// get current user email (if logged in)
	// (GET /users/email)
	GetCurrentEmail(ctx echo.Context) error
	// list all users as super admin (require to be super amdin)
	// (GET /users/list_as_super_admin)
	ListUsersAsSuperAdmin(ctx echo.Context, params ListUsersAsSuperAdminParams) error
	// list all workspace invites
	// (GET /users/list_invites)
	ListWorkspaceInvites(ctx echo.Context) error
	// logout
	// (POST /users/logout)
	Logout(ctx echo.Context) error
	// set password
	// (POST /users/setpassword)
	SetPassword(ctx echo.Context) error
	// create token
	// (POST /users/tokens/create)
	CreateToken(ctx echo.Context) error
	// delete token
	// (DELETE /users/tokens/delete/{token_prefix})
	DeleteToken(ctx echo.Context, tokenPrefix string) error
	// list token
	// (GET /users/tokens/list)
	ListTokens(ctx echo.Context) error
	// global update user (require super admin)
	// (POST /users/update/{email})
	GlobalUserUpdate(ctx echo.Context, email string) error
	// get current global whoami (if logged in)
	// (GET /users/whoami)
	GlobalWhoami(ctx echo.Context) error
	// get backend version
	// (GET /version)
	BackendVersion(ctx echo.Context) error
	// add granular acls
	// (POST /w/{workspace}/acls/add/{kind}/{path})
	AddGranularAcls(ctx echo.Context, workspace WorkspaceId, kind AddGranularAclsParamsKind, path Path) error
	// get granular acls
	// (GET /w/{workspace}/acls/get/{kind}/{path})
	GetGranularAcls(ctx echo.Context, workspace WorkspaceId, kind GetGranularAclsParamsKind, path Path) error
	// remove granular acls
	// (POST /w/{workspace}/acls/remove/{kind}/{path})
	RemoveGranularAcls(ctx echo.Context, workspace WorkspaceId, kind RemoveGranularAclsParamsKind, path Path) error
	// get audit log (requires admin privilege)
	// (GET /w/{workspace}/audit/get/{id})
	GetAuditLog(ctx echo.Context, workspace WorkspaceId, id PathId) error
	// list audit logs (requires admin privilege)
	// (GET /w/{workspace}/audit/list)
	ListAuditLogs(ctx echo.Context, workspace WorkspaceId, params ListAuditLogsParams) error
	// archive flow by path
	// (POST /w/{workspace}/flows/archive/{path})
	ArchiveFlowByPath(ctx echo.Context, workspace WorkspaceId, path ScriptPath) error
	// create flow
	// (POST /w/{workspace}/flows/create)
	CreateFlow(ctx echo.Context, workspace WorkspaceId) error
	// exists flow by path
	// (GET /w/{workspace}/flows/exists/{path})
	ExistsFlowByPath(ctx echo.Context, workspace WorkspaceId, path ScriptPath) error
	// get flow by path
	// (GET /w/{workspace}/flows/get/{path})
	GetFlowByPath(ctx echo.Context, workspace WorkspaceId, path ScriptPath) error
	// list all available flows
	// (GET /w/{workspace}/flows/list)
	ListFlows(ctx echo.Context, workspace WorkspaceId, params ListFlowsParams) error
	// update flow
	// (POST /w/{workspace}/flows/update/{path})
	UpdateFlow(ctx echo.Context, workspace WorkspaceId, path ScriptPath) error
	// add user to group
	// (POST /w/{workspace}/groups/adduser/{name})
	AddUserToGroup(ctx echo.Context, workspace WorkspaceId, name Name) error
	// create group
	// (POST /w/{workspace}/groups/create)
	CreateGroup(ctx echo.Context, workspace WorkspaceId) error
	// delete group
	// (DELETE /w/{workspace}/groups/delete/{name})
	DeleteGroup(ctx echo.Context, workspace WorkspaceId, name Name) error
	// get group
	// (GET /w/{workspace}/groups/get/{name})
	GetGroup(ctx echo.Context, workspace WorkspaceId, name Name) error
	// list groups
	// (GET /w/{workspace}/groups/list)
	ListGroups(ctx echo.Context, workspace WorkspaceId, params ListGroupsParams) error
	// list group names
	// (GET /w/{workspace}/groups/listnames)
	ListGroupNames(ctx echo.Context, workspace WorkspaceId) error
	// remove user to group
	// (POST /w/{workspace}/groups/removeuser/{name})
	RemoveUserToGroup(ctx echo.Context, workspace WorkspaceId, name Name) error
	// update group
	// (POST /w/{workspace}/groups/update/{name})
	UpdateGroup(ctx echo.Context, workspace WorkspaceId, name Name) error
	// cancel a job for a suspended flow
	// (GET /w/{workspace}/jobs/cancel/{id}/{resume_id}/{signature})
	CancelSuspendedJobGet(ctx echo.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params CancelSuspendedJobGetParams) error
	// cancel a job for a suspended flow
	// (POST /w/{workspace}/jobs/cancel/{id}/{resume_id}/{signature})
	CancelSuspendedJobPost(ctx echo.Context, workspace WorkspaceId, id JobId, resumeId int, signature string) error
	// delete completed job (erase content but keep run id)
	// (POST /w/{workspace}/jobs/completed/delete/{id})
	DeleteCompletedJob(ctx echo.Context, workspace WorkspaceId, id JobId) error
	// get completed job
	// (GET /w/{workspace}/jobs/completed/get/{id})
	GetCompletedJob(ctx echo.Context, workspace WorkspaceId, id JobId) error
	// list all available completed jobs
	// (GET /w/{workspace}/jobs/completed/list)
	ListCompletedJobs(ctx echo.Context, workspace WorkspaceId, params ListCompletedJobsParams) error
	// get job
	// (GET /w/{workspace}/jobs/get/{id})
	GetJob(ctx echo.Context, workspace WorkspaceId, id JobId) error
	// get job updates
	// (GET /w/{workspace}/jobs/getupdate/{id})
	GetJobUpdates(ctx echo.Context, workspace WorkspaceId, id JobId, params GetJobUpdatesParams) error
	// create an HMac signature given a job id and a resume id
	// (GET /w/{workspace}/jobs/job_signature/{id}/{resume_id})
	CreateJobSignature(ctx echo.Context, workspace WorkspaceId, id JobId, resumeId int) error
	// list all available jobs
	// (GET /w/{workspace}/jobs/list)
	ListJobs(ctx echo.Context, workspace WorkspaceId, params ListJobsParams) error
	// cancel queued job
	// (POST /w/{workspace}/jobs/queue/cancel/{id})
	CancelQueuedJob(ctx echo.Context, workspace WorkspaceId, id JobId) error
	// list all available queued jobs
	// (GET /w/{workspace}/jobs/queue/list)
	ListQueue(ctx echo.Context, workspace WorkspaceId, params ListQueueParams) error
	// resume a job for a suspended flow
	// (GET /w/{workspace}/jobs/resume/{id}/{resume_id}/{signature})
	ResumeSuspendedJobGet(ctx echo.Context, workspace WorkspaceId, id JobId, resumeId int, signature string, params ResumeSuspendedJobGetParams) error
	// resume a job for a suspended flow
	// (POST /w/{workspace}/jobs/resume/{id}/{resume_id}/{signature})
	ResumeSuspendedJobPost(ctx echo.Context, workspace WorkspaceId, id JobId, resumeId int, signature string) error
	// run flow by path
	// (POST /w/{workspace}/jobs/run/f/{path})
	RunFlowByPath(ctx echo.Context, workspace WorkspaceId, path ScriptPath, params RunFlowByPathParams) error
	// run script by hash
	// (POST /w/{workspace}/jobs/run/h/{hash})
	RunScriptByHash(ctx echo.Context, workspace WorkspaceId, hash ScriptHash, params RunScriptByHashParams) error
	// run script by path
	// (POST /w/{workspace}/jobs/run/p/{path})
	RunScriptByPath(ctx echo.Context, workspace WorkspaceId, path ScriptPath, params RunScriptByPathParams) error
	// run script preview
	// (POST /w/{workspace}/jobs/run/preview)
	RunScriptPreview(ctx echo.Context, workspace WorkspaceId) error
	// run flow preview
	// (POST /w/{workspace}/jobs/run/preview_flow)
	RunFlowPreview(ctx echo.Context, workspace WorkspaceId) error
	// run script by path
	// (POST /w/{workspace}/jobs/run_wait_result/p/{path})
	RunWaitResultScriptByPath(ctx echo.Context, workspace WorkspaceId, path ScriptPath, params RunWaitResultScriptByPathParams) error
	// create OAuth account
	// (POST /w/{workspace}/oauth/create_account)
	CreateAccount(ctx echo.Context, workspace WorkspaceId) error
	// disconnect account
	// (POST /w/{workspace}/oauth/disconnect/{id})
	DisconnectAccount(ctx echo.Context, workspace WorkspaceId, id AccountId) error
	// disconnect slack
	// (POST /w/{workspace}/oauth/disconnect_slack)
	DisconnectSlack(ctx echo.Context, workspace WorkspaceId) error
	// refresh token
	// (POST /w/{workspace}/oauth/refresh_token/{id})
	RefreshToken(ctx echo.Context, workspace WorkspaceId, id AccountId) error
	// set workspace's slack
	// (POST /w/{workspace}/oauth/set_workspace_slack)
	SetWorkspaceSlack(ctx echo.Context, workspace WorkspaceId) error
	// create resource
	// (POST /w/{workspace}/resources/create)
	CreateResource(ctx echo.Context, workspace WorkspaceId) error
	// delete resource
	// (DELETE /w/{workspace}/resources/delete/{path})
	DeleteResource(ctx echo.Context, workspace WorkspaceId, path Path) error
	// does resource exists
	// (GET /w/{workspace}/resources/exists/{path})
	ExistsResource(ctx echo.Context, workspace WorkspaceId, path Path) error
	// get resource
	// (GET /w/{workspace}/resources/get/{path})
	GetResource(ctx echo.Context, workspace WorkspaceId, path Path) error
	// list resources
	// (GET /w/{workspace}/resources/list)
	ListResource(ctx echo.Context, workspace WorkspaceId, params ListResourceParams) error
	// create resource_type
	// (POST /w/{workspace}/resources/type/create)
	CreateResourceType(ctx echo.Context, workspace WorkspaceId) error
	// delete resource_type
	// (DELETE /w/{workspace}/resources/type/delete/{path})
	DeleteResourceType(ctx echo.Context, workspace WorkspaceId, path Path) error
	// does resource_type exists
	// (GET /w/{workspace}/resources/type/exists/{path})
	ExistsResourceType(ctx echo.Context, workspace WorkspaceId, path Path) error
	// get resource_type
	// (GET /w/{workspace}/resources/type/get/{path})
	GetResourceType(ctx echo.Context, workspace WorkspaceId, path Path) error
	// list resource_types
	// (GET /w/{workspace}/resources/type/list)
	ListResourceType(ctx echo.Context, workspace WorkspaceId) error
	// list resource_types names
	// (GET /w/{workspace}/resources/type/listnames)
	ListResourceTypeNames(ctx echo.Context, workspace WorkspaceId) error
	// update resource_type
	// (POST /w/{workspace}/resources/type/update/{path})
	UpdateResourceType(ctx echo.Context, workspace WorkspaceId, path Path) error
	// update resource
	// (POST /w/{workspace}/resources/update/{path})
	UpdateResource(ctx echo.Context, workspace WorkspaceId, path Path) error
	// create schedule
	// (POST /w/{workspace}/schedules/create)
	CreateSchedule(ctx echo.Context, workspace WorkspaceId) error
	// delete schedule
	// (DELETE /w/{workspace}/schedules/delete/{path})
	DeleteSchedule(ctx echo.Context, workspace WorkspaceId, path Path) error
	// does schedule exists
	// (GET /w/{workspace}/schedules/exists/{path})
	ExistsSchedule(ctx echo.Context, workspace WorkspaceId, path Path) error
	// get schedule
	// (GET /w/{workspace}/schedules/get/{path})
	GetSchedule(ctx echo.Context, workspace WorkspaceId, path Path) error
	// list schedules
	// (GET /w/{workspace}/schedules/list)
	ListSchedules(ctx echo.Context, workspace WorkspaceId, params ListSchedulesParams) error
	// set enabled schedule
	// (POST /w/{workspace}/schedules/setenabled/{path})
	SetScheduleEnabled(ctx echo.Context, workspace WorkspaceId, path Path) error
	// update schedule
	// (POST /w/{workspace}/schedules/update/{path})
	UpdateSchedule(ctx echo.Context, workspace WorkspaceId, path Path) error
	// archive script by hash
	// (POST /w/{workspace}/scripts/archive/h/{hash})
	ArchiveScriptByHash(ctx echo.Context, workspace WorkspaceId, hash ScriptHash) error
	// archive script by path
	// (POST /w/{workspace}/scripts/archive/p/{path})
	ArchiveScriptByPath(ctx echo.Context, workspace WorkspaceId, path ScriptPath) error
	// create script
	// (POST /w/{workspace}/scripts/create)
	CreateScript(ctx echo.Context, workspace WorkspaceId) error
	// delete script by hash (erase content but keep hash)
	// (POST /w/{workspace}/scripts/delete/h/{hash})
	DeleteScriptByHash(ctx echo.Context, workspace WorkspaceId, hash ScriptHash) error
	// get script deployment status
	// (GET /w/{workspace}/scripts/deployment_status/h/{hash})
	GetScriptDeploymentStatus(ctx echo.Context, workspace WorkspaceId, hash ScriptHash) error
	// exists script by path
	// (GET /w/{workspace}/scripts/exists/p/{path})
	ExistsScriptByPath(ctx echo.Context, workspace WorkspaceId, path ScriptPath) error
	// get script by hash
	// (GET /w/{workspace}/scripts/get/h/{hash})
	GetScriptByHash(ctx echo.Context, workspace WorkspaceId, hash ScriptHash) error
	// get script by path
	// (GET /w/{workspace}/scripts/get/p/{path})
	GetScriptByPath(ctx echo.Context, workspace WorkspaceId, path ScriptPath) error
	// list all available scripts
	// (GET /w/{workspace}/scripts/list)
	ListScripts(ctx echo.Context, workspace WorkspaceId, params ListScriptsParams) error
	// raw script by hash
	// (GET /w/{workspace}/scripts/raw/h/{path})
	RawScriptByHash(ctx echo.Context, workspace WorkspaceId, path ScriptPath) error
	// raw script by path
	// (GET /w/{workspace}/scripts/raw/p/{path})
	RawScriptByPath(ctx echo.Context, workspace WorkspaceId, path ScriptPath) error
	// create user (require admin privilege)
	// (POST /w/{workspace}/users/add)
	CreateUser(ctx echo.Context, workspace WorkspaceId) error
	// delete user (require admin privilege)
	// (DELETE /w/{workspace}/users/delete/{username})
	DeleteUser(ctx echo.Context, workspace WorkspaceId, username string) error
	// leave workspace
	// (POST /w/{workspace}/users/leave_workspace)
	LeaveWorkspace(ctx echo.Context, workspace WorkspaceId) error
	// list users
	// (GET /w/{workspace}/users/list)
	ListUsers(ctx echo.Context, workspace WorkspaceId) error
	// list usernames
	// (GET /w/{workspace}/users/list_usernames)
	ListUsernames(ctx echo.Context, workspace WorkspaceId) error
	// update user (require admin privilege)
	// (POST /w/{workspace}/users/update/{username})
	UpdateUser(ctx echo.Context, workspace WorkspaceId, username string) error
	// whoami
	// (GET /w/{workspace}/users/whoami)
	Whoami(ctx echo.Context, workspace WorkspaceId) error
	// whois
	// (GET /w/{workspace}/users/whois/{username})
	Whois(ctx echo.Context, workspace WorkspaceId, username string) error
	// create variable
	// (POST /w/{workspace}/variables/create)
	CreateVariable(ctx echo.Context, workspace WorkspaceId) error
	// delete variable
	// (DELETE /w/{workspace}/variables/delete/{path})
	DeleteVariable(ctx echo.Context, workspace WorkspaceId, path Path) error
	// does variable exists at path
	// (GET /w/{workspace}/variables/exists/{path})
	ExistsVariable(ctx echo.Context, workspace WorkspaceId, path Path) error
	// get variable
	// (GET /w/{workspace}/variables/get/{path})
	GetVariable(ctx echo.Context, workspace WorkspaceId, path Path, params GetVariableParams) error
	// list variables
	// (GET /w/{workspace}/variables/list)
	ListVariable(ctx echo.Context, workspace WorkspaceId) error
	// list contextual variables
	// (GET /w/{workspace}/variables/list_contextual)
	ListContextualVariables(ctx echo.Context, workspace WorkspaceId) error
	// update variable
	// (POST /w/{workspace}/variables/update/{path})
	UpdateVariable(ctx echo.Context, workspace WorkspaceId, path Path) error
	// delete workspace
	// (DELETE /w/{workspace}/workspaces/delete)
	DeleteWorkspace(ctx echo.Context, workspace WorkspaceId) error
	// delete user invite
	// (POST /w/{workspace}/workspaces/delete_invite)
	DeleteInvite(ctx echo.Context, workspace WorkspaceId) error
	// edit slack command
	// (POST /w/{workspace}/workspaces/edit_slack_command)
	EditSlackCommand(ctx echo.Context, workspace WorkspaceId) error
	// get settings
	// (GET /w/{workspace}/workspaces/get_settings)
	GetSettings(ctx echo.Context, workspace WorkspaceId) error
	// invite user to workspace
	// (POST /w/{workspace}/workspaces/invite_user)
	InviteUser(ctx echo.Context, workspace WorkspaceId) error
	// list pending invites for a workspace
	// (GET /w/{workspace}/workspaces/list_pending_invites)
	ListPendingInvites(ctx echo.Context, workspace WorkspaceId) error
	// list workers
	// (GET /workers/list)
	ListWorkers(ctx echo.Context, params ListWorkersParams) error
	// create workspace
	// (POST /workspaces/create)
	CreateWorkspace(ctx echo.Context) error
	// exists workspace
	// (POST /workspaces/exists)
	ExistsWorkspace(ctx echo.Context) error
	// exists username
	// (POST /workspaces/exists_username)
	ExistsUsername(ctx echo.Context) error
	// list all workspaces visible to me
	// (GET /workspaces/list)
	ListWorkspaces(ctx echo.Context) error
	// list all workspaces as super admin (require to be super admin)
	// (GET /workspaces/list_as_superadmin)
	ListWorkspacesAsSuperAdmin(ctx echo.Context, params ListWorkspacesAsSuperAdminParams) error
	// list all workspaces visible to me with user info
	// (GET /workspaces/users)
	ListUserWorkspaces(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// Login converts echo context to params.
func (w *ServerInterfaceWrapper) Login(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Login(ctx)
	return err
}

// GetHubFlowById converts echo context to params.
func (w *ServerInterfaceWrapper) GetHubFlowById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id PathId

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetHubFlowById(ctx, id)
	return err
}

// ListHubFlows converts echo context to params.
func (w *ServerInterfaceWrapper) ListHubFlows(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListHubFlows(ctx)
	return err
}

// ConnectCallback converts echo context to params.
func (w *ServerInterfaceWrapper) ConnectCallback(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "client_name" -------------
	var clientName ClientName

	err = runtime.BindStyledParameterWithLocation("simple", false, "client_name", runtime.ParamLocationPath, ctx.Param("client_name"), &clientName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter client_name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ConnectCallback(ctx, clientName)
	return err
}

// ConnectSlackCallback converts echo context to params.
func (w *ServerInterfaceWrapper) ConnectSlackCallback(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ConnectSlackCallback(ctx)
	return err
}

// ListOAuthConnects converts echo context to params.
func (w *ServerInterfaceWrapper) ListOAuthConnects(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListOAuthConnects(ctx)
	return err
}

// ListOAuthLogins converts echo context to params.
func (w *ServerInterfaceWrapper) ListOAuthLogins(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListOAuthLogins(ctx)
	return err
}

// LoginWithOauth converts echo context to params.
func (w *ServerInterfaceWrapper) LoginWithOauth(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "client_name" -------------
	var clientName ClientName

	err = runtime.BindStyledParameterWithLocation("simple", false, "client_name", runtime.ParamLocationPath, ctx.Param("client_name"), &clientName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter client_name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LoginWithOauth(ctx, clientName)
	return err
}

// GetOpenApiYaml converts echo context to params.
func (w *ServerInterfaceWrapper) GetOpenApiYaml(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetOpenApiYaml(ctx)
	return err
}

// PreviewSchedule converts echo context to params.
func (w *ServerInterfaceWrapper) PreviewSchedule(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PreviewSchedule(ctx)
	return err
}

// DenoToJsonschema converts echo context to params.
func (w *ServerInterfaceWrapper) DenoToJsonschema(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DenoToJsonschema(ctx)
	return err
}

// GoToJsonschema converts echo context to params.
func (w *ServerInterfaceWrapper) GoToJsonschema(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GoToJsonschema(ctx)
	return err
}

// GetHubScriptContentByPath converts echo context to params.
func (w *ServerInterfaceWrapper) GetHubScriptContentByPath(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "path" -------------
	var path ScriptPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetHubScriptContentByPath(ctx, path)
	return err
}

// ListHubScripts converts echo context to params.
func (w *ServerInterfaceWrapper) ListHubScripts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListHubScripts(ctx)
	return err
}

// PythonToJsonschema converts echo context to params.
func (w *ServerInterfaceWrapper) PythonToJsonschema(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PythonToJsonschema(ctx)
	return err
}

// AcceptInvite converts echo context to params.
func (w *ServerInterfaceWrapper) AcceptInvite(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AcceptInvite(ctx)
	return err
}

// CreateUserGlobally converts echo context to params.
func (w *ServerInterfaceWrapper) CreateUserGlobally(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateUserGlobally(ctx)
	return err
}

// DeclineInvite converts echo context to params.
func (w *ServerInterfaceWrapper) DeclineInvite(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeclineInvite(ctx)
	return err
}

// GetCurrentEmail converts echo context to params.
func (w *ServerInterfaceWrapper) GetCurrentEmail(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCurrentEmail(ctx)
	return err
}

// ListUsersAsSuperAdmin converts echo context to params.
func (w *ServerInterfaceWrapper) ListUsersAsSuperAdmin(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUsersAsSuperAdminParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "per_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "per_page", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter per_page: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListUsersAsSuperAdmin(ctx, params)
	return err
}

// ListWorkspaceInvites converts echo context to params.
func (w *ServerInterfaceWrapper) ListWorkspaceInvites(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListWorkspaceInvites(ctx)
	return err
}

// Logout converts echo context to params.
func (w *ServerInterfaceWrapper) Logout(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Logout(ctx)
	return err
}

// SetPassword converts echo context to params.
func (w *ServerInterfaceWrapper) SetPassword(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetPassword(ctx)
	return err
}

// CreateToken converts echo context to params.
func (w *ServerInterfaceWrapper) CreateToken(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateToken(ctx)
	return err
}

// DeleteToken converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteToken(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "token_prefix" -------------
	var tokenPrefix string

	err = runtime.BindStyledParameterWithLocation("simple", false, "token_prefix", runtime.ParamLocationPath, ctx.Param("token_prefix"), &tokenPrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token_prefix: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteToken(ctx, tokenPrefix)
	return err
}

// ListTokens converts echo context to params.
func (w *ServerInterfaceWrapper) ListTokens(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListTokens(ctx)
	return err
}

// GlobalUserUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) GlobalUserUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "email" -------------
	var email string

	err = runtime.BindStyledParameterWithLocation("simple", false, "email", runtime.ParamLocationPath, ctx.Param("email"), &email)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter email: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GlobalUserUpdate(ctx, email)
	return err
}

// GlobalWhoami converts echo context to params.
func (w *ServerInterfaceWrapper) GlobalWhoami(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GlobalWhoami(ctx)
	return err
}

// BackendVersion converts echo context to params.
func (w *ServerInterfaceWrapper) BackendVersion(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BackendVersion(ctx)
	return err
}

// AddGranularAcls converts echo context to params.
func (w *ServerInterfaceWrapper) AddGranularAcls(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "kind" -------------
	var kind AddGranularAclsParamsKind

	err = runtime.BindStyledParameterWithLocation("simple", false, "kind", runtime.ParamLocationPath, ctx.Param("kind"), &kind)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter kind: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddGranularAcls(ctx, workspace, kind, path)
	return err
}

// GetGranularAcls converts echo context to params.
func (w *ServerInterfaceWrapper) GetGranularAcls(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "kind" -------------
	var kind GetGranularAclsParamsKind

	err = runtime.BindStyledParameterWithLocation("simple", false, "kind", runtime.ParamLocationPath, ctx.Param("kind"), &kind)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter kind: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetGranularAcls(ctx, workspace, kind, path)
	return err
}

// RemoveGranularAcls converts echo context to params.
func (w *ServerInterfaceWrapper) RemoveGranularAcls(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "kind" -------------
	var kind RemoveGranularAclsParamsKind

	err = runtime.BindStyledParameterWithLocation("simple", false, "kind", runtime.ParamLocationPath, ctx.Param("kind"), &kind)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter kind: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RemoveGranularAcls(ctx, workspace, kind, path)
	return err
}

// GetAuditLog converts echo context to params.
func (w *ServerInterfaceWrapper) GetAuditLog(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id PathId

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAuditLog(ctx, workspace, id)
	return err
}

// ListAuditLogs converts echo context to params.
func (w *ServerInterfaceWrapper) ListAuditLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAuditLogsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "per_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "per_page", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter per_page: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// ------------- Optional query parameter "username" -------------

	err = runtime.BindQueryParameter("form", true, false, "username", ctx.QueryParams(), &params.Username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	// ------------- Optional query parameter "operation" -------------

	err = runtime.BindQueryParameter("form", true, false, "operation", ctx.QueryParams(), &params.Operation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operation: %s", err))
	}

	// ------------- Optional query parameter "resource" -------------

	err = runtime.BindQueryParameter("form", true, false, "resource", ctx.QueryParams(), &params.Resource)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter resource: %s", err))
	}

	// ------------- Optional query parameter "action_kind" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_kind", ctx.QueryParams(), &params.ActionKind)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_kind: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListAuditLogs(ctx, workspace, params)
	return err
}

// ArchiveFlowByPath converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveFlowByPath(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path ScriptPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ArchiveFlowByPath(ctx, workspace, path)
	return err
}

// CreateFlow converts echo context to params.
func (w *ServerInterfaceWrapper) CreateFlow(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateFlow(ctx, workspace)
	return err
}

// ExistsFlowByPath converts echo context to params.
func (w *ServerInterfaceWrapper) ExistsFlowByPath(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path ScriptPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ExistsFlowByPath(ctx, workspace, path)
	return err
}

// GetFlowByPath converts echo context to params.
func (w *ServerInterfaceWrapper) GetFlowByPath(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path ScriptPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFlowByPath(ctx, workspace, path)
	return err
}

// ListFlows converts echo context to params.
func (w *ServerInterfaceWrapper) ListFlows(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListFlowsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "per_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "per_page", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter per_page: %s", err))
	}

	// ------------- Optional query parameter "order_desc" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_desc", ctx.QueryParams(), &params.OrderDesc)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_desc: %s", err))
	}

	// ------------- Optional query parameter "created_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_by", ctx.QueryParams(), &params.CreatedBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_by: %s", err))
	}

	// ------------- Optional query parameter "path_start" -------------

	err = runtime.BindQueryParameter("form", true, false, "path_start", ctx.QueryParams(), &params.PathStart)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path_start: %s", err))
	}

	// ------------- Optional query parameter "path_exact" -------------

	err = runtime.BindQueryParameter("form", true, false, "path_exact", ctx.QueryParams(), &params.PathExact)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path_exact: %s", err))
	}

	// ------------- Optional query parameter "show_archived" -------------

	err = runtime.BindQueryParameter("form", true, false, "show_archived", ctx.QueryParams(), &params.ShowArchived)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter show_archived: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListFlows(ctx, workspace, params)
	return err
}

// UpdateFlow converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateFlow(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path ScriptPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateFlow(ctx, workspace, path)
	return err
}

// AddUserToGroup converts echo context to params.
func (w *ServerInterfaceWrapper) AddUserToGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name Name

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddUserToGroup(ctx, workspace, name)
	return err
}

// CreateGroup converts echo context to params.
func (w *ServerInterfaceWrapper) CreateGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateGroup(ctx, workspace)
	return err
}

// DeleteGroup converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name Name

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteGroup(ctx, workspace, name)
	return err
}

// GetGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name Name

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetGroup(ctx, workspace, name)
	return err
}

// ListGroups converts echo context to params.
func (w *ServerInterfaceWrapper) ListGroups(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "per_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "per_page", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter per_page: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListGroups(ctx, workspace, params)
	return err
}

// ListGroupNames converts echo context to params.
func (w *ServerInterfaceWrapper) ListGroupNames(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListGroupNames(ctx, workspace)
	return err
}

// RemoveUserToGroup converts echo context to params.
func (w *ServerInterfaceWrapper) RemoveUserToGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name Name

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RemoveUserToGroup(ctx, workspace, name)
	return err
}

// UpdateGroup converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "name" -------------
	var name Name

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, ctx.Param("name"), &name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateGroup(ctx, workspace, name)
	return err
}

// CancelSuspendedJobGet converts echo context to params.
func (w *ServerInterfaceWrapper) CancelSuspendedJobGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id JobId

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "resume_id" -------------
	var resumeId int

	err = runtime.BindStyledParameterWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, ctx.Param("resume_id"), &resumeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter resume_id: %s", err))
	}

	// ------------- Path parameter "signature" -------------
	var signature string

	err = runtime.BindStyledParameterWithLocation("simple", false, "signature", runtime.ParamLocationPath, ctx.Param("signature"), &signature)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter signature: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CancelSuspendedJobGetParams
	// ------------- Optional query parameter "payload" -------------

	err = runtime.BindQueryParameter("form", true, false, "payload", ctx.QueryParams(), &params.Payload)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payload: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CancelSuspendedJobGet(ctx, workspace, id, resumeId, signature, params)
	return err
}

// CancelSuspendedJobPost converts echo context to params.
func (w *ServerInterfaceWrapper) CancelSuspendedJobPost(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id JobId

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "resume_id" -------------
	var resumeId int

	err = runtime.BindStyledParameterWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, ctx.Param("resume_id"), &resumeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter resume_id: %s", err))
	}

	// ------------- Path parameter "signature" -------------
	var signature string

	err = runtime.BindStyledParameterWithLocation("simple", false, "signature", runtime.ParamLocationPath, ctx.Param("signature"), &signature)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter signature: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CancelSuspendedJobPost(ctx, workspace, id, resumeId, signature)
	return err
}

// DeleteCompletedJob converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteCompletedJob(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id JobId

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteCompletedJob(ctx, workspace, id)
	return err
}

// GetCompletedJob converts echo context to params.
func (w *ServerInterfaceWrapper) GetCompletedJob(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id JobId

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCompletedJob(ctx, workspace, id)
	return err
}

// ListCompletedJobs converts echo context to params.
func (w *ServerInterfaceWrapper) ListCompletedJobs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListCompletedJobsParams
	// ------------- Optional query parameter "order_desc" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_desc", ctx.QueryParams(), &params.OrderDesc)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_desc: %s", err))
	}

	// ------------- Optional query parameter "created_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_by", ctx.QueryParams(), &params.CreatedBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_by: %s", err))
	}

	// ------------- Optional query parameter "parent_job" -------------

	err = runtime.BindQueryParameter("form", true, false, "parent_job", ctx.QueryParams(), &params.ParentJob)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter parent_job: %s", err))
	}

	// ------------- Optional query parameter "script_path_exact" -------------

	err = runtime.BindQueryParameter("form", true, false, "script_path_exact", ctx.QueryParams(), &params.ScriptPathExact)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter script_path_exact: %s", err))
	}

	// ------------- Optional query parameter "script_path_start" -------------

	err = runtime.BindQueryParameter("form", true, false, "script_path_start", ctx.QueryParams(), &params.ScriptPathStart)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter script_path_start: %s", err))
	}

	// ------------- Optional query parameter "script_hash" -------------

	err = runtime.BindQueryParameter("form", true, false, "script_hash", ctx.QueryParams(), &params.ScriptHash)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter script_hash: %s", err))
	}

	// ------------- Optional query parameter "created_before" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_before", ctx.QueryParams(), &params.CreatedBefore)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_before: %s", err))
	}

	// ------------- Optional query parameter "created_after" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_after", ctx.QueryParams(), &params.CreatedAfter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_after: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Success)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "job_kinds" -------------

	err = runtime.BindQueryParameter("form", true, false, "job_kinds", ctx.QueryParams(), &params.JobKinds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter job_kinds: %s", err))
	}

	// ------------- Optional query parameter "is_skipped" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_skipped", ctx.QueryParams(), &params.IsSkipped)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_skipped: %s", err))
	}

	// ------------- Optional query parameter "is_flow_step" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_flow_step", ctx.QueryParams(), &params.IsFlowStep)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_flow_step: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListCompletedJobs(ctx, workspace, params)
	return err
}

// GetJob converts echo context to params.
func (w *ServerInterfaceWrapper) GetJob(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id JobId

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetJob(ctx, workspace, id)
	return err
}

// GetJobUpdates converts echo context to params.
func (w *ServerInterfaceWrapper) GetJobUpdates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id JobId

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetJobUpdatesParams
	// ------------- Optional query parameter "running" -------------

	err = runtime.BindQueryParameter("form", true, false, "running", ctx.QueryParams(), &params.Running)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter running: %s", err))
	}

	// ------------- Optional query parameter "log_offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "log_offset", ctx.QueryParams(), &params.LogOffset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter log_offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetJobUpdates(ctx, workspace, id, params)
	return err
}

// CreateJobSignature converts echo context to params.
func (w *ServerInterfaceWrapper) CreateJobSignature(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id JobId

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "resume_id" -------------
	var resumeId int

	err = runtime.BindStyledParameterWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, ctx.Param("resume_id"), &resumeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter resume_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateJobSignature(ctx, workspace, id, resumeId)
	return err
}

// ListJobs converts echo context to params.
func (w *ServerInterfaceWrapper) ListJobs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListJobsParams
	// ------------- Optional query parameter "created_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_by", ctx.QueryParams(), &params.CreatedBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_by: %s", err))
	}

	// ------------- Optional query parameter "parent_job" -------------

	err = runtime.BindQueryParameter("form", true, false, "parent_job", ctx.QueryParams(), &params.ParentJob)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter parent_job: %s", err))
	}

	// ------------- Optional query parameter "script_path_exact" -------------

	err = runtime.BindQueryParameter("form", true, false, "script_path_exact", ctx.QueryParams(), &params.ScriptPathExact)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter script_path_exact: %s", err))
	}

	// ------------- Optional query parameter "script_path_start" -------------

	err = runtime.BindQueryParameter("form", true, false, "script_path_start", ctx.QueryParams(), &params.ScriptPathStart)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter script_path_start: %s", err))
	}

	// ------------- Optional query parameter "script_hash" -------------

	err = runtime.BindQueryParameter("form", true, false, "script_hash", ctx.QueryParams(), &params.ScriptHash)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter script_hash: %s", err))
	}

	// ------------- Optional query parameter "created_before" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_before", ctx.QueryParams(), &params.CreatedBefore)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_before: %s", err))
	}

	// ------------- Optional query parameter "created_after" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_after", ctx.QueryParams(), &params.CreatedAfter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_after: %s", err))
	}

	// ------------- Optional query parameter "job_kinds" -------------

	err = runtime.BindQueryParameter("form", true, false, "job_kinds", ctx.QueryParams(), &params.JobKinds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter job_kinds: %s", err))
	}

	// ------------- Optional query parameter "is_skipped" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_skipped", ctx.QueryParams(), &params.IsSkipped)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_skipped: %s", err))
	}

	// ------------- Optional query parameter "is_flow_step" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_flow_step", ctx.QueryParams(), &params.IsFlowStep)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_flow_step: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Success)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListJobs(ctx, workspace, params)
	return err
}

// CancelQueuedJob converts echo context to params.
func (w *ServerInterfaceWrapper) CancelQueuedJob(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id JobId

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CancelQueuedJob(ctx, workspace, id)
	return err
}

// ListQueue converts echo context to params.
func (w *ServerInterfaceWrapper) ListQueue(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListQueueParams
	// ------------- Optional query parameter "order_desc" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_desc", ctx.QueryParams(), &params.OrderDesc)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_desc: %s", err))
	}

	// ------------- Optional query parameter "created_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_by", ctx.QueryParams(), &params.CreatedBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_by: %s", err))
	}

	// ------------- Optional query parameter "parent_job" -------------

	err = runtime.BindQueryParameter("form", true, false, "parent_job", ctx.QueryParams(), &params.ParentJob)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter parent_job: %s", err))
	}

	// ------------- Optional query parameter "script_path_exact" -------------

	err = runtime.BindQueryParameter("form", true, false, "script_path_exact", ctx.QueryParams(), &params.ScriptPathExact)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter script_path_exact: %s", err))
	}

	// ------------- Optional query parameter "script_path_start" -------------

	err = runtime.BindQueryParameter("form", true, false, "script_path_start", ctx.QueryParams(), &params.ScriptPathStart)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter script_path_start: %s", err))
	}

	// ------------- Optional query parameter "script_hash" -------------

	err = runtime.BindQueryParameter("form", true, false, "script_hash", ctx.QueryParams(), &params.ScriptHash)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter script_hash: %s", err))
	}

	// ------------- Optional query parameter "created_before" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_before", ctx.QueryParams(), &params.CreatedBefore)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_before: %s", err))
	}

	// ------------- Optional query parameter "created_after" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_after", ctx.QueryParams(), &params.CreatedAfter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_after: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Success)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "job_kinds" -------------

	err = runtime.BindQueryParameter("form", true, false, "job_kinds", ctx.QueryParams(), &params.JobKinds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter job_kinds: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListQueue(ctx, workspace, params)
	return err
}

// ResumeSuspendedJobGet converts echo context to params.
func (w *ServerInterfaceWrapper) ResumeSuspendedJobGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id JobId

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "resume_id" -------------
	var resumeId int

	err = runtime.BindStyledParameterWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, ctx.Param("resume_id"), &resumeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter resume_id: %s", err))
	}

	// ------------- Path parameter "signature" -------------
	var signature string

	err = runtime.BindStyledParameterWithLocation("simple", false, "signature", runtime.ParamLocationPath, ctx.Param("signature"), &signature)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter signature: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ResumeSuspendedJobGetParams
	// ------------- Optional query parameter "payload" -------------

	err = runtime.BindQueryParameter("form", true, false, "payload", ctx.QueryParams(), &params.Payload)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter payload: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ResumeSuspendedJobGet(ctx, workspace, id, resumeId, signature, params)
	return err
}

// ResumeSuspendedJobPost converts echo context to params.
func (w *ServerInterfaceWrapper) ResumeSuspendedJobPost(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id JobId

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "resume_id" -------------
	var resumeId int

	err = runtime.BindStyledParameterWithLocation("simple", false, "resume_id", runtime.ParamLocationPath, ctx.Param("resume_id"), &resumeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter resume_id: %s", err))
	}

	// ------------- Path parameter "signature" -------------
	var signature string

	err = runtime.BindStyledParameterWithLocation("simple", false, "signature", runtime.ParamLocationPath, ctx.Param("signature"), &signature)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter signature: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ResumeSuspendedJobPost(ctx, workspace, id, resumeId, signature)
	return err
}

// RunFlowByPath converts echo context to params.
func (w *ServerInterfaceWrapper) RunFlowByPath(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path ScriptPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RunFlowByPathParams
	// ------------- Optional query parameter "scheduled_for" -------------

	err = runtime.BindQueryParameter("form", true, false, "scheduled_for", ctx.QueryParams(), &params.ScheduledFor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scheduled_for: %s", err))
	}

	// ------------- Optional query parameter "scheduled_in_secs" -------------

	err = runtime.BindQueryParameter("form", true, false, "scheduled_in_secs", ctx.QueryParams(), &params.ScheduledInSecs)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scheduled_in_secs: %s", err))
	}

	// ------------- Optional query parameter "parent_job" -------------

	err = runtime.BindQueryParameter("form", true, false, "parent_job", ctx.QueryParams(), &params.ParentJob)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter parent_job: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RunFlowByPath(ctx, workspace, path, params)
	return err
}

// RunScriptByHash converts echo context to params.
func (w *ServerInterfaceWrapper) RunScriptByHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "hash" -------------
	var hash ScriptHash

	err = runtime.BindStyledParameterWithLocation("simple", false, "hash", runtime.ParamLocationPath, ctx.Param("hash"), &hash)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hash: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RunScriptByHashParams
	// ------------- Optional query parameter "scheduled_for" -------------

	err = runtime.BindQueryParameter("form", true, false, "scheduled_for", ctx.QueryParams(), &params.ScheduledFor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scheduled_for: %s", err))
	}

	// ------------- Optional query parameter "scheduled_in_secs" -------------

	err = runtime.BindQueryParameter("form", true, false, "scheduled_in_secs", ctx.QueryParams(), &params.ScheduledInSecs)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scheduled_in_secs: %s", err))
	}

	// ------------- Optional query parameter "parent_job" -------------

	err = runtime.BindQueryParameter("form", true, false, "parent_job", ctx.QueryParams(), &params.ParentJob)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter parent_job: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RunScriptByHash(ctx, workspace, hash, params)
	return err
}

// RunScriptByPath converts echo context to params.
func (w *ServerInterfaceWrapper) RunScriptByPath(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path ScriptPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RunScriptByPathParams
	// ------------- Optional query parameter "scheduled_for" -------------

	err = runtime.BindQueryParameter("form", true, false, "scheduled_for", ctx.QueryParams(), &params.ScheduledFor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scheduled_for: %s", err))
	}

	// ------------- Optional query parameter "scheduled_in_secs" -------------

	err = runtime.BindQueryParameter("form", true, false, "scheduled_in_secs", ctx.QueryParams(), &params.ScheduledInSecs)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scheduled_in_secs: %s", err))
	}

	// ------------- Optional query parameter "parent_job" -------------

	err = runtime.BindQueryParameter("form", true, false, "parent_job", ctx.QueryParams(), &params.ParentJob)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter parent_job: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RunScriptByPath(ctx, workspace, path, params)
	return err
}

// RunScriptPreview converts echo context to params.
func (w *ServerInterfaceWrapper) RunScriptPreview(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RunScriptPreview(ctx, workspace)
	return err
}

// RunFlowPreview converts echo context to params.
func (w *ServerInterfaceWrapper) RunFlowPreview(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RunFlowPreview(ctx, workspace)
	return err
}

// RunWaitResultScriptByPath converts echo context to params.
func (w *ServerInterfaceWrapper) RunWaitResultScriptByPath(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path ScriptPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RunWaitResultScriptByPathParams
	// ------------- Optional query parameter "scheduled_for" -------------

	err = runtime.BindQueryParameter("form", true, false, "scheduled_for", ctx.QueryParams(), &params.ScheduledFor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scheduled_for: %s", err))
	}

	// ------------- Optional query parameter "scheduled_in_secs" -------------

	err = runtime.BindQueryParameter("form", true, false, "scheduled_in_secs", ctx.QueryParams(), &params.ScheduledInSecs)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scheduled_in_secs: %s", err))
	}

	// ------------- Optional query parameter "parent_job" -------------

	err = runtime.BindQueryParameter("form", true, false, "parent_job", ctx.QueryParams(), &params.ParentJob)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter parent_job: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RunWaitResultScriptByPath(ctx, workspace, path, params)
	return err
}

// CreateAccount converts echo context to params.
func (w *ServerInterfaceWrapper) CreateAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateAccount(ctx, workspace)
	return err
}

// DisconnectAccount converts echo context to params.
func (w *ServerInterfaceWrapper) DisconnectAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id AccountId

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DisconnectAccount(ctx, workspace, id)
	return err
}

// DisconnectSlack converts echo context to params.
func (w *ServerInterfaceWrapper) DisconnectSlack(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DisconnectSlack(ctx, workspace)
	return err
}

// RefreshToken converts echo context to params.
func (w *ServerInterfaceWrapper) RefreshToken(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id AccountId

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RefreshToken(ctx, workspace, id)
	return err
}

// SetWorkspaceSlack converts echo context to params.
func (w *ServerInterfaceWrapper) SetWorkspaceSlack(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetWorkspaceSlack(ctx, workspace)
	return err
}

// CreateResource converts echo context to params.
func (w *ServerInterfaceWrapper) CreateResource(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateResource(ctx, workspace)
	return err
}

// DeleteResource converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteResource(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteResource(ctx, workspace, path)
	return err
}

// ExistsResource converts echo context to params.
func (w *ServerInterfaceWrapper) ExistsResource(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ExistsResource(ctx, workspace, path)
	return err
}

// GetResource converts echo context to params.
func (w *ServerInterfaceWrapper) GetResource(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetResource(ctx, workspace, path)
	return err
}

// ListResource converts echo context to params.
func (w *ServerInterfaceWrapper) ListResource(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListResourceParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "per_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "per_page", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter per_page: %s", err))
	}

	// ------------- Optional query parameter "resource_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "resource_type", ctx.QueryParams(), &params.ResourceType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter resource_type: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListResource(ctx, workspace, params)
	return err
}

// CreateResourceType converts echo context to params.
func (w *ServerInterfaceWrapper) CreateResourceType(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateResourceType(ctx, workspace)
	return err
}

// DeleteResourceType converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteResourceType(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteResourceType(ctx, workspace, path)
	return err
}

// ExistsResourceType converts echo context to params.
func (w *ServerInterfaceWrapper) ExistsResourceType(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ExistsResourceType(ctx, workspace, path)
	return err
}

// GetResourceType converts echo context to params.
func (w *ServerInterfaceWrapper) GetResourceType(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetResourceType(ctx, workspace, path)
	return err
}

// ListResourceType converts echo context to params.
func (w *ServerInterfaceWrapper) ListResourceType(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListResourceType(ctx, workspace)
	return err
}

// ListResourceTypeNames converts echo context to params.
func (w *ServerInterfaceWrapper) ListResourceTypeNames(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListResourceTypeNames(ctx, workspace)
	return err
}

// UpdateResourceType converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateResourceType(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateResourceType(ctx, workspace, path)
	return err
}

// UpdateResource converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateResource(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateResource(ctx, workspace, path)
	return err
}

// CreateSchedule converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSchedule(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSchedule(ctx, workspace)
	return err
}

// DeleteSchedule converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteSchedule(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteSchedule(ctx, workspace, path)
	return err
}

// ExistsSchedule converts echo context to params.
func (w *ServerInterfaceWrapper) ExistsSchedule(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ExistsSchedule(ctx, workspace, path)
	return err
}

// GetSchedule converts echo context to params.
func (w *ServerInterfaceWrapper) GetSchedule(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSchedule(ctx, workspace, path)
	return err
}

// ListSchedules converts echo context to params.
func (w *ServerInterfaceWrapper) ListSchedules(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListSchedulesParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "per_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "per_page", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter per_page: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListSchedules(ctx, workspace, params)
	return err
}

// SetScheduleEnabled converts echo context to params.
func (w *ServerInterfaceWrapper) SetScheduleEnabled(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetScheduleEnabled(ctx, workspace, path)
	return err
}

// UpdateSchedule converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateSchedule(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateSchedule(ctx, workspace, path)
	return err
}

// ArchiveScriptByHash converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveScriptByHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "hash" -------------
	var hash ScriptHash

	err = runtime.BindStyledParameterWithLocation("simple", false, "hash", runtime.ParamLocationPath, ctx.Param("hash"), &hash)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hash: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ArchiveScriptByHash(ctx, workspace, hash)
	return err
}

// ArchiveScriptByPath converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveScriptByPath(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path ScriptPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ArchiveScriptByPath(ctx, workspace, path)
	return err
}

// CreateScript converts echo context to params.
func (w *ServerInterfaceWrapper) CreateScript(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateScript(ctx, workspace)
	return err
}

// DeleteScriptByHash converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScriptByHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "hash" -------------
	var hash ScriptHash

	err = runtime.BindStyledParameterWithLocation("simple", false, "hash", runtime.ParamLocationPath, ctx.Param("hash"), &hash)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hash: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteScriptByHash(ctx, workspace, hash)
	return err
}

// GetScriptDeploymentStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetScriptDeploymentStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "hash" -------------
	var hash ScriptHash

	err = runtime.BindStyledParameterWithLocation("simple", false, "hash", runtime.ParamLocationPath, ctx.Param("hash"), &hash)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hash: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetScriptDeploymentStatus(ctx, workspace, hash)
	return err
}

// ExistsScriptByPath converts echo context to params.
func (w *ServerInterfaceWrapper) ExistsScriptByPath(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path ScriptPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ExistsScriptByPath(ctx, workspace, path)
	return err
}

// GetScriptByHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetScriptByHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "hash" -------------
	var hash ScriptHash

	err = runtime.BindStyledParameterWithLocation("simple", false, "hash", runtime.ParamLocationPath, ctx.Param("hash"), &hash)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hash: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetScriptByHash(ctx, workspace, hash)
	return err
}

// GetScriptByPath converts echo context to params.
func (w *ServerInterfaceWrapper) GetScriptByPath(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path ScriptPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetScriptByPath(ctx, workspace, path)
	return err
}

// ListScripts converts echo context to params.
func (w *ServerInterfaceWrapper) ListScripts(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListScriptsParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "per_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "per_page", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter per_page: %s", err))
	}

	// ------------- Optional query parameter "order_desc" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_desc", ctx.QueryParams(), &params.OrderDesc)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_desc: %s", err))
	}

	// ------------- Optional query parameter "created_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "created_by", ctx.QueryParams(), &params.CreatedBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created_by: %s", err))
	}

	// ------------- Optional query parameter "path_start" -------------

	err = runtime.BindQueryParameter("form", true, false, "path_start", ctx.QueryParams(), &params.PathStart)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path_start: %s", err))
	}

	// ------------- Optional query parameter "path_exact" -------------

	err = runtime.BindQueryParameter("form", true, false, "path_exact", ctx.QueryParams(), &params.PathExact)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path_exact: %s", err))
	}

	// ------------- Optional query parameter "first_parent_hash" -------------

	err = runtime.BindQueryParameter("form", true, false, "first_parent_hash", ctx.QueryParams(), &params.FirstParentHash)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first_parent_hash: %s", err))
	}

	// ------------- Optional query parameter "last_parent_hash" -------------

	err = runtime.BindQueryParameter("form", true, false, "last_parent_hash", ctx.QueryParams(), &params.LastParentHash)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter last_parent_hash: %s", err))
	}

	// ------------- Optional query parameter "parent_hash" -------------

	err = runtime.BindQueryParameter("form", true, false, "parent_hash", ctx.QueryParams(), &params.ParentHash)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter parent_hash: %s", err))
	}

	// ------------- Optional query parameter "show_archived" -------------

	err = runtime.BindQueryParameter("form", true, false, "show_archived", ctx.QueryParams(), &params.ShowArchived)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter show_archived: %s", err))
	}

	// ------------- Optional query parameter "is_template" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_template", ctx.QueryParams(), &params.IsTemplate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_template: %s", err))
	}

	// ------------- Optional query parameter "kind" -------------

	err = runtime.BindQueryParameter("form", true, false, "kind", ctx.QueryParams(), &params.Kind)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter kind: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListScripts(ctx, workspace, params)
	return err
}

// RawScriptByHash converts echo context to params.
func (w *ServerInterfaceWrapper) RawScriptByHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path ScriptPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawScriptByHash(ctx, workspace, path)
	return err
}

// RawScriptByPath converts echo context to params.
func (w *ServerInterfaceWrapper) RawScriptByPath(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path ScriptPath

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawScriptByPath(ctx, workspace, path)
	return err
}

// CreateUser converts echo context to params.
func (w *ServerInterfaceWrapper) CreateUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateUser(ctx, workspace)
	return err
}

// DeleteUser converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "username" -------------
	var username string

	err = runtime.BindStyledParameterWithLocation("simple", false, "username", runtime.ParamLocationPath, ctx.Param("username"), &username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteUser(ctx, workspace, username)
	return err
}

// LeaveWorkspace converts echo context to params.
func (w *ServerInterfaceWrapper) LeaveWorkspace(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LeaveWorkspace(ctx, workspace)
	return err
}

// ListUsers converts echo context to params.
func (w *ServerInterfaceWrapper) ListUsers(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListUsers(ctx, workspace)
	return err
}

// ListUsernames converts echo context to params.
func (w *ServerInterfaceWrapper) ListUsernames(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListUsernames(ctx, workspace)
	return err
}

// UpdateUser converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "username" -------------
	var username string

	err = runtime.BindStyledParameterWithLocation("simple", false, "username", runtime.ParamLocationPath, ctx.Param("username"), &username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateUser(ctx, workspace, username)
	return err
}

// Whoami converts echo context to params.
func (w *ServerInterfaceWrapper) Whoami(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Whoami(ctx, workspace)
	return err
}

// Whois converts echo context to params.
func (w *ServerInterfaceWrapper) Whois(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "username" -------------
	var username string

	err = runtime.BindStyledParameterWithLocation("simple", false, "username", runtime.ParamLocationPath, ctx.Param("username"), &username)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter username: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Whois(ctx, workspace, username)
	return err
}

// CreateVariable converts echo context to params.
func (w *ServerInterfaceWrapper) CreateVariable(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateVariable(ctx, workspace)
	return err
}

// DeleteVariable converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteVariable(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteVariable(ctx, workspace, path)
	return err
}

// ExistsVariable converts echo context to params.
func (w *ServerInterfaceWrapper) ExistsVariable(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ExistsVariable(ctx, workspace, path)
	return err
}

// GetVariable converts echo context to params.
func (w *ServerInterfaceWrapper) GetVariable(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetVariableParams
	// ------------- Optional query parameter "decrypt_secret" -------------

	err = runtime.BindQueryParameter("form", true, false, "decrypt_secret", ctx.QueryParams(), &params.DecryptSecret)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter decrypt_secret: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetVariable(ctx, workspace, path, params)
	return err
}

// ListVariable converts echo context to params.
func (w *ServerInterfaceWrapper) ListVariable(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListVariable(ctx, workspace)
	return err
}

// ListContextualVariables converts echo context to params.
func (w *ServerInterfaceWrapper) ListContextualVariables(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListContextualVariables(ctx, workspace)
	return err
}

// UpdateVariable converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateVariable(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	// ------------- Path parameter "path" -------------
	var path Path

	err = runtime.BindStyledParameterWithLocation("simple", false, "path", runtime.ParamLocationPath, ctx.Param("path"), &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateVariable(ctx, workspace, path)
	return err
}

// DeleteWorkspace converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteWorkspace(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteWorkspace(ctx, workspace)
	return err
}

// DeleteInvite converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteInvite(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteInvite(ctx, workspace)
	return err
}

// EditSlackCommand converts echo context to params.
func (w *ServerInterfaceWrapper) EditSlackCommand(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EditSlackCommand(ctx, workspace)
	return err
}

// GetSettings converts echo context to params.
func (w *ServerInterfaceWrapper) GetSettings(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSettings(ctx, workspace)
	return err
}

// InviteUser converts echo context to params.
func (w *ServerInterfaceWrapper) InviteUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.InviteUser(ctx, workspace)
	return err
}

// ListPendingInvites converts echo context to params.
func (w *ServerInterfaceWrapper) ListPendingInvites(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workspace" -------------
	var workspace WorkspaceId

	err = runtime.BindStyledParameterWithLocation("simple", false, "workspace", runtime.ParamLocationPath, ctx.Param("workspace"), &workspace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workspace: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPendingInvites(ctx, workspace)
	return err
}

// ListWorkers converts echo context to params.
func (w *ServerInterfaceWrapper) ListWorkers(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListWorkersParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "per_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "per_page", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter per_page: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListWorkers(ctx, params)
	return err
}

// CreateWorkspace converts echo context to params.
func (w *ServerInterfaceWrapper) CreateWorkspace(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateWorkspace(ctx)
	return err
}

// ExistsWorkspace converts echo context to params.
func (w *ServerInterfaceWrapper) ExistsWorkspace(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ExistsWorkspace(ctx)
	return err
}

// ExistsUsername converts echo context to params.
func (w *ServerInterfaceWrapper) ExistsUsername(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ExistsUsername(ctx)
	return err
}

// ListWorkspaces converts echo context to params.
func (w *ServerInterfaceWrapper) ListWorkspaces(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListWorkspaces(ctx)
	return err
}

// ListWorkspacesAsSuperAdmin converts echo context to params.
func (w *ServerInterfaceWrapper) ListWorkspacesAsSuperAdmin(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListWorkspacesAsSuperAdminParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "per_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "per_page", ctx.QueryParams(), &params.PerPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter per_page: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListWorkspacesAsSuperAdmin(ctx, params)
	return err
}

// ListUserWorkspaces converts echo context to params.
func (w *ServerInterfaceWrapper) ListUserWorkspaces(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	ctx.Set(CookieAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListUserWorkspaces(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/auth/login", wrapper.Login)
	router.GET(baseURL+"/flows/hub/get/:id", wrapper.GetHubFlowById)
	router.GET(baseURL+"/flows/hub/list", wrapper.ListHubFlows)
	router.POST(baseURL+"/oauth/connect_callback/:client_name", wrapper.ConnectCallback)
	router.POST(baseURL+"/oauth/connect_slack_callback", wrapper.ConnectSlackCallback)
	router.GET(baseURL+"/oauth/list_connects", wrapper.ListOAuthConnects)
	router.GET(baseURL+"/oauth/list_logins", wrapper.ListOAuthLogins)
	router.POST(baseURL+"/oauth/login_callback/:client_name", wrapper.LoginWithOauth)
	router.GET(baseURL+"/openapi.yaml", wrapper.GetOpenApiYaml)
	router.POST(baseURL+"/schedules/preview", wrapper.PreviewSchedule)
	router.POST(baseURL+"/scripts/deno/tojsonschema", wrapper.DenoToJsonschema)
	router.POST(baseURL+"/scripts/go/tojsonschema", wrapper.GoToJsonschema)
	router.GET(baseURL+"/scripts/hub/get/:path", wrapper.GetHubScriptContentByPath)
	router.GET(baseURL+"/scripts/hub/list", wrapper.ListHubScripts)
	router.POST(baseURL+"/scripts/python/tojsonschema", wrapper.PythonToJsonschema)
	router.POST(baseURL+"/users/accept_invite", wrapper.AcceptInvite)
	router.POST(baseURL+"/users/create", wrapper.CreateUserGlobally)
	router.POST(baseURL+"/users/decline_invite", wrapper.DeclineInvite)
	router.GET(baseURL+"/users/email", wrapper.GetCurrentEmail)
	router.GET(baseURL+"/users/list_as_super_admin", wrapper.ListUsersAsSuperAdmin)
	router.GET(baseURL+"/users/list_invites", wrapper.ListWorkspaceInvites)
	router.POST(baseURL+"/users/logout", wrapper.Logout)
	router.POST(baseURL+"/users/setpassword", wrapper.SetPassword)
	router.POST(baseURL+"/users/tokens/create", wrapper.CreateToken)
	router.DELETE(baseURL+"/users/tokens/delete/:token_prefix", wrapper.DeleteToken)
	router.GET(baseURL+"/users/tokens/list", wrapper.ListTokens)
	router.POST(baseURL+"/users/update/:email", wrapper.GlobalUserUpdate)
	router.GET(baseURL+"/users/whoami", wrapper.GlobalWhoami)
	router.GET(baseURL+"/version", wrapper.BackendVersion)
	router.POST(baseURL+"/w/:workspace/acls/add/:kind/:path", wrapper.AddGranularAcls)
	router.GET(baseURL+"/w/:workspace/acls/get/:kind/:path", wrapper.GetGranularAcls)
	router.POST(baseURL+"/w/:workspace/acls/remove/:kind/:path", wrapper.RemoveGranularAcls)
	router.GET(baseURL+"/w/:workspace/audit/get/:id", wrapper.GetAuditLog)
	router.GET(baseURL+"/w/:workspace/audit/list", wrapper.ListAuditLogs)
	router.POST(baseURL+"/w/:workspace/flows/archive/:path", wrapper.ArchiveFlowByPath)
	router.POST(baseURL+"/w/:workspace/flows/create", wrapper.CreateFlow)
	router.GET(baseURL+"/w/:workspace/flows/exists/:path", wrapper.ExistsFlowByPath)
	router.GET(baseURL+"/w/:workspace/flows/get/:path", wrapper.GetFlowByPath)
	router.GET(baseURL+"/w/:workspace/flows/list", wrapper.ListFlows)
	router.POST(baseURL+"/w/:workspace/flows/update/:path", wrapper.UpdateFlow)
	router.POST(baseURL+"/w/:workspace/groups/adduser/:name", wrapper.AddUserToGroup)
	router.POST(baseURL+"/w/:workspace/groups/create", wrapper.CreateGroup)
	router.DELETE(baseURL+"/w/:workspace/groups/delete/:name", wrapper.DeleteGroup)
	router.GET(baseURL+"/w/:workspace/groups/get/:name", wrapper.GetGroup)
	router.GET(baseURL+"/w/:workspace/groups/list", wrapper.ListGroups)
	router.GET(baseURL+"/w/:workspace/groups/listnames", wrapper.ListGroupNames)
	router.POST(baseURL+"/w/:workspace/groups/removeuser/:name", wrapper.RemoveUserToGroup)
	router.POST(baseURL+"/w/:workspace/groups/update/:name", wrapper.UpdateGroup)
	router.GET(baseURL+"/w/:workspace/jobs/cancel/:id/:resume_id/:signature", wrapper.CancelSuspendedJobGet)
	router.POST(baseURL+"/w/:workspace/jobs/cancel/:id/:resume_id/:signature", wrapper.CancelSuspendedJobPost)
	router.POST(baseURL+"/w/:workspace/jobs/completed/delete/:id", wrapper.DeleteCompletedJob)
	router.GET(baseURL+"/w/:workspace/jobs/completed/get/:id", wrapper.GetCompletedJob)
	router.GET(baseURL+"/w/:workspace/jobs/completed/list", wrapper.ListCompletedJobs)
	router.GET(baseURL+"/w/:workspace/jobs/get/:id", wrapper.GetJob)
	router.GET(baseURL+"/w/:workspace/jobs/getupdate/:id", wrapper.GetJobUpdates)
	router.GET(baseURL+"/w/:workspace/jobs/job_signature/:id/:resume_id", wrapper.CreateJobSignature)
	router.GET(baseURL+"/w/:workspace/jobs/list", wrapper.ListJobs)
	router.POST(baseURL+"/w/:workspace/jobs/queue/cancel/:id", wrapper.CancelQueuedJob)
	router.GET(baseURL+"/w/:workspace/jobs/queue/list", wrapper.ListQueue)
	router.GET(baseURL+"/w/:workspace/jobs/resume/:id/:resume_id/:signature", wrapper.ResumeSuspendedJobGet)
	router.POST(baseURL+"/w/:workspace/jobs/resume/:id/:resume_id/:signature", wrapper.ResumeSuspendedJobPost)
	router.POST(baseURL+"/w/:workspace/jobs/run/f/:path", wrapper.RunFlowByPath)
	router.POST(baseURL+"/w/:workspace/jobs/run/h/:hash", wrapper.RunScriptByHash)
	router.POST(baseURL+"/w/:workspace/jobs/run/p/:path", wrapper.RunScriptByPath)
	router.POST(baseURL+"/w/:workspace/jobs/run/preview", wrapper.RunScriptPreview)
	router.POST(baseURL+"/w/:workspace/jobs/run/preview_flow", wrapper.RunFlowPreview)
	router.POST(baseURL+"/w/:workspace/jobs/run_wait_result/p/:path", wrapper.RunWaitResultScriptByPath)
	router.POST(baseURL+"/w/:workspace/oauth/create_account", wrapper.CreateAccount)
	router.POST(baseURL+"/w/:workspace/oauth/disconnect/:id", wrapper.DisconnectAccount)
	router.POST(baseURL+"/w/:workspace/oauth/disconnect_slack", wrapper.DisconnectSlack)
	router.POST(baseURL+"/w/:workspace/oauth/refresh_token/:id", wrapper.RefreshToken)
	router.POST(baseURL+"/w/:workspace/oauth/set_workspace_slack", wrapper.SetWorkspaceSlack)
	router.POST(baseURL+"/w/:workspace/resources/create", wrapper.CreateResource)
	router.DELETE(baseURL+"/w/:workspace/resources/delete/:path", wrapper.DeleteResource)
	router.GET(baseURL+"/w/:workspace/resources/exists/:path", wrapper.ExistsResource)
	router.GET(baseURL+"/w/:workspace/resources/get/:path", wrapper.GetResource)
	router.GET(baseURL+"/w/:workspace/resources/list", wrapper.ListResource)
	router.POST(baseURL+"/w/:workspace/resources/type/create", wrapper.CreateResourceType)
	router.DELETE(baseURL+"/w/:workspace/resources/type/delete/:path", wrapper.DeleteResourceType)
	router.GET(baseURL+"/w/:workspace/resources/type/exists/:path", wrapper.ExistsResourceType)
	router.GET(baseURL+"/w/:workspace/resources/type/get/:path", wrapper.GetResourceType)
	router.GET(baseURL+"/w/:workspace/resources/type/list", wrapper.ListResourceType)
	router.GET(baseURL+"/w/:workspace/resources/type/listnames", wrapper.ListResourceTypeNames)
	router.POST(baseURL+"/w/:workspace/resources/type/update/:path", wrapper.UpdateResourceType)
	router.POST(baseURL+"/w/:workspace/resources/update/:path", wrapper.UpdateResource)
	router.POST(baseURL+"/w/:workspace/schedules/create", wrapper.CreateSchedule)
	router.DELETE(baseURL+"/w/:workspace/schedules/delete/:path", wrapper.DeleteSchedule)
	router.GET(baseURL+"/w/:workspace/schedules/exists/:path", wrapper.ExistsSchedule)
	router.GET(baseURL+"/w/:workspace/schedules/get/:path", wrapper.GetSchedule)
	router.GET(baseURL+"/w/:workspace/schedules/list", wrapper.ListSchedules)
	router.POST(baseURL+"/w/:workspace/schedules/setenabled/:path", wrapper.SetScheduleEnabled)
	router.POST(baseURL+"/w/:workspace/schedules/update/:path", wrapper.UpdateSchedule)
	router.POST(baseURL+"/w/:workspace/scripts/archive/h/:hash", wrapper.ArchiveScriptByHash)
	router.POST(baseURL+"/w/:workspace/scripts/archive/p/:path", wrapper.ArchiveScriptByPath)
	router.POST(baseURL+"/w/:workspace/scripts/create", wrapper.CreateScript)
	router.POST(baseURL+"/w/:workspace/scripts/delete/h/:hash", wrapper.DeleteScriptByHash)
	router.GET(baseURL+"/w/:workspace/scripts/deployment_status/h/:hash", wrapper.GetScriptDeploymentStatus)
	router.GET(baseURL+"/w/:workspace/scripts/exists/p/:path", wrapper.ExistsScriptByPath)
	router.GET(baseURL+"/w/:workspace/scripts/get/h/:hash", wrapper.GetScriptByHash)
	router.GET(baseURL+"/w/:workspace/scripts/get/p/:path", wrapper.GetScriptByPath)
	router.GET(baseURL+"/w/:workspace/scripts/list", wrapper.ListScripts)
	router.GET(baseURL+"/w/:workspace/scripts/raw/h/:path", wrapper.RawScriptByHash)
	router.GET(baseURL+"/w/:workspace/scripts/raw/p/:path", wrapper.RawScriptByPath)
	router.POST(baseURL+"/w/:workspace/users/add", wrapper.CreateUser)
	router.DELETE(baseURL+"/w/:workspace/users/delete/:username", wrapper.DeleteUser)
	router.POST(baseURL+"/w/:workspace/users/leave_workspace", wrapper.LeaveWorkspace)
	router.GET(baseURL+"/w/:workspace/users/list", wrapper.ListUsers)
	router.GET(baseURL+"/w/:workspace/users/list_usernames", wrapper.ListUsernames)
	router.POST(baseURL+"/w/:workspace/users/update/:username", wrapper.UpdateUser)
	router.GET(baseURL+"/w/:workspace/users/whoami", wrapper.Whoami)
	router.GET(baseURL+"/w/:workspace/users/whois/:username", wrapper.Whois)
	router.POST(baseURL+"/w/:workspace/variables/create", wrapper.CreateVariable)
	router.DELETE(baseURL+"/w/:workspace/variables/delete/:path", wrapper.DeleteVariable)
	router.GET(baseURL+"/w/:workspace/variables/exists/:path", wrapper.ExistsVariable)
	router.GET(baseURL+"/w/:workspace/variables/get/:path", wrapper.GetVariable)
	router.GET(baseURL+"/w/:workspace/variables/list", wrapper.ListVariable)
	router.GET(baseURL+"/w/:workspace/variables/list_contextual", wrapper.ListContextualVariables)
	router.POST(baseURL+"/w/:workspace/variables/update/:path", wrapper.UpdateVariable)
	router.DELETE(baseURL+"/w/:workspace/workspaces/delete", wrapper.DeleteWorkspace)
	router.POST(baseURL+"/w/:workspace/workspaces/delete_invite", wrapper.DeleteInvite)
	router.POST(baseURL+"/w/:workspace/workspaces/edit_slack_command", wrapper.EditSlackCommand)
	router.GET(baseURL+"/w/:workspace/workspaces/get_settings", wrapper.GetSettings)
	router.POST(baseURL+"/w/:workspace/workspaces/invite_user", wrapper.InviteUser)
	router.GET(baseURL+"/w/:workspace/workspaces/list_pending_invites", wrapper.ListPendingInvites)
	router.GET(baseURL+"/workers/list", wrapper.ListWorkers)
	router.POST(baseURL+"/workspaces/create", wrapper.CreateWorkspace)
	router.POST(baseURL+"/workspaces/exists", wrapper.ExistsWorkspace)
	router.POST(baseURL+"/workspaces/exists_username", wrapper.ExistsUsername)
	router.GET(baseURL+"/workspaces/list", wrapper.ListWorkspaces)
	router.GET(baseURL+"/workspaces/list_as_superadmin", wrapper.ListWorkspacesAsSuperAdmin)
	router.GET(baseURL+"/workspaces/users", wrapper.ListUserWorkspaces)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AP//c6nytnpIAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
