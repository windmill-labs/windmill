// Auto-generated MCP tools from OpenAPI specification
// This file is generated by generate_mcp_tools.py - DO NOT EDIT MANUALLY

use std::borrow::Cow;
use windmill_mcp::server::EndpointTool;

pub fn all_tools() -> Vec<EndpointTool> {
    vec![
    EndpointTool {
        name: Cow::Borrowed("queryDocumentation"),
        description: Cow::Borrowed("query Windmill AI documentation assistant (EE only)"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/inkeep"),
        method: Cow::Borrowed("POST"),
        path_params_schema: None,
        query_params_schema: None,
        body_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "query": {
                        "type": "string",
                        "description": "The documentation query to send to the AI assistant"
                }
        },
        "required": [
                "query"
        ]
})),
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("createVariable"),
        description: Cow::Borrowed("create variable"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/variables/create"),
        method: Cow::Borrowed("POST"),
        path_params_schema: None,
        query_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "already_encrypted": {
                        "type": "boolean",
                        "description": "whether the variable is already encrypted (default false)"
                }
        },
        "required": []
})),
        body_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "path": {
                        "type": "string",
                        "description": "The path to the variable"
                },
                "value": {
                        "type": "string",
                        "description": "The value of the variable"
                },
                "is_secret": {
                        "type": "boolean",
                        "description": "Whether the variable is a secret"
                },
                "description": {
                        "type": "string",
                        "description": "The description of the variable"
                },
                "account": {
                        "type": "integer",
                        "description": "The account identifier"
                },
                "is_oauth": {
                        "type": "boolean",
                        "description": "Whether the variable is an OAuth variable"
                },
                "expires_at": {
                        "type": "string",
                        "description": "The expiration date of the variable",
                        "format": "date-time"
                }
        },
        "required": [
                "path",
                "value",
                "is_secret",
                "description"
        ]
})),
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("deleteVariable"),
        description: Cow::Borrowed("delete variable"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/variables/delete/{path}"),
        method: Cow::Borrowed("DELETE"),
        path_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "path": {
                        "type": "string"
                }
        },
        "required": [
                "path"
        ]
})),
        query_params_schema: None,
        body_schema: None,
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("updateVariable"),
        description: Cow::Borrowed("update variable"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/variables/update/{path}"),
        method: Cow::Borrowed("POST"),
        path_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "path__path": {
                        "type": "string",
                        "description": "(path parameter)"
                }
        },
        "required": [
                "path__path"
        ]
})),
        query_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "already_encrypted": {
                        "type": "boolean",
                        "description": "whether the variable is already encrypted (default false)"
                }
        },
        "required": []
})),
        body_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "value": {
                        "type": "string",
                        "description": "The new value of the variable"
                },
                "is_secret": {
                        "type": "boolean",
                        "description": "Whether the variable is a secret"
                },
                "description": {
                        "type": "string",
                        "description": "The new description of the variable"
                },
                "path__body": {
                        "type": "string",
                        "description": "The path to the variable (body parameter)"
                }
        }
})),
        path_field_renames: Some(serde_json::json!({
        "path__path": "path"
})),
        query_field_renames: None,
        body_field_renames: Some(serde_json::json!({
        "path__body": "path"
})),
    },
    EndpointTool {
        name: Cow::Borrowed("getVariable"),
        description: Cow::Borrowed("get variable"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/variables/get/{path}"),
        method: Cow::Borrowed("GET"),
        path_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "path": {
                        "type": "string"
                }
        },
        "required": [
                "path"
        ]
})),
        query_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "decrypt_secret": {
                        "type": "boolean",
                        "description": "ask to decrypt secret if this variable is secret\n(if not secret no effect, default: true)\n"
                },
                "include_encrypted": {
                        "type": "boolean",
                        "description": "ask to include the encrypted value if secret and decrypt secret is not true (default: false)\n"
                }
        },
        "required": []
})),
        body_schema: None,
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("listVariable"),
        description: Cow::Borrowed("list variables"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/variables/list"),
        method: Cow::Borrowed("GET"),
        path_params_schema: None,
        query_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "path_start": {
                        "type": "string",
                        "description": "filter variables by path prefix"
                },
                "page": {
                        "type": "integer",
                        "description": "which page to return (start at 1, default 1)"
                },
                "per_page": {
                        "type": "integer",
                        "description": "number of items to return for a given page (default 30, max 100)"
                }
        },
        "required": []
})),
        body_schema: None,
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("createResource"),
        description: Cow::Borrowed("create resource"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/resources/create"),
        method: Cow::Borrowed("POST"),
        path_params_schema: None,
        query_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "update_if_exists": {
                        "type": "boolean",
                        "description": "update the resource if it already exists (default false)"
                }
        },
        "required": []
})),
        body_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "path": {
                        "type": "string",
                        "description": "The path to the resource"
                },
                "value": {
                        "type": "object"
                },
                "description": {
                        "type": "string",
                        "description": "The description of the resource"
                },
                "resource_type": {
                        "type": "string",
                        "description": "The resource_type associated with the resource"
                }
        },
        "required": [
                "path",
                "value",
                "resource_type"
        ]
})),
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("deleteResource"),
        description: Cow::Borrowed("delete resource"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/resources/delete/{path}"),
        method: Cow::Borrowed("DELETE"),
        path_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "path": {
                        "type": "string"
                }
        },
        "required": [
                "path"
        ]
})),
        query_params_schema: None,
        body_schema: None,
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("updateResource"),
        description: Cow::Borrowed("update resource"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/resources/update/{path}"),
        method: Cow::Borrowed("POST"),
        path_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "path__path": {
                        "type": "string",
                        "description": "(path parameter)"
                }
        },
        "required": [
                "path__path"
        ]
})),
        query_params_schema: None,
        body_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "description": {
                        "type": "string",
                        "description": "The new description of the resource"
                },
                "value": {
                        "type": "object"
                },
                "resource_type": {
                        "type": "string",
                        "description": "The new resource_type to be associated with the resource"
                },
                "path__body": {
                        "type": "string",
                        "description": "The path to the resource (body parameter)"
                }
        }
})),
        path_field_renames: Some(serde_json::json!({
        "path__path": "path"
})),
        query_field_renames: None,
        body_field_renames: Some(serde_json::json!({
        "path__body": "path"
})),
    },
    EndpointTool {
        name: Cow::Borrowed("getResource"),
        description: Cow::Borrowed("get resource"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/resources/get/{path}"),
        method: Cow::Borrowed("GET"),
        path_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "path": {
                        "type": "string"
                }
        },
        "required": [
                "path"
        ]
})),
        query_params_schema: None,
        body_schema: None,
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("listResource"),
        description: Cow::Borrowed("list resources"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/resources/list"),
        method: Cow::Borrowed("GET"),
        path_params_schema: None,
        query_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "page": {
                        "type": "integer",
                        "description": "which page to return (start at 1, default 1)"
                },
                "per_page": {
                        "type": "integer",
                        "description": "number of items to return for a given page (default 30, max 100)"
                },
                "resource_type": {
                        "type": "string",
                        "description": "resource_types to list from, separated by ',',"
                },
                "resource_type_exclude": {
                        "type": "string",
                        "description": "resource_types to not list from, separated by ',',"
                },
                "path_start": {
                        "type": "string",
                        "description": "filter resources by path prefix"
                }
        },
        "required": []
})),
        body_schema: None,
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("listResourceType"),
        description: Cow::Borrowed("list resource_types"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/resources/type/list"),
        method: Cow::Borrowed("GET"),
        path_params_schema: None,
        query_params_schema: None,
        body_schema: None,
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("listScripts"),
        description: Cow::Borrowed("list all scripts"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/scripts/list"),
        method: Cow::Borrowed("GET"),
        path_params_schema: None,
        query_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "page": {
                        "type": "integer",
                        "description": "which page to return (start at 1, default 1)"
                },
                "per_page": {
                        "type": "integer",
                        "description": "number of items to return for a given page (default 30, max 100)"
                },
                "order_desc": {
                        "type": "boolean",
                        "description": "order by desc order (default true)"
                },
                "created_by": {
                        "type": "string",
                        "description": "mask to filter exact matching user creator"
                },
                "path_start": {
                        "type": "string",
                        "description": "mask to filter matching starting path"
                },
                "path_exact": {
                        "type": "string",
                        "description": "mask to filter exact matching path"
                },
                "first_parent_hash": {
                        "type": "string",
                        "description": "mask to filter scripts whom first direct parent has exact hash"
                },
                "last_parent_hash": {
                        "type": "string",
                        "description": "mask to filter scripts whom last parent in the chain has exact hash.\nBeware that each script stores only a limited number of parents. Hence\nthe last parent hash for a script is not necessarily its top-most parent.\nTo find the top-most parent you will have to jump from last to last hash\n until finding the parent\n"
                },
                "parent_hash": {
                        "type": "string",
                        "description": "is the hash present in the array of stored parent hashes for this script.\nThe same warning applies than for last_parent_hash. A script only store a\nlimited number of direct parent\n"
                },
                "show_archived": {
                        "type": "boolean",
                        "description": "(default false)\nshow only the archived files.\nwhen multiple archived hash share the same path, only the ones with the latest create_at\nare\ned.\n"
                },
                "include_without_main": {
                        "type": "boolean",
                        "description": "(default false)\ninclude scripts without an exported main function\n"
                },
                "include_draft_only": {
                        "type": "boolean",
                        "description": "(default false)\ninclude scripts that have no deployed version\n"
                },
                "is_template": {
                        "type": "boolean",
                        "description": "(default regardless)\nif true show only the templates\nif false show only the non templates\nif not defined, show all regardless of if the script is a template\n"
                },
                "kinds": {
                        "type": "string",
                        "description": "(default regardless)\nscript kinds to filter, split by comma\n"
                },
                "starred_only": {
                        "type": "boolean",
                        "description": "(default false)\nshow only the starred items\n"
                },
                "with_deployment_msg": {
                        "type": "boolean",
                        "description": "(default false)\ninclude deployment message\n"
                },
                "languages": {
                        "type": "string",
                        "description": "Filter to only include scripts written in the given languages.\nAccepts multiple values as a comma-separated list.\n"
                },
                "without_description": {
                        "type": "boolean",
                        "description": "(default false)\nIf true, the description field will be omitted from the response.\n"
                },
                "dedicated_worker": {
                        "type": "boolean",
                        "description": "(default regardless)\nIf true, show only scripts with dedicated_worker enabled.\nIf false, show only scripts with dedicated_worker disabled.\n"
                }
        },
        "required": []
})),
        body_schema: None,
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("createScript"),
        description: Cow::Borrowed("create script"),
        instructions: Cow::Borrowed("To create a script, specify the path (e.g., 'f/my_folder/my_script'), the content (source code), and the language. For TypeScript, use 'bun' unless deno-specific APIs are needed."),
        path: Cow::Borrowed("/w/{workspace}/scripts/create"),
        method: Cow::Borrowed("POST"),
        path_params_schema: None,
        query_params_schema: None,
        body_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "path": {
                        "type": "string"
                },
                "summary": {
                        "type": "string"
                },
                "description": {
                        "type": "string"
                },
                "content": {
                        "type": "string"
                },
                "language": {
                        "type": "string",
                        "description": "Possible values: python3, deno, go, bash, powershell, postgresql, mysql, bigquery, snowflake, mssql, oracledb, graphql, nativets, bun, php, rust, ansible, csharp, nu, java, ruby, duckdb, bunnative"
                },
                "kind": {
                        "type": "string",
                        "description": "Possible values: script, failure, trigger, command, approval, preprocessor"
                },
                "tag": {
                        "type": "string"
                },
                "deployment_message": {
                        "type": "string"
                }
        },
        "required": [
                "path",
                "summary",
                "description",
                "content",
                "language"
        ]
})),
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("deleteScriptByHash"),
        description: Cow::Borrowed("delete script by hash (erase content but keep hash, require admin)"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/scripts/delete/h/{hash}"),
        method: Cow::Borrowed("POST"),
        path_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "hash": {
                        "type": "string"
                }
        },
        "required": [
                "hash"
        ]
})),
        query_params_schema: None,
        body_schema: None,
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("deleteScriptByPath"),
        description: Cow::Borrowed("delete script at a given path (require admin)"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/scripts/delete/p/{path}"),
        method: Cow::Borrowed("POST"),
        path_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "path": {
                        "type": "string"
                }
        },
        "required": [
                "path"
        ]
})),
        query_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "keep_captures": {
                        "type": "boolean",
                        "description": "keep captures"
                }
        },
        "required": []
})),
        body_schema: None,
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("getScriptByPath"),
        description: Cow::Borrowed("get script by path"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/scripts/get/p/{path}"),
        method: Cow::Borrowed("GET"),
        path_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "path": {
                        "type": "string"
                }
        },
        "required": [
                "path"
        ]
})),
        query_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "with_starred_info": {
                        "type": "boolean"
                }
        },
        "required": []
})),
        body_schema: None,
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("runScriptByPath"),
        description: Cow::Borrowed("run script by path"),
        instructions: Cow::Borrowed("You should first use getScriptByPath to retrieve the script's schema and understand what arguments are expected."),
        path: Cow::Borrowed("/w/{workspace}/jobs/run/p/{path}"),
        method: Cow::Borrowed("POST"),
        path_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "path": {
                        "type": "string"
                }
        },
        "required": [
                "path"
        ]
})),
        query_params_schema: None,
        body_schema: Some(serde_json::json!({
        "type": "object",
        "description": "The arguments to pass to the script or flow",
        "additionalProperties": true
})),
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("listFlows"),
        description: Cow::Borrowed("list all flows"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/flows/list"),
        method: Cow::Borrowed("GET"),
        path_params_schema: None,
        query_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "page": {
                        "type": "integer",
                        "description": "which page to return (start at 1, default 1)"
                },
                "per_page": {
                        "type": "integer",
                        "description": "number of items to return for a given page (default 30, max 100)"
                },
                "order_desc": {
                        "type": "boolean",
                        "description": "order by desc order (default true)"
                },
                "created_by": {
                        "type": "string",
                        "description": "mask to filter exact matching user creator"
                },
                "path_start": {
                        "type": "string",
                        "description": "mask to filter matching starting path"
                },
                "path_exact": {
                        "type": "string",
                        "description": "mask to filter exact matching path"
                },
                "show_archived": {
                        "type": "boolean",
                        "description": "(default false)\nshow only the archived files.\nwhen multiple archived hash share the same path, only the ones with the latest create_at\nare displayed.\n"
                },
                "starred_only": {
                        "type": "boolean",
                        "description": "(default false)\nshow only the starred items\n"
                },
                "include_draft_only": {
                        "type": "boolean",
                        "description": "(default false)\ninclude items that have no deployed version\n"
                },
                "with_deployment_msg": {
                        "type": "boolean",
                        "description": "(default false)\ninclude deployment message\n"
                },
                "without_description": {
                        "type": "boolean",
                        "description": "(default false)\nIf true, the description field will be omitted from the response.\n"
                },
                "dedicated_worker": {
                        "type": "boolean",
                        "description": "(default regardless)\nIf true, show only flows with dedicated_worker enabled.\nIf false, show only flows with dedicated_worker disabled.\n"
                }
        },
        "required": []
})),
        body_schema: None,
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("getFlowByPath"),
        description: Cow::Borrowed("get flow by path"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/flows/get/{path}"),
        method: Cow::Borrowed("GET"),
        path_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "path": {
                        "type": "string"
                }
        },
        "required": [
                "path"
        ]
})),
        query_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "with_starred_info": {
                        "type": "boolean"
                }
        },
        "required": []
})),
        body_schema: None,
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("createFlow"),
        description: Cow::Borrowed("create flow"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/flows/create"),
        method: Cow::Borrowed("POST"),
        path_params_schema: None,
        query_params_schema: None,
        body_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "summary": {
                        "type": "string",
                        "description": "Short description of what this flow does"
                },
                "description": {
                        "type": "string",
                        "description": "Detailed documentation for this flow"
                },
                "value": {
                        "type": "object"
                },
                "schema": {
                        "type": "object"
                },
                "path": {
                        "type": "string"
                },
                "tag": {
                        "type": "string"
                },
                "deployment_message": {
                        "type": "string"
                }
        },
        "required": [
                "summary",
                "value",
                "path"
        ],
        "description": "Top-level flow definition containing metadata, configuration, and the flow structure"
})),
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("updateFlow"),
        description: Cow::Borrowed("update flow"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/flows/update/{path}"),
        method: Cow::Borrowed("POST"),
        path_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "path__path": {
                        "type": "string",
                        "description": "(path parameter)"
                }
        },
        "required": [
                "path__path"
        ]
})),
        query_params_schema: None,
        body_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "summary": {
                        "type": "string",
                        "description": "Short description of what this flow does"
                },
                "description": {
                        "type": "string",
                        "description": "Detailed documentation for this flow"
                },
                "value": {
                        "type": "object"
                },
                "schema": {
                        "type": "object"
                },
                "tag": {
                        "type": "string"
                },
                "deployment_message": {
                        "type": "string"
                },
                "path__body": {
                        "type": "string",
                        "description": "(body parameter)"
                }
        },
        "required": [
                "summary",
                "value",
                "path__body"
        ],
        "description": "Top-level flow definition containing metadata, configuration, and the flow structure"
})),
        path_field_renames: Some(serde_json::json!({
        "path__path": "path"
})),
        query_field_renames: None,
        body_field_renames: Some(serde_json::json!({
        "path__body": "path"
})),
    },
    EndpointTool {
        name: Cow::Borrowed("deleteFlowByPath"),
        description: Cow::Borrowed("delete flow by path"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/flows/delete/{path}"),
        method: Cow::Borrowed("DELETE"),
        path_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "path": {
                        "type": "string"
                }
        },
        "required": [
                "path"
        ]
})),
        query_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "keep_captures": {
                        "type": "boolean",
                        "description": "keep captures"
                }
        },
        "required": []
})),
        body_schema: None,
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("createApp"),
        description: Cow::Borrowed("create app"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/apps/create"),
        method: Cow::Borrowed("POST"),
        path_params_schema: None,
        query_params_schema: None,
        body_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "path": {
                        "type": "string"
                },
                "value": {
                        "type": "object"
                },
                "summary": {
                        "type": "string"
                },
                "policy": {
                        "type": "object"
                },
                "deployment_message": {
                        "type": "string"
                }
        },
        "required": [
                "path",
                "value",
                "summary",
                "policy"
        ]
})),
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("updateApp"),
        description: Cow::Borrowed("update app"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/apps/update/{path}"),
        method: Cow::Borrowed("POST"),
        path_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "path__path": {
                        "type": "string",
                        "description": "(path parameter)"
                }
        },
        "required": [
                "path__path"
        ]
})),
        query_params_schema: None,
        body_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "summary": {
                        "type": "string"
                },
                "value": {
                        "type": "object"
                },
                "policy": {
                        "type": "object"
                },
                "deployment_message": {
                        "type": "string"
                },
                "path__body": {
                        "type": "string",
                        "description": "(body parameter)"
                }
        }
})),
        path_field_renames: Some(serde_json::json!({
        "path__path": "path"
})),
        query_field_renames: None,
        body_field_renames: Some(serde_json::json!({
        "path__body": "path"
})),
    },
    EndpointTool {
        name: Cow::Borrowed("runFlowByPath"),
        description: Cow::Borrowed("run flow by path"),
        instructions: Cow::Borrowed("You should first use getFlowByPath to retrieve the flow's schema and understand what arguments are expected."),
        path: Cow::Borrowed("/w/{workspace}/jobs/run/f/{path}"),
        method: Cow::Borrowed("POST"),
        path_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "path": {
                        "type": "string"
                }
        },
        "required": [
                "path"
        ]
})),
        query_params_schema: None,
        body_schema: Some(serde_json::json!({
        "type": "object",
        "description": "The arguments to pass to the script or flow",
        "additionalProperties": true
})),
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("runScriptPreviewAndWaitResult"),
        description: Cow::Borrowed("run script preview and wait for result"),
        instructions: Cow::Borrowed("Allows testing a script before deploying it. For typescript code, the language to send is either bun or deno. By default, send bun if no deno specific code is detected."),
        path: Cow::Borrowed("/w/{workspace}/jobs/run_wait_result/preview"),
        method: Cow::Borrowed("POST"),
        path_params_schema: None,
        query_params_schema: None,
        body_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "content": {
                        "type": "string",
                        "description": "The code to run"
                },
                "path": {
                        "type": "string",
                        "description": "The path to the script"
                },
                "script_hash": {
                        "type": "string",
                        "description": "The hash of the script"
                },
                "args": {
                        "type": "object",
                        "description": "The arguments to pass to the script or flow",
                        "additionalProperties": true
                },
                "language": {
                        "type": "string",
                        "description": "Possible values: python3, deno, go, bash, powershell, postgresql, mysql, bigquery, snowflake, mssql, oracledb, graphql, nativets, bun, php, rust, ansible, csharp, nu, java, ruby, duckdb, bunnative"
                },
                "tag": {
                        "type": "string"
                },
                "kind": {
                        "type": "string",
                        "description": "Possible values: code, identity, http"
                },
                "dedicated_worker": {
                        "type": "boolean"
                },
                "lock": {
                        "type": "string"
                }
        },
        "required": [
                "args",
                "content",
                "language"
        ]
})),
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("listQueue"),
        description: Cow::Borrowed("list all queued jobs"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/jobs/queue/list"),
        method: Cow::Borrowed("GET"),
        path_params_schema: None,
        query_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "order_desc": {
                        "type": "boolean",
                        "description": "order by desc order (default true)"
                },
                "created_by": {
                        "type": "string",
                        "description": "mask to filter exact matching user creator"
                },
                "parent_job": {
                        "type": "string",
                        "format": "uuid",
                        "description": "The parent job that is at the origin and responsible for the execution of this script if any"
                },
                "worker": {
                        "type": "string",
                        "description": "worker this job was ran on"
                },
                "script_path_exact": {
                        "type": "string",
                        "description": "mask to filter exact matching path"
                },
                "script_path_start": {
                        "type": "string",
                        "description": "mask to filter matching starting path"
                },
                "schedule_path": {
                        "type": "string",
                        "description": "mask to filter by schedule path"
                },
                "trigger_path": {
                        "type": "string",
                        "description": "mask to filter by trigger path"
                },
                "trigger_kind": {
                        "description": "trigger kind (schedule, http, websocket...). Possible values: webhook, default_email, email, schedule, http, websocket, postgres, kafka, nats, mqtt, sqs, gcp",
                        "type": "string"
                },
                "script_hash": {
                        "type": "string",
                        "description": "mask to filter exact matching path"
                },
                "started_before": {
                        "type": "string",
                        "format": "date-time",
                        "description": "filter on started before (inclusive) timestamp"
                },
                "started_after": {
                        "type": "string",
                        "format": "date-time",
                        "description": "filter on started after (exclusive) timestamp"
                },
                "success": {
                        "type": "boolean",
                        "description": "filter on successful jobs"
                },
                "scheduled_for_before_now": {
                        "type": "boolean",
                        "description": "filter on jobs scheduled_for before now (hence waitinf for a worker)"
                },
                "job_kinds": {
                        "type": "string",
                        "description": "filter on job kind (values 'preview', 'script', 'dependencies', 'flow') separated by,"
                },
                "suspended": {
                        "type": "boolean",
                        "description": "filter on suspended jobs"
                },
                "running": {
                        "type": "boolean",
                        "description": "filter on running jobs"
                },
                "args": {
                        "type": "string",
                        "description": "filter on jobs containing those args as a json subset (@> in postgres)"
                },
                "result": {
                        "type": "string",
                        "description": "filter on jobs containing those result as a json subset (@> in postgres)"
                },
                "allow_wildcards": {
                        "type": "boolean",
                        "description": "allow wildcards (*) in the filter of label, tag, worker"
                },
                "tag": {
                        "type": "string",
                        "description": "filter on jobs with a given tag/worker group"
                },
                "page": {
                        "type": "integer",
                        "description": "which page to return (start at 1, default 1)"
                },
                "per_page": {
                        "type": "integer",
                        "description": "number of items to return for a given page (default 30, max 100)"
                },
                "all_workspaces": {
                        "type": "boolean",
                        "description": "get jobs from all workspaces (only valid if request come from the `admins` workspace)"
                },
                "is_not_schedule": {
                        "type": "boolean",
                        "description": "is not a scheduled job"
                }
        },
        "required": []
})),
        body_schema: None,
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("listJobs"),
        description: Cow::Borrowed("list all jobs"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/jobs/list"),
        method: Cow::Borrowed("GET"),
        path_params_schema: None,
        query_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "created_by": {
                        "type": "string",
                        "description": "mask to filter exact matching user creator"
                },
                "label": {
                        "type": "string",
                        "description": "mask to filter exact matching job's label (job labels are completed jobs with as a result an object containing a string in the array at key 'wm_labels')"
                },
                "worker": {
                        "type": "string",
                        "description": "worker this job was ran on"
                },
                "parent_job": {
                        "type": "string",
                        "format": "uuid",
                        "description": "The parent job that is at the origin and responsible for the execution of this script if any"
                },
                "script_path_exact": {
                        "type": "string",
                        "description": "mask to filter exact matching path"
                },
                "script_path_start": {
                        "type": "string",
                        "description": "mask to filter matching starting path"
                },
                "schedule_path": {
                        "type": "string",
                        "description": "mask to filter by schedule path"
                },
                "script_hash": {
                        "type": "string",
                        "description": "mask to filter exact matching path"
                },
                "started_before": {
                        "type": "string",
                        "format": "date-time",
                        "description": "filter on started before (inclusive) timestamp"
                },
                "started_after": {
                        "type": "string",
                        "format": "date-time",
                        "description": "filter on started after (exclusive) timestamp"
                },
                "created_before": {
                        "type": "string",
                        "format": "date-time",
                        "description": "filter on created before (inclusive) timestamp"
                },
                "created_after": {
                        "type": "string",
                        "format": "date-time",
                        "description": "filter on created after (exclusive) timestamp"
                },
                "completed_before": {
                        "type": "string",
                        "format": "date-time",
                        "description": "filter on started before (inclusive) timestamp"
                },
                "completed_after": {
                        "type": "string",
                        "format": "date-time",
                        "description": "filter on started after (exclusive) timestamp"
                },
                "created_before_queue": {
                        "type": "string",
                        "format": "date-time",
                        "description": "filter on jobs created before X for jobs in the queue only"
                },
                "created_after_queue": {
                        "type": "string",
                        "format": "date-time",
                        "description": "filter on jobs created after X for jobs in the queue only"
                },
                "running": {
                        "type": "boolean",
                        "description": "filter on running jobs"
                },
                "scheduled_for_before_now": {
                        "type": "boolean",
                        "description": "filter on jobs scheduled_for before now (hence waitinf for a worker)"
                },
                "job_kinds": {
                        "type": "string",
                        "description": "filter on job kind (values 'preview', 'script', 'dependencies', 'flow') separated by,"
                },
                "suspended": {
                        "type": "boolean",
                        "description": "filter on suspended jobs"
                },
                "args": {
                        "type": "string",
                        "description": "filter on jobs containing those args as a json subset (@> in postgres)"
                },
                "tag": {
                        "type": "string",
                        "description": "filter on jobs with a given tag/worker group"
                },
                "result": {
                        "type": "string",
                        "description": "filter on jobs containing those result as a json subset (@> in postgres)"
                },
                "allow_wildcards": {
                        "type": "boolean",
                        "description": "allow wildcards (*) in the filter of label, tag, worker"
                },
                "per_page": {
                        "type": "integer",
                        "description": "number of items to return for a given page (default 30, max 100)"
                },
                "trigger_kind": {
                        "description": "trigger kind (schedule, http, websocket...). Possible values: webhook, default_email, email, schedule, http, websocket, postgres, kafka, nats, mqtt, sqs, gcp",
                        "type": "string"
                },
                "is_skipped": {
                        "type": "boolean",
                        "description": "is the job skipped"
                },
                "is_flow_step": {
                        "type": "boolean",
                        "description": "is the job a flow step"
                },
                "has_null_parent": {
                        "type": "boolean",
                        "description": "has null parent"
                },
                "success": {
                        "type": "boolean",
                        "description": "filter on successful jobs"
                },
                "all_workspaces": {
                        "type": "boolean",
                        "description": "get jobs from all workspaces (only valid if request come from the `admins` workspace)"
                },
                "is_not_schedule": {
                        "type": "boolean",
                        "description": "is not a scheduled job"
                }
        },
        "required": []
})),
        body_schema: None,
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("createSchedule"),
        description: Cow::Borrowed("create schedule"),
        instructions: Cow::Borrowed("Creates a new schedule.
The schedule should include seconds.
You should get the schema of the script or flow before creating the schedule to correctly specify the arguments needed.
"),
        path: Cow::Borrowed("/w/{workspace}/schedules/create"),
        method: Cow::Borrowed("POST"),
        path_params_schema: None,
        query_params_schema: None,
        body_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "path": {
                        "type": "string",
                        "description": "The unique path identifier for this schedule"
                },
                "schedule": {
                        "type": "string",
                        "description": "Cron expression with 6 fields (seconds, minutes, hours, day of month, month, day of week). Example '0 0 12 * * *' for daily at noon"
                },
                "timezone": {
                        "type": "string",
                        "description": "IANA timezone for the schedule (e.g., 'UTC', 'Europe/Paris', 'America/New_York')"
                },
                "script_path": {
                        "type": "string",
                        "description": "Path to the script or flow to execute when triggered"
                },
                "is_flow": {
                        "type": "boolean",
                        "description": "True if script_path points to a flow, false if it points to a script"
                },
                "args": {
                        "type": "object",
                        "description": "The arguments to pass to the script or flow",
                        "additionalProperties": true
                },
                "enabled": {
                        "type": "boolean",
                        "description": "Whether the schedule is currently active and will trigger jobs"
                },
                "on_failure": {
                        "type": "string",
                        "description": "Path to a script or flow to run when the scheduled job fails"
                },
                "on_failure_times": {
                        "type": "number",
                        "description": "Number of consecutive failures before the on_failure handler is triggered (default 1)"
                },
                "on_failure_exact": {
                        "type": "boolean",
                        "description": "If true, trigger on_failure handler only on exactly N failures, not on every failure after N"
                },
                "on_failure_extra_args": {
                        "type": "object",
                        "description": "The arguments to pass to the script or flow",
                        "additionalProperties": true
                },
                "on_recovery": {
                        "type": "string",
                        "description": "Path to a script or flow to run when the schedule recovers after failures"
                },
                "on_recovery_times": {
                        "type": "number",
                        "description": "Number of consecutive successes before the on_recovery handler is triggered (default 1)"
                },
                "on_recovery_extra_args": {
                        "type": "object",
                        "description": "The arguments to pass to the script or flow",
                        "additionalProperties": true
                },
                "on_success": {
                        "type": "string",
                        "description": "Path to a script or flow to run after each successful execution"
                },
                "on_success_extra_args": {
                        "type": "object",
                        "description": "The arguments to pass to the script or flow",
                        "additionalProperties": true
                },
                "ws_error_handler_muted": {
                        "type": "boolean",
                        "description": "If true, the workspace-level error handler will not be triggered for this schedule's failures"
                },
                "retry": {
                        "type": "object",
                        "description": "Retry configuration for failed module executions",
                        "properties": {
                                "constant": {
                                        "type": "object",
                                        "description": "Retry with constant delay between attempts",
                                        "properties": {
                                                "attempts": {
                                                        "type": "integer",
                                                        "description": "Number of retry attempts"
                                                },
                                                "seconds": {
                                                        "type": "integer",
                                                        "description": "Seconds to wait between retries"
                                                }
                                        }
                                },
                                "exponential": {
                                        "type": "object",
                                        "description": "Retry with exponential backoff (delay doubles each time)",
                                        "properties": {
                                                "attempts": {
                                                        "type": "integer",
                                                        "description": "Number of retry attempts"
                                                },
                                                "multiplier": {
                                                        "type": "integer",
                                                        "description": "Multiplier for exponential backoff"
                                                },
                                                "seconds": {
                                                        "type": "integer",
                                                        "minimum": 1,
                                                        "description": "Initial delay in seconds"
                                                },
                                                "random_factor": {
                                                        "type": "integer",
                                                        "minimum": 0,
                                                        "maximum": 100,
                                                        "description": "Random jitter percentage (0-100) to avoid thundering herd"
                                                }
                                        }
                                },
                                "retry_if": {
                                        "type": "object",
                                        "description": "Conditional retry based on error or result",
                                        "properties": {
                                                "expr": {
                                                        "type": "string",
                                                        "description": "JavaScript expression that returns true to retry. Has access to 'result' and 'error' variables"
                                                }
                                        },
                                        "required": [
                                                "expr"
                                        ]
                                }
                        }
                },
                "no_flow_overlap": {
                        "type": "boolean",
                        "description": "If true, skip this schedule's execution if the previous run is still in progress (prevents concurrent runs)"
                },
                "summary": {
                        "type": "string",
                        "description": "Short summary describing the purpose of this schedule"
                },
                "description": {
                        "type": "string",
                        "description": "Detailed description of what this schedule does"
                },
                "tag": {
                        "type": "string",
                        "description": "Worker tag to route jobs to specific worker groups"
                },
                "paused_until": {
                        "type": "string",
                        "format": "date-time",
                        "description": "ISO 8601 datetime until which the schedule is paused. Schedule resumes automatically after this time"
                },
                "cron_version": {
                        "type": "string",
                        "description": "Cron parser version. Use 'v2' for extended syntax with additional features"
                },
                "dynamic_skip": {
                        "type": "string",
                        "description": "Path to a script that validates scheduled datetimes. Receives scheduled_for datetime and returns boolean to skip (true) or run (false)"
                }
        },
        "required": [
                "path",
                "schedule",
                "timezone",
                "script_path",
                "is_flow",
                "args"
        ]
})),
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("updateSchedule"),
        description: Cow::Borrowed("update schedule"),
        instructions: Cow::Borrowed("Updates a schedule.
The schedule should include seconds.
You should get the schema of the script or flow before updating the schedule to correctly specify the arguments needed.
"),
        path: Cow::Borrowed("/w/{workspace}/schedules/update/{path}"),
        method: Cow::Borrowed("POST"),
        path_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "path": {
                        "type": "string"
                }
        },
        "required": [
                "path"
        ]
})),
        query_params_schema: None,
        body_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "schedule": {
                        "type": "string",
                        "description": "Cron expression with 6 fields (seconds, minutes, hours, day of month, month, day of week). Example '0 0 12 * * *' for daily at noon"
                },
                "timezone": {
                        "type": "string",
                        "description": "IANA timezone for the schedule (e.g., 'UTC', 'Europe/Paris', 'America/New_York')"
                },
                "args": {
                        "type": "object",
                        "description": "The arguments to pass to the script or flow",
                        "additionalProperties": true
                },
                "on_failure": {
                        "type": "string",
                        "description": "Path to a script or flow to run when the scheduled job fails"
                },
                "on_failure_times": {
                        "type": "number",
                        "description": "Number of consecutive failures before the on_failure handler is triggered (default 1)"
                },
                "on_failure_exact": {
                        "type": "boolean",
                        "description": "If true, trigger on_failure handler only on exactly N failures, not on every failure after N"
                },
                "on_failure_extra_args": {
                        "type": "object",
                        "description": "The arguments to pass to the script or flow",
                        "additionalProperties": true
                },
                "on_recovery": {
                        "type": "string",
                        "description": "Path to a script or flow to run when the schedule recovers after failures"
                },
                "on_recovery_times": {
                        "type": "number",
                        "description": "Number of consecutive successes before the on_recovery handler is triggered (default 1)"
                },
                "on_recovery_extra_args": {
                        "type": "object",
                        "description": "The arguments to pass to the script or flow",
                        "additionalProperties": true
                },
                "on_success": {
                        "type": "string",
                        "description": "Path to a script or flow to run after each successful execution"
                },
                "on_success_extra_args": {
                        "type": "object",
                        "description": "The arguments to pass to the script or flow",
                        "additionalProperties": true
                },
                "ws_error_handler_muted": {
                        "type": "boolean",
                        "description": "If true, the workspace-level error handler will not be triggered for this schedule's failures"
                },
                "retry": {
                        "type": "object",
                        "description": "Retry configuration for failed module executions",
                        "properties": {
                                "constant": {
                                        "type": "object",
                                        "description": "Retry with constant delay between attempts",
                                        "properties": {
                                                "attempts": {
                                                        "type": "integer",
                                                        "description": "Number of retry attempts"
                                                },
                                                "seconds": {
                                                        "type": "integer",
                                                        "description": "Seconds to wait between retries"
                                                }
                                        }
                                },
                                "exponential": {
                                        "type": "object",
                                        "description": "Retry with exponential backoff (delay doubles each time)",
                                        "properties": {
                                                "attempts": {
                                                        "type": "integer",
                                                        "description": "Number of retry attempts"
                                                },
                                                "multiplier": {
                                                        "type": "integer",
                                                        "description": "Multiplier for exponential backoff"
                                                },
                                                "seconds": {
                                                        "type": "integer",
                                                        "minimum": 1,
                                                        "description": "Initial delay in seconds"
                                                },
                                                "random_factor": {
                                                        "type": "integer",
                                                        "minimum": 0,
                                                        "maximum": 100,
                                                        "description": "Random jitter percentage (0-100) to avoid thundering herd"
                                                }
                                        }
                                },
                                "retry_if": {
                                        "type": "object",
                                        "description": "Conditional retry based on error or result",
                                        "properties": {
                                                "expr": {
                                                        "type": "string",
                                                        "description": "JavaScript expression that returns true to retry. Has access to 'result' and 'error' variables"
                                                }
                                        },
                                        "required": [
                                                "expr"
                                        ]
                                }
                        }
                },
                "no_flow_overlap": {
                        "type": "boolean",
                        "description": "If true, skip this schedule's execution if the previous run is still in progress (prevents concurrent runs)"
                },
                "summary": {
                        "type": "string",
                        "description": "Short summary describing the purpose of this schedule"
                },
                "description": {
                        "type": "string",
                        "description": "Detailed description of what this schedule does"
                },
                "tag": {
                        "type": "string",
                        "description": "Worker tag to route jobs to specific worker groups"
                },
                "paused_until": {
                        "type": "string",
                        "format": "date-time",
                        "description": "ISO 8601 datetime until which the schedule is paused. Schedule resumes automatically after this time"
                },
                "cron_version": {
                        "type": "string",
                        "description": "Cron parser version. Use 'v2' for extended syntax with additional features"
                },
                "dynamic_skip": {
                        "type": "string",
                        "description": "Path to a script that validates scheduled datetimes. Receives scheduled_for datetime and returns boolean to skip (true) or run (false)"
                }
        },
        "required": [
                "schedule",
                "timezone",
                "args"
        ]
})),
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("deleteSchedule"),
        description: Cow::Borrowed("delete schedule"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/schedules/delete/{path}"),
        method: Cow::Borrowed("DELETE"),
        path_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "path": {
                        "type": "string"
                }
        },
        "required": [
                "path"
        ]
})),
        query_params_schema: None,
        body_schema: None,
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("getSchedule"),
        description: Cow::Borrowed("get schedule"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/schedules/get/{path}"),
        method: Cow::Borrowed("GET"),
        path_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "path": {
                        "type": "string"
                }
        },
        "required": [
                "path"
        ]
})),
        query_params_schema: None,
        body_schema: None,
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("listSchedules"),
        description: Cow::Borrowed("list schedules"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/w/{workspace}/schedules/list"),
        method: Cow::Borrowed("GET"),
        path_params_schema: None,
        query_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "page": {
                        "type": "integer",
                        "description": "which page to return (start at 1, default 1)"
                },
                "per_page": {
                        "type": "integer",
                        "description": "number of items to return for a given page (default 30, max 100)"
                },
                "args": {
                        "type": "string",
                        "description": "filter on jobs containing those args as a json subset (@> in postgres)"
                },
                "path": {
                        "type": "string",
                        "description": "filter by path"
                },
                "is_flow": {
                        "type": "boolean",
                        "description": "filter schedules by whether they target a flow"
                },
                "path_start": {
                        "type": "string",
                        "description": "filter schedules by path prefix"
                }
        },
        "required": []
})),
        body_schema: None,
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    },
    EndpointTool {
        name: Cow::Borrowed("listWorkers"),
        description: Cow::Borrowed("list workers"),
        instructions: Cow::Borrowed(""),
        path: Cow::Borrowed("/workers/list"),
        method: Cow::Borrowed("GET"),
        path_params_schema: None,
        query_params_schema: Some(serde_json::json!({
        "type": "object",
        "properties": {
                "page": {
                        "type": "integer",
                        "description": "which page to return (start at 1, default 1)"
                },
                "per_page": {
                        "type": "integer",
                        "description": "number of items to return for a given page (default 30, max 100)"
                },
                "ping_since": {
                        "type": "integer",
                        "description": "number of seconds the worker must have had a last ping more recent of (default to 300)"
                }
        },
        "required": []
})),
        body_schema: None,
        path_field_renames: None,
        query_field_renames: None,
        body_field_renames: None,
    }
    ]
}
