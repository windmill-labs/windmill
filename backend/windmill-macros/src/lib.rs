use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, ItemStruct, Lit};

#[proc_macro_attribute]
pub fn annotations(attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemStruct);
    let name = input.ident.clone();
    // TODO: Optimize/Refactor
    let fields = input.fields.iter().map(|f| f.ident.clone().unwrap());

    // Match on the literal to extract the string value
    let comm_lit = match parse_macro_input!(attr as Lit) {
        Lit::Str(lit_str) => lit_str.value(), // This will give "#" without quotes
        _ => panic!("Expected a string literal"),
    };

    let mut re = format!("^{}", &comm_lit);
    re.push_str(r#"\W*"#);

    let mut len = 0;
    let mut capture_group = "".to_string();
    for (i, field) in input.fields.iter().enumerate() {
        if i > 0 {
            capture_group.push_str("|")
        }
        capture_group.push_str(
            &(field
                .ident
                .clone()
                .expect("Annotations are only supported on named structs")
                .to_string()),
        );
        len += 1;
    }

    // Limit to 15 per line, the reason, is that it regex gets too heavy
    // Anyways it is not the problem until language has more than 15 annotations
    // If you have more than 15 annotations on line, its probabely better to refactor
    // 15 Annotations on single line for instance:
    // ann1 ann2 ann3 ann4 ann5 ann6 ann7 ann8 ann9 ann10 ann11 ann12 ann13 ann14 ann15
    for _ in 0..len.min(15) {
        // (?:(ann|ann2|ann3)\b\W*)?
        re.push_str(r#"(?:("#);
        re.push_str(&capture_group);
        re.push_str(r#")\b\W*)?"#);
    }

    re.push_str(&format!("$|^(?:#)"));

    // ^#\W*                 - Capture comment and make sure there is nothing before it
    // (?:(ann1|ann2)\b\W*)? - Optionally capture one of annotations
    // (?:(ann1|ann2)\b\W*)? - Repeat
    // $                     - Make sure there is only annotations on line
    // $|^(?:#)              - Make everything but ^# optional

    TokenStream::from(quote! {
        #[derive(Default, Debug)]
        #input

        impl #name {
            /// Autogenerated by windmill-macros
            pub fn parse(inner_content: &str) -> Self{
                let mut res = Self::default();
                // Avoid regex recompilation
                lazy_static::lazy_static! {
                    static ref RE: regex::Regex = regex::Regex::new(#re).unwrap();
                }

                // Create lines stream
                let mut lines = inner_content.lines();
                while let Some(line) = lines.next() {
                    // Will not succeed if there is no # in beginning of the line
                    if let Some(caps) = RE.captures(line){

                        for (i, mat) in caps.iter().skip(1).enumerate() {
                            //                      ^^^^^^
                            // Skip matched, we are interested only in groups
                            if let Some(mat) = mat {
                                match mat.as_str() {
                                    // Unfold fields
                                    // Read more: https://docs.rs/quote/latest/quote/macro.quote.html#interpolation
                                    #( stringify!(#fields) => res.#fields = true, )*
                                    _ => unreachable!(),
                                };
                            } else {
                                break;
                            }
                        }
                    } else {
                        break;
                    }
                }
                res
            }
        }
    })
}
