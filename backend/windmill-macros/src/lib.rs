use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, ItemStruct, Lit};

#[proc_macro_attribute]
pub fn annotations(attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemStruct);
    let name = input.ident.clone();
    // TODO: Optimize/Refactor
    let fields = input.fields.iter().map(|f| f.ident.clone().unwrap());

    // Match on the literal to extract the string value
    let comm_lit = match parse_macro_input!(attr as Lit) {
        Lit::Str(lit_str) => lit_str.value(), // This will give "#" without quotes
        _ => panic!("Expected a string literal"),
    };

    let mut re = format!("^(?:{})", &comm_lit);

    let mut len = 0;
    let mut capture_group = "".to_string();
    for (i, field) in input.fields.iter().enumerate() {
        if i > 0 {
            capture_group.push_str("|")
        }
        capture_group.push_str(
            &(field
                .ident
                .clone()
                .expect("Annotations are only supported on named structs")
                .to_string()),
        );
        len += 1;
    }

    for _ in 0..len {
        // (?:\W*\b(ann|ann2|ann3)\b\W*)?
        re.push_str(r#"(?:\W*\b("#);
        re.push_str(&capture_group);
        re.push_str(r#")\b\W*)?"#);
    }

    re.push_str(&format!("$|^(?:{})", &comm_lit));

    // Final regex will look something like this:

    // ^(?:#)                     - Capture comment and make sure there is nothing before it
    // (?:\W*\b(ann1|ann2)\b\W*)? - Optionally capture one of annotations
    // (?:\W*\b(ann1|ann2)\b\W*)? - Repeat
    // $                          - Make sure there is only annotations on line
    // |^(?:#)                    - Detect if there is comment sign in right position

    TokenStream::from(quote! {
        #[derive(Default, Debug)]
        #input

        impl #name {
            /// Autogenerated by windmill-macros
            pub fn parse(inner_content: &str) -> Self{
                let mut res = Self::default();
                // Avoid regex recompilation
                lazy_static::lazy_static! {
                    static ref RE: regex::Regex = regex::Regex::new(#re).unwrap();
                }

                // Create lines stream
                let mut lines = inner_content.lines();
                while let Some(line) = lines.next() {
                    // Will not succeed if there is no # in beginning of the line
                    if let Some(caps) = RE.captures(line){

                        for (i, mat) in caps.iter().skip(1).enumerate() {
                            //                      ^^^^^^
                            // Skip matched, we are interested only in groups
                            if let Some(mat) = mat {
                                match mat.as_str() {
                                    // Unfold fields
                                    // Read more: https://docs.rs/quote/latest/quote/macro.quote.html#interpolation
                                    #( stringify!(#fields) => res.#fields = true, )*
                                    _ => unreachable!(),
                                };
                            }
                        }

                    } else {
                        break;
                    }
                }
                res
            }
        }
    })
}
