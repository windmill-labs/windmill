use proc_macro::TokenStream;
use proc_macro2::Literal;
use quote::{quote, IdentFragment, ToTokens};
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};
use syn::{parse_macro_input, Ident, ItemStruct, Lit, LitInt};

fn string_to_hash(s: &str) -> u64 {
    let mut h = DefaultHasher::new();
    s.hash(&mut h);
    h.finish() // This returns a u64
}

#[proc_macro_attribute]
pub fn annotations(attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemStruct);
    let name = input.ident.clone();
    let fields = input
        .fields
        .iter()
        .map(|f| f.ident.clone().unwrap())
        .collect::<Vec<Ident>>();

    let hashes = fields
        .iter()
        .map(|f| Literal::u64_unsuffixed(string_to_hash(&f.to_string())))
        .collect::<Vec<Literal>>();

    // TODO: Hash collision
    // Match on the literal to extract the string value
    let comm_lit = match parse_macro_input!(attr as Lit) {
        Lit::Str(lit_str) => lit_str.value(), // This will give "#" without quotes
        _ => panic!("Expected a string literal"),
    };
    let comm_hash = Literal::u64_unsuffixed(string_to_hash(&comm_lit));

    let mut capture_group = "".to_string();
    for (i, field) in fields.iter().enumerate() {
        if i > 0 {
            capture_group.push_str("|")
        } else {
            capture_group.push_str(&format!("^{}|", &comm_lit))
        }
        capture_group.push_str(&(field.to_string()));
        capture_group.push_str("\\b");
    }

    let mut reg = "".to_string();

    reg.push_str(&capture_group);
    reg.push_str(r#"|\w+"#);

    // Example generated regex:

    // ?^#
    // |?ann1\b|ann2\b|ann3\b
    // |\w+

    TokenStream::from(quote! {
        #[derive(Default, Debug)]
        #input

        impl std::ops::BitOrAssign for #name{
            fn bitor_assign(&mut self, rhs: Self) {
                #( self.#fields |= rhs.#fields; )*
            }
        }

        impl #name {

            fn string_to_hash(s: &str) -> u64 {
                let mut h = DefaultHasher::new();
                s.hash(&mut h);
                h.finish() // This returns a u64
            }
            /// Autogenerated by windmill-macros
            pub fn parse(inner_content: &str) -> Self{
                let mut res = Self::default();
                lazy_static::lazy_static! {
                    static ref RE: regex::Regex = regex::Regex::new(#reg).unwrap();
                }
                // Create lines stream
                let mut lines = inner_content.lines();
                while let Some(line) = lines.next() {
                    let mut used = false;
                    let mut non_annotation = false;
                    let mut new = Self::default();
                    let mut hasher = DefaultHasher::new();
                    for (i, mat) in RE.find_iter(line).enumerate() {

                        let mt = mat.as_str();

                        match Self::string_to_hash(mt){
                            #comm_hash => {
                                if i == 0 {
                                    used = true;
                                    continue;
                                } else {
                                    break;
                                }
                            },
                            // Unfold fields
                            // Read more: https://docs.rs/quote/latest/quote/macro.quote.html#interpolation
                            #( #hashes => new.#fields = true, )*
                            _ => non_annotation = true,
                        };
                    }

                    if !used {
                        break;
                    } else if !non_annotation {
                        res |= new;
                    }
                }
                res
            }
        }
    })
}
