/*istanbul ignore start*/
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.diffWords = diffWords;
exports.diffWordsWithSpace = diffWordsWithSpace;
exports.wordWithSpaceDiff = exports.wordDiff = void 0;
/*istanbul ignore end*/
var
/*istanbul ignore start*/
_base = _interopRequireDefault(require("./base"))
/*istanbul ignore end*/
;
var
/*istanbul ignore start*/
_string = require("../util/string")
/*istanbul ignore end*/
;
/*istanbul ignore start*/ function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
/*istanbul ignore end*/
// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode
//
// Ranges and exceptions:
// Latin-1 Supplement, 0080–00FF
//  - U+00D7  × Multiplication sign
//  - U+00F7  ÷ Division sign
// Latin Extended-A, 0100–017F
// Latin Extended-B, 0180–024F
// IPA Extensions, 0250–02AF
// Spacing Modifier Letters, 02B0–02FF
//  - U+02C7  ˇ &#711;  Caron
//  - U+02D8  ˘ &#728;  Breve
//  - U+02D9  ˙ &#729;  Dot Above
//  - U+02DA  ˚ &#730;  Ring Above
//  - U+02DB  ˛ &#731;  Ogonek
//  - U+02DC  ˜ &#732;  Small Tilde
//  - U+02DD  ˝ &#733;  Double Acute Accent
// Latin Extended Additional, 1E00–1EFF
var extendedWordChars = "a-zA-Z\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}";

// Each token is one of the following:
// - A punctuation mark plus the surrounding whitespace
// - A word plus the surrounding whitespace
// - Pure whitespace (but only in the special case where this the entire text
//   is just whitespace)
//
// We have to include surrounding whitespace in the tokens because the two
// alternative approaches produce horribly broken results:
// * If we just discard the whitespace, we can't fully reproduce the original
//   text from the sequence of tokens and any attempt to render the diff will
//   get the whitespace wrong.
// * If we have separate tokens for whitespace, then in a typical text every
//   second token will be a single space character. But this often results in
//   the optimal diff between two texts being a perverse one that preserves
//   the spaces between words but deletes and reinserts actual common words.
//   See https://github.com/kpdecker/jsdiff/issues/160#issuecomment-1866099640
//   for an example.
//
// Keeping the surrounding whitespace of course has implications for .equals
// and .join, not just .tokenize.

// This regex does NOT fully implement the tokenization rules described above.
// Instead, it gives runs of whitespace their own "token". The tokenize method
// then handles stitching whitespace tokens onto adjacent word or punctuation
// tokens.
var tokenizeIncludingWhitespace = new RegExp(
/*istanbul ignore start*/
"[".concat(
/*istanbul ignore end*/
extendedWordChars, "]+|\\s+|[^").concat(extendedWordChars, "]"), 'ug');
var wordDiff =
/*istanbul ignore start*/
exports.wordDiff =
/*istanbul ignore end*/
new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
[
/*istanbul ignore start*/
"default"
/*istanbul ignore end*/
]();
wordDiff.equals = function (left, right, options) {
  if (options.ignoreCase) {
    left = left.toLowerCase();
    right = right.toLowerCase();
  }
  return left.trim() === right.trim();
};
wordDiff.tokenize = function (value) {
  /*istanbul ignore start*/
  var
  /*istanbul ignore end*/
  options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var parts;
  if (options.intlSegmenter) {
    if (options.intlSegmenter.resolvedOptions().granularity != 'word') {
      throw new Error('The segmenter passed must have a granularity of "word"');
    }
    parts = Array.from(options.intlSegmenter.segment(value), function (segment)
    /*istanbul ignore start*/
    {
      return (
        /*istanbul ignore end*/
        segment.segment
      );
    });
  } else {
    parts = value.match(tokenizeIncludingWhitespace) || [];
  }
  var tokens = [];
  var prevPart = null;
  parts.forEach(function (part) {
    if (/\s/.test(part)) {
      if (prevPart == null) {
        tokens.push(part);
      } else {
        tokens.push(tokens.pop() + part);
      }
    } else if (/\s/.test(prevPart)) {
      if (tokens[tokens.length - 1] == prevPart) {
        tokens.push(tokens.pop() + part);
      } else {
        tokens.push(prevPart + part);
      }
    } else {
      tokens.push(part);
    }
    prevPart = part;
  });
  return tokens;
};
wordDiff.join = function (tokens) {
  // Tokens being joined here will always have appeared consecutively in the
  // same text, so we can simply strip off the leading whitespace from all the
  // tokens except the first (and except any whitespace-only tokens - but such
  // a token will always be the first and only token anyway) and then join them
  // and the whitespace around words and punctuation will end up correct.
  return tokens.map(function (token, i) {
    if (i == 0) {
      return token;
    } else {
      return token.replace(/^\s+/, '');
    }
  }).join('');
};
wordDiff.postProcess = function (changes, options) {
  if (!changes || options.oneChangePerToken) {
    return changes;
  }
  var lastKeep = null;
  // Change objects representing any insertion or deletion since the last
  // "keep" change object. There can be at most one of each.
  var insertion = null;
  var deletion = null;
  changes.forEach(function (change) {
    if (change.added) {
      insertion = change;
    } else if (change.removed) {
      deletion = change;
    } else {
      if (insertion || deletion) {
        // May be false at start of text
        dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change);
      }
      lastKeep = change;
      insertion = null;
      deletion = null;
    }
  });
  if (insertion || deletion) {
    dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);
  }
  return changes;
};
function diffWords(oldStr, newStr, options) {
  // This option has never been documented and never will be (it's clearer to
  // just call `diffWordsWithSpace` directly if you need that behavior), but
  // has existed in jsdiff for a long time, so we retain support for it here
  // for the sake of backwards compatibility.
  if (
  /*istanbul ignore start*/
  (
  /*istanbul ignore end*/
  options === null || options === void 0 ? void 0 : options.ignoreWhitespace) != null && !options.ignoreWhitespace) {
    return diffWordsWithSpace(oldStr, newStr, options);
  }
  return wordDiff.diff(oldStr, newStr, options);
}
function dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {
  // Before returning, we tidy up the leading and trailing whitespace of the
  // change objects to eliminate cases where trailing whitespace in one object
  // is repeated as leading whitespace in the next.
  // Below are examples of the outcomes we want here to explain the code.
  // I=insert, K=keep, D=delete
  // 1. diffing 'foo bar baz' vs 'foo baz'
  //    Prior to cleanup, we have K:'foo ' D:' bar ' K:' baz'
  //    After cleanup, we want:   K:'foo ' D:'bar ' K:'baz'
  //
  // 2. Diffing 'foo bar baz' vs 'foo qux baz'
  //    Prior to cleanup, we have K:'foo ' D:' bar ' I:' qux ' K:' baz'
  //    After cleanup, we want K:'foo ' D:'bar' I:'qux' K:' baz'
  //
  // 3. Diffing 'foo\nbar baz' vs 'foo baz'
  //    Prior to cleanup, we have K:'foo ' D:'\nbar ' K:' baz'
  //    After cleanup, we want K'foo' D:'\nbar' K:' baz'
  //
  // 4. Diffing 'foo baz' vs 'foo\nbar baz'
  //    Prior to cleanup, we have K:'foo\n' I:'\nbar ' K:' baz'
  //    After cleanup, we ideally want K'foo' I:'\nbar' K:' baz'
  //    but don't actually manage this currently (the pre-cleanup change
  //    objects don't contain enough information to make it possible).
  //
  // 5. Diffing 'foo   bar baz' vs 'foo  baz'
  //    Prior to cleanup, we have K:'foo  ' D:'   bar ' K:'  baz'
  //    After cleanup, we want K:'foo  ' D:' bar ' K:'baz'
  //
  // Our handling is unavoidably imperfect in the case where there's a single
  // indel between keeps and the whitespace has changed. For instance, consider
  // diffing 'foo\tbar\nbaz' vs 'foo baz'. Unless we create an extra change
  // object to represent the insertion of the space character (which isn't even
  // a token), we have no way to avoid losing information about the texts'
  // original whitespace in the result we return. Still, we do our best to
  // output something that will look sensible if we e.g. print it with
  // insertions in green and deletions in red.

  // Between two "keep" change objects (or before the first or after the last
  // change object), we can have either:
  // * A "delete" followed by an "insert"
  // * Just an "insert"
  // * Just a "delete"
  // We handle the three cases separately.
  if (deletion && insertion) {
    var oldWsPrefix = deletion.value.match(/^\s*/)[0];
    var oldWsSuffix = deletion.value.match(/\s*$/)[0];
    var newWsPrefix = insertion.value.match(/^\s*/)[0];
    var newWsSuffix = insertion.value.match(/\s*$/)[0];
    if (startKeep) {
      var commonWsPrefix =
      /*istanbul ignore start*/
      (0,
      /*istanbul ignore end*/
      /*istanbul ignore start*/
      _string
      /*istanbul ignore end*/
      .
      /*istanbul ignore start*/
      longestCommonPrefix)
      /*istanbul ignore end*/
      (oldWsPrefix, newWsPrefix);
      startKeep.value =
      /*istanbul ignore start*/
      (0,
      /*istanbul ignore end*/
      /*istanbul ignore start*/
      _string
      /*istanbul ignore end*/
      .
      /*istanbul ignore start*/
      replaceSuffix)
      /*istanbul ignore end*/
      (startKeep.value, newWsPrefix, commonWsPrefix);
      deletion.value =
      /*istanbul ignore start*/
      (0,
      /*istanbul ignore end*/
      /*istanbul ignore start*/
      _string
      /*istanbul ignore end*/
      .
      /*istanbul ignore start*/
      removePrefix)
      /*istanbul ignore end*/
      (deletion.value, commonWsPrefix);
      insertion.value =
      /*istanbul ignore start*/
      (0,
      /*istanbul ignore end*/
      /*istanbul ignore start*/
      _string
      /*istanbul ignore end*/
      .
      /*istanbul ignore start*/
      removePrefix)
      /*istanbul ignore end*/
      (insertion.value, commonWsPrefix);
    }
    if (endKeep) {
      var commonWsSuffix =
      /*istanbul ignore start*/
      (0,
      /*istanbul ignore end*/
      /*istanbul ignore start*/
      _string
      /*istanbul ignore end*/
      .
      /*istanbul ignore start*/
      longestCommonSuffix)
      /*istanbul ignore end*/
      (oldWsSuffix, newWsSuffix);
      endKeep.value =
      /*istanbul ignore start*/
      (0,
      /*istanbul ignore end*/
      /*istanbul ignore start*/
      _string
      /*istanbul ignore end*/
      .
      /*istanbul ignore start*/
      replacePrefix)
      /*istanbul ignore end*/
      (endKeep.value, newWsSuffix, commonWsSuffix);
      deletion.value =
      /*istanbul ignore start*/
      (0,
      /*istanbul ignore end*/
      /*istanbul ignore start*/
      _string
      /*istanbul ignore end*/
      .
      /*istanbul ignore start*/
      removeSuffix)
      /*istanbul ignore end*/
      (deletion.value, commonWsSuffix);
      insertion.value =
      /*istanbul ignore start*/
      (0,
      /*istanbul ignore end*/
      /*istanbul ignore start*/
      _string
      /*istanbul ignore end*/
      .
      /*istanbul ignore start*/
      removeSuffix)
      /*istanbul ignore end*/
      (insertion.value, commonWsSuffix);
    }
  } else if (insertion) {
    // The whitespaces all reflect what was in the new text rather than
    // the old, so we essentially have no information about whitespace
    // insertion or deletion. We just want to dedupe the whitespace.
    // We do that by having each change object keep its trailing
    // whitespace and deleting duplicate leading whitespace where
    // present.
    if (startKeep) {
      insertion.value = insertion.value.replace(/^\s*/, '');
    }
    if (endKeep) {
      endKeep.value = endKeep.value.replace(/^\s*/, '');
    }
    // otherwise we've got a deletion and no insertion
  } else if (startKeep && endKeep) {
    var newWsFull = endKeep.value.match(/^\s*/)[0],
      delWsStart = deletion.value.match(/^\s*/)[0],
      delWsEnd = deletion.value.match(/\s*$/)[0];

    // Any whitespace that comes straight after startKeep in both the old and
    // new texts, assign to startKeep and remove from the deletion.
    var newWsStart =
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/
    /*istanbul ignore start*/
    _string
    /*istanbul ignore end*/
    .
    /*istanbul ignore start*/
    longestCommonPrefix)
    /*istanbul ignore end*/
    (newWsFull, delWsStart);
    deletion.value =
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/
    /*istanbul ignore start*/
    _string
    /*istanbul ignore end*/
    .
    /*istanbul ignore start*/
    removePrefix)
    /*istanbul ignore end*/
    (deletion.value, newWsStart);

    // Any whitespace that comes straight before endKeep in both the old and
    // new texts, and hasn't already been assigned to startKeep, assign to
    // endKeep and remove from the deletion.
    var newWsEnd =
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/
    /*istanbul ignore start*/
    _string
    /*istanbul ignore end*/
    .
    /*istanbul ignore start*/
    longestCommonSuffix)
    /*istanbul ignore end*/
    (
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/
    /*istanbul ignore start*/
    _string
    /*istanbul ignore end*/
    .
    /*istanbul ignore start*/
    removePrefix)
    /*istanbul ignore end*/
    (newWsFull, newWsStart), delWsEnd);
    deletion.value =
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/
    /*istanbul ignore start*/
    _string
    /*istanbul ignore end*/
    .
    /*istanbul ignore start*/
    removeSuffix)
    /*istanbul ignore end*/
    (deletion.value, newWsEnd);
    endKeep.value =
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/
    /*istanbul ignore start*/
    _string
    /*istanbul ignore end*/
    .
    /*istanbul ignore start*/
    replacePrefix)
    /*istanbul ignore end*/
    (endKeep.value, newWsFull, newWsEnd);

    // If there's any whitespace from the new text that HASN'T already been
    // assigned, assign it to the start:
    startKeep.value =
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/
    /*istanbul ignore start*/
    _string
    /*istanbul ignore end*/
    .
    /*istanbul ignore start*/
    replaceSuffix)
    /*istanbul ignore end*/
    (startKeep.value, newWsFull, newWsFull.slice(0, newWsFull.length - newWsEnd.length));
  } else if (endKeep) {
    // We are at the start of the text. Preserve all the whitespace on
    // endKeep, and just remove whitespace from the end of deletion to the
    // extent that it overlaps with the start of endKeep.
    var endKeepWsPrefix = endKeep.value.match(/^\s*/)[0];
    var deletionWsSuffix = deletion.value.match(/\s*$/)[0];
    var overlap =
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/
    /*istanbul ignore start*/
    _string
    /*istanbul ignore end*/
    .
    /*istanbul ignore start*/
    maximumOverlap)
    /*istanbul ignore end*/
    (deletionWsSuffix, endKeepWsPrefix);
    deletion.value =
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/
    /*istanbul ignore start*/
    _string
    /*istanbul ignore end*/
    .
    /*istanbul ignore start*/
    removeSuffix)
    /*istanbul ignore end*/
    (deletion.value, overlap);
  } else if (startKeep) {
    // We are at the END of the text. Preserve all the whitespace on
    // startKeep, and just remove whitespace from the start of deletion to
    // the extent that it overlaps with the end of startKeep.
    var startKeepWsSuffix = startKeep.value.match(/\s*$/)[0];
    var deletionWsPrefix = deletion.value.match(/^\s*/)[0];
    var _overlap =
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/
    /*istanbul ignore start*/
    _string
    /*istanbul ignore end*/
    .
    /*istanbul ignore start*/
    maximumOverlap)
    /*istanbul ignore end*/
    (startKeepWsSuffix, deletionWsPrefix);
    deletion.value =
    /*istanbul ignore start*/
    (0,
    /*istanbul ignore end*/
    /*istanbul ignore start*/
    _string
    /*istanbul ignore end*/
    .
    /*istanbul ignore start*/
    removePrefix)
    /*istanbul ignore end*/
    (deletion.value, _overlap);
  }
}
var wordWithSpaceDiff =
/*istanbul ignore start*/
exports.wordWithSpaceDiff =
/*istanbul ignore end*/
new
/*istanbul ignore start*/
_base
/*istanbul ignore end*/
[
/*istanbul ignore start*/
"default"
/*istanbul ignore end*/
]();
wordWithSpaceDiff.tokenize = function (value) {
  // Slightly different to the tokenizeIncludingWhitespace regex used above in
  // that this one treats each individual newline as a distinct tokens, rather
  // than merging them into other surrounding whitespace. This was requested
  // in https://github.com/kpdecker/jsdiff/issues/180 &
  //    https://github.com/kpdecker/jsdiff/issues/211
  var regex = new RegExp(
  /*istanbul ignore start*/
  "(\\r?\\n)|[".concat(
  /*istanbul ignore end*/
  extendedWordChars, "]+|[^\\S\\n\\r]+|[^").concat(extendedWordChars, "]"), 'ug');
  return value.match(regex) || [];
};
function diffWordsWithSpace(oldStr, newStr, options) {
  return wordWithSpaceDiff.diff(oldStr, newStr, options);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfYmFzZSIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX3N0cmluZyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJleHRlbmRlZFdvcmRDaGFycyIsInRva2VuaXplSW5jbHVkaW5nV2hpdGVzcGFjZSIsIlJlZ0V4cCIsImNvbmNhdCIsIndvcmREaWZmIiwiZXhwb3J0cyIsIkRpZmYiLCJlcXVhbHMiLCJsZWZ0IiwicmlnaHQiLCJvcHRpb25zIiwiaWdub3JlQ2FzZSIsInRvTG93ZXJDYXNlIiwidHJpbSIsInRva2VuaXplIiwidmFsdWUiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJwYXJ0cyIsImludGxTZWdtZW50ZXIiLCJyZXNvbHZlZE9wdGlvbnMiLCJncmFudWxhcml0eSIsIkVycm9yIiwiQXJyYXkiLCJmcm9tIiwic2VnbWVudCIsIm1hdGNoIiwidG9rZW5zIiwicHJldlBhcnQiLCJmb3JFYWNoIiwicGFydCIsInRlc3QiLCJwdXNoIiwicG9wIiwiam9pbiIsIm1hcCIsInRva2VuIiwiaSIsInJlcGxhY2UiLCJwb3N0UHJvY2VzcyIsImNoYW5nZXMiLCJvbmVDaGFuZ2VQZXJUb2tlbiIsImxhc3RLZWVwIiwiaW5zZXJ0aW9uIiwiZGVsZXRpb24iLCJjaGFuZ2UiLCJhZGRlZCIsInJlbW92ZWQiLCJkZWR1cGVXaGl0ZXNwYWNlSW5DaGFuZ2VPYmplY3RzIiwiZGlmZldvcmRzIiwib2xkU3RyIiwibmV3U3RyIiwiaWdub3JlV2hpdGVzcGFjZSIsImRpZmZXb3Jkc1dpdGhTcGFjZSIsImRpZmYiLCJzdGFydEtlZXAiLCJlbmRLZWVwIiwib2xkV3NQcmVmaXgiLCJvbGRXc1N1ZmZpeCIsIm5ld1dzUHJlZml4IiwibmV3V3NTdWZmaXgiLCJjb21tb25Xc1ByZWZpeCIsImxvbmdlc3RDb21tb25QcmVmaXgiLCJyZXBsYWNlU3VmZml4IiwicmVtb3ZlUHJlZml4IiwiY29tbW9uV3NTdWZmaXgiLCJsb25nZXN0Q29tbW9uU3VmZml4IiwicmVwbGFjZVByZWZpeCIsInJlbW92ZVN1ZmZpeCIsIm5ld1dzRnVsbCIsImRlbFdzU3RhcnQiLCJkZWxXc0VuZCIsIm5ld1dzU3RhcnQiLCJuZXdXc0VuZCIsInNsaWNlIiwiZW5kS2VlcFdzUHJlZml4IiwiZGVsZXRpb25Xc1N1ZmZpeCIsIm92ZXJsYXAiLCJtYXhpbXVtT3ZlcmxhcCIsInN0YXJ0S2VlcFdzU3VmZml4IiwiZGVsZXRpb25Xc1ByZWZpeCIsIndvcmRXaXRoU3BhY2VEaWZmIiwicmVnZXgiXSwic291cmNlcyI6WyIuLi8uLi9zcmMvZGlmZi93b3JkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEaWZmIGZyb20gJy4vYmFzZSc7XG5pbXBvcnQgeyBsb25nZXN0Q29tbW9uUHJlZml4LCBsb25nZXN0Q29tbW9uU3VmZml4LCByZXBsYWNlUHJlZml4LCByZXBsYWNlU3VmZml4LCByZW1vdmVQcmVmaXgsIHJlbW92ZVN1ZmZpeCwgbWF4aW11bU92ZXJsYXAgfSBmcm9tICcuLi91dGlsL3N0cmluZyc7XG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluX3NjcmlwdF9pbl9Vbmljb2RlXG4vL1xuLy8gUmFuZ2VzIGFuZCBleGNlcHRpb25zOlxuLy8gTGF0aW4tMSBTdXBwbGVtZW50LCAwMDgw4oCTMDBGRlxuLy8gIC0gVSswMEQ3ICDDlyBNdWx0aXBsaWNhdGlvbiBzaWduXG4vLyAgLSBVKzAwRjcgIMO3IERpdmlzaW9uIHNpZ25cbi8vIExhdGluIEV4dGVuZGVkLUEsIDAxMDDigJMwMTdGXG4vLyBMYXRpbiBFeHRlbmRlZC1CLCAwMTgw4oCTMDI0RlxuLy8gSVBBIEV4dGVuc2lvbnMsIDAyNTDigJMwMkFGXG4vLyBTcGFjaW5nIE1vZGlmaWVyIExldHRlcnMsIDAyQjDigJMwMkZGXG4vLyAgLSBVKzAyQzcgIMuHICYjNzExOyAgQ2Fyb25cbi8vICAtIFUrMDJEOCAgy5ggJiM3Mjg7ICBCcmV2ZVxuLy8gIC0gVSswMkQ5ICDLmSAmIzcyOTsgIERvdCBBYm92ZVxuLy8gIC0gVSswMkRBICDLmiAmIzczMDsgIFJpbmcgQWJvdmVcbi8vICAtIFUrMDJEQiAgy5sgJiM3MzE7ICBPZ29uZWtcbi8vICAtIFUrMDJEQyAgy5wgJiM3MzI7ICBTbWFsbCBUaWxkZVxuLy8gIC0gVSswMkREICDLnSAmIzczMzsgIERvdWJsZSBBY3V0ZSBBY2NlbnRcbi8vIExhdGluIEV4dGVuZGVkIEFkZGl0aW9uYWwsIDFFMDDigJMxRUZGXG5jb25zdCBleHRlbmRlZFdvcmRDaGFycyA9ICdhLXpBLVpcXFxcdXtDMH0tXFxcXHV7RkZ9XFxcXHV7RDh9LVxcXFx1e0Y2fVxcXFx1e0Y4fS1cXFxcdXsyQzZ9XFxcXHV7MkM4fS1cXFxcdXsyRDd9XFxcXHV7MkRFfS1cXFxcdXsyRkZ9XFxcXHV7MUUwMH0tXFxcXHV7MUVGRn0nO1xuXG4vLyBFYWNoIHRva2VuIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuLy8gLSBBIHB1bmN0dWF0aW9uIG1hcmsgcGx1cyB0aGUgc3Vycm91bmRpbmcgd2hpdGVzcGFjZVxuLy8gLSBBIHdvcmQgcGx1cyB0aGUgc3Vycm91bmRpbmcgd2hpdGVzcGFjZVxuLy8gLSBQdXJlIHdoaXRlc3BhY2UgKGJ1dCBvbmx5IGluIHRoZSBzcGVjaWFsIGNhc2Ugd2hlcmUgdGhpcyB0aGUgZW50aXJlIHRleHRcbi8vICAgaXMganVzdCB3aGl0ZXNwYWNlKVxuLy9cbi8vIFdlIGhhdmUgdG8gaW5jbHVkZSBzdXJyb3VuZGluZyB3aGl0ZXNwYWNlIGluIHRoZSB0b2tlbnMgYmVjYXVzZSB0aGUgdHdvXG4vLyBhbHRlcm5hdGl2ZSBhcHByb2FjaGVzIHByb2R1Y2UgaG9ycmlibHkgYnJva2VuIHJlc3VsdHM6XG4vLyAqIElmIHdlIGp1c3QgZGlzY2FyZCB0aGUgd2hpdGVzcGFjZSwgd2UgY2FuJ3QgZnVsbHkgcmVwcm9kdWNlIHRoZSBvcmlnaW5hbFxuLy8gICB0ZXh0IGZyb20gdGhlIHNlcXVlbmNlIG9mIHRva2VucyBhbmQgYW55IGF0dGVtcHQgdG8gcmVuZGVyIHRoZSBkaWZmIHdpbGxcbi8vICAgZ2V0IHRoZSB3aGl0ZXNwYWNlIHdyb25nLlxuLy8gKiBJZiB3ZSBoYXZlIHNlcGFyYXRlIHRva2VucyBmb3Igd2hpdGVzcGFjZSwgdGhlbiBpbiBhIHR5cGljYWwgdGV4dCBldmVyeVxuLy8gICBzZWNvbmQgdG9rZW4gd2lsbCBiZSBhIHNpbmdsZSBzcGFjZSBjaGFyYWN0ZXIuIEJ1dCB0aGlzIG9mdGVuIHJlc3VsdHMgaW5cbi8vICAgdGhlIG9wdGltYWwgZGlmZiBiZXR3ZWVuIHR3byB0ZXh0cyBiZWluZyBhIHBlcnZlcnNlIG9uZSB0aGF0IHByZXNlcnZlc1xuLy8gICB0aGUgc3BhY2VzIGJldHdlZW4gd29yZHMgYnV0IGRlbGV0ZXMgYW5kIHJlaW5zZXJ0cyBhY3R1YWwgY29tbW9uIHdvcmRzLlxuLy8gICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2twZGVja2VyL2pzZGlmZi9pc3N1ZXMvMTYwI2lzc3VlY29tbWVudC0xODY2MDk5NjQwXG4vLyAgIGZvciBhbiBleGFtcGxlLlxuLy9cbi8vIEtlZXBpbmcgdGhlIHN1cnJvdW5kaW5nIHdoaXRlc3BhY2Ugb2YgY291cnNlIGhhcyBpbXBsaWNhdGlvbnMgZm9yIC5lcXVhbHNcbi8vIGFuZCAuam9pbiwgbm90IGp1c3QgLnRva2VuaXplLlxuXG4vLyBUaGlzIHJlZ2V4IGRvZXMgTk9UIGZ1bGx5IGltcGxlbWVudCB0aGUgdG9rZW5pemF0aW9uIHJ1bGVzIGRlc2NyaWJlZCBhYm92ZS5cbi8vIEluc3RlYWQsIGl0IGdpdmVzIHJ1bnMgb2Ygd2hpdGVzcGFjZSB0aGVpciBvd24gXCJ0b2tlblwiLiBUaGUgdG9rZW5pemUgbWV0aG9kXG4vLyB0aGVuIGhhbmRsZXMgc3RpdGNoaW5nIHdoaXRlc3BhY2UgdG9rZW5zIG9udG8gYWRqYWNlbnQgd29yZCBvciBwdW5jdHVhdGlvblxuLy8gdG9rZW5zLlxuY29uc3QgdG9rZW5pemVJbmNsdWRpbmdXaGl0ZXNwYWNlID0gbmV3IFJlZ0V4cChgWyR7ZXh0ZW5kZWRXb3JkQ2hhcnN9XSt8XFxcXHMrfFteJHtleHRlbmRlZFdvcmRDaGFyc31dYCwgJ3VnJyk7XG5cbmV4cG9ydCBjb25zdCB3b3JkRGlmZiA9IG5ldyBEaWZmKCk7XG53b3JkRGlmZi5lcXVhbHMgPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5pZ25vcmVDYXNlKSB7XG4gICAgbGVmdCA9IGxlZnQudG9Mb3dlckNhc2UoKTtcbiAgICByaWdodCA9IHJpZ2h0LnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICByZXR1cm4gbGVmdC50cmltKCkgPT09IHJpZ2h0LnRyaW0oKTtcbn07XG5cbndvcmREaWZmLnRva2VuaXplID0gZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgcGFydHM7XG4gIGlmIChvcHRpb25zLmludGxTZWdtZW50ZXIpIHtcbiAgICBpZiAob3B0aW9ucy5pbnRsU2VnbWVudGVyLnJlc29sdmVkT3B0aW9ucygpLmdyYW51bGFyaXR5ICE9ICd3b3JkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2VnbWVudGVyIHBhc3NlZCBtdXN0IGhhdmUgYSBncmFudWxhcml0eSBvZiBcIndvcmRcIicpO1xuICAgIH1cbiAgICBwYXJ0cyA9IEFycmF5LmZyb20ob3B0aW9ucy5pbnRsU2VnbWVudGVyLnNlZ21lbnQodmFsdWUpLCBzZWdtZW50ID0+IHNlZ21lbnQuc2VnbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgcGFydHMgPSB2YWx1ZS5tYXRjaCh0b2tlbml6ZUluY2x1ZGluZ1doaXRlc3BhY2UpIHx8IFtdO1xuICB9XG4gIGNvbnN0IHRva2VucyA9IFtdO1xuICBsZXQgcHJldlBhcnQgPSBudWxsO1xuICBwYXJ0cy5mb3JFYWNoKHBhcnQgPT4ge1xuICAgIGlmICgoL1xccy8pLnRlc3QocGFydCkpIHtcbiAgICAgIGlmIChwcmV2UGFydCA9PSBudWxsKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHBhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW5zLnBvcCgpICsgcGFydCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoL1xccy8pLnRlc3QocHJldlBhcnQpKSB7XG4gICAgICBpZiAodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSA9PSBwcmV2UGFydCkge1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbnMucG9wKCkgKyBwYXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHByZXZQYXJ0ICsgcGFydCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRva2Vucy5wdXNoKHBhcnQpO1xuICAgIH1cblxuICAgIHByZXZQYXJ0ID0gcGFydDtcbiAgfSk7XG4gIHJldHVybiB0b2tlbnM7XG59O1xuXG53b3JkRGlmZi5qb2luID0gZnVuY3Rpb24odG9rZW5zKSB7XG4gIC8vIFRva2VucyBiZWluZyBqb2luZWQgaGVyZSB3aWxsIGFsd2F5cyBoYXZlIGFwcGVhcmVkIGNvbnNlY3V0aXZlbHkgaW4gdGhlXG4gIC8vIHNhbWUgdGV4dCwgc28gd2UgY2FuIHNpbXBseSBzdHJpcCBvZmYgdGhlIGxlYWRpbmcgd2hpdGVzcGFjZSBmcm9tIGFsbCB0aGVcbiAgLy8gdG9rZW5zIGV4Y2VwdCB0aGUgZmlyc3QgKGFuZCBleGNlcHQgYW55IHdoaXRlc3BhY2Utb25seSB0b2tlbnMgLSBidXQgc3VjaFxuICAvLyBhIHRva2VuIHdpbGwgYWx3YXlzIGJlIHRoZSBmaXJzdCBhbmQgb25seSB0b2tlbiBhbnl3YXkpIGFuZCB0aGVuIGpvaW4gdGhlbVxuICAvLyBhbmQgdGhlIHdoaXRlc3BhY2UgYXJvdW5kIHdvcmRzIGFuZCBwdW5jdHVhdGlvbiB3aWxsIGVuZCB1cCBjb3JyZWN0LlxuICByZXR1cm4gdG9rZW5zLm1hcCgodG9rZW4sIGkpID0+IHtcbiAgICBpZiAoaSA9PSAwKSB7XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0b2tlbi5yZXBsYWNlKCgvXlxccysvKSwgJycpO1xuICAgIH1cbiAgfSkuam9pbignJyk7XG59O1xuXG53b3JkRGlmZi5wb3N0UHJvY2VzcyA9IGZ1bmN0aW9uKGNoYW5nZXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFjaGFuZ2VzIHx8IG9wdGlvbnMub25lQ2hhbmdlUGVyVG9rZW4pIHtcbiAgICByZXR1cm4gY2hhbmdlcztcbiAgfVxuXG4gIGxldCBsYXN0S2VlcCA9IG51bGw7XG4gIC8vIENoYW5nZSBvYmplY3RzIHJlcHJlc2VudGluZyBhbnkgaW5zZXJ0aW9uIG9yIGRlbGV0aW9uIHNpbmNlIHRoZSBsYXN0XG4gIC8vIFwia2VlcFwiIGNoYW5nZSBvYmplY3QuIFRoZXJlIGNhbiBiZSBhdCBtb3N0IG9uZSBvZiBlYWNoLlxuICBsZXQgaW5zZXJ0aW9uID0gbnVsbDtcbiAgbGV0IGRlbGV0aW9uID0gbnVsbDtcbiAgY2hhbmdlcy5mb3JFYWNoKGNoYW5nZSA9PiB7XG4gICAgaWYgKGNoYW5nZS5hZGRlZCkge1xuICAgICAgaW5zZXJ0aW9uID0gY2hhbmdlO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcbiAgICAgIGRlbGV0aW9uID0gY2hhbmdlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW5zZXJ0aW9uIHx8IGRlbGV0aW9uKSB7IC8vIE1heSBiZSBmYWxzZSBhdCBzdGFydCBvZiB0ZXh0XG4gICAgICAgIGRlZHVwZVdoaXRlc3BhY2VJbkNoYW5nZU9iamVjdHMobGFzdEtlZXAsIGRlbGV0aW9uLCBpbnNlcnRpb24sIGNoYW5nZSk7XG4gICAgICB9XG4gICAgICBsYXN0S2VlcCA9IGNoYW5nZTtcbiAgICAgIGluc2VydGlvbiA9IG51bGw7XG4gICAgICBkZWxldGlvbiA9IG51bGw7XG4gICAgfVxuICB9KTtcbiAgaWYgKGluc2VydGlvbiB8fCBkZWxldGlvbikge1xuICAgIGRlZHVwZVdoaXRlc3BhY2VJbkNoYW5nZU9iamVjdHMobGFzdEtlZXAsIGRlbGV0aW9uLCBpbnNlcnRpb24sIG51bGwpO1xuICB9XG4gIHJldHVybiBjaGFuZ2VzO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZXb3JkcyhvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykge1xuICAvLyBUaGlzIG9wdGlvbiBoYXMgbmV2ZXIgYmVlbiBkb2N1bWVudGVkIGFuZCBuZXZlciB3aWxsIGJlIChpdCdzIGNsZWFyZXIgdG9cbiAgLy8ganVzdCBjYWxsIGBkaWZmV29yZHNXaXRoU3BhY2VgIGRpcmVjdGx5IGlmIHlvdSBuZWVkIHRoYXQgYmVoYXZpb3IpLCBidXRcbiAgLy8gaGFzIGV4aXN0ZWQgaW4ganNkaWZmIGZvciBhIGxvbmcgdGltZSwgc28gd2UgcmV0YWluIHN1cHBvcnQgZm9yIGl0IGhlcmVcbiAgLy8gZm9yIHRoZSBzYWtlIG9mIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBpZiAob3B0aW9ucz8uaWdub3JlV2hpdGVzcGFjZSAhPSBudWxsICYmICFvcHRpb25zLmlnbm9yZVdoaXRlc3BhY2UpIHtcbiAgICByZXR1cm4gZGlmZldvcmRzV2l0aFNwYWNlKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB3b3JkRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gZGVkdXBlV2hpdGVzcGFjZUluQ2hhbmdlT2JqZWN0cyhzdGFydEtlZXAsIGRlbGV0aW9uLCBpbnNlcnRpb24sIGVuZEtlZXApIHtcbiAgLy8gQmVmb3JlIHJldHVybmluZywgd2UgdGlkeSB1cCB0aGUgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSBvZiB0aGVcbiAgLy8gY2hhbmdlIG9iamVjdHMgdG8gZWxpbWluYXRlIGNhc2VzIHdoZXJlIHRyYWlsaW5nIHdoaXRlc3BhY2UgaW4gb25lIG9iamVjdFxuICAvLyBpcyByZXBlYXRlZCBhcyBsZWFkaW5nIHdoaXRlc3BhY2UgaW4gdGhlIG5leHQuXG4gIC8vIEJlbG93IGFyZSBleGFtcGxlcyBvZiB0aGUgb3V0Y29tZXMgd2Ugd2FudCBoZXJlIHRvIGV4cGxhaW4gdGhlIGNvZGUuXG4gIC8vIEk9aW5zZXJ0LCBLPWtlZXAsIEQ9ZGVsZXRlXG4gIC8vIDEuIGRpZmZpbmcgJ2ZvbyBiYXIgYmF6JyB2cyAnZm9vIGJheidcbiAgLy8gICAgUHJpb3IgdG8gY2xlYW51cCwgd2UgaGF2ZSBLOidmb28gJyBEOicgYmFyICcgSzonIGJheidcbiAgLy8gICAgQWZ0ZXIgY2xlYW51cCwgd2Ugd2FudDogICBLOidmb28gJyBEOidiYXIgJyBLOidiYXonXG4gIC8vXG4gIC8vIDIuIERpZmZpbmcgJ2ZvbyBiYXIgYmF6JyB2cyAnZm9vIHF1eCBiYXonXG4gIC8vICAgIFByaW9yIHRvIGNsZWFudXAsIHdlIGhhdmUgSzonZm9vICcgRDonIGJhciAnIEk6JyBxdXggJyBLOicgYmF6J1xuICAvLyAgICBBZnRlciBjbGVhbnVwLCB3ZSB3YW50IEs6J2ZvbyAnIEQ6J2JhcicgSToncXV4JyBLOicgYmF6J1xuICAvL1xuICAvLyAzLiBEaWZmaW5nICdmb29cXG5iYXIgYmF6JyB2cyAnZm9vIGJheidcbiAgLy8gICAgUHJpb3IgdG8gY2xlYW51cCwgd2UgaGF2ZSBLOidmb28gJyBEOidcXG5iYXIgJyBLOicgYmF6J1xuICAvLyAgICBBZnRlciBjbGVhbnVwLCB3ZSB3YW50IEsnZm9vJyBEOidcXG5iYXInIEs6JyBiYXonXG4gIC8vXG4gIC8vIDQuIERpZmZpbmcgJ2ZvbyBiYXonIHZzICdmb29cXG5iYXIgYmF6J1xuICAvLyAgICBQcmlvciB0byBjbGVhbnVwLCB3ZSBoYXZlIEs6J2Zvb1xcbicgSTonXFxuYmFyICcgSzonIGJheidcbiAgLy8gICAgQWZ0ZXIgY2xlYW51cCwgd2UgaWRlYWxseSB3YW50IEsnZm9vJyBJOidcXG5iYXInIEs6JyBiYXonXG4gIC8vICAgIGJ1dCBkb24ndCBhY3R1YWxseSBtYW5hZ2UgdGhpcyBjdXJyZW50bHkgKHRoZSBwcmUtY2xlYW51cCBjaGFuZ2VcbiAgLy8gICAgb2JqZWN0cyBkb24ndCBjb250YWluIGVub3VnaCBpbmZvcm1hdGlvbiB0byBtYWtlIGl0IHBvc3NpYmxlKS5cbiAgLy9cbiAgLy8gNS4gRGlmZmluZyAnZm9vICAgYmFyIGJheicgdnMgJ2ZvbyAgYmF6J1xuICAvLyAgICBQcmlvciB0byBjbGVhbnVwLCB3ZSBoYXZlIEs6J2ZvbyAgJyBEOicgICBiYXIgJyBLOicgIGJheidcbiAgLy8gICAgQWZ0ZXIgY2xlYW51cCwgd2Ugd2FudCBLOidmb28gICcgRDonIGJhciAnIEs6J2JheidcbiAgLy9cbiAgLy8gT3VyIGhhbmRsaW5nIGlzIHVuYXZvaWRhYmx5IGltcGVyZmVjdCBpbiB0aGUgY2FzZSB3aGVyZSB0aGVyZSdzIGEgc2luZ2xlXG4gIC8vIGluZGVsIGJldHdlZW4ga2VlcHMgYW5kIHRoZSB3aGl0ZXNwYWNlIGhhcyBjaGFuZ2VkLiBGb3IgaW5zdGFuY2UsIGNvbnNpZGVyXG4gIC8vIGRpZmZpbmcgJ2Zvb1xcdGJhclxcbmJheicgdnMgJ2ZvbyBiYXonLiBVbmxlc3Mgd2UgY3JlYXRlIGFuIGV4dHJhIGNoYW5nZVxuICAvLyBvYmplY3QgdG8gcmVwcmVzZW50IHRoZSBpbnNlcnRpb24gb2YgdGhlIHNwYWNlIGNoYXJhY3RlciAod2hpY2ggaXNuJ3QgZXZlblxuICAvLyBhIHRva2VuKSwgd2UgaGF2ZSBubyB3YXkgdG8gYXZvaWQgbG9zaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0ZXh0cydcbiAgLy8gb3JpZ2luYWwgd2hpdGVzcGFjZSBpbiB0aGUgcmVzdWx0IHdlIHJldHVybi4gU3RpbGwsIHdlIGRvIG91ciBiZXN0IHRvXG4gIC8vIG91dHB1dCBzb21ldGhpbmcgdGhhdCB3aWxsIGxvb2sgc2Vuc2libGUgaWYgd2UgZS5nLiBwcmludCBpdCB3aXRoXG4gIC8vIGluc2VydGlvbnMgaW4gZ3JlZW4gYW5kIGRlbGV0aW9ucyBpbiByZWQuXG5cbiAgLy8gQmV0d2VlbiB0d28gXCJrZWVwXCIgY2hhbmdlIG9iamVjdHMgKG9yIGJlZm9yZSB0aGUgZmlyc3Qgb3IgYWZ0ZXIgdGhlIGxhc3RcbiAgLy8gY2hhbmdlIG9iamVjdCksIHdlIGNhbiBoYXZlIGVpdGhlcjpcbiAgLy8gKiBBIFwiZGVsZXRlXCIgZm9sbG93ZWQgYnkgYW4gXCJpbnNlcnRcIlxuICAvLyAqIEp1c3QgYW4gXCJpbnNlcnRcIlxuICAvLyAqIEp1c3QgYSBcImRlbGV0ZVwiXG4gIC8vIFdlIGhhbmRsZSB0aGUgdGhyZWUgY2FzZXMgc2VwYXJhdGVseS5cbiAgaWYgKGRlbGV0aW9uICYmIGluc2VydGlvbikge1xuICAgIGNvbnN0IG9sZFdzUHJlZml4ID0gZGVsZXRpb24udmFsdWUubWF0Y2goL15cXHMqLylbMF07XG4gICAgY29uc3Qgb2xkV3NTdWZmaXggPSBkZWxldGlvbi52YWx1ZS5tYXRjaCgvXFxzKiQvKVswXTtcbiAgICBjb25zdCBuZXdXc1ByZWZpeCA9IGluc2VydGlvbi52YWx1ZS5tYXRjaCgvXlxccyovKVswXTtcbiAgICBjb25zdCBuZXdXc1N1ZmZpeCA9IGluc2VydGlvbi52YWx1ZS5tYXRjaCgvXFxzKiQvKVswXTtcblxuICAgIGlmIChzdGFydEtlZXApIHtcbiAgICAgIGNvbnN0IGNvbW1vbldzUHJlZml4ID0gbG9uZ2VzdENvbW1vblByZWZpeChvbGRXc1ByZWZpeCwgbmV3V3NQcmVmaXgpO1xuICAgICAgc3RhcnRLZWVwLnZhbHVlID0gcmVwbGFjZVN1ZmZpeChzdGFydEtlZXAudmFsdWUsIG5ld1dzUHJlZml4LCBjb21tb25Xc1ByZWZpeCk7XG4gICAgICBkZWxldGlvbi52YWx1ZSA9IHJlbW92ZVByZWZpeChkZWxldGlvbi52YWx1ZSwgY29tbW9uV3NQcmVmaXgpO1xuICAgICAgaW5zZXJ0aW9uLnZhbHVlID0gcmVtb3ZlUHJlZml4KGluc2VydGlvbi52YWx1ZSwgY29tbW9uV3NQcmVmaXgpO1xuICAgIH1cbiAgICBpZiAoZW5kS2VlcCkge1xuICAgICAgY29uc3QgY29tbW9uV3NTdWZmaXggPSBsb25nZXN0Q29tbW9uU3VmZml4KG9sZFdzU3VmZml4LCBuZXdXc1N1ZmZpeCk7XG4gICAgICBlbmRLZWVwLnZhbHVlID0gcmVwbGFjZVByZWZpeChlbmRLZWVwLnZhbHVlLCBuZXdXc1N1ZmZpeCwgY29tbW9uV3NTdWZmaXgpO1xuICAgICAgZGVsZXRpb24udmFsdWUgPSByZW1vdmVTdWZmaXgoZGVsZXRpb24udmFsdWUsIGNvbW1vbldzU3VmZml4KTtcbiAgICAgIGluc2VydGlvbi52YWx1ZSA9IHJlbW92ZVN1ZmZpeChpbnNlcnRpb24udmFsdWUsIGNvbW1vbldzU3VmZml4KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW5zZXJ0aW9uKSB7XG4gICAgLy8gVGhlIHdoaXRlc3BhY2VzIGFsbCByZWZsZWN0IHdoYXQgd2FzIGluIHRoZSBuZXcgdGV4dCByYXRoZXIgdGhhblxuICAgIC8vIHRoZSBvbGQsIHNvIHdlIGVzc2VudGlhbGx5IGhhdmUgbm8gaW5mb3JtYXRpb24gYWJvdXQgd2hpdGVzcGFjZVxuICAgIC8vIGluc2VydGlvbiBvciBkZWxldGlvbi4gV2UganVzdCB3YW50IHRvIGRlZHVwZSB0aGUgd2hpdGVzcGFjZS5cbiAgICAvLyBXZSBkbyB0aGF0IGJ5IGhhdmluZyBlYWNoIGNoYW5nZSBvYmplY3Qga2VlcCBpdHMgdHJhaWxpbmdcbiAgICAvLyB3aGl0ZXNwYWNlIGFuZCBkZWxldGluZyBkdXBsaWNhdGUgbGVhZGluZyB3aGl0ZXNwYWNlIHdoZXJlXG4gICAgLy8gcHJlc2VudC5cbiAgICBpZiAoc3RhcnRLZWVwKSB7XG4gICAgICBpbnNlcnRpb24udmFsdWUgPSBpbnNlcnRpb24udmFsdWUucmVwbGFjZSgvXlxccyovLCAnJyk7XG4gICAgfVxuICAgIGlmIChlbmRLZWVwKSB7XG4gICAgICBlbmRLZWVwLnZhbHVlID0gZW5kS2VlcC52YWx1ZS5yZXBsYWNlKC9eXFxzKi8sICcnKTtcbiAgICB9XG4gIC8vIG90aGVyd2lzZSB3ZSd2ZSBnb3QgYSBkZWxldGlvbiBhbmQgbm8gaW5zZXJ0aW9uXG4gIH0gZWxzZSBpZiAoc3RhcnRLZWVwICYmIGVuZEtlZXApIHtcbiAgICBjb25zdCBuZXdXc0Z1bGwgPSBlbmRLZWVwLnZhbHVlLm1hdGNoKC9eXFxzKi8pWzBdLFxuICAgICAgICBkZWxXc1N0YXJ0ID0gZGVsZXRpb24udmFsdWUubWF0Y2goL15cXHMqLylbMF0sXG4gICAgICAgIGRlbFdzRW5kID0gZGVsZXRpb24udmFsdWUubWF0Y2goL1xccyokLylbMF07XG5cbiAgICAvLyBBbnkgd2hpdGVzcGFjZSB0aGF0IGNvbWVzIHN0cmFpZ2h0IGFmdGVyIHN0YXJ0S2VlcCBpbiBib3RoIHRoZSBvbGQgYW5kXG4gICAgLy8gbmV3IHRleHRzLCBhc3NpZ24gdG8gc3RhcnRLZWVwIGFuZCByZW1vdmUgZnJvbSB0aGUgZGVsZXRpb24uXG4gICAgY29uc3QgbmV3V3NTdGFydCA9IGxvbmdlc3RDb21tb25QcmVmaXgobmV3V3NGdWxsLCBkZWxXc1N0YXJ0KTtcbiAgICBkZWxldGlvbi52YWx1ZSA9IHJlbW92ZVByZWZpeChkZWxldGlvbi52YWx1ZSwgbmV3V3NTdGFydCk7XG5cbiAgICAvLyBBbnkgd2hpdGVzcGFjZSB0aGF0IGNvbWVzIHN0cmFpZ2h0IGJlZm9yZSBlbmRLZWVwIGluIGJvdGggdGhlIG9sZCBhbmRcbiAgICAvLyBuZXcgdGV4dHMsIGFuZCBoYXNuJ3QgYWxyZWFkeSBiZWVuIGFzc2lnbmVkIHRvIHN0YXJ0S2VlcCwgYXNzaWduIHRvXG4gICAgLy8gZW5kS2VlcCBhbmQgcmVtb3ZlIGZyb20gdGhlIGRlbGV0aW9uLlxuICAgIGNvbnN0IG5ld1dzRW5kID0gbG9uZ2VzdENvbW1vblN1ZmZpeChcbiAgICAgIHJlbW92ZVByZWZpeChuZXdXc0Z1bGwsIG5ld1dzU3RhcnQpLFxuICAgICAgZGVsV3NFbmRcbiAgICApO1xuICAgIGRlbGV0aW9uLnZhbHVlID0gcmVtb3ZlU3VmZml4KGRlbGV0aW9uLnZhbHVlLCBuZXdXc0VuZCk7XG4gICAgZW5kS2VlcC52YWx1ZSA9IHJlcGxhY2VQcmVmaXgoZW5kS2VlcC52YWx1ZSwgbmV3V3NGdWxsLCBuZXdXc0VuZCk7XG5cbiAgICAvLyBJZiB0aGVyZSdzIGFueSB3aGl0ZXNwYWNlIGZyb20gdGhlIG5ldyB0ZXh0IHRoYXQgSEFTTidUIGFscmVhZHkgYmVlblxuICAgIC8vIGFzc2lnbmVkLCBhc3NpZ24gaXQgdG8gdGhlIHN0YXJ0OlxuICAgIHN0YXJ0S2VlcC52YWx1ZSA9IHJlcGxhY2VTdWZmaXgoXG4gICAgICBzdGFydEtlZXAudmFsdWUsXG4gICAgICBuZXdXc0Z1bGwsXG4gICAgICBuZXdXc0Z1bGwuc2xpY2UoMCwgbmV3V3NGdWxsLmxlbmd0aCAtIG5ld1dzRW5kLmxlbmd0aClcbiAgICApO1xuICB9IGVsc2UgaWYgKGVuZEtlZXApIHtcbiAgICAvLyBXZSBhcmUgYXQgdGhlIHN0YXJ0IG9mIHRoZSB0ZXh0LiBQcmVzZXJ2ZSBhbGwgdGhlIHdoaXRlc3BhY2Ugb25cbiAgICAvLyBlbmRLZWVwLCBhbmQganVzdCByZW1vdmUgd2hpdGVzcGFjZSBmcm9tIHRoZSBlbmQgb2YgZGVsZXRpb24gdG8gdGhlXG4gICAgLy8gZXh0ZW50IHRoYXQgaXQgb3ZlcmxhcHMgd2l0aCB0aGUgc3RhcnQgb2YgZW5kS2VlcC5cbiAgICBjb25zdCBlbmRLZWVwV3NQcmVmaXggPSBlbmRLZWVwLnZhbHVlLm1hdGNoKC9eXFxzKi8pWzBdO1xuICAgIGNvbnN0IGRlbGV0aW9uV3NTdWZmaXggPSBkZWxldGlvbi52YWx1ZS5tYXRjaCgvXFxzKiQvKVswXTtcbiAgICBjb25zdCBvdmVybGFwID0gbWF4aW11bU92ZXJsYXAoZGVsZXRpb25Xc1N1ZmZpeCwgZW5kS2VlcFdzUHJlZml4KTtcbiAgICBkZWxldGlvbi52YWx1ZSA9IHJlbW92ZVN1ZmZpeChkZWxldGlvbi52YWx1ZSwgb3ZlcmxhcCk7XG4gIH0gZWxzZSBpZiAoc3RhcnRLZWVwKSB7XG4gICAgLy8gV2UgYXJlIGF0IHRoZSBFTkQgb2YgdGhlIHRleHQuIFByZXNlcnZlIGFsbCB0aGUgd2hpdGVzcGFjZSBvblxuICAgIC8vIHN0YXJ0S2VlcCwgYW5kIGp1c3QgcmVtb3ZlIHdoaXRlc3BhY2UgZnJvbSB0aGUgc3RhcnQgb2YgZGVsZXRpb24gdG9cbiAgICAvLyB0aGUgZXh0ZW50IHRoYXQgaXQgb3ZlcmxhcHMgd2l0aCB0aGUgZW5kIG9mIHN0YXJ0S2VlcC5cbiAgICBjb25zdCBzdGFydEtlZXBXc1N1ZmZpeCA9IHN0YXJ0S2VlcC52YWx1ZS5tYXRjaCgvXFxzKiQvKVswXTtcbiAgICBjb25zdCBkZWxldGlvbldzUHJlZml4ID0gZGVsZXRpb24udmFsdWUubWF0Y2goL15cXHMqLylbMF07XG4gICAgY29uc3Qgb3ZlcmxhcCA9IG1heGltdW1PdmVybGFwKHN0YXJ0S2VlcFdzU3VmZml4LCBkZWxldGlvbldzUHJlZml4KTtcbiAgICBkZWxldGlvbi52YWx1ZSA9IHJlbW92ZVByZWZpeChkZWxldGlvbi52YWx1ZSwgb3ZlcmxhcCk7XG4gIH1cbn1cblxuXG5leHBvcnQgY29uc3Qgd29yZFdpdGhTcGFjZURpZmYgPSBuZXcgRGlmZigpO1xud29yZFdpdGhTcGFjZURpZmYudG9rZW5pemUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAvLyBTbGlnaHRseSBkaWZmZXJlbnQgdG8gdGhlIHRva2VuaXplSW5jbHVkaW5nV2hpdGVzcGFjZSByZWdleCB1c2VkIGFib3ZlIGluXG4gIC8vIHRoYXQgdGhpcyBvbmUgdHJlYXRzIGVhY2ggaW5kaXZpZHVhbCBuZXdsaW5lIGFzIGEgZGlzdGluY3QgdG9rZW5zLCByYXRoZXJcbiAgLy8gdGhhbiBtZXJnaW5nIHRoZW0gaW50byBvdGhlciBzdXJyb3VuZGluZyB3aGl0ZXNwYWNlLiBUaGlzIHdhcyByZXF1ZXN0ZWRcbiAgLy8gaW4gaHR0cHM6Ly9naXRodWIuY29tL2twZGVja2VyL2pzZGlmZi9pc3N1ZXMvMTgwICZcbiAgLy8gICAgaHR0cHM6Ly9naXRodWIuY29tL2twZGVja2VyL2pzZGlmZi9pc3N1ZXMvMjExXG4gIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgKFxcXFxyP1xcXFxuKXxbJHtleHRlbmRlZFdvcmRDaGFyc31dK3xbXlxcXFxTXFxcXG5cXFxccl0rfFteJHtleHRlbmRlZFdvcmRDaGFyc31dYCwgJ3VnJyk7XG4gIHJldHVybiB2YWx1ZS5tYXRjaChyZWdleCkgfHwgW107XG59O1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmZXb3Jkc1dpdGhTcGFjZShvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykge1xuICByZXR1cm4gd29yZFdpdGhTcGFjZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUFBLEtBQUEsR0FBQUMsc0JBQUEsQ0FBQUMsT0FBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUFDLE9BQUEsR0FBQUQsT0FBQTtBQUFBO0FBQUE7QUFBb0osbUNBQUFELHVCQUFBRyxHQUFBLFdBQUFBLEdBQUEsSUFBQUEsR0FBQSxDQUFBQyxVQUFBLEdBQUFELEdBQUEsZ0JBQUFBLEdBQUE7QUFBQTtBQUVwSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFNRSxpQkFBaUIsR0FBRywyR0FBMkc7O0FBRXJJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFNQywyQkFBMkIsR0FBRyxJQUFJQyxNQUFNO0FBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUE7QUFBS0gsaUJBQWlCLGdCQUFBRyxNQUFBLENBQWFILGlCQUFpQixRQUFLLElBQUksQ0FBQztBQUVyRyxJQUFNSSxRQUFRO0FBQUE7QUFBQUMsT0FBQSxDQUFBRCxRQUFBO0FBQUE7QUFBRztBQUFJRTtBQUFBQTtBQUFBQTtBQUFBQTtBQUFBQTtBQUFBQTtBQUFBQTtBQUFBQSxDQUFJLENBQUMsQ0FBQztBQUNsQ0YsUUFBUSxDQUFDRyxNQUFNLEdBQUcsVUFBU0MsSUFBSSxFQUFF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
