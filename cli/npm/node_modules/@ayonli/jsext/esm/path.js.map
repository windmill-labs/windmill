{"version":3,"file":"path.js","sources":["../path.ts"],"sourcesContent":["/**\n * Platform-independent utility functions for dealing with file system paths and\n * URLs.\n *\n * The functions in this module are designed to be generic and work in any\n * runtime, whether server-side or browsers. They can be used for both system\n * paths and URLs.\n * @module\n */\nimport { isDeno, isNodeLike } from \"./env.ts\";\nimport { stripEnd, trim } from \"./string.ts\";\nimport { contains, endsWith, equals, isAbsolute, isFileProtocol, isFileUrl, isFsPath, isNotQuery, isPosixPath, isUrl, isVolume, isWindowsPath, split, startsWith, } from \"./path/util.ts\";\nexport { isWindowsPath, isPosixPath, isFsPath, isUrl, isFileUrl, isAbsolute, contains, endsWith, startsWith, equals, split, };\n/**\n * Platform-specific path segment separator. The value is `\\` in Windows\n * server-side environments, and `/` elsewhere.\n */\nexport const sep = (() => {\n    if (isDeno) {\n        if (Deno.build.os === \"windows\") {\n            return \"\\\\\";\n        }\n    }\n    else if (isNodeLike) {\n        if (process.platform === \"win32\") {\n            return \"\\\\\";\n        }\n    }\n    return \"/\";\n})();\n/**\n * Returns the current working directory.\n *\n * **NOTE:** In the browser, this function returns the current origin and pathname.\n *\n * This function may fail in unsupported environments or being rejected by the\n * permission system of the runtime.\n */\nexport function cwd() {\n    if (isDeno) {\n        return Deno.cwd();\n    }\n    else if (isNodeLike) {\n        return process.cwd();\n    }\n    else if (typeof location === \"object\" && location.origin) {\n        return location.origin + (location.pathname === \"/\" ? \"\" : location.pathname);\n    }\n    else {\n        throw new Error(\"Unable to determine the current working directory.\");\n    }\n}\n/**\n * Concatenates all given `segments` into a well-formed path.\n * @experimental\n *\n * @example\n * ```ts\n * import { join } from \"@ayonli/jsext/path\";\n *\n * console.log(join(\"foo\", \"bar\")); // \"foo/bar\" or \"foo\\\\bar\" on Windows\n * console.log(join(\"/\", \"foo\", \"bar\")); // \"/foo/bar\"\n * console.log(join(\"C:\\\\\", \"foo\", \"bar\")); // \"C:\\\\foo\\\\bar\"\n * console.log(join(\"file:///foo\", \"bar\", \"..\")) // \"file:///foo\"\n *\n * console.log(join(\"http://example.com\", \"foo\", \"bar\", \"?query\"));\n * // \"http://example.com/foo/bar?query\"\n * ```\n */\nexport function join(...segments) {\n    let _paths = [];\n    for (let i = 0; i < segments.length; i++) {\n        const path = segments[i];\n        if (path) {\n            if (isAbsolute(path)) {\n                _paths = [];\n            }\n            _paths.push(path);\n        }\n    }\n    const paths = [];\n    for (let i = 0; i < _paths.length; i++) {\n        let segment = _paths[i];\n        for (const _segment of split(segment)) {\n            if (_segment === \"..\") {\n                if (!paths.length || paths.every(p => p === \"..\")) {\n                    paths.push(\"..\");\n                }\n                else if (paths.length > 2\n                    || (paths.length === 2 && !isAbsolute(paths[1]))\n                    || (paths.length === 1 && !isAbsolute(paths[0]))) {\n                    paths.pop();\n                }\n            }\n            else if (_segment && _segment !== \".\") {\n                paths.push(_segment);\n            }\n        }\n    }\n    if (!paths.length) {\n        return \".\";\n    }\n    const start = paths[0];\n    const _sep = isUrl(start) || isPosixPath(start) ? \"/\" : isWindowsPath(start) ? \"\\\\\" : sep;\n    let path = \"\";\n    for (let i = 0; i < paths.length; i++) {\n        const segment = paths[i];\n        if (!path || segment[0] === \"?\" || segment[0] === \"#\") {\n            path += segment;\n        }\n        else if (isVolume(segment)) {\n            if (path) {\n                path += segment + \"/\";\n            }\n            else {\n                path = segment;\n            }\n        }\n        else {\n            path += (path.endsWith(_sep) ? \"\" : _sep) + trim(segment, \"/\\\\\");\n        }\n    }\n    if (/^file:\\/\\/\\/[a-z]:$/i.test(path)) {\n        return path + \"/\";\n    }\n    else {\n        return path;\n    }\n}\n/**\n * This function is similar to Node.js implementation, but does not preserve\n * trailing slashes.\n *\n * Since Node.js implementation is not well-designed and this function is\n * identical as calling `join(path)`, so it is deprecated.\n * @experimental\n *\n * @deprecated use {@link join} or {@link sanitize} instead.\n */\nexport function normalize(path) {\n    return join(path);\n}\n/**\n * Similar to {@link normalize}, but also remove the search string and hash\n * string if present.\n * @experimental\n *\n * @example\n * ```ts\n * import { sanitize } from \"@ayonli/jsext/path\";\n *\n * console.log(sanitize(\"foo/bar?query\")); // \"foo/bar\"\n * console.log(sanitize(\"foo/bar#hash\")); // \"foo/bar\"\n * console.log(sanitize(\"foo/bar/..?query#hash\")); // \"foo\"\n * console.log(sanitize(\"foo/./bar/..?query#hash\")); // \"foo\"\n * ```\n */\nexport function sanitize(path) {\n    return join(...split(path).filter(isNotQuery));\n}\n/**\n * Resolves path `segments` into a well-formed path.\n *\n * This function is similar to {@link join}, except it always returns an\n * absolute path based on the current working directory if the input segments\n * are not absolute by themselves.\n * @experimental\n */\nexport function resolve(...segments) {\n    segments = segments.filter(s => s !== \"\");\n    const _cwd = cwd();\n    if (!segments.length) {\n        return _cwd;\n    }\n    segments = isAbsolute(segments[0]) ? segments : [_cwd, ...segments];\n    return join(...segments);\n}\n/**\n * Returns the parent path of the given `path`.\n * @experimental\n *\n * @example\n * ```ts\n * import { dirname } from \"@ayonli/jsext/path\";\n *\n * console.log(dirname(\"foo/bar\")); // \"foo\"\n * console.log(dirname(\"/foo/bar\")); // \"/foo\"\n * console.log(dirname(\"C:\\\\foo\\\\bar\")); // \"C:\\\\foo\"\n * console.log(dirname(\"file:///foo/bar\")); // \"file:///foo\"\n * console.log(dirname(\"http://example.com/foo/bar\")); // \"http://example.com/foo\"\n * console.log(dirname(\"http://example.com/foo\")); // \"http://example.com\"\n * console.log(dirname(\"http://example.com/foo/bar?foo=bar#baz\")); // \"http://example.com/foo\"\n * ```\n */\nexport function dirname(path) {\n    if (isUrl(path)) {\n        const { protocol, host, pathname } = new URL(path);\n        const origin = protocol + \"//\" + host;\n        const _dirname = dirname(decodeURI(pathname));\n        if (_dirname === \"/\") {\n            return isFileProtocol(origin) ? origin + \"/\" : origin;\n        }\n        else {\n            return origin + _dirname;\n        }\n    }\n    else {\n        const segments = split(path).filter(isNotQuery);\n        const last = segments.pop();\n        if (segments.length) {\n            return join(...segments);\n        }\n        else if (last === \"/\") {\n            return \"/\";\n        }\n        else if (isVolume(last, true)) {\n            return last + \"\\\\\";\n        }\n        else if (isVolume(last)) {\n            return last;\n        }\n        else {\n            return \".\";\n        }\n    }\n}\n/**\n * Return the last portion of the given `path`. Trailing directory separators\n * are ignored, and optional `suffix` is removed.\n * @experimental\n *\n * @example\n * ```ts\n * import { basename } from \"@ayonli/jsext/path\";\n *\n * console.log(basename(\"/foo/bar\")); // \"bar\"\n * console.log(basename(\"c:\\\\foo\\\\bar\")); // \"bar\"\n * console.log(basename(\"file:///foo/bar\")); // \"bar\"\n * console.log(basename(\"http://example.com/foo/bar\")); // \"bar\"\n * console.log(basename(\"http://example.com/foo/bar?foo=bar#baz\")); // \"bar\"\n * console.log(basename(\"http://example.com/foo/bar.txt?foo=bar#baz\", \".txt\")); // \"bar\"\n * ```\n */\nexport function basename(path, suffix = \"\") {\n    if (isUrl(path)) {\n        const { pathname } = new URL(path);\n        return basename(decodeURI(pathname), suffix);\n    }\n    else {\n        const segments = split(path).filter(isNotQuery);\n        const _basename = segments.pop();\n        if (!_basename || _basename === \"/\" || isVolume(_basename)) {\n            return \"\";\n        }\n        else if (suffix) {\n            return stripEnd(_basename, suffix);\n        }\n        else {\n            return _basename;\n        }\n    }\n}\n/**\n * Returns the extension of the `path` with leading period.\n * @experimental\n *\n * @example\n * ```ts\n * import { extname } from \"@ayonli/jsext/path\";\n *\n * console.log(extname(\"/foo/bar.txt\")); // \".txt\"\n * console.log(extname(\"c:\\\\foo\\\\bar.txt\")); // \".txt\"\n * console.log(extname(\"file:///foo/bar.txt\")); // \".txt\"\n * console.log(extname(\"http://example.com/foo/bar.txt\")); // \".txt\"\n * console.log(extname(\"http://example.com/foo/bar.txt?foo=bar#baz\")); // \".txt\"\n * ```\n */\nexport function extname(path) {\n    const base = basename(path);\n    const index = base.lastIndexOf(\".\");\n    if (index === -1) {\n        return \"\";\n    }\n    else {\n        return base.slice(index);\n    }\n}\n/**\n * Converts the given path to a file URL if it's not one already.\n * @experimental\n *\n * @example\n * ```ts\n * import { toFileUrl } from \"@ayonli/jsext/path\";\n *\n * console.log(toFileUrl(\"foo/bar\")); // \"file:///foo/bar\"\n * console.log(toFileUrl(\"c:\\\\foo\\\\bar\")); // \"file:///c:/foo/bar\"\n * ```\n */\nexport function toFileUrl(path) {\n    if (isFileUrl(path)) {\n        return path;\n    }\n    else if (!isUrl(path)) {\n        let _path = resolve(path).replace(/\\\\/g, \"/\");\n        _path = _path[0] === \"/\" ? _path : \"/\" + _path;\n        return new URL(\"file://\" + _path).href;\n    }\n    else {\n        throw new Error(\"Cannot convert a URL to a file URL.\");\n    }\n}\n/**\n * Converts the given URL to a file system path if it's not one already.\n * @experimental\n *\n * @example\n * ```ts\n * import { toFsPath } from \"@ayonli/jsext/path\";\n *\n * console.log(toFsPath(\"file:///foo/bar\")); // \"/foo/bar\"\n * console.log(toFsPath(\"file:///c:/foo/bar\")); // \"c:\\\\foo\\\\bar\"\n * ```\n */\nexport function toFsPath(url) {\n    if (isFsPath(url)) {\n        return url;\n    }\n    else if (isFileUrl(url)) {\n        url = url.replace(/^file:(\\/\\/)?/i, \"\").replace(/^\\/([a-z]):/i, \"$1:\");\n        return join(url);\n    }\n    else if (!isUrl(url)) {\n        return resolve(url);\n    }\n    else {\n        throw new Error(\"Cannot convert a URL to a file system path.\");\n    }\n}\n//# sourceMappingURL=path.js.map"],"names":[],"mappings":"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"}