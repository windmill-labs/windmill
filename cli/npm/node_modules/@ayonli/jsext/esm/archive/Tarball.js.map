{"version":3,"file":"Tarball.js","sources":["../../archive/Tarball.ts"],"sourcesContent":["var _a, _b;\nimport bytes, { concat as concatBytes } from \"../bytes.ts\";\nimport { Exception } from \"../error.ts\";\nimport { makeTree } from \"../fs/util.ts\";\nimport { omit } from \"../object.ts\";\nimport { basename, dirname } from \"../path.ts\";\nimport { concat as concatStreams, toReadableStream } from \"../reader.ts\";\nimport { stripEnd } from \"../string.ts\";\nconst _stream = Symbol.for(\"stream\");\nconst _bodyUsed = Symbol.for(\"bodyUsed\");\nvar FileTypes;\n(function (FileTypes) {\n    FileTypes[FileTypes[\"file\"] = 0] = \"file\";\n    FileTypes[FileTypes[\"link\"] = 1] = \"link\";\n    FileTypes[FileTypes[\"symlink\"] = 2] = \"symlink\";\n    FileTypes[FileTypes[\"character-device\"] = 3] = \"character-device\";\n    FileTypes[FileTypes[\"block-device\"] = 4] = \"block-device\";\n    FileTypes[FileTypes[\"directory\"] = 5] = \"directory\";\n    FileTypes[FileTypes[\"fifo\"] = 6] = \"fifo\";\n    FileTypes[FileTypes[\"contiguous-file\"] = 7] = \"contiguous-file\";\n})(FileTypes || (FileTypes = {}));\nexport const HEADER_LENGTH = 512;\nconst USTAR_MAGIC_HEADER = \"ustar\\x00\";\nconst USTarFileHeaderFieldLengths = {\n    name: 100, // 0\n    mode: 8, // 100\n    uid: 8, // 108\n    gid: 8, // 116\n    size: 12, // 124\n    mtime: 12, // 136\n    checksum: 8, // 148\n    typeflag: 1, // 156\n    linkname: 100, // 157\n    magic: 6, // 257\n    version: 2, // 263\n    uname: 32, // 265\n    gname: 32, // 297\n    devmajor: 8, // 329\n    devminor: 8, // 337\n    prefix: 155, // 345\n    padding: 12, // 500\n};\n// https://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13_06\n// eight checksum bytes taken to be ascii spaces (decimal value 32)\nconst initialChecksum = 8 * 32;\nconst FilenameTooLongError = new Exception(\"UStar format does not allow a long file name (length of [file name\"\n    + \"prefix] + / + [file name] must be shorter than 256 bytes)\", {\n    name: \"FilenameTooLongError\",\n    code: 431\n});\nfunction toFixedOctal(num, bytes) {\n    return num.toString(8).padStart(bytes, \"0\");\n}\nfunction trimBytes(data) {\n    const index = data.indexOf(0);\n    return index === -1 ? data : data.subarray(0, index);\n}\nfunction formatHeader(data) {\n    const buffer = new Uint8Array(HEADER_LENGTH);\n    let offset = 0;\n    for (const [field, length] of Object.entries(USTarFileHeaderFieldLengths)) {\n        const entry = bytes(data[field] || \"\");\n        buffer.set(entry, offset);\n        offset += length;\n    }\n    return buffer;\n}\nexport function parseHeader(header) {\n    const decoder = new TextDecoder();\n    const data = {};\n    let offset = 0;\n    for (const [field, length] of Object.entries(USTarFileHeaderFieldLengths)) {\n        let buffer = header.subarray(offset, offset + length);\n        if (field !== \"magic\") {\n            buffer = trimBytes(buffer);\n        }\n        const value = decoder.decode(buffer).trim();\n        data[field] = value;\n        offset += length;\n    }\n    // validate checksum\n    const checksum = getChecksum(header);\n    if (checksum !== parseInt(data.checksum, 8)) {\n        if (checksum === initialChecksum) {\n            // EOF\n            return null;\n        }\n        throw new Error(\"The archive is corrupted\");\n    }\n    if (!data.magic.startsWith(\"ustar\")) {\n        throw new TypeError(\"Unsupported archive format: \" + data.magic);\n    }\n    return [data, header.subarray(0, offset), header.subarray(offset)];\n}\nfunction getChecksum(header) {\n    let sum = initialChecksum;\n    for (let i = 0; i < HEADER_LENGTH; i++) {\n        if (i >= 148 && i < 156) {\n            // Ignore checksum header\n            continue;\n        }\n        sum += header[i];\n    }\n    return sum;\n}\nexport function createEntry(headerInfo) {\n    var _c;\n    const relativePath = (headerInfo.prefix ? headerInfo.prefix + \"/\" : \"\")\n        + stripEnd(headerInfo.name, \"/\");\n    return {\n        name: basename(relativePath),\n        kind: ((_c = FileTypes[parseInt(headerInfo.typeflag)]) !== null && _c !== void 0 ? _c : \"file\"),\n        relativePath,\n        size: parseInt(headerInfo.size, 8),\n        mtime: new Date(parseInt(headerInfo.mtime, 8) * 1000),\n        mode: parseInt(headerInfo.mode, 8),\n        uid: parseInt(headerInfo.uid, 8),\n        gid: parseInt(headerInfo.gid, 8),\n        owner: headerInfo.uname.trim(),\n        group: headerInfo.gname.trim(),\n    };\n}\nexport const _entries = Symbol.for(\"entries\");\n/**\n * A `Tarball` instance represents a tar archive.\n *\n * @example\n * ```ts\n * // create a tarball\n * import { stat, createReadableStream, createWriteableStream } from \"@ayonli/jsext/fs\";\n * import { Tarball } from \"@ayonli/jsext/archive\";\n *\n * const tarball = new Tarball();\n *\n * const file1 = await stat(\"foo.txt\");\n * const stream1 = createReadableStream(\"foo.txt\");\n * tarball.append(stream1, { relativePath: \"foo.txt\", size: file1.size });\n *\n * const file2 = await stat(\"bar.txt\");\n * const stream2 = createReadableStream(\"bar.txt\");\n * tarball.append(stream2, { relativePath: \"bar.txt\", size: file2.size });\n *\n * const output = createWritableStream(\"archive.tar\");\n * await tarball.stream().pipeTo(output);\n * ```\n *\n * @example\n * ```ts\n * // load a tarball\n * import { createReadableStream } from \"@ayonli/jsext/fs\";\n * import { Tarball } from \"@ayonli/jsext/archive\";\n *\n * const input = createReadableStream(\"archive.tar\");\n * const tarball = await Tarball.load(input);\n *\n * for (const entry of tarball) {\n *     console.log(entry);\n * }\n * ```\n */\nexport default class Tarball {\n    constructor() {\n        this[_a] = [];\n        this[_b] = false;\n        if (typeof ReadableStream === \"undefined\") {\n            throw new TypeError(\"ReadableStream is not supported in this environment\");\n        }\n    }\n    constructEntry(relativePath, data, info) {\n        var _c, _d, _e, _f, _g;\n        // UStar format has a limitation of file name length. Specifically:\n        // \n        // 1. File names can contain at most 255 bytes.\n        // 2. File names longer than 100 bytes must be split at a directory separator in two parts,\n        //   the first being at most 155 bytes long. So, in most cases file names must be a bit shorter\n        //   than 255 bytes.\n        // \n        // So we need to separate file name into two parts if needed.\n        let name = relativePath;\n        let prefix = \"\";\n        if (name.length > 100) {\n            let i = name.length;\n            while (i >= 0) {\n                i = name.lastIndexOf(\"/\", i);\n                if (i <= 155) {\n                    prefix = name.slice(0, i);\n                    name = name.slice(i + 1);\n                    break;\n                }\n                i--;\n            }\n            if (i < 0 || name.length > 100) {\n                throw FilenameTooLongError;\n            }\n            else if (prefix.length > 155) {\n                throw FilenameTooLongError;\n            }\n        }\n        let body;\n        let size = 0;\n        if (typeof data === \"string\") {\n            const _data = bytes(data);\n            body = toReadableStream([_data]);\n            size = _data.byteLength;\n        }\n        else if (data instanceof ArrayBuffer) {\n            body = toReadableStream([new Uint8Array(data)]);\n            size = data.byteLength;\n        }\n        else if (data instanceof Uint8Array) {\n            body = toReadableStream([data]);\n            size = data.byteLength;\n        }\n        else if (ArrayBuffer.isView(data)) {\n            const _data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n            body = toReadableStream([_data]);\n            size = _data.byteLength;\n        }\n        else if (typeof Blob === \"function\" && data instanceof Blob) {\n            body = data.stream();\n            size = data.size;\n        }\n        else if (data instanceof ReadableStream) {\n            body = data;\n            if (info.size != undefined) {\n                size = info.size;\n            }\n            else {\n                throw new TypeError(\"size must be provided for ReadableStream data\");\n            }\n        }\n        else {\n            throw new TypeError(\"data must be a string, Uint8Array, ArrayBuffer, ArrayBufferView, Blob, or ReadableStream\");\n        }\n        const kind = (_c = info.kind) !== null && _c !== void 0 ? _c : \"file\";\n        const mode = (_d = info.mode) !== null && _d !== void 0 ? _d : (kind === \"directory\" ? 0o755 : 0o666);\n        const mtime = (_e = info.mtime) !== null && _e !== void 0 ? _e : new Date();\n        if (kind === \"directory\") {\n            size = 0; // ensure size is 0 for directories\n        }\n        const headerInfo = {\n            name,\n            mode: toFixedOctal(mode, USTarFileHeaderFieldLengths.mode),\n            uid: toFixedOctal((_f = info.uid) !== null && _f !== void 0 ? _f : 0, USTarFileHeaderFieldLengths.uid),\n            gid: toFixedOctal((_g = info.gid) !== null && _g !== void 0 ? _g : 0, USTarFileHeaderFieldLengths.gid),\n            size: toFixedOctal(size, USTarFileHeaderFieldLengths.size),\n            mtime: toFixedOctal(Math.floor((mtime.getTime()) / 1000), USTarFileHeaderFieldLengths.mtime),\n            checksum: \"        \",\n            typeflag: kind in FileTypes ? String(FileTypes[kind]) : \"0\",\n            linkname: kind === \"link\" || kind === \"symlink\" ? name : \"\",\n            magic: USTAR_MAGIC_HEADER,\n            version: \"00\",\n            uname: info.owner || \"\",\n            gname: info.group || \"\",\n            devmajor: \"00000000\",\n            devminor: \"00000000\",\n            prefix,\n        };\n        // calculate the checksum\n        let checksum = 0;\n        const encoder = new TextEncoder();\n        Object.values(headerInfo).forEach((data) => {\n            checksum += encoder.encode(data).reduce((p, c) => p + c, 0);\n        });\n        headerInfo.checksum = toFixedOctal(checksum, USTarFileHeaderFieldLengths.checksum);\n        const header = formatHeader(headerInfo);\n        const fileName = info.name\n            || (typeof File === \"function\" && data instanceof File\n                ? data.name\n                : basename(relativePath));\n        return {\n            name: fileName,\n            kind,\n            relativePath,\n            size,\n            mtime,\n            mode,\n            uid: info.uid || 0,\n            gid: info.gid || 0,\n            owner: info.owner || \"\",\n            group: info.group || \"\",\n            header,\n            body,\n        };\n    }\n    append(data, info = {}) {\n        if (data === null) {\n            if (info.kind === \"directory\") {\n                data = new Uint8Array(0);\n            }\n            else {\n                throw new TypeError(\"data must be provided for files\");\n            }\n        }\n        let relativePath = info.relativePath;\n        if (!relativePath) {\n            if (typeof File === \"function\" && data instanceof File) {\n                relativePath = (data.webkitRelativePath || data.name);\n            }\n            else {\n                throw new TypeError(\"info.relativePath must be provided\");\n            }\n        }\n        const dir = dirname(relativePath).replace(/\\\\/g, \"/\");\n        // If the input path has parent directories that are not in the archive,\n        // we need to add them first.\n        if (dir && dir !== \".\" && !this[_entries].some((entry) => entry.relativePath === dir)) {\n            this.append(null, {\n                kind: \"directory\",\n                relativePath: dir,\n            });\n        }\n        const entry = this.constructEntry(relativePath, data, info);\n        this[_entries].push(entry);\n    }\n    /**\n     * Retrieves an entry in the archive by its relative path.\n     *\n     * The returned entry object contains a `stream` property which is a copy of\n     * the entry's data, and since it's a copy, the data in the archive is still\n     * available even after the `stream` property is consumed.\n     *\n     * However, due to the nature of the `ReadableStream.tee()` API, if the copy\n     * is consumed, the data will be loaded and cached in memory until the\n     * tarball's stream is consumed or dropped. This may cause memory issues for\n     * large files, so it is recommended not to use the `stream` property unless\n     * necessary.\n     */\n    retrieve(relativePath) {\n        const _entry = this[_entries].find((entry) => entry.relativePath === relativePath);\n        if (!_entry) {\n            return null;\n        }\n        const entry = omit(_entry, [\"header\", \"body\"]);\n        Object.defineProperty(entry, \"stream\", {\n            get() {\n                if (entry[_stream]) {\n                    return entry[_stream];\n                }\n                else {\n                    const [copy1, copy2] = _entry.body.tee();\n                    _entry.body = copy1;\n                    return (entry[_stream] = copy2);\n                }\n            },\n        });\n        return entry;\n    }\n    /**\n     * Removes an entry from the archive by its relative path.\n     *\n     * This function returns `true` if the entry is successfully removed, or `false` if the entry\n     * does not exist.\n     */\n    remove(relativePath) {\n        const index = this[_entries].findIndex((entry) => entry.relativePath === relativePath);\n        if (index === -1) {\n            return false;\n        }\n        else {\n            this[_entries].splice(index, 1);\n            return true;\n        }\n    }\n    /**\n     * Replaces an entry in the archive with new data.\n     *\n     * This function returns `true` if the entry is successfully replaced, or `false` if the entry\n     * does not exist or the entry kind of the new data is incompatible with the old one.\n     */\n    replace(relativePath, data, info = {}) {\n        const index = this[_entries].findIndex((entry) => entry.relativePath === relativePath);\n        const oldEntry = index === -1 ? undefined : this[_entries][index];\n        if (!oldEntry) {\n            return false;\n        }\n        else if (oldEntry.kind === \"directory\" && info.kind !== \"directory\") {\n            return false;\n        }\n        else if (oldEntry.kind !== \"directory\" && info.kind === \"directory\") {\n            return false;\n        }\n        else if (data === null) {\n            if (info.kind === \"directory\") {\n                data = new Uint8Array(0);\n            }\n            else {\n                throw new TypeError(\"data must be provided for files\");\n            }\n        }\n        const newEntry = this.constructEntry(relativePath, data, info);\n        this[_entries][index] = newEntry;\n        return true;\n    }\n    [(_a = _entries, _b = _bodyUsed, Symbol.iterator)]() {\n        return this.entries();\n    }\n    /**\n     * Iterates over the entries in the archive.\n     */\n    *entries() {\n        const iter = this[_entries][Symbol.iterator]();\n        for (const entry of iter) {\n            yield omit(entry, [\"header\", \"body\"]);\n        }\n    }\n    /**\n     * Returns a tree view of the entries in the archive.\n     *\n     * NOTE: The entries returned by this function are reordered first by kind\n     * (directories before files), then by names alphabetically.\n     */\n    treeView() {\n        const now = new Date();\n        const entries = [...this.entries()];\n        const { children, ...rest } = makeTree(\"\", entries);\n        return {\n            ...rest,\n            size: 0,\n            mtime: now,\n            mode: 0o755,\n            uid: 0,\n            gid: 0,\n            owner: \"\",\n            group: \"\",\n            children: children !== null && children !== void 0 ? children : [],\n        };\n    }\n    /**\n     * Returns the approximate size of the archive in bytes.\n     *\n     * NOTE: This value may not reflect the actual size of the archive file\n     * when constructed via the {@link load} method.\n     */\n    get size() {\n        return this[_entries].reduce((size, entry) => {\n            size += entry.header.byteLength;\n            size += entry.size;\n            const paddingSize = HEADER_LENGTH - (entry.size % HEADER_LENGTH || HEADER_LENGTH);\n            if (paddingSize > 0) {\n                size += paddingSize;\n            }\n            return size;\n        }, 0);\n    }\n    /**\n     * Indicates whether the body of the tarball has been used. This property\n     * will be set to `true` after the `stream()` method is called.\n     */\n    get bodyUsed() {\n        return this[_bodyUsed];\n    }\n    /**\n     * Returns a readable stream of the archive that can be piped to a writable\n     * target.\n     *\n     * This method can only be called once per instance, as after the stream\n     * has been consumed, the underlying data of the archive's entries will no\n     * longer be available, and subsequent calls to this method will throw an\n     * error.\n     *\n     * To reuse the stream, use the `tee()` method of the stream to create a\n     * copy of the stream instead.\n     */\n    stream(options = {}) {\n        if (this[_bodyUsed]) {\n            throw new TypeError(\"The body of the tarball has been used\");\n        }\n        this[_bodyUsed] = true;\n        const streams = [];\n        for (const { size, header, body } of this[_entries]) {\n            streams.push(toReadableStream([header]));\n            streams.push(body);\n            const paddingSize = HEADER_LENGTH - (size % HEADER_LENGTH || HEADER_LENGTH);\n            if (paddingSize > 0) {\n                streams.push(toReadableStream([new Uint8Array(paddingSize)]));\n            }\n        }\n        const stream = concatStreams(...streams);\n        if (options.gzip) {\n            const gzip = new CompressionStream(\"gzip\");\n            return stream.pipeThrough(gzip);\n        }\n        else {\n            return stream;\n        }\n    }\n    /**\n     * Loads a tar archive from a readable stream.\n     *\n     * NOTE: This function loads the entire archive into memory, so it is not\n     * suitable for large archives. For large archives, use the `untar` function\n     * to extract files to the file system instead.\n     */\n    static async load(stream, options = {}) {\n        if (options.gzip) {\n            const gzip = new DecompressionStream(\"gzip\");\n            stream = stream.pipeThrough(gzip);\n        }\n        const tarball = new Tarball();\n        const reader = stream.getReader();\n        let lastChunk = new Uint8Array(0);\n        let header = null;\n        let headerInfo = null;\n        let entry = null;\n        let writer = null;\n        let writtenBytes = 0;\n        let paddingSize = 0;\n        try {\n            outer: while (true) {\n                const { done, value } = await reader.read();\n                if (done) {\n                    break;\n                }\n                lastChunk = lastChunk.byteLength ? concatBytes(lastChunk, value) : value;\n                while (true) {\n                    if (paddingSize > 0 && lastChunk.byteLength >= paddingSize) {\n                        lastChunk = lastChunk.subarray(paddingSize);\n                        paddingSize = 0;\n                    }\n                    if (!entry) {\n                        if (lastChunk.byteLength >= HEADER_LENGTH) {\n                            const _header = parseHeader(lastChunk);\n                            if (_header) {\n                                [headerInfo, header, lastChunk] = _header;\n                                entry = createEntry(headerInfo);\n                            }\n                            else {\n                                lastChunk = new Uint8Array(0);\n                                break outer;\n                            }\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                    const fileSize = entry.size;\n                    if (writer) {\n                        let leftBytes = fileSize - writtenBytes;\n                        if (lastChunk.byteLength > leftBytes) {\n                            const chunk = lastChunk.subarray(0, leftBytes);\n                            writer.push(chunk);\n                            writtenBytes += chunk.byteLength;\n                            lastChunk = lastChunk.subarray(leftBytes);\n                        }\n                        else {\n                            writer.push(lastChunk);\n                            writtenBytes += lastChunk.byteLength;\n                            lastChunk = new Uint8Array(0);\n                        }\n                    }\n                    else {\n                        writer = [];\n                        continue;\n                    }\n                    if (writtenBytes === fileSize) {\n                        const _entry = {\n                            ...entry,\n                            header: header,\n                            body: toReadableStream(writer),\n                        };\n                        tarball[_entries].push(_entry);\n                        paddingSize = HEADER_LENGTH - (fileSize % HEADER_LENGTH || HEADER_LENGTH);\n                        writtenBytes = 0;\n                        headerInfo = null;\n                        header = null;\n                        entry = null;\n                        writer = null;\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            if (lastChunk.byteLength) {\n                throw new Error(\"The archive is corrupted\");\n            }\n            return tarball;\n        }\n        finally {\n            reader.releaseLock();\n        }\n    }\n}\n//# sourceMappingURL=Tarball.js.map"],"names":["concatStreams","concatBytes"],"mappings":"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"}