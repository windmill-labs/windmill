/// <reference types="node" />
/// <reference types="node" />
import { DirEntry } from "../fs.ts";
import type { NetAddress, RequestContext, RequestErrorHandler, ServeOptions } from "./server.ts";
import type { WebSocketServer } from "../ws.ts";
import type { IncomingMessage, ServerResponse } from "node:http";
import type { Http2ServerRequest, Http2ServerResponse } from "node:http2";
export interface TimingMetrics {
    timeStart: number;
    timeEnd?: number | undefined;
    description?: string | undefined;
}
export type TimingFunctions = Pick<RequestContext, "time" | "timeEnd"> & {
    /**
     * Returns the timers map associated with the timing functions. If
     * `sanitize` is set, a new map is returned which excludes timers that have
     * not ended yet, and will move the `total` timer to the end of the map if
     * present.
     */
    getTimers: (sanitize?: boolean) => Map<string, TimingMetrics>;
};
/**
 * Creates timing functions for measuring the request processing time. This
 * function returns the timing functions and a `timers` map that associates
 * with them.
 */
export declare function createTimingFunctions(): TimingFunctions & {
    /**
     * @deprecated use `getTimers` instead.
     */
    timers: Map<string, TimingMetrics>;
};
/**
 * Creates a request context object from the given `request` and properties.
 */
export declare function createRequestContext(request: Request, props: Pick<RequestContext, "remoteAddress" | "waitUntil" | "bindings" | "time" | "timeEnd"> & {
    ws: WebSocketServer;
}): RequestContext;
/**
 * Patches the timing metrics to the response's headers.
 */
export declare function patchTimingMetrics(response: Response, timers: Map<string, TimingMetrics>): Response;
/**
 * Returns a new request handler that wraps the given one so that we can add
 * extra `headers` to the response.
 */
export declare function withHeaders<A extends any[]>(handle: (...args: A) => Response | Promise<Response>, headers?: HeadersInit | null | undefined): (...args: A) => Promise<Response>;
/**
 * Adds a event listener to the `fetch` event in service workers that handles
 * HTTP requests with the given options.
 */
export declare function listenFetchEvent(options: Pick<ServeOptions, "fetch" | "headers"> & {
    onError: RequestErrorHandler;
    ws: WebSocketServer;
    bindings?: RequestContext["bindings"];
}): void;
/**
 * Renders a directory listing page for the `pathname` with the given `entries`.
 */
export declare function renderDirectoryPage(pathname: string, entries: DirEntry[], extraHeaders?: HeadersInit): Promise<Response>;
/**
 * Creates a Node.js HTTP request listener with modern Web APIs.
 *
 * NOTE: This function is only available in Node.js and requires Node.js v18.4.1
 * or above.
 *
 * @example
 * ```ts
 * import * as http from "node:http";
 * import { withWeb } from "@ayonli/jsext/http/internal";
 *
 * const server = http.createServer(withWeb(async (req) => {
 *     return new Response("Hello, World!");
 * }));
 *
 * server.listen(8000);
 * ```
 */
export declare function withWeb(listener: (req: Request, info: {
    remoteAddress: NetAddress;
}) => Response | Promise<Response>): (req: IncomingMessage | Http2ServerRequest, res: ServerResponse | Http2ServerResponse) => void;
