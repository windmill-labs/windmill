/// <reference types="mocha" />
/// <reference types="node" />
export declare function resolveReadableStream<T>(promise: Promise<ReadableStream<T>>): ReadableStream<T>;
/**
 * If the given `promise` resolves to a `ReadableStream<Uint8Array>`, this
 * function will return a new `ReadableStream<Uint8Array>` object that can be
 * used to read the byte stream without the need to wait for the promise to
 * resolve.
 *
 * This function is optimized for zero-copy read, so it's recommended to use
 * this function when the source stream is a byte stream.
 */
export declare function resolveByteStream(promise: Promise<ReadableStream<Uint8Array>>): ReadableStream<Uint8Array>;
/**
 * Converts the given `source` into an `AsyncIterable` object if it's not one
 * already, returns `null` if failed.
 */
export declare function asAsyncIterable(source: any): AsyncIterable<any> | null;
/**
 * Wraps a source as an `AsyncIterable` object that can be used in the
 * `for await...of...` loop for reading streaming data.
 */
export declare function toAsyncIterable<T>(iterable: AsyncIterable<T> | Iterable<T>): AsyncIterable<T>;
/**
 * @example
 * ```ts
 * import { toAsyncIterable } from "@ayonli/jsext/reader";
 *
 * const res = new Response("Hello, World!");
 *
 * for await (const chunk of toAsyncIterable(res.body!)) {
 *     console.log("receive chunk:", chunk);
 * }
 * ```
 */
export declare function toAsyncIterable<T>(stream: ReadableStream<T> | Promise<ReadableStream<T>>): AsyncIterable<T>;
/**
 * @example
 * ```ts
 * import { toAsyncIterable } from "@ayonli/jsext/reader";
 *
 * // listen to the `onmessage`
 * const sse = new EventSource("/sse/message");
 *
 * for await (const msg of toAsyncIterable(sse)) {
 *     console.log("receive message:", msg);
 * }
 *
 * // listen to a specific event
 * const channel = new EventSource("/sse/broadcast");
 *
 * for await (const msg of toAsyncIterable(channel, { event: "broadcast" })) {
 *     console.log("receive message:", msg);
 * }
 * ```
 */
export declare function toAsyncIterable(es: EventSource, options?: {
    event?: string;
}): AsyncIterable<string>;
/**
 * @example
 * ```ts
 * import { toAsyncIterable } from "@ayonli/jsext/reader";
 *
 * const ws = new WebSocket("/ws");
 *
 * for await (const msg of toAsyncIterable(ws)) {
 *     if (typeof data === "string") {
 *         console.log("receive text message:", data);
 *     } else {
 *         console.log("receive binary data:", data);
 *     }
 * }
 * ```
 */
export declare function toAsyncIterable<T extends Uint8Array | string>(ws: WebSocket): AsyncIterable<T>;
/**
 * @example
 * ```ts
 * import { toAsyncIterable } from "@ayonli/jsext/reader";
 *
 * for await (const msg of toAsyncIterable(self)) {
 *     console.log("receive message from the parent window:", msg);
 * }
 * ```
 */
export declare function toAsyncIterable<T>(target: EventTarget, eventMap?: {
    message?: string;
    error?: string;
    close?: string;
}): AsyncIterable<T>;
/**
 * @example
 * ```ts
 * import { toAsyncIterable } from "@ayonli/jsext/reader";
 *
 * for await (const msg of toAsyncIterable(process)) {
 *     console.log("receive message from the parent process:", msg);
 * }
 * ```
 */
export declare function toAsyncIterable<T>(target: NodeJS.EventEmitter, eventMap?: {
    data?: string;
    error?: string;
    close?: string;
}): AsyncIterable<T>;
