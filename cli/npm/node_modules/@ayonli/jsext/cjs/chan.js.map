{"version":3,"file":"chan.js","sources":["../chan.ts"],"sourcesContent":["/**\n * A channel implementation that transfers data across routines, even across\n * multiple threads, inspired by Golang.\n * @module\n */\nvar _a;\nimport { serial } from \"./number.ts\";\nimport { id } from \"./env.ts\";\nif (typeof Symbol.dispose === \"undefined\") {\n    Object.defineProperty(Symbol, \"dispose\", { value: Symbol(\"Symbol.dispose\") });\n}\nconst idGenerator = serial(true);\n/**\n * A channel implementation that transfers data across routines, even across\n * multiple threads, inspired by Golang.\n */\nexport class Channel {\n    constructor(capacity = 0) {\n        this[_a] = idGenerator.next().value;\n        this.buffer = [];\n        this.producers = [];\n        this.consumers = [];\n        this.error = null;\n        this.state = 1;\n        if (capacity < 0) {\n            throw new RangeError(\"the capacity of a channel must not be negative\");\n        }\n        this.capacity = capacity;\n    }\n    /**\n     * Pushes data to the channel.\n     *\n     * If there is a receiver, the data will be consumed immediately. Otherwise:\n     *\n     * - If this is an non-buffered channel, this function will block until a\n     *  receiver is available and the data is consumed.\n     *\n     * - If this is a buffered channel, then:\n     *      - If the buffer size is within the capacity, the data will be pushed\n     *        to the buffer.\n     *      - Otherwise, this function will block until there is new space for\n     *        the data in the buffer.\n     */\n    send(data) {\n        if (this.state !== 1) {\n            throw new Error(\"the channel is closed\");\n        }\n        else if (this.consumers.length) {\n            const consume = this.consumers.shift();\n            return Promise.resolve(consume(null, data));\n        }\n        else if (this.capacity && this.buffer.length < this.capacity) {\n            this.buffer.push(data);\n            return Promise.resolve(undefined);\n        }\n        else {\n            return new Promise(resolve => {\n                this.producers.push(() => {\n                    if (this.capacity) {\n                        const _data = this.buffer.shift();\n                        this.buffer.push(data);\n                        resolve();\n                        return _data;\n                    }\n                    else {\n                        resolve();\n                        return data;\n                    }\n                });\n            });\n        }\n    }\n    /**\n     * Retrieves data from the channel.\n     *\n     * If there isn't data available at the moment, this function will block\n     * until new data is available.\n     *\n     * If the channel is closed, then:\n     *\n     * - If there is error set in the channel, this function throws that error\n     *   immediately.\n     * - Otherwise, this function returns `undefined` immediately.\n     */\n    recv() {\n        if (this.buffer.length) {\n            const data = this.buffer.shift();\n            if (this.state === 2 && !this.buffer.length) {\n                this.state = 0;\n            }\n            return Promise.resolve(data);\n        }\n        else if (this.producers.length) {\n            const produce = this.producers.shift();\n            if (this.state === 2 && !this.producers.length) {\n                this.state = 0;\n            }\n            return Promise.resolve(produce());\n        }\n        else if (this.state === 0) {\n            return Promise.resolve(undefined);\n        }\n        else if (this.error) {\n            // Error can only be consumed once, after that, that closure will\n            // be complete.\n            const { error } = this;\n            this.state = 0;\n            this.error = null;\n            return Promise.reject(error);\n        }\n        else if (this.state === 2) {\n            this.state = 0;\n            return Promise.resolve(undefined);\n        }\n        else {\n            return new Promise((resolve, reject) => {\n                this.consumers.push((err, data) => {\n                    if (this.state === 2 && !this.consumers.length) {\n                        this.state = 0;\n                    }\n                    err ? reject(err) : resolve(data);\n                });\n            });\n        }\n    }\n    /**\n     * Closes the channel. If `err` is supplied, it will be captured by the\n     * receiver.\n     *\n     * No more data shall be sent once the channel is closed.\n     *\n     * Explicitly closing the channel is not required, if the channel is no\n     * longer used, it will be automatically released by the GC. However, if\n     * the channel is used in a `for await...of...` loop, closing the channel\n     * will allow the loop to break automatically.\n     *\n     * Moreover, if the channel is used between parallel threads, it will no\n     * longer be able to release automatically, must explicitly call this\n     * function in order to release for GC.\n     */\n    close(err = null) {\n        if (this.state !== 1) {\n            // prevent duplicated call\n            return;\n        }\n        this.state = 2;\n        this.error = err;\n        let consume;\n        while (consume = this.consumers.shift()) {\n            consume(err, undefined);\n        }\n    }\n    [(_a = id, Symbol.asyncIterator)]() {\n        const channel = this;\n        return {\n            async next() {\n                const bufSize = channel.buffer.length;\n                const queueSize = channel.producers.length;\n                const value = await channel.recv();\n                return {\n                    value: value,\n                    done: channel.state === 0 && !bufSize && !queueSize,\n                };\n            }\n        };\n    }\n    [Symbol.dispose]() {\n        this.close();\n    }\n    /** @deprecated This method is deprecated in favor of the `send()` method. */\n    push(data) {\n        return this.send(data);\n    }\n    /** @deprecated This method is deprecated in favor of the `recv()` method. */\n    pop() {\n        return this.recv();\n    }\n}\n/**\n * Inspired by Golang, cerates a {@link Channel} that can be used to transfer\n * data across routines.\n *\n * If `capacity` is not set, a non-buffered channel will be created. For a\n * non-buffered channel, the sender and receiver must be present at the same\n * time (theoretically), otherwise, the channel will block (non-IO aspect).\n *\n * If `capacity` is set, a buffered channel will be created. For a buffered\n * channel, data will be queued in the buffer first and then consumed by the\n * receiver in FIFO order. Once the buffer size reaches the capacity limit, no\n * more data will be sent unless there is new space available.\n *\n * It is possible to set the `capacity` to `Infinity` to allow the channel to\n * never block and behave like a message queue.\n *\n * Unlike `EventEmitter` or `EventTarget`, `Channel` guarantees the data will\n * always be delivered, even if there is no receiver at the moment.\n *\n * Also, unlike Golang, `await channel.recv()` does not prevent the program from\n * exiting.\n *\n * Channels can be used to send and receive streaming data between main thread\n * and worker threads wrapped by `parallel()`, but once used that way,\n * `channel.close()` must be explicitly called in order to release the channel\n * for garbage collection.\n *\n * @example\n * ```ts\n * // non-buffered\n * import chan from \"@ayonli/jsext/chan\";\n *\n * const channel = chan<number>();\n *\n * (async () => {\n *     await channel.send(123);\n * })();\n *\n * const num = await channel.recv();\n * console.log(num); // 123\n * // output:\n * // 123\n * ```\n *\n * @example\n * ```ts\n * // buffered\n * import chan from \"@ayonli/jsext/chan\";\n *\n * const channel = chan<number>(3);\n *\n * await channel.send(123);\n * await channel.send(456);\n * await channel.send(789);\n *\n * const num1 = await channel.recv();\n * const num2 = await channel.recv();\n * const num3 = await channel.recv();\n *\n * console.log(num1); // 123\n * console.log(num2); // 456\n * console.log(num3); // 789\n * ```\n *\n * @example\n * ```ts\n * // iterable\n * import chan from \"@ayonli/jsext/chan\";\n * import { range } from \"@ayonli/jsext/number\";\n *\n * const channel = chan<number>();\n *\n * (async () => {\n *     for (const num of range(1, 5)) {\n *         await channel.send(num);\n *     }\n *\n *     channel.close();\n * })();\n *\n * for await (const num of channel) {\n *     console.log(num);\n * }\n * // output:\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * ```\n */\nexport default function chan(capacity = 0) {\n    return new Channel(capacity);\n}\n//# sourceMappingURL=chan.js.map"],"names":["serial","id"],"mappings":"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"}