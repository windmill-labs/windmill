{"version":3,"file":"lock.js","sources":["../lock.ts"],"sourcesContent":["/**\n * A mutual exclusion mechanism for concurrent operations and protecting shared\n * data.\n * @module\n */\nvar _a;\nimport BiMap from \"./collections/BiMap.ts\";\nif (typeof Symbol.dispose === \"undefined\") {\n    Object.defineProperty(Symbol, \"dispose\", { value: Symbol(\"Symbol.dispose\") });\n}\nconst _queue = Symbol.for(\"queue\");\nconst _value = Symbol.for(\"value\");\nconst _mutex = Symbol.for(\"mutex\");\nconst _unlocked = Symbol.for(\"unlocked\");\n/**\n * Mutual Exclusion prevents multiple coroutines from accessing the same shared\n * resource simultaneously.\n *\n * **NOTE:**\n * Currently, the Mutex instance can not be used across multiple threads, but is\n * considering adding support for `parallel` threads.\n *\n * @example\n * ```ts\n * import { Mutex } from \"@ayonli/jsext/lock\";\n * import { random } from \"@ayonli/jsext/number\";\n * import { sleep } from \"@ayonli/jsext/async\";\n *\n * const mutex = new Mutex(1);\n *\n * async function concurrentOperation() {\n *     using shared = await mutex.lock();\n *     const value1 = shared.value;\n *\n *     await otherAsyncOperations();\n *\n *     shared.value += 1\n *     const value2 = shared.value;\n *\n *     // Without mutex lock, the shared value may have been modified by other\n *     // calls during `await otherAsyncOperation()`, and the following\n *     // assertion will fail.\n *     console.assert(value1 + 1 === value2);\n * }\n *\n * async function otherAsyncOperations() {\n *     await sleep(100 * random(1, 10));\n * }\n *\n * await Promise.all([\n *     concurrentOperation(),\n *     concurrentOperation(),\n *     concurrentOperation(),\n *     concurrentOperation(),\n * ]);\n * ```\n */\nexport class Mutex {\n    /**\n     * @param value The data associated to the mutex instance.\n     */\n    constructor(value) {\n        this[_a] = [];\n        this[_value] = value;\n    }\n    /**\n     * Acquires the lock of the mutex, optionally for modifying the shared\n     * resource.\n     */\n    async lock() {\n        await new Promise(resolve => {\n            if (this[_queue].length) {\n                this[_queue].push(resolve);\n            }\n            else {\n                this[_queue].push(resolve);\n                resolve();\n            }\n        });\n        const lock = Object.create(Mutex.Lock.prototype);\n        lock[_mutex] = this;\n        return lock;\n    }\n}\n_a = _queue;\n(function (Mutex) {\n    var _b;\n    class Lock {\n        constructor(mutex) {\n            this[_b] = false;\n            this[_mutex] = mutex;\n        }\n        /** Accesses the data associated to the mutex instance. */\n        get value() {\n            if (this[_unlocked]) {\n                throw new ReferenceError(\"trying to access data after unlocked\");\n            }\n            return this[_mutex][_value];\n        }\n        set value(v) {\n            if (this[_unlocked]) {\n                throw new ReferenceError(\"trying to access data after unlocked\");\n            }\n            this[_mutex][_value] = v;\n        }\n        /** Releases the current lock of the mutex. */\n        unlock() {\n            this[_unlocked] = true;\n            const queue = this[_mutex][_queue];\n            queue.shift();\n            const next = queue[0];\n            if (next) {\n                next();\n            }\n            else if (registry.hasValue(this[_mutex])) {\n                registry.deleteValue(this[_mutex]);\n            }\n        }\n        [(_b = _unlocked, Symbol.dispose)]() {\n            this.unlock();\n        }\n    }\n    Mutex.Lock = Lock;\n})(Mutex || (Mutex = {}));\nconst registry = new BiMap();\n/**\n * Acquires a mutex lock for the given key in order to perform concurrent\n * operations and prevent conflicts.\n *\n * If the key is currently being locked by other coroutines, this function will\n * block until the lock becomes available again.\n *\n * @example\n * ```ts\n * import lock from \"@ayonli/jsext/lock\";\n *\n * const key = \"lock_key\";\n *\n * export async function concurrentOperation() {\n *     using ctx = await lock(key);\n *     void ctx;\n *\n *     // This block will never be run if there are other coroutines holding\n *     // the lock.\n *     //\n *     // Other coroutines trying to lock the same key will also never be run\n *     // before this function completes.\n * }\n * ```\n */\nexport default async function lock(key) {\n    let mutex = registry.get(key);\n    if (!mutex) {\n        registry.set(key, mutex = new Mutex(void 0));\n    }\n    return await mutex.lock();\n}\n//# sourceMappingURL=lock.js.map"],"names":["BiMap"],"mappings":"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"}