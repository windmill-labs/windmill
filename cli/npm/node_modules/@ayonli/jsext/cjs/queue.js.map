{"version":3,"file":"queue.js","sources":["../queue.ts"],"sourcesContent":["/**\n * This module provides a mechanism to handle tasks sequentially and prevent\n * concurrency conflicts.\n * @module\n */\nimport chan from \"./chan.ts\";\nexport class Queue {\n    constructor(handler, bufferSize = 0) {\n        this.channel = chan(bufferSize);\n        (async () => {\n            var _a;\n            for await (const data of this.channel) {\n                try {\n                    await handler.call(void 0, data);\n                }\n                catch (err) {\n                    (_a = this.errorHandler) === null || _a === void 0 ? void 0 : _a.call(this, err);\n                }\n            }\n        })().catch(err => {\n            var _a;\n            (_a = this.errorHandler) === null || _a === void 0 ? void 0 : _a.call(void 0, err);\n        });\n    }\n    push(data) {\n        return this.channel.send(data);\n    }\n    close() {\n        var _a;\n        (_a = this.channel) === null || _a === void 0 ? void 0 : _a.close();\n    }\n    onError(handler) {\n        this.errorHandler = handler;\n    }\n    [Symbol.dispose]() {\n        this.close();\n    }\n}\n/**\n * Processes data sequentially by the given `handler` function and prevents\n * concurrency conflicts, it returns a {@link Queue} instance that we can push\n * data into.\n *\n * @param bufferSize The maximum capacity of the underlying channel, once\n * reached, the push operation will block until there is new space available.\n * By default, this option is not set and use a non-buffered channel instead.\n *\n * @example\n * ```ts\n * import queue from \"@ayonli/jsext/queue\";\n *\n * const list: string[] = [];\n * const q = queue(async (str: string) => {\n *     await Promise.resolve(null);\n *     list.push(str);\n * });\n *\n * q.onError(err => {\n *     console.error(err);\n * })\n *\n * await q.push(\"foo\");\n * await q.push(\"foo\");\n *\n * console.log(list.length);\n * q.close();\n * // output:\n * // 2\n * ```\n */\nexport default function queue(handler, bufferSize = 0) {\n    return new Queue(handler, bufferSize);\n}\n//# sourceMappingURL=queue.js.map"],"names":["chan"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AAEO,MAAM,KAAK,CAAC;AACnB,IAAI,WAAW,CAAC,OAAO,EAAE,UAAU,GAAG,CAAC,EAAE;AACzC,QAAQ,IAAI,CAAC,OAAO,GAAGA,YAAI,CAAC,UAAU,CAAC,CAAC;AACxC,QAAQ,CAAC,YAAY;AACrB,YAAY,IAAI,EAAE,CAAC;AACnB,YAAY,WAAW,MAAM,IAAI,IAAI,IAAI,CAAC,OAAO,EAAE;AACnD,gBAAgB,IAAI;AACpB,oBAAoB,MAAM,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;AACrD,iBAAiB;AACjB,gBAAgB,OAAO,GAAG,EAAE;AAC5B,oBAAoB,CAAC,EAAE,GAAG,IAAI,CAAC,YAAY,MAAM,IAAI,IAAI,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;AACrG,iBAAiB;AACjB,aAAa;AACb,SAAS,GAAG,CAAC,KAAK,CAAC,GAAG,IAAI;AAC1B,YAAY,IAAI,EAAE,CAAC;AACnB,YAAY,CAAC,EAAE,GAAG,IAAI,CAAC,YAAY,MAAM,IAAI,IAAI,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,GAAG,CAAC,CAAC;AAC/F,SAAS,CAAC,CAAC;AACX,KAAK;AACL,IAAI,IAAI,CAAC,IAAI,EAAE;AACf,QAAQ,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACvC,KAAK;AACL,IAAI,KAAK,GAAG;AACZ,QAAQ,IAAI,EAAE,CAAC;AACf,QAAQ,CAAC,EAAE,GAAG,IAAI,CAAC,OAAO,MAAM,IAAI,IAAI,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC,KAAK,EAAE,CAAC;AAC5E,KAAK;AACL,IAAI,OAAO,CAAC,OAAO,EAAE;AACrB,QAAQ,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC;AACpC,KAAK;AACL,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG;AACvB,QAAQ,IAAI,CAAC,KAAK,EAAE,CAAC;AACrB,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,SAAS,KAAK,CAAC,OAAO,EAAE,UAAU,GAAG,CAAC,EAAE;AACvD,IAAI,OAAO,IAAI,KAAK,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;AAC1C;;;;;"}