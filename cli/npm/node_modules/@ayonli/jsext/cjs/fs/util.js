'use strict';

var array = require('../array.js');
var filetype = require('../filetype.js');
var object = require('../object.js');
var path = require('../path.js');
var path_util = require('../path/util.js');

function fixDirEntry(entry) {
    Object.defineProperty(entry, "path", {
        get() {
            return entry.relativePath;
        },
    });
    return entry;
}
function fixFileType(file) {
    var _a;
    if (!file.type) {
        const ext = path.extname(file.name);
        if (ext) {
            Object.defineProperty(file, "type", {
                value: (_a = filetype.getMIME(ext)) !== null && _a !== void 0 ? _a : "",
                writable: false,
                configurable: true,
            });
        }
    }
    return file;
}
/**
 * @param addPathProp `DirEntry.prop` is deprecated, this option is for backward
 * compatibility.
 */
function makeTree(dir, entries, addPathProp = false) {
    const list = entries.map(entry => ({
        ...entry,
        paths: path_util.split(entry.relativePath),
    }));
    const nodes = (function walk(list, store) {
        // Order the entries first by kind, then by names alphabetically.
        list = [
            ...array.orderBy(list.filter(e => e.kind === "directory"), e => e.name, "asc"),
            ...array.orderBy(list.filter(e => e.kind === "file"), e => e.name, "asc"),
        ];
        const nodes = [];
        for (const entry of list) {
            if (entry.kind === "directory") {
                const paths = entry.paths;
                const childEntries = store.filter(e => array.startsWith(e.paths, paths));
                const directChildren = childEntries
                    .filter(e => e.paths.length === paths.length + 1);
                if (directChildren.length) {
                    const indirectChildren = childEntries
                        .filter(e => !directChildren.includes(e));
                    const _entry = {
                        ...object.omit(entry, ["paths"]),
                        children: walk(directChildren, indirectChildren),
                    };
                    addPathProp && fixDirEntry(_entry);
                    nodes.push(_entry);
                }
                else {
                    let _entry = {
                        ...object.omit(entry, ["paths"]),
                        children: [],
                    };
                    addPathProp && fixDirEntry(_entry);
                    nodes.push(_entry);
                }
            }
            else {
                const _entry = {
                    ...object.omit(entry, ["paths"]),
                };
                addPathProp && fixDirEntry(_entry);
                nodes.push(_entry);
            }
        }
        return nodes;
    })(list.filter(entry => entry.paths.length === 1), list.filter(entry => entry.paths.length > 1));
    let rootName;
    if (typeof dir === "object") {
        rootName = dir.name || "(root)";
    }
    else if (dir) {
        rootName = path.basename(dir);
        if (!rootName || rootName === ".") {
            rootName = "(root)";
        }
    }
    else {
        rootName = "(root)";
    }
    const rooEntry = {
        name: rootName,
        kind: "directory",
        relativePath: "",
        children: nodes,
    };
    if (typeof dir === "object") {
        rooEntry.handle = dir;
    }
    addPathProp && fixDirEntry(rooEntry);
    return rooEntry;
}

exports.fixDirEntry = fixDirEntry;
exports.fixFileType = fixFileType;
exports.makeTree = makeTree;
//# sourceMappingURL=util.js.map
