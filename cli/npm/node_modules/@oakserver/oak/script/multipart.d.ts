import * as dntShim from "./_dnt.shims.js";
/** When reading a body in full via `.read()` from a {@linkcode FormDataReader}
 * this is what is what the value is resolved, providing a split between any
 * fields, and multi-part files that were provided. */
export interface FormDataBody {
    /** A record of form parts where the key was the `name` of the part and the
     * value was the value of the part. This record does not include any files
     * that were part of the form data.
     *
     * *Note*: Duplicate names are not included in this record, if there are
     * duplicates, the last value will be the value that is set here.  If there
     * is a possibility of duplicate values, use the `.stream()` method on
     * {@linkcode FormDataReader} to iterate over the values. */
    fields: Record<string, string>;
    /** An array of any files that were part of the form data. */
    files?: FormDataFile[];
}
/** A representation of a file that has been read from a form data body. Based
 * on the {@linkcode FormDataReadOptions} that were passed when reading will
 * determine if files are written to disk or not and how they are written to
 * disk.  When written to disk, the extension of the file will be determined by
 * the content type, with the `.filename` property containing the full path to
 * the file.
 *
 * The original filename as part of the form data is available in
 * `originalName`, but for security and stability reasons, it is not used to
 * determine the name of the file on disk. If further processing or renaming
 * is required, the implementor should do that processing. */
export interface FormDataFile {
    /** When the file has not been written out to disc, the contents of the file
     * as a {@linkcode Uint8Array}. */
    content?: Uint8Array;
    /** The content type of the form data file. */
    contentType: string;
    /** When the file has been written out to disc, the full path to the file. */
    filename?: string;
    /** The `name` that was assigned to the form data file. */
    name: string;
    /** The `filename` that was provided in the form data file. */
    originalName: string;
}
/** Options which impact how the form data is decoded for a
 * {@linkcode FormDataReader}. All these options have sensible defaults for
 * most applications, but can be modified for different use cases. Many of these
 * options can have an impact on the stability of a server, especially if there
 * is someone attempting a denial of service attack on your server, so be
 * careful when changing the defaults. */
export interface FormDataReadOptions {
    /** The size of the buffer to read from the request body at a single time.
     * This defaults to 1mb. */
    bufferSize?: number;
    /** A mapping of custom media types that are supported, mapped to their
     * extension when determining the extension for a file. The key should be an
     * all lowercase media type with the value being the extension (without an
     * initial period), to be used when decoding the file.
     *
     * ### Example
     *
     * Form data that is sent with content having a type of `text/vdn.custom` will
     * be decoded and assigned a filename ending with `.txt`:
     *
     * ```ts
     * import { Application } from "https://deno.land/x/oak/mod.ts";
     *
     * const app = new Application();
     * app.use(async (ctx) => {
     *   const body = ctx.request.body();
     *   if (body.type === "form-data") {
     *     const formatData = await body.value.read({
     *       customContentTypes: {
     *         "text/vnd.custom": "txt"
     *       }
     *     });
     *     console.log(formData);
     *   }
     * });
     * ```
     */
    customContentTypes?: Record<string, string>;
    /** The maximum file size (in bytes) that can be handled.  This defaults to
     * 10MB when not specified.  This is to try to avoid DOS attacks where
     * someone would continue to try to send a "file" continuously until a host
     * limit was reached crashing the server or the host. Also see `maxSize`. */
    maxFileSize?: number;
    /** The maximum size (in bytes) of a file to hold in memory, and not write
     * to disk. This defaults to `0`, so that all multipart form files are
     * written to disk. When set to a positive integer, if the form data file is
     * smaller, it will be retained in memory and available in the `.content`
     * property of the `FormDataFile` object.  If the file exceeds the `maxSize`
     * it will be written to disk and the `.filename` property will contain the
     * full path to the output file. */
    maxSize?: number;
    /** When writing form data files to disk, the output path.  This will default
     * to a temporary path generated by `Deno.makeTempDir()`. */
    outPath?: string;
    /** When a form data file is written to disk, it will be generated with a
     * random filename and have an extension based off the content type for the
     * file.  `prefix` can be specified though to prepend to the file name. */
    prefix?: string;
}
/** An interface which provides an interface to access the fields of a
 * `multipart/form-data` body.
 *
 * Normally an instance of this is accessed when handling a request body, and
 * dealing with decoding it.  There are options that can be set when attempting
 * to read a multi-part body (see: {@linkcode FormDataReadOptions}).
 *
 * If you `.read()` the value, then a promise is provided of type
 * {@linkcode FormDataBody}. If you use the `.stream()` property, it is an async
 * iterator which yields up a tuple of with the first element being a
 *
 * ### Examples
 *
 * Using `.read()`:
 *
 * ```ts
 * import { Application } from "https://deno.land/x/oak/mod.ts";
 *
 * const app = new Application();
 *
 * app.use(async (ctx) => {
 *   const body = ctx.request.body();
 *   if (body.type === "form-data") {
 *     const value = body.value;
 *     const formData = await value.read();
 *     // the form data is fully available
 *   }
 * });
 * ```
 *
 *  Using `.stream()`:
 *
 * ```ts
 * import { Application } from "https://deno.land/x/oak/mod.ts";
 *
 * const app = new Application();
 *
 * app.use(async (ctx) => {
 *   const body = ctx.request.body();
 *   if (body.type === "form-data") {
 *     const value = body.value;
 *     for await (const [name, value] of value.stream()) {
 *       // asynchronously iterate each part of the body
 *     }
 *   }
 * });
 * ```
 */
export declare class FormDataReader {
    #private;
    constructor(contentType: string, body: dntShim.Deno.Reader);
    /** Reads the multipart body of the response and resolves with an object which
     * contains fields and files that were part of the response.
     *
     * *Note*: this method handles multiple files with the same `name` attribute
     * in the request, but by design it does not handle multiple fields that share
     * the same `name`.  If you expect the request body to contain multiple form
     * data fields with the same name, it is better to use the `.stream()` method
     * which will iterate over each form data field individually. */
    read(options?: FormDataReadOptions): Promise<FormDataBody>;
    /** Returns an iterator which will asynchronously yield each part of the form
     * data.  The yielded value is a tuple, where the first element is the name
     * of the part and the second element is a `string` or a `FormDataFile`
     * object. */
    stream(options?: FormDataReadOptions): AsyncIterableIterator<[name: string, value: string | FormDataFile]>;
}
