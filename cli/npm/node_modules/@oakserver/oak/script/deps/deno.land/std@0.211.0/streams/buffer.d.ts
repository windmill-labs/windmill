/// <reference types="node" />
import * as dntShim from "../../../../_dnt.shims.js";
/** A variable-sized buffer of bytes with `read()` and `write()` methods.
 *
 * Buffer is almost always used with some I/O like files and sockets. It allows
 * one to buffer up a download from a socket. Buffer grows and shrinks as
 * necessary.
 *
 * Buffer is NOT the same thing as Node's Buffer. Node's Buffer was created in
 * 2009 before JavaScript had the concept of ArrayBuffers. It's simply a
 * non-standard ArrayBuffer.
 *
 * ArrayBuffer is a fixed memory allocation. Buffer is implemented on top of
 * ArrayBuffer.
 *
 * Based on [Go Buffer](https://golang.org/pkg/bytes/#Buffer). */
export declare class Buffer {
    #private;
    /** Getter returning the instance's {@linkcode ReadableStream}. */
    get readable(): dntShim.ReadableStream<Uint8Array>;
    /** Getter returning the instance's {@linkcode WritableStream}. */
    get writable(): WritableStream<Uint8Array>;
    /** Constructs a new instance. */
    constructor(ab?: ArrayBufferLike | ArrayLike<number>);
    /** Returns a slice holding the unread portion of the buffer.
     *
     * The slice is valid for use only until the next buffer modification (that
     * is, only until the next call to a method like `read()`, `write()`,
     * `reset()`, or `truncate()`). If `options.copy` is false the slice aliases
     * the buffer content at least until the next buffer modification, so
     * immediate changes to the slice will affect the result of future reads.
     */
    bytes(options?: {
        copy: boolean;
    }): Uint8Array;
    /** Returns whether the unread portion of the buffer is empty. */
    empty(): boolean;
    /** A read only number of bytes of the unread portion of the buffer. */
    get length(): number;
    /** The read only capacity of the buffer's underlying byte slice, that is,
     * the total space allocated for the buffer's data. */
    get capacity(): number;
    /**
     * Discards all but the first `n` unread bytes from the buffer but
     * continues to use the same allocated storage. It throws if `n` is
     * negative or greater than the length of the buffer.
     */
    truncate(n: number): void;
    /** Resets to an empty buffer. */
    reset(): void;
    /** Grows the buffer's capacity, if necessary, to guarantee space for
     * another `n` bytes. After `.grow(n)`, at least `n` bytes can be written to
     * the buffer without another allocation. If `n` is negative, `.grow()` will
     * throw. If the buffer can't grow it will throw an error.
     *
     * Based on Go Lang's
     * [Buffer.Grow](https://golang.org/pkg/bytes/#Buffer.Grow). */
    grow(n: number): void;
}
