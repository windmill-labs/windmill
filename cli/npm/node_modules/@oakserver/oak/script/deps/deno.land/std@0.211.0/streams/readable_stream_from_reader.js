"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readableStreamFromReader = void 0;
const tslib_1 = require("tslib");
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
const dntShim = tslib_1.__importStar(require("../../../../_dnt.shims.js"));
const _common_js_1 = require("./_common.js");
function isCloser(value) {
    return typeof value === "object" && value !== null && value !== undefined &&
        "close" in value &&
        // deno-lint-ignore no-explicit-any
        typeof value["close"] === "function";
}
/**
 * Create a {@linkcode ReadableStream} of {@linkcode Uint8Array}s from a
 * {@linkcode Reader}.
 *
 * When the pull algorithm is called on the stream, a chunk from the reader
 * will be read.  When `null` is returned from the reader, the stream will be
 * closed along with the reader (if it is also a `Closer`).
 *
 * An example converting a `Deno.FsFile` into a readable stream:
 *
 * ```ts
 * import { readableStreamFromReader } from "https://deno.land/std@$STD_VERSION/streams/readable_stream_from_reader.ts";
 *
 * const file = await Deno.open("./file.txt", { read: true });
 * const fileStream = readableStreamFromReader(file);
 * ```
 *
 * @deprecated (will be removed after 1.0.0) Use {@linkcode ReadableStream} directly instead.
 */
function readableStreamFromReader(reader, options = {}) {
    const { autoClose = true, chunkSize = _common_js_1.DEFAULT_CHUNK_SIZE, strategy, } = options;
    return new dntShim.ReadableStream({
        async pull(controller) {
            const chunk = new Uint8Array(chunkSize);
            try {
                const read = await reader.read(chunk);
                if (read === null) {
                    if (isCloser(reader) && autoClose) {
                        reader.close();
                    }
                    controller.close();
                    return;
                }
                controller.enqueue(chunk.subarray(0, read));
            }
            catch (e) {
                controller.error(e);
                if (isCloser(reader)) {
                    reader.close();
                }
            }
        },
        cancel() {
            if (isCloser(reader) && autoClose) {
                reader.close();
            }
        },
    }, strategy);
}
exports.readableStreamFromReader = readableStreamFromReader;
