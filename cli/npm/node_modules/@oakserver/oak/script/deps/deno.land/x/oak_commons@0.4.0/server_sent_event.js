"use strict";
// Copyright 2018-2024 the oak authors. All rights reserved. MIT license.
// This module is browser compatible.
var _ServerSentEvent_data, _ServerSentEvent_id, _ServerSentEvent_type, _ServerSentEventStreamTarget_instances, _ServerSentEventStreamTarget_bodyInit, _ServerSentEventStreamTarget_closed, _ServerSentEventStreamTarget_controller, _ServerSentEventStreamTarget_keepAliveId, _ServerSentEventStreamTarget_error, _ServerSentEventStreamTarget_push;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerSentEventStreamTarget = exports.ServerSentEvent = void 0;
const tslib_1 = require("tslib");
/**
 * Provides {@linkcode ServerSentEvent} and
 * {@linkcode ServerSentEventStreamTarget} which provides an interface to send
 * server sent events to a browser using the DOM event model.
 *
 * The {@linkcode ServerSentEventStreamTarget} provides the `.asResponse()` or
 * `.asResponseInit()` to provide a body and headers to the client to establish
 * the event connection. This is accomplished by keeping a connection open to
 * the client by not closing the body, which allows events to be sent down the
 * connection and processed by the client browser.
 *
 * See more about Server-sent events on [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events)
 *
 * ## Example
 *
 * ```ts
 * import {
 *   ServerSentEvent,
 *   ServerSentEventStreamTarget,
 * } from "https://deno.land/std@$STD_VERSION/http/unstable_server_sent_event.ts";
 *
 * Deno.serve({ port: 8000 }, (request) => {
 *   const target = new ServerSentEventStreamTarget();
 *   let counter = 0;
 *
 *   // Sends an event every 2 seconds, incrementing the ID
 *   const id = setInterval(() => {
 *     const evt = new ServerSentEvent(
 *       "message",
 *       { data: { hello: "world" }, id: counter++ },
 *     );
 *     target.dispatchEvent(evt);
 *   }, 2000);
 *
 *   target.addEventListener("close", () => clearInterval(id));
 *   return target.asResponse();
 * });
 * ```
 *
 * @module
 */
const dntShim = tslib_1.__importStar(require("../../../../_dnt.shims.js"));
const deps_js_1 = require("./deps.js");
const encoder = new TextEncoder();
const DEFAULT_KEEP_ALIVE_INTERVAL = 30000;
class CloseEvent extends Event {
    constructor(eventInit) {
        super("close", eventInit);
    }
}
/**
 * An event which contains information which will be sent to the remote
 * connection and be made available in an `EventSource` as an event. A server
 * creates new events and dispatches them on the target which will then be
 * sent to a client.
 *
 * See more about Server-sent events on [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events)
 *
 * ### Example
 *
 * ```ts
 * import {
 *   ServerSentEvent,
 *   ServerSentEventStreamTarget,
 * } from "https://deno.land/std@$STD_VERSION/http/server_sent_event.ts";
 *
 * Deno.serve({ port: 8000 }, (request) => {
 *   const target = new ServerSentEventStreamTarget();
 *   const evt = new ServerSentEvent("message", {
 *     data: { hello: "world" },
 *     id: 1
 *   });
 *   target.dispatchEvent(evt);
 *   return target.asResponse();
 * });
 * ```
 */
class ServerSentEvent extends Event {
    /**
     * @param type the event type that will be available on the client. The type
     *             of `"message"` will be handled specifically as a message
     *             server-side event.
     * @param eventInit initialization options for the event
     */
    constructor(type, eventInit = {}) {
        super(type, eventInit);
        _ServerSentEvent_data.set(this, void 0);
        _ServerSentEvent_id.set(this, void 0);
        _ServerSentEvent_type.set(this, void 0);
        const { data, replacer, space } = eventInit;
        tslib_1.__classPrivateFieldSet(this, _ServerSentEvent_type, type, "f");
        try {
            tslib_1.__classPrivateFieldSet(this, _ServerSentEvent_data, typeof data === "string"
                ? data
                : data !== undefined
                    ? JSON.stringify(data, replacer, space)
                    : "", "f");
        }
        catch (e) {
            (0, deps_js_1.assert)(e instanceof Error);
            throw new TypeError(`data could not be coerced into a serialized string.\n  ${e.message}`);
        }
        const { id } = eventInit;
        tslib_1.__classPrivateFieldSet(this, _ServerSentEvent_id, id, "f");
    }
    /** The data associated with the event, which will be sent to the client and
     * be made available in the `EventSource`. */
    get data() {
        return tslib_1.__classPrivateFieldGet(this, _ServerSentEvent_data, "f");
    }
    /** The optional ID associated with the event that will be sent to the client
     * and be made available in the `EventSource`. */
    get id() {
        return tslib_1.__classPrivateFieldGet(this, _ServerSentEvent_id, "f");
    }
    toString() {
        const data = `data: ${tslib_1.__classPrivateFieldGet(this, _ServerSentEvent_data, "f").split("\n").join("\ndata: ")}\n`;
        return `${tslib_1.__classPrivateFieldGet(this, _ServerSentEvent_type, "f") === "__message" ? "" : `event: ${tslib_1.__classPrivateFieldGet(this, _ServerSentEvent_type, "f")}\n`}${tslib_1.__classPrivateFieldGet(this, _ServerSentEvent_id, "f") ? `id: ${String(tslib_1.__classPrivateFieldGet(this, _ServerSentEvent_id, "f"))}\n` : ""}${data}\n`;
    }
}
exports.ServerSentEvent = ServerSentEvent;
_ServerSentEvent_data = new WeakMap(), _ServerSentEvent_id = new WeakMap(), _ServerSentEvent_type = new WeakMap();
const RESPONSE_HEADERS = [
    ["Connection", "Keep-Alive"],
    ["Content-Type", "text/event-stream"],
    ["Cache-Control", "no-cache"],
    ["Keep-Alive", `timeout=${Number.MAX_SAFE_INTEGER}`],
];
/**
 * An implementation of {@linkcode ServerSentEventTarget} that provides a
 * readable stream as a body of a response to establish a connection to a
 * client.
 */
class ServerSentEventStreamTarget extends EventTarget {
    get closed() {
        return tslib_1.__classPrivateFieldGet(this, _ServerSentEventStreamTarget_closed, "f");
    }
    constructor({ keepAlive = false } = {}) {
        super();
        _ServerSentEventStreamTarget_instances.add(this);
        _ServerSentEventStreamTarget_bodyInit.set(this, void 0);
        _ServerSentEventStreamTarget_closed.set(this, false);
        _ServerSentEventStreamTarget_controller.set(this, void 0);
        // we are ignoring any here, because when exporting to npm/Node.js, the timer
        // handle isn't a number.
        // deno-lint-ignore no-explicit-any
        _ServerSentEventStreamTarget_keepAliveId.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _ServerSentEventStreamTarget_bodyInit, new dntShim.ReadableStream({
            start: (controller) => {
                tslib_1.__classPrivateFieldSet(this, _ServerSentEventStreamTarget_controller, controller, "f");
            },
            cancel: (error) => {
                // connections closing are considered "normal" for SSE events and just
                // mean the far side has closed.
                if (error instanceof Error && error.message.includes("connection closed")) {
                    this.close();
                }
                else {
                    tslib_1.__classPrivateFieldGet(this, _ServerSentEventStreamTarget_instances, "m", _ServerSentEventStreamTarget_error).call(this, error);
                }
            },
        }), "f");
        this.addEventListener("close", () => {
            tslib_1.__classPrivateFieldSet(this, _ServerSentEventStreamTarget_closed, true, "f");
            if (tslib_1.__classPrivateFieldGet(this, _ServerSentEventStreamTarget_keepAliveId, "f") !== null && tslib_1.__classPrivateFieldGet(this, _ServerSentEventStreamTarget_keepAliveId, "f") !== undefined) {
                clearInterval(tslib_1.__classPrivateFieldGet(this, _ServerSentEventStreamTarget_keepAliveId, "f"));
                tslib_1.__classPrivateFieldSet(this, _ServerSentEventStreamTarget_keepAliveId, undefined, "f");
            }
            if (tslib_1.__classPrivateFieldGet(this, _ServerSentEventStreamTarget_controller, "f")) {
                try {
                    tslib_1.__classPrivateFieldGet(this, _ServerSentEventStreamTarget_controller, "f").close();
                }
                catch {
                    // we ignore any errors here, as it is likely that the controller
                    // is already closed
                }
            }
        });
        if (keepAlive) {
            const interval = typeof keepAlive === "number"
                ? keepAlive
                : DEFAULT_KEEP_ALIVE_INTERVAL;
            tslib_1.__classPrivateFieldSet(this, _ServerSentEventStreamTarget_keepAliveId, setInterval(() => {
                this.dispatchComment("keep-alive comment");
            }, interval), "f");
        }
    }
    /** Returns a {@linkcode Response} which contains the body and headers needed
     * to initiate a SSE connection with the client. */
    asResponse(responseInit) {
        return new dntShim.Response(...this.asResponseInit(responseInit));
    }
    /** Returns a tuple which contains the {@linkcode BodyInit} and
     * {@linkcode ResponseInit} needed to create a response that will establish
     * a SSE connection with the client. */
    asResponseInit(responseInit = {}) {
        const headers = new dntShim.Headers(responseInit.headers);
        for (const [key, value] of RESPONSE_HEADERS) {
            headers.set(key, value);
        }
        responseInit.headers = headers;
        return [tslib_1.__classPrivateFieldGet(this, _ServerSentEventStreamTarget_bodyInit, "f"), responseInit];
    }
    close() {
        this.dispatchEvent(new CloseEvent({ cancelable: false }));
        return Promise.resolve();
    }
    dispatchComment(comment) {
        tslib_1.__classPrivateFieldGet(this, _ServerSentEventStreamTarget_instances, "m", _ServerSentEventStreamTarget_push).call(this, `: ${comment.split("\n").join("\n: ")}\n\n`);
        return true;
    }
    // deno-lint-ignore no-explicit-any
    dispatchMessage(data) {
        const event = new ServerSentEvent("__message", { data });
        return this.dispatchEvent(event);
    }
    dispatchEvent(event) {
        const dispatched = super.dispatchEvent(event);
        if (dispatched && event instanceof ServerSentEvent) {
            tslib_1.__classPrivateFieldGet(this, _ServerSentEventStreamTarget_instances, "m", _ServerSentEventStreamTarget_push).call(this, String(event));
        }
        return dispatched;
    }
    [(_ServerSentEventStreamTarget_bodyInit = new WeakMap(), _ServerSentEventStreamTarget_closed = new WeakMap(), _ServerSentEventStreamTarget_controller = new WeakMap(), _ServerSentEventStreamTarget_keepAliveId = new WeakMap(), _ServerSentEventStreamTarget_instances = new WeakSet(), _ServerSentEventStreamTarget_error = function _ServerSentEventStreamTarget_error(error) {
        this.dispatchEvent(new CloseEvent({ cancelable: false }));
        const errorEvent = new dntShim.ErrorEvent("error", { error });
        this.dispatchEvent(errorEvent);
    }, _ServerSentEventStreamTarget_push = function _ServerSentEventStreamTarget_push(payload) {
        if (!tslib_1.__classPrivateFieldGet(this, _ServerSentEventStreamTarget_controller, "f")) {
            tslib_1.__classPrivateFieldGet(this, _ServerSentEventStreamTarget_instances, "m", _ServerSentEventStreamTarget_error).call(this, new Error("The controller has not been set."));
            return;
        }
        if (tslib_1.__classPrivateFieldGet(this, _ServerSentEventStreamTarget_closed, "f")) {
            return;
        }
        tslib_1.__classPrivateFieldGet(this, _ServerSentEventStreamTarget_controller, "f").enqueue(encoder.encode(payload));
    }, Symbol.for("Deno.customInspect"))](inspect) {
        return `${this.constructor.name} ${inspect({ "#bodyInit": tslib_1.__classPrivateFieldGet(this, _ServerSentEventStreamTarget_bodyInit, "f"), "#closed": tslib_1.__classPrivateFieldGet(this, _ServerSentEventStreamTarget_closed, "f") })}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, 
    // deno-lint-ignore no-explicit-any
    options, inspect) {
        if (depth < 0) {
            return options.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options, {
            depth: options.depth === null ? null : options.depth - 1,
        });
        return `${options.stylize(this.constructor.name, "special")} ${inspect({ "#bodyInit": tslib_1.__classPrivateFieldGet(this, _ServerSentEventStreamTarget_bodyInit, "f"), "#closed": tslib_1.__classPrivateFieldGet(this, _ServerSentEventStreamTarget_closed, "f") }, newOptions)}`;
    }
}
exports.ServerSentEventStreamTarget = ServerSentEventStreamTarget;
