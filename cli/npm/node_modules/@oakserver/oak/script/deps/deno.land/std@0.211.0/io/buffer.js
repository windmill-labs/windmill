"use strict";
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
var _Buffer_instances, _Buffer_buf, _Buffer_off, _Buffer_tryGrowByReslice, _Buffer_reslice, _Buffer_grow;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Buffer = void 0;
const tslib_1 = require("tslib");
const assert_js_1 = require("../assert/assert.js");
const copy_js_1 = require("../bytes/copy.js");
// MIN_READ is the minimum ArrayBuffer size passed to a read call by
// buffer.ReadFrom. As long as the Buffer has at least MIN_READ bytes beyond
// what is required to hold the contents of r, readFrom() will not grow the
// underlying buffer.
const MIN_READ = 32 * 1024;
const MAX_SIZE = 2 ** 32 - 2;
/** A variable-sized buffer of bytes with `read()` and `write()` methods.
 *
 * Buffer is almost always used with some I/O like files and sockets. It allows
 * one to buffer up a download from a socket. Buffer grows and shrinks as
 * necessary.
 *
 * Buffer is NOT the same thing as Node's Buffer. Node's Buffer was created in
 * 2009 before JavaScript had the concept of ArrayBuffers. It's simply a
 * non-standard ArrayBuffer.
 *
 * ArrayBuffer is a fixed memory allocation. Buffer is implemented on top of
 * ArrayBuffer.
 *
 * Based on [Go Buffer](https://golang.org/pkg/bytes/#Buffer).
 *
 * @deprecated (will be removed after 1.0.0) Use the [Web Streams API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Streams_API} instead.
 */
class Buffer {
    constructor(ab) {
        _Buffer_instances.add(this);
        _Buffer_buf.set(this, void 0); // contents are the bytes buf[off : len(buf)]
        _Buffer_off.set(this, 0); // read at buf[off], write at buf[buf.byteLength]
        tslib_1.__classPrivateFieldSet(this, _Buffer_buf, ab === undefined ? new Uint8Array(0) : new Uint8Array(ab), "f");
    }
    /** Returns a slice holding the unread portion of the buffer.
     *
     * The slice is valid for use only until the next buffer modification (that
     * is, only until the next call to a method like `read()`, `write()`,
     * `reset()`, or `truncate()`). If `options.copy` is false the slice aliases the buffer content at
     * least until the next buffer modification, so immediate changes to the
     * slice will affect the result of future reads.
     * @param [options={ copy: true }]
     */
    bytes(options = { copy: true }) {
        if (options.copy === false)
            return tslib_1.__classPrivateFieldGet(this, _Buffer_buf, "f").subarray(tslib_1.__classPrivateFieldGet(this, _Buffer_off, "f"));
        return tslib_1.__classPrivateFieldGet(this, _Buffer_buf, "f").slice(tslib_1.__classPrivateFieldGet(this, _Buffer_off, "f"));
    }
    /** Returns whether the unread portion of the buffer is empty. */
    empty() {
        return tslib_1.__classPrivateFieldGet(this, _Buffer_buf, "f").byteLength <= tslib_1.__classPrivateFieldGet(this, _Buffer_off, "f");
    }
    /** A read only number of bytes of the unread portion of the buffer. */
    get length() {
        return tslib_1.__classPrivateFieldGet(this, _Buffer_buf, "f").byteLength - tslib_1.__classPrivateFieldGet(this, _Buffer_off, "f");
    }
    /** The read only capacity of the buffer's underlying byte slice, that is,
     * the total space allocated for the buffer's data. */
    get capacity() {
        return tslib_1.__classPrivateFieldGet(this, _Buffer_buf, "f").buffer.byteLength;
    }
    /** Discards all but the first `n` unread bytes from the buffer but
     * continues to use the same allocated storage. It throws if `n` is
     * negative or greater than the length of the buffer. */
    truncate(n) {
        if (n === 0) {
            this.reset();
            return;
        }
        if (n < 0 || n > this.length) {
            throw Error("bytes.Buffer: truncation out of range");
        }
        tslib_1.__classPrivateFieldGet(this, _Buffer_instances, "m", _Buffer_reslice).call(this, tslib_1.__classPrivateFieldGet(this, _Buffer_off, "f") + n);
    }
    reset() {
        tslib_1.__classPrivateFieldGet(this, _Buffer_instances, "m", _Buffer_reslice).call(this, 0);
        tslib_1.__classPrivateFieldSet(this, _Buffer_off, 0, "f");
    }
    /** Reads the next `p.length` bytes from the buffer or until the buffer is
     * drained. Returns the number of bytes read. If the buffer has no data to
     * return, the return is EOF (`null`). */
    readSync(p) {
        if (this.empty()) {
            // Buffer is empty, reset to recover space.
            this.reset();
            if (p.byteLength === 0) {
                // this edge case is tested in 'bufferReadEmptyAtEOF' test
                return 0;
            }
            return null;
        }
        const nread = (0, copy_js_1.copy)(tslib_1.__classPrivateFieldGet(this, _Buffer_buf, "f").subarray(tslib_1.__classPrivateFieldGet(this, _Buffer_off, "f")), p);
        tslib_1.__classPrivateFieldSet(this, _Buffer_off, tslib_1.__classPrivateFieldGet(this, _Buffer_off, "f") + nread, "f");
        return nread;
    }
    /** Reads the next `p.length` bytes from the buffer or until the buffer is
     * drained. Resolves to the number of bytes read. If the buffer has no
     * data to return, resolves to EOF (`null`).
     *
     * NOTE: This methods reads bytes synchronously; it's provided for
     * compatibility with `Reader` interfaces.
     */
    read(p) {
        const rr = this.readSync(p);
        return Promise.resolve(rr);
    }
    writeSync(p) {
        const m = tslib_1.__classPrivateFieldGet(this, _Buffer_instances, "m", _Buffer_grow).call(this, p.byteLength);
        return (0, copy_js_1.copy)(p, tslib_1.__classPrivateFieldGet(this, _Buffer_buf, "f"), m);
    }
    /** NOTE: This methods writes bytes synchronously; it's provided for
     * compatibility with `Writer` interface. */
    write(p) {
        const n = this.writeSync(p);
        return Promise.resolve(n);
    }
    /** Grows the buffer's capacity, if necessary, to guarantee space for
     * another `n` bytes. After `.grow(n)`, at least `n` bytes can be written to
     * the buffer without another allocation. If `n` is negative, `.grow()` will
     * throw. If the buffer can't grow it will throw an error.
     *
     * Based on Go Lang's
     * [Buffer.Grow](https://golang.org/pkg/bytes/#Buffer.Grow). */
    grow(n) {
        if (n < 0) {
            throw Error("Buffer.grow: negative count");
        }
        const m = tslib_1.__classPrivateFieldGet(this, _Buffer_instances, "m", _Buffer_grow).call(this, n);
        tslib_1.__classPrivateFieldGet(this, _Buffer_instances, "m", _Buffer_reslice).call(this, m);
    }
    /** Reads data from `r` until EOF (`null`) and appends it to the buffer,
     * growing the buffer as needed. It resolves to the number of bytes read.
     * If the buffer becomes too large, `.readFrom()` will reject with an error.
     *
     * Based on Go Lang's
     * [Buffer.ReadFrom](https://golang.org/pkg/bytes/#Buffer.ReadFrom). */
    async readFrom(r) {
        let n = 0;
        const tmp = new Uint8Array(MIN_READ);
        while (true) {
            const shouldGrow = this.capacity - this.length < MIN_READ;
            // read into tmp buffer if there's not enough room
            // otherwise read directly into the internal buffer
            const buf = shouldGrow
                ? tmp
                : new Uint8Array(tslib_1.__classPrivateFieldGet(this, _Buffer_buf, "f").buffer, this.length);
            const nread = await r.read(buf);
            if (nread === null) {
                return n;
            }
            // write will grow if needed
            if (shouldGrow)
                this.writeSync(buf.subarray(0, nread));
            else
                tslib_1.__classPrivateFieldGet(this, _Buffer_instances, "m", _Buffer_reslice).call(this, this.length + nread);
            n += nread;
        }
    }
    /** Reads data from `r` until EOF (`null`) and appends it to the buffer,
     * growing the buffer as needed. It returns the number of bytes read. If the
     * buffer becomes too large, `.readFromSync()` will throw an error.
     *
     * Based on Go Lang's
     * [Buffer.ReadFrom](https://golang.org/pkg/bytes/#Buffer.ReadFrom). */
    readFromSync(r) {
        let n = 0;
        const tmp = new Uint8Array(MIN_READ);
        while (true) {
            const shouldGrow = this.capacity - this.length < MIN_READ;
            // read into tmp buffer if there's not enough room
            // otherwise read directly into the internal buffer
            const buf = shouldGrow
                ? tmp
                : new Uint8Array(tslib_1.__classPrivateFieldGet(this, _Buffer_buf, "f").buffer, this.length);
            const nread = r.readSync(buf);
            if (nread === null) {
                return n;
            }
            // write will grow if needed
            if (shouldGrow)
                this.writeSync(buf.subarray(0, nread));
            else
                tslib_1.__classPrivateFieldGet(this, _Buffer_instances, "m", _Buffer_reslice).call(this, this.length + nread);
            n += nread;
        }
    }
}
exports.Buffer = Buffer;
_Buffer_buf = new WeakMap(), _Buffer_off = new WeakMap(), _Buffer_instances = new WeakSet(), _Buffer_tryGrowByReslice = function _Buffer_tryGrowByReslice(n) {
    const l = tslib_1.__classPrivateFieldGet(this, _Buffer_buf, "f").byteLength;
    if (n <= this.capacity - l) {
        tslib_1.__classPrivateFieldGet(this, _Buffer_instances, "m", _Buffer_reslice).call(this, l + n);
        return l;
    }
    return -1;
}, _Buffer_reslice = function _Buffer_reslice(len) {
    (0, assert_js_1.assert)(len <= tslib_1.__classPrivateFieldGet(this, _Buffer_buf, "f").buffer.byteLength);
    tslib_1.__classPrivateFieldSet(this, _Buffer_buf, new Uint8Array(tslib_1.__classPrivateFieldGet(this, _Buffer_buf, "f").buffer, 0, len), "f");
}, _Buffer_grow = function _Buffer_grow(n) {
    const m = this.length;
    // If buffer is empty, reset to recover space.
    if (m === 0 && tslib_1.__classPrivateFieldGet(this, _Buffer_off, "f") !== 0) {
        this.reset();
    }
    // Fast: Try to grow by means of a reslice.
    const i = tslib_1.__classPrivateFieldGet(this, _Buffer_instances, "m", _Buffer_tryGrowByReslice).call(this, n);
    if (i >= 0) {
        return i;
    }
    const c = this.capacity;
    if (n <= Math.floor(c / 2) - m) {
        // We can slide things down instead of allocating a new
        // ArrayBuffer. We only need m+n <= c to slide, but
        // we instead let capacity get twice as large so we
        // don't spend all our time copying.
        (0, copy_js_1.copy)(tslib_1.__classPrivateFieldGet(this, _Buffer_buf, "f").subarray(tslib_1.__classPrivateFieldGet(this, _Buffer_off, "f")), tslib_1.__classPrivateFieldGet(this, _Buffer_buf, "f"));
    }
    else if (c + n > MAX_SIZE) {
        throw new Error("The buffer cannot be grown beyond the maximum size.");
    }
    else {
        // Not enough space anywhere, we need to allocate.
        const buf = new Uint8Array(Math.min(2 * c + n, MAX_SIZE));
        (0, copy_js_1.copy)(tslib_1.__classPrivateFieldGet(this, _Buffer_buf, "f").subarray(tslib_1.__classPrivateFieldGet(this, _Buffer_off, "f")), buf);
        tslib_1.__classPrivateFieldSet(this, _Buffer_buf, buf, "f");
    }
    // Restore this.#off and len(this.#buf).
    tslib_1.__classPrivateFieldSet(this, _Buffer_off, 0, "f");
    tslib_1.__classPrivateFieldGet(this, _Buffer_instances, "m", _Buffer_reslice).call(this, Math.min(m + n, MAX_SIZE));
    return m;
};
