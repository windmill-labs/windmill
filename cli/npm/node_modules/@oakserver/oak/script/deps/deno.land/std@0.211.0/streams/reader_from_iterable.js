"use strict";
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
Object.defineProperty(exports, "__esModule", { value: true });
exports.readerFromIterable = void 0;
const buffer_js_1 = require("../io/buffer.js");
const write_all_js_1 = require("./write_all.js");
/**
 * Create a {@linkcode Reader} from an iterable of {@linkcode Uint8Array}s.
 *
 * ```ts
 * import { readerFromIterable } from "https://deno.land/std@$STD_VERSION/streams/reader_from_iterable.ts";
 * import { copy } from "https://deno.land/std@$STD_VERSION/streams/copy.ts";
 *
 * const file = await Deno.open("metrics.txt", { write: true });
 * const reader = readerFromIterable((async function* () {
 *   while (true) {
 *     await new Promise((r) => setTimeout(r, 1000));
 *     const message = `data: ${JSON.stringify(Deno.metrics())}\n\n`;
 *     yield new TextEncoder().encode(message);
 *   }
 * })());
 * await copy(reader, file);
 * ```
 *
 * @deprecated (will be removed after 1.0.0) Use {@linkcode ReadableStream.from} instead.
 */
function readerFromIterable(iterable) {
    const iterator = iterable[Symbol.asyncIterator]?.() ??
        iterable[Symbol.iterator]?.();
    const buffer = new buffer_js_1.Buffer();
    return {
        async read(p) {
            if (buffer.length === 0) {
                const result = await iterator.next();
                if (result.done) {
                    return null;
                }
                else {
                    if (result.value.byteLength <= p.byteLength) {
                        p.set(result.value);
                        return result.value.byteLength;
                    }
                    p.set(result.value.subarray(0, p.byteLength));
                    await (0, write_all_js_1.writeAll)(buffer, result.value.subarray(p.byteLength));
                    return p.byteLength;
                }
            }
            else {
                const n = await buffer.read(p);
                if (n === null) {
                    return this.read(p);
                }
                return n;
            }
        },
    };
}
exports.readerFromIterable = readerFromIterable;
