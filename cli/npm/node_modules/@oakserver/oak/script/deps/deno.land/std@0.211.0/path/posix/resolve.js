"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolve = void 0;
const tslib_1 = require("tslib");
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
const dntShim = tslib_1.__importStar(require("../../../../../_dnt.shims.js"));
const normalize_string_js_1 = require("../_common/normalize_string.js");
const assert_path_js_1 = require("../_common/assert_path.js");
const _util_js_1 = require("./_util.js");
/**
 * Resolves path segments into a `path`
 * @param pathSegments to process to path
 */
function resolve(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        let path;
        if (i >= 0)
            path = pathSegments[i];
        else {
            // deno-lint-ignore no-explicit-any
            const { Deno } = dntShim.dntGlobalThis;
            if (typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno.cwd();
        }
        (0, assert_path_js_1.assertPath)(path);
        // Skip empty entries
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = (0, _util_js_1.isPosixPathSeparator)(path.charCodeAt(0));
    }
    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when Deno.cwd() fails)
    // Normalize the path
    resolvedPath = (0, normalize_string_js_1.normalizeString)(resolvedPath, !resolvedAbsolute, "/", _util_js_1.isPosixPathSeparator);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0)
            return `/${resolvedPath}`;
        else
            return "/";
    }
    else if (resolvedPath.length > 0)
        return resolvedPath;
    else
        return ".";
}
exports.resolve = resolve;
