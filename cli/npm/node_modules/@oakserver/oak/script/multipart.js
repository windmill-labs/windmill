"use strict";
var _FormDataReader_body, _FormDataReader_boundaryFinal, _FormDataReader_boundaryPart, _FormDataReader_reading;
Object.defineProperty(exports, "__esModule", { value: true });
exports.FormDataReader = void 0;
const tslib_1 = require("tslib");
// Copyright 2018-2023 the oak authors. All rights reserved. MIT license.
const dntShim = tslib_1.__importStar(require("./_dnt.shims.js"));
const buf_reader_js_1 = require("./buf_reader.js");
const content_disposition_js_1 = require("./content_disposition.js");
const deps_js_1 = require("./deps.js");
const headers_js_1 = require("./headers.js");
const util_js_1 = require("./util.js");
const decoder = new TextDecoder();
const encoder = new TextEncoder();
const BOUNDARY_PARAM_REGEX = (0, headers_js_1.toParamRegExp)("boundary", "i");
const DEFAULT_BUFFER_SIZE = 1048576; // 1mb
const DEFAULT_MAX_FILE_SIZE = 10485760; // 10mb
const DEFAULT_MAX_SIZE = 0; // all files written to disc
const NAME_PARAM_REGEX = (0, headers_js_1.toParamRegExp)("name", "i");
function append(a, b) {
    const ab = new Uint8Array(a.length + b.length);
    ab.set(a, 0);
    ab.set(b, a.length);
    return ab;
}
function isEqual(a, b) {
    return (0, deps_js_1.equals)((0, util_js_1.skipLWSPChar)(a), b);
}
async function readToStartOrEnd(body, start, end) {
    let lineResult;
    while ((lineResult = await body.readLine())) {
        if (isEqual(lineResult.bytes, start)) {
            return true;
        }
        if (isEqual(lineResult.bytes, end)) {
            return false;
        }
    }
    throw new deps_js_1.errors.BadRequest("Unable to find multi-part boundary.");
}
/** Yield up individual parts by reading the body and parsing out the ford
 * data values. */
async function* parts({ body, customContentTypes = {}, final, part, maxFileSize, maxSize, outPath, prefix, }) {
    async function getFile(contentType) {
        const ext = customContentTypes[contentType.toLowerCase()] ??
            (0, deps_js_1.extension)(contentType);
        if (!ext) {
            throw new deps_js_1.errors.BadRequest(`The form contained content type "${contentType}" which is not supported by the server.`);
        }
        if (!outPath) {
            outPath = await dntShim.Deno.makeTempDir();
        }
        const filename = `${outPath}/${await (0, util_js_1.getRandomFilename)(prefix, ext)}`;
        const file = await dntShim.Deno.open(filename, { write: true, createNew: true });
        return [filename, file];
    }
    while (true) {
        const headers = await (0, headers_js_1.readHeaders)(body);
        const contentType = headers["content-type"];
        const contentDisposition = headers["content-disposition"];
        if (!contentDisposition) {
            throw new deps_js_1.errors.BadRequest("Form data part missing content-disposition header");
        }
        if (!contentDisposition.match(/^form-data;/i)) {
            throw new deps_js_1.errors.BadRequest(`Unexpected content-disposition header: "${contentDisposition}"`);
        }
        const matches = NAME_PARAM_REGEX.exec(contentDisposition);
        if (!matches) {
            throw new deps_js_1.errors.BadRequest(`Unable to determine name of form body part`);
        }
        let [, name] = matches;
        name = (0, headers_js_1.unquote)(name);
        if (contentType) {
            const originalName = (0, content_disposition_js_1.getFilename)(contentDisposition);
            let byteLength = 0;
            let file;
            let filename;
            let buf;
            if (maxSize) {
                buf = new Uint8Array();
            }
            else {
                const result = await getFile(contentType);
                filename = result[0];
                file = result[1];
            }
            while (true) {
                const readResult = await body.readLine(false);
                if (!readResult) {
                    throw new deps_js_1.errors.BadRequest("Unexpected EOF reached");
                }
                const { bytes } = readResult;
                const strippedBytes = (0, util_js_1.stripEol)(bytes);
                if (isEqual(strippedBytes, part) || isEqual(strippedBytes, final)) {
                    if (file) {
                        // remove extra 2 bytes ([CR, LF]) from result file
                        const bytesDiff = bytes.length - strippedBytes.length;
                        if (bytesDiff) {
                            const originalBytesSize = await file.seek(-bytesDiff, dntShim.Deno.SeekMode.Current);
                            await file.truncate(originalBytesSize);
                        }
                        file.close();
                    }
                    yield [
                        name,
                        {
                            content: buf,
                            contentType,
                            name,
                            filename,
                            originalName,
                        },
                    ];
                    if (isEqual(strippedBytes, final)) {
                        return;
                    }
                    break;
                }
                byteLength += bytes.byteLength;
                if (byteLength > maxFileSize) {
                    if (file) {
                        file.close();
                    }
                    throw new deps_js_1.errors.RequestEntityTooLarge(`File size exceeds limit of ${maxFileSize} bytes.`);
                }
                if (buf) {
                    if (byteLength > maxSize) {
                        const result = await getFile(contentType);
                        filename = result[0];
                        file = result[1];
                        await (0, deps_js_1.writeAll)(file, buf);
                        buf = undefined;
                    }
                    else {
                        buf = append(buf, bytes);
                    }
                }
                if (file) {
                    await (0, deps_js_1.writeAll)(file, bytes);
                }
            }
        }
        else {
            const lines = [];
            while (true) {
                const readResult = await body.readLine();
                if (!readResult) {
                    throw new deps_js_1.errors.BadRequest("Unexpected EOF reached");
                }
                const { bytes } = readResult;
                if (isEqual(bytes, part) || isEqual(bytes, final)) {
                    yield [name, lines.join("\n")];
                    if (isEqual(bytes, final)) {
                        return;
                    }
                    break;
                }
                lines.push(decoder.decode(bytes));
            }
        }
    }
}
/** An interface which provides an interface to access the fields of a
 * `multipart/form-data` body.
 *
 * Normally an instance of this is accessed when handling a request body, and
 * dealing with decoding it.  There are options that can be set when attempting
 * to read a multi-part body (see: {@linkcode FormDataReadOptions}).
 *
 * If you `.read()` the value, then a promise is provided of type
 * {@linkcode FormDataBody}. If you use the `.stream()` property, it is an async
 * iterator which yields up a tuple of with the first element being a
 *
 * ### Examples
 *
 * Using `.read()`:
 *
 * ```ts
 * import { Application } from "https://deno.land/x/oak/mod.ts";
 *
 * const app = new Application();
 *
 * app.use(async (ctx) => {
 *   const body = ctx.request.body();
 *   if (body.type === "form-data") {
 *     const value = body.value;
 *     const formData = await value.read();
 *     // the form data is fully available
 *   }
 * });
 * ```
 *
 *  Using `.stream()`:
 *
 * ```ts
 * import { Application } from "https://deno.land/x/oak/mod.ts";
 *
 * const app = new Application();
 *
 * app.use(async (ctx) => {
 *   const body = ctx.request.body();
 *   if (body.type === "form-data") {
 *     const value = body.value;
 *     for await (const [name, value] of value.stream()) {
 *       // asynchronously iterate each part of the body
 *     }
 *   }
 * });
 * ```
 */
class FormDataReader {
    constructor(contentType, body) {
        _FormDataReader_body.set(this, void 0);
        _FormDataReader_boundaryFinal.set(this, void 0);
        _FormDataReader_boundaryPart.set(this, void 0);
        _FormDataReader_reading.set(this, false);
        const matches = contentType.match(BOUNDARY_PARAM_REGEX);
        if (!matches) {
            throw new deps_js_1.errors.BadRequest(`Content type "${contentType}" does not contain a valid boundary.`);
        }
        let [, boundary] = matches;
        boundary = (0, headers_js_1.unquote)(boundary);
        tslib_1.__classPrivateFieldSet(this, _FormDataReader_boundaryPart, encoder.encode(`--${boundary}`), "f");
        tslib_1.__classPrivateFieldSet(this, _FormDataReader_boundaryFinal, encoder.encode(`--${boundary}--`), "f");
        tslib_1.__classPrivateFieldSet(this, _FormDataReader_body, body, "f");
    }
    /** Reads the multipart body of the response and resolves with an object which
     * contains fields and files that were part of the response.
     *
     * *Note*: this method handles multiple files with the same `name` attribute
     * in the request, but by design it does not handle multiple fields that share
     * the same `name`.  If you expect the request body to contain multiple form
     * data fields with the same name, it is better to use the `.stream()` method
     * which will iterate over each form data field individually. */
    async read(options = {}) {
        if (tslib_1.__classPrivateFieldGet(this, _FormDataReader_reading, "f")) {
            throw new Error("Body is already being read.");
        }
        tslib_1.__classPrivateFieldSet(this, _FormDataReader_reading, true, "f");
        const { outPath, maxFileSize = DEFAULT_MAX_FILE_SIZE, maxSize = DEFAULT_MAX_SIZE, bufferSize = DEFAULT_BUFFER_SIZE, customContentTypes, } = options;
        const body = new buf_reader_js_1.BufReader(tslib_1.__classPrivateFieldGet(this, _FormDataReader_body, "f"), bufferSize);
        const result = { fields: {} };
        if (!(await readToStartOrEnd(body, tslib_1.__classPrivateFieldGet(this, _FormDataReader_boundaryPart, "f"), tslib_1.__classPrivateFieldGet(this, _FormDataReader_boundaryFinal, "f")))) {
            return result;
        }
        try {
            for await (const part of parts({
                body,
                customContentTypes,
                part: tslib_1.__classPrivateFieldGet(this, _FormDataReader_boundaryPart, "f"),
                final: tslib_1.__classPrivateFieldGet(this, _FormDataReader_boundaryFinal, "f"),
                maxFileSize,
                maxSize,
                outPath,
            })) {
                const [key, value] = part;
                if (typeof value === "string") {
                    result.fields[key] = value;
                }
                else {
                    if (!result.files) {
                        result.files = [];
                    }
                    result.files.push(value);
                }
            }
        }
        catch (err) {
            if (err instanceof dntShim.Deno.errors.PermissionDenied) {
                console.error(err.stack ? err.stack : `${err.name}: ${err.message}`);
            }
            else {
                throw err;
            }
        }
        return result;
    }
    /** Returns an iterator which will asynchronously yield each part of the form
     * data.  The yielded value is a tuple, where the first element is the name
     * of the part and the second element is a `string` or a `FormDataFile`
     * object. */
    async *stream(options = {}) {
        if (tslib_1.__classPrivateFieldGet(this, _FormDataReader_reading, "f")) {
            throw new Error("Body is already being read.");
        }
        tslib_1.__classPrivateFieldSet(this, _FormDataReader_reading, true, "f");
        const { outPath, customContentTypes, maxFileSize = DEFAULT_MAX_FILE_SIZE, maxSize = DEFAULT_MAX_SIZE, bufferSize = 32000, } = options;
        const body = new buf_reader_js_1.BufReader(tslib_1.__classPrivateFieldGet(this, _FormDataReader_body, "f"), bufferSize);
        if (!(await readToStartOrEnd(body, tslib_1.__classPrivateFieldGet(this, _FormDataReader_boundaryPart, "f"), tslib_1.__classPrivateFieldGet(this, _FormDataReader_boundaryFinal, "f")))) {
            return;
        }
        try {
            for await (const part of parts({
                body,
                customContentTypes,
                part: tslib_1.__classPrivateFieldGet(this, _FormDataReader_boundaryPart, "f"),
                final: tslib_1.__classPrivateFieldGet(this, _FormDataReader_boundaryFinal, "f"),
                maxFileSize,
                maxSize,
                outPath,
            })) {
                yield part;
            }
        }
        catch (err) {
            if (err instanceof dntShim.Deno.errors.PermissionDenied) {
                console.error(err.stack ? err.stack : `${err.name}: ${err.message}`);
            }
            else {
                throw err;
            }
        }
    }
    [(_FormDataReader_body = new WeakMap(), _FormDataReader_boundaryFinal = new WeakMap(), _FormDataReader_boundaryPart = new WeakMap(), _FormDataReader_reading = new WeakMap(), Symbol.for("Deno.customInspect"))](inspect) {
        return `${this.constructor.name} ${inspect({})}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, 
    // deno-lint-ignore no-explicit-any
    options, inspect) {
        if (depth < 0) {
            return options.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options, {
            depth: options.depth === null ? null : options.depth - 1,
        });
        return `${options.stylize(this.constructor.name, "special")} ${inspect({}, newOptions)}`;
    }
}
exports.FormDataReader = FormDataReader;
