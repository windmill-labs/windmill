import type { Application, State } from "./application.js";
import { type ErrorStatus, type HttpErrorOptions, SecureCookieMap, type ServerSentEventTarget, type ServerSentEventTargetOptions } from "./deps.js";
import { Request } from "./request.js";
import { Response } from "./response.js";
import { SendOptions } from "./send.js";
import type { ServerRequest, UpgradeWebSocketOptions } from "./types";
export interface ContextOptions<S extends AS = State, AS extends State = Record<string, any>> {
    jsonBodyReplacer?: (key: string, value: unknown, context: Context<S>) => unknown;
    jsonBodyReviver?: (key: string, value: unknown, context: Context<S>) => unknown;
    secure?: boolean;
}
export interface ContextSendOptions extends SendOptions {
    /** The filename to send, which will be resolved based on the other options.
     * If this property is omitted, the current context's `.request.url.pathname`
     * will be used. */
    path?: string;
}
/** Provides context about the current request and response to middleware
 * functions, and the current instance being processed is the first argument
 * provided a {@linkcode Middleware} function.
 *
 * _Typically this is only used as a type annotation and shouldn't be
 * constructed directly._
 *
 * ### Example
 *
 * ```ts
 * import { Application, Context } from "https://deno.land/x/oak/mod.ts";
 *
 * const app = new Application();
 *
 * app.use((ctx) => {
 *   // information about the request is here:
 *   ctx.request;
 *   // information about the response is here:
 *   ctx.response;
 *   // the cookie store is here:
 *   ctx.cookies;
 * });
 *
 * // Needs a type annotation because it cannot be inferred.
 * function mw(ctx: Context) {
 *   // process here...
 * }
 *
 * app.use(mw);
 * ```
 *
 * @template S the state which extends the application state (`AS`)
 * @template AS the type of the state derived from the application
 */
export declare class Context<S extends AS = State, AS extends State = Record<string, any>> {
    #private;
    /** A reference to the current application. */
    app: Application<AS>;
    /** An object which allows access to cookies, mediating both the request and
     * response. */
    cookies: SecureCookieMap;
    /** Is `true` if the current connection is upgradeable to a web socket.
     * Otherwise the value is `false`.  Use `.upgrade()` to upgrade the connection
     * and return the web socket. */
    get isUpgradable(): boolean;
    /** Determines if the request should be responded to.  If `false` when the
     * middleware completes processing, the response will not be sent back to the
     * requestor.  Typically this is used if the middleware will take over low
     * level processing of requests and responses, for example if using web
     * sockets.  This automatically gets set to `false` when the context is
     * upgraded to a web socket via the `.upgrade()` method.
     *
     * The default is `true`. */
    respond: boolean;
    /** An object which contains information about the current request. */
    request: Request;
    /** An object which contains information about the response that will be sent
     * when the middleware finishes processing. */
    response: Response;
    /** If the the current context has been upgraded, then this will be set to
     * with the current web socket, otherwise it is `undefined`. */
    get socket(): WebSocket | undefined;
    /** The object to pass state to front-end views.  This can be typed by
     * supplying the generic state argument when creating a new app.  For
     * example:
     *
     * ```ts
     * const app = new Application<{ foo: string }>();
     * ```
     *
     * Or can be contextually inferred based on setting an initial state object:
     *
     * ```ts
     * const app = new Application({ state: { foo: "bar" } });
     * ```
     *
     * On each request/response cycle, the context's state is cloned from the
     * application state. This means changes to the context's `.state` will be
     * dropped when the request drops, but "defaults" can be applied to the
     * application's state.  Changes to the application's state though won't be
     * reflected until the next request in the context's state.
     */
    state: S;
    constructor(app: Application<AS>, serverRequest: ServerRequest, state: S, { secure, jsonBodyReplacer, jsonBodyReviver, }?: ContextOptions<S, AS>);
    /** Asserts the condition and if the condition fails, creates an HTTP error
     * with the provided status (which defaults to `500`).  The error status by
     * default will be set on the `.response.status`.
     *
     * Because of limitation of TypeScript, any assertion type function requires
     * specific type annotations, so the {@linkcode Context} type should be used
     * even if it can be inferred from the context.
     *
     * ### Example
     *
     * ```ts
     * import { Context, Status } from "https://deno.land/x/oak/mod.ts";
     *
     * export function mw(ctx: Context) {
     *   const body = ctx.request.body();
     *   ctx.assert(body.type === "json", Status.NotAcceptable);
     *   // process the body and send a response...
     * }
     * ```
     */
    assert(condition: any, errorStatus?: ErrorStatus, message?: string, props?: Record<string, unknown> & Omit<HttpErrorOptions, "status">): asserts condition;
    /** Asynchronously fulfill a response with a file from the local file
     * system.
     *
     * If the `options.path` is not supplied, the file to be sent will default
     * to this `.request.url.pathname`.
     *
     * Requires Deno read permission. */
    send(options: ContextSendOptions): Promise<string | undefined>;
    /** Convert the connection to stream events, returning an event target for
     * sending server sent events.  Events dispatched on the returned target will
     * be sent to the client and be available in the client's `EventSource` that
     * initiated the connection.
     *
     * **Note** the body needs to be returned to the client to be able to
     * dispatch events, so dispatching events within the middleware will delay
     * sending the body back to the client.
     *
     * This will set the response body and update response headers to support
     * sending SSE events. Additional middleware should not modify the body.
     */
    sendEvents(options?: ServerSentEventTargetOptions): ServerSentEventTarget;
    /** Create and throw an HTTP Error, which can be used to pass status
     * information which can be caught by other middleware to send more
     * meaningful error messages back to the client.  The passed error status will
     * be set on the `.response.status` by default as well.
     */
    throw(errorStatus: ErrorStatus, message?: string, props?: Record<string, unknown>): never;
    /** Take the current request and upgrade it to a web socket, resolving with
     * the a web standard `WebSocket` object. This will set `.respond` to
     * `false`.  If the socket cannot be upgraded, this method will throw. */
    upgrade(options?: UpgradeWebSocketOptions): WebSocket;
}
