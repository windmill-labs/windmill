/// <reference types="node" />
import * as dntShim from "./_dnt.shims.js";
import type { State } from "./application.js";
import type { Context } from "./context.js";
import type { RouteParams, RouterContext } from "./router.js";
import type { Data, Key } from "./types";
export declare const DEFAULT_CHUNK_SIZE = 16640;
/** Body types which will be coerced into strings before being sent. */
export declare const BODY_TYPES: string[];
export declare function assert(cond: unknown, msg?: string): asserts cond;
/** Safely decode a URI component, where if it fails, instead of throwing,
 * just returns the original string
 */
export declare function decodeComponent(text: string): string;
/** Encodes the url preventing double enconding */
export declare function encodeUrl(url: string): string;
export declare function getRandomFilename(prefix?: string, extension?: string): Promise<string>;
export declare function getBoundary(): Promise<string>;
/** Guard for Async Iterables */
export declare function isAsyncIterable(value: unknown): value is AsyncIterable<unknown>;
export declare function isRouterContext<R extends string, P extends RouteParams<R>, S extends State>(value: Context<S>): value is RouterContext<R, P, S>;
/** Guard for `Deno.Reader`. */
export declare function isReader(value: unknown): value is dntShim.Deno.Reader;
export declare function isConn(value: unknown): value is dntShim.Deno.Conn;
export declare function isListenTlsOptions(value: unknown): value is dntShim.Deno.ListenTlsOptions;
export interface ReadableStreamFromReaderOptions {
    /** If the `reader` is also a `Deno.Closer`, automatically close the `reader`
     * when `EOF` is encountered, or a read error occurs.
     *
     * Defaults to `true`. */
    autoClose?: boolean;
    /** The size of chunks to allocate to read, the default is ~16KiB, which is
     * the maximum size that Deno operations can currently support. */
    chunkSize?: number;
    /** The queuing strategy to create the `ReadableStream` with. */
    strategy?: {
        highWaterMark?: number | undefined;
        size?: undefined;
    };
}
/**
 * Create a `ReadableStream<Uint8Array>` from an `AsyncIterable`.
 */
export declare function readableStreamFromAsyncIterable(source: AsyncIterable<unknown>): dntShim.ReadableStream<Uint8Array>;
/**
 * Create a `ReadableStream<Uint8Array>` from a `Deno.Reader`.
 *
 * When the pull algorithm is called on the stream, a chunk from the reader
 * will be read.  When `null` is returned from the reader, the stream will be
 * closed along with the reader (if it is also a `Deno.Closer`).
 *
 * An example converting a `Deno.FsFile` into a readable stream:
 *
 * ```ts
 * import { readableStreamFromReader } from "https://deno.land/std/io/mod.ts";
 *
 * const file = await Deno.open("./file.txt", { read: true });
 * const fileStream = readableStreamFromReader(file);
 * ```
 */
export declare function readableStreamFromReader(reader: dntShim.Deno.Reader | (dntShim.Deno.Reader & dntShim.Deno.Closer), options?: ReadableStreamFromReaderOptions): dntShim.ReadableStream<Uint8Array>;
/** Determines if a string "looks" like HTML */
export declare function isHtml(value: string): boolean;
/** Returns `u8` with leading white space removed. */
export declare function skipLWSPChar(u8: Uint8Array): Uint8Array;
export declare function stripEol(value: Uint8Array): Uint8Array;
export declare function resolvePath(relativePath: string): string;
export declare function resolvePath(rootPath: string, relativePath: string): string;
/** A utility class that transforms "any" chunk into an `Uint8Array`. */
export declare class Uint8ArrayTransformStream extends dntShim.TransformStream<unknown, Uint8Array> {
    constructor();
}
export declare function encodeBase64Safe(data: string | ArrayBuffer): string;
export declare function isNode(): boolean;
export declare function importKey(key: Key): Promise<dntShim.CryptoKey>;
export declare function sign(data: Data, key: dntShim.CryptoKey): Promise<ArrayBuffer>;
