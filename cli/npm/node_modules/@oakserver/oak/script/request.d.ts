import * as dntShim from "./_dnt.shims.js";
import type { Body, BodyBytes, BodyForm, BodyFormData, BodyJson, BodyOptions, BodyReader, BodyStream, BodyText } from "./body.js";
import { type HTTPMethods, UserAgent } from "./deps.js";
import type { ServerRequest } from "./types";
export interface OakRequestOptions {
    jsonBodyReviver?: (key: string, value: unknown) => unknown;
    proxy?: boolean;
    secure?: boolean;
}
/** An interface which provides information about the current request. The
 * instance related to the current request is available on the
 * {@linkcode Context}'s `.request` property.
 *
 * The interface contains several properties to get information about the
 * request as well as several methods, which include content negotiation and
 * the ability to decode a request body.
 */
export declare class Request {
    #private;
    /** Is `true` if the request might have a body, otherwise `false`.
     *
     * **WARNING** this is an unreliable API. In HTTP/2 in many situations you
     * cannot determine if a request has a body or not unless you attempt to read
     * the body, due to the streaming nature of HTTP/2. As of Deno 1.16.1, for
     * HTTP/1.1, Deno also reflects that behaviour.  The only reliable way to
     * determine if a request has a body or not is to attempt to read the body.
     */
    get hasBody(): boolean;
    /** The `Headers` supplied in the request. */
    get headers(): dntShim.Headers;
    /** Request remote address. When the application's `.proxy` is true, the
     * `X-Forwarded-For` will be used to determine the requesting remote address.
     */
    get ip(): string;
    /** When the application's `.proxy` is `true`, this will be set to an array of
     * IPs, ordered from upstream to downstream, based on the value of the header
     * `X-Forwarded-For`.  When `false` an empty array is returned. */
    get ips(): string[];
    /** The HTTP Method used by the request. */
    get method(): HTTPMethods;
    /** Shortcut to `request.url.protocol === "https:"`. */
    get secure(): boolean;
    /** Set to the value of the _original_ Deno server request. */
    get originalRequest(): ServerRequest;
    /** A parsed URL for the request which complies with the browser standards.
     * When the application's `.proxy` is `true`, this value will be based off of
     * the `X-Forwarded-Proto` and `X-Forwarded-Host` header values if present in
     * the request. */
    get url(): URL;
    /** An object representing the requesting user agent. If the `User-Agent`
     * header isn't defined in the request, all the properties will be undefined.
     *
     * See [std/http/user_agent#UserAgent](https://deno.land/std@0.211.0/http/user_agent.ts?s=UserAgent)
     * for more information.
     */
    get userAgent(): UserAgent;
    constructor(serverRequest: ServerRequest, { proxy, secure, jsonBodyReviver }?: OakRequestOptions);
    /** Returns an array of media types, accepted by the requestor, in order of
     * preference.  If there are no encodings supplied by the requestor,
     * then accepting any is implied is returned.
     */
    accepts(): string[] | undefined;
    /** For a given set of media types, return the best match accepted by the
     * requestor.  If there are no encoding that match, then the method returns
     * `undefined`.
     */
    accepts(...types: string[]): string | undefined;
    /** Returns an array of encodings, accepted by the requestor, in order of
     * preference.  If there are no encodings supplied by the requestor,
     * then `["*"]` is returned, matching any.
     */
    acceptsEncodings(): string[] | undefined;
    /** For a given set of encodings, return the best match accepted by the
     * requestor.  If there are no encodings that match, then the method returns
     * `undefined`.
     *
     * **NOTE:** You should always supply `identity` as one of the encodings
     * to ensure that there is a match when the `Accept-Encoding` header is part
     * of the request.
     */
    acceptsEncodings(...encodings: string[]): string | undefined;
    /** Returns an array of languages, accepted by the requestor, in order of
     * preference.  If there are no languages supplied by the requestor,
     * `["*"]` is returned, indicating any language is accepted.
     */
    acceptsLanguages(): string[] | undefined;
    /** For a given set of languages, return the best match accepted by the
     * requestor.  If there are no languages that match, then the method returns
     * `undefined`. */
    acceptsLanguages(...langs: string[]): string | undefined;
    body(options: BodyOptions<"bytes">): BodyBytes;
    body(options: BodyOptions<"form">): BodyForm;
    body(options: BodyOptions<"form-data">): BodyFormData;
    body(options: BodyOptions<"json">): BodyJson;
    body(options: BodyOptions<"reader">): BodyReader;
    body(options: BodyOptions<"stream">): BodyStream;
    body(options: BodyOptions<"text">): BodyText;
    body(options?: BodyOptions): Body;
}
