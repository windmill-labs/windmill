"use strict";
var _RequestBody_instances, _RequestBody_body, _RequestBody_formDataReader, _RequestBody_headers, _RequestBody_jsonBodyReviver, _RequestBody_stream, _RequestBody_readAllBody, _RequestBody_readBody, _RequestBody_type, _RequestBody_exceedsLimit, _RequestBody_parse, _RequestBody_validateGetArgs, _RequestBody_valuePromise;
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestBody = void 0;
const tslib_1 = require("tslib");
// Copyright 2018-2023 the oak authors. All rights reserved. MIT license.
const dntShim = tslib_1.__importStar(require("./_dnt.shims.js"));
const deps_js_1 = require("./deps.js");
const isMediaType_js_1 = require("./isMediaType.js");
const multipart_js_1 = require("./multipart.js");
const util_js_1 = require("./util.js");
const DEFAULT_LIMIT = 10485760; // 10mb
const defaultBodyContentTypes = {
    json: ["json", "application/*+json", "application/csp-report"],
    form: ["urlencoded"],
    formData: ["multipart"],
    text: ["text"],
};
function resolveType(contentType, contentTypes) {
    const contentTypesJson = [
        ...defaultBodyContentTypes.json,
        ...(contentTypes.json ?? []),
    ];
    const contentTypesForm = [
        ...defaultBodyContentTypes.form,
        ...(contentTypes.form ?? []),
    ];
    const contentTypesFormData = [
        ...defaultBodyContentTypes.formData,
        ...(contentTypes.formData ?? []),
    ];
    const contentTypesText = [
        ...defaultBodyContentTypes.text,
        ...(contentTypes.text ?? []),
    ];
    if (contentTypes.bytes && (0, isMediaType_js_1.isMediaType)(contentType, contentTypes.bytes)) {
        return "bytes";
    }
    else if ((0, isMediaType_js_1.isMediaType)(contentType, contentTypesJson)) {
        return "json";
    }
    else if ((0, isMediaType_js_1.isMediaType)(contentType, contentTypesForm)) {
        return "form";
    }
    else if ((0, isMediaType_js_1.isMediaType)(contentType, contentTypesFormData)) {
        return "form-data";
    }
    else if ((0, isMediaType_js_1.isMediaType)(contentType, contentTypesText)) {
        return "text";
    }
    return "bytes";
}
const decoder = new TextDecoder(undefined, { fatal: true });
class RequestBody {
    constructor({ body, readBody }, headers, jsonBodyReviver) {
        _RequestBody_instances.add(this);
        _RequestBody_body.set(this, void 0);
        _RequestBody_formDataReader.set(this, void 0);
        _RequestBody_headers.set(this, void 0);
        _RequestBody_jsonBodyReviver.set(this, void 0);
        _RequestBody_stream.set(this, void 0);
        _RequestBody_readAllBody.set(this, void 0);
        _RequestBody_readBody.set(this, void 0);
        _RequestBody_type.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _RequestBody_body, body, "f");
        tslib_1.__classPrivateFieldSet(this, _RequestBody_headers, headers, "f");
        tslib_1.__classPrivateFieldSet(this, _RequestBody_jsonBodyReviver, jsonBodyReviver, "f");
        tslib_1.__classPrivateFieldSet(this, _RequestBody_readBody, readBody, "f");
    }
    get({ limit = DEFAULT_LIMIT, type, contentTypes = {} } = {}) {
        tslib_1.__classPrivateFieldGet(this, _RequestBody_instances, "m", _RequestBody_validateGetArgs).call(this, type, contentTypes);
        if (type === "reader") {
            if (!tslib_1.__classPrivateFieldGet(this, _RequestBody_body, "f")) {
                tslib_1.__classPrivateFieldSet(this, _RequestBody_type, "undefined", "f");
                throw new TypeError(`Body is undefined and cannot be returned as "reader".`);
            }
            tslib_1.__classPrivateFieldSet(this, _RequestBody_type, "reader", "f");
            return {
                type,
                value: (0, deps_js_1.readerFromStreamReader)(tslib_1.__classPrivateFieldGet(this, _RequestBody_body, "f").getReader()),
            };
        }
        if (type === "stream") {
            if (!tslib_1.__classPrivateFieldGet(this, _RequestBody_body, "f")) {
                tslib_1.__classPrivateFieldSet(this, _RequestBody_type, "undefined", "f");
                throw new TypeError(`Body is undefined and cannot be returned as "stream".`);
            }
            tslib_1.__classPrivateFieldSet(this, _RequestBody_type, "stream", "f");
            const streams = (tslib_1.__classPrivateFieldGet(this, _RequestBody_stream, "f") ?? tslib_1.__classPrivateFieldGet(this, _RequestBody_body, "f"))
                .tee();
            tslib_1.__classPrivateFieldSet(this, _RequestBody_stream, streams[1], "f");
            return { type, value: streams[0] };
        }
        if (!this.has()) {
            tslib_1.__classPrivateFieldSet(this, _RequestBody_type, "undefined", "f");
        }
        else if (!tslib_1.__classPrivateFieldGet(this, _RequestBody_type, "f")) {
            const encoding = tslib_1.__classPrivateFieldGet(this, _RequestBody_headers, "f").get("content-encoding") ??
                "identity";
            if (encoding !== "identity") {
                throw new deps_js_1.errors.UnsupportedMediaType(`Unsupported content-encoding: ${encoding}`);
            }
        }
        if (tslib_1.__classPrivateFieldGet(this, _RequestBody_type, "f") === "undefined" && (!type || type === "undefined")) {
            return { type: "undefined", value: undefined };
        }
        if (!type) {
            const contentType = tslib_1.__classPrivateFieldGet(this, _RequestBody_headers, "f").get("content-type");
            if (!contentType) {
                throw (0, deps_js_1.createHttpError)(deps_js_1.Status.BadRequest, "The Content-Type header is missing from the request");
            }
            type = resolveType(contentType, contentTypes);
        }
        (0, util_js_1.assert)(type);
        const body = Object.create(null);
        Object.defineProperties(body, {
            type: {
                value: type,
                configurable: true,
                enumerable: true,
            },
            value: {
                get: tslib_1.__classPrivateFieldGet(this, _RequestBody_instances, "m", _RequestBody_parse).call(this, type, limit),
                configurable: true,
                enumerable: true,
            },
        });
        return body;
    }
    /** Returns if the request might have a body or not, without attempting to
     * consume it.
     *
     * **WARNING** This is an unreliable API. In HTTP/2 it is not possible to
     * determine if certain HTTP methods have a body or not without attempting to
     * read the body. As of Deno 1.16.1 and later, for HTTP/1.1 aligns to the
     * HTTP/2 behaviour.
     */
    has() {
        return tslib_1.__classPrivateFieldGet(this, _RequestBody_body, "f") != null;
    }
}
exports.RequestBody = RequestBody;
_RequestBody_body = new WeakMap(), _RequestBody_formDataReader = new WeakMap(), _RequestBody_headers = new WeakMap(), _RequestBody_jsonBodyReviver = new WeakMap(), _RequestBody_stream = new WeakMap(), _RequestBody_readAllBody = new WeakMap(), _RequestBody_readBody = new WeakMap(), _RequestBody_type = new WeakMap(), _RequestBody_instances = new WeakSet(), _RequestBody_exceedsLimit = function _RequestBody_exceedsLimit(limit) {
    if (!limit || limit === Infinity) {
        return false;
    }
    if (!tslib_1.__classPrivateFieldGet(this, _RequestBody_body, "f")) {
        return false;
    }
    const contentLength = tslib_1.__classPrivateFieldGet(this, _RequestBody_headers, "f").get("content-length") ?? "0";
    const parsed = parseInt(contentLength, 10);
    if (isNaN(parsed)) {
        return true;
    }
    return parsed > limit;
}, _RequestBody_parse = function _RequestBody_parse(type, limit) {
    switch (type) {
        case "form":
            tslib_1.__classPrivateFieldSet(this, _RequestBody_type, "bytes", "f");
            if (tslib_1.__classPrivateFieldGet(this, _RequestBody_instances, "m", _RequestBody_exceedsLimit).call(this, limit)) {
                return () => Promise.reject((0, deps_js_1.createHttpError)(deps_js_1.Status.BadRequest, `Body exceeds a limit of ${limit}.`, { expose: false }));
            }
            return async () => new URLSearchParams(decoder.decode(await tslib_1.__classPrivateFieldGet(this, _RequestBody_instances, "m", _RequestBody_valuePromise).call(this)).replace(/\+/g, " "));
        case "form-data":
            tslib_1.__classPrivateFieldSet(this, _RequestBody_type, "form-data", "f");
            return () => {
                const contentType = tslib_1.__classPrivateFieldGet(this, _RequestBody_headers, "f").get("content-type");
                (0, util_js_1.assert)(contentType);
                const readableStream = tslib_1.__classPrivateFieldGet(this, _RequestBody_body, "f") ?? new dntShim.ReadableStream();
                try {
                    return tslib_1.__classPrivateFieldGet(this, _RequestBody_formDataReader, "f") ??
                        (tslib_1.__classPrivateFieldSet(this, _RequestBody_formDataReader, new multipart_js_1.FormDataReader(contentType, (0, deps_js_1.readerFromStreamReader)(readableStream.getReader())), "f"));
                }
                catch (err) {
                    const message = err instanceof Error
                        ? err.message
                        : "Malformed request body.";
                    throw (0, deps_js_1.createHttpError)(deps_js_1.Status.BadRequest, message, { expose: false });
                }
            };
        case "json":
            tslib_1.__classPrivateFieldSet(this, _RequestBody_type, "bytes", "f");
            if (tslib_1.__classPrivateFieldGet(this, _RequestBody_instances, "m", _RequestBody_exceedsLimit).call(this, limit)) {
                return () => Promise.reject((0, deps_js_1.createHttpError)(deps_js_1.Status.BadRequest, `Body exceeds a limit of ${limit}.`, { expose: false }));
            }
            return async () => {
                const value = await tslib_1.__classPrivateFieldGet(this, _RequestBody_instances, "m", _RequestBody_valuePromise).call(this);
                try {
                    return value.length
                        ? JSON.parse(decoder.decode(await tslib_1.__classPrivateFieldGet(this, _RequestBody_instances, "m", _RequestBody_valuePromise).call(this)), tslib_1.__classPrivateFieldGet(this, _RequestBody_jsonBodyReviver, "f"))
                        : null;
                }
                catch (err) {
                    const message = err instanceof Error
                        ? err.message
                        : "Malformed request body.";
                    throw (0, deps_js_1.createHttpError)(deps_js_1.Status.BadRequest, message, { expose: false });
                }
            };
        case "bytes":
            tslib_1.__classPrivateFieldSet(this, _RequestBody_type, "bytes", "f");
            if (tslib_1.__classPrivateFieldGet(this, _RequestBody_instances, "m", _RequestBody_exceedsLimit).call(this, limit)) {
                return () => Promise.reject((0, deps_js_1.createHttpError)(deps_js_1.Status.BadRequest, `Body exceeds a limit of ${limit}.`, { expose: false }));
            }
            return () => tslib_1.__classPrivateFieldGet(this, _RequestBody_instances, "m", _RequestBody_valuePromise).call(this);
        case "text":
            tslib_1.__classPrivateFieldSet(this, _RequestBody_type, "bytes", "f");
            if (tslib_1.__classPrivateFieldGet(this, _RequestBody_instances, "m", _RequestBody_exceedsLimit).call(this, limit)) {
                return () => Promise.reject((0, deps_js_1.createHttpError)(deps_js_1.Status.BadRequest, `Body exceeds a limit of ${limit}.`, { expose: false }));
            }
            return async () => {
                try {
                    return decoder.decode(await tslib_1.__classPrivateFieldGet(this, _RequestBody_instances, "m", _RequestBody_valuePromise).call(this));
                }
                catch (err) {
                    const message = err instanceof Error
                        ? err.message
                        : "Malformed request body.";
                    throw (0, deps_js_1.createHttpError)(deps_js_1.Status.BadRequest, message, { expose: false });
                }
            };
        default:
            throw (0, deps_js_1.createHttpError)(deps_js_1.Status.InternalServerError, `Invalid body type: "${type}"`, { expose: true });
    }
}, _RequestBody_validateGetArgs = function _RequestBody_validateGetArgs(type, contentTypes) {
    if (type === "reader" && tslib_1.__classPrivateFieldGet(this, _RequestBody_type, "f") && tslib_1.__classPrivateFieldGet(this, _RequestBody_type, "f") !== "reader") {
        throw new TypeError(`Body already consumed as "${tslib_1.__classPrivateFieldGet(this, _RequestBody_type, "f")}" and cannot be returned as a reader.`);
    }
    if (type === "stream" && tslib_1.__classPrivateFieldGet(this, _RequestBody_type, "f") && tslib_1.__classPrivateFieldGet(this, _RequestBody_type, "f") !== "stream") {
        throw new TypeError(`Body already consumed as "${tslib_1.__classPrivateFieldGet(this, _RequestBody_type, "f")}" and cannot be returned as a stream.`);
    }
    if (type === "form-data" && tslib_1.__classPrivateFieldGet(this, _RequestBody_type, "f") && tslib_1.__classPrivateFieldGet(this, _RequestBody_type, "f") !== "form-data") {
        throw new TypeError(`Body already consumed as "${tslib_1.__classPrivateFieldGet(this, _RequestBody_type, "f")}" and cannot be returned as a stream.`);
    }
    if (tslib_1.__classPrivateFieldGet(this, _RequestBody_type, "f") === "reader" && type !== "reader") {
        throw new TypeError("Body already consumed as a reader and can only be returned as a reader.");
    }
    if (tslib_1.__classPrivateFieldGet(this, _RequestBody_type, "f") === "stream" && type !== "stream") {
        throw new TypeError("Body already consumed as a stream and can only be returned as a stream.");
    }
    if (tslib_1.__classPrivateFieldGet(this, _RequestBody_type, "f") === "form-data" && type !== "form-data") {
        throw new TypeError("Body already consumed as form data and can only be returned as form data.");
    }
    if (type && Object.keys(contentTypes).length) {
        throw new TypeError(`"type" and "contentTypes" cannot be specified at the same time`);
    }
}, _RequestBody_valuePromise = function _RequestBody_valuePromise() {
    return tslib_1.__classPrivateFieldGet(this, _RequestBody_readAllBody, "f") ?? (tslib_1.__classPrivateFieldSet(this, _RequestBody_readAllBody, tslib_1.__classPrivateFieldGet(this, _RequestBody_readBody, "f").call(this), "f"));
};
