"use strict";
var _MultiPartStream_contentLength, _MultiPartStream_postscript, _MultiPartStream_preamble;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiPartStream = exports.parseRange = exports.ifRange = void 0;
const tslib_1 = require("tslib");
// Copyright 2018-2023 the oak authors. All rights reserved. MIT license.
const dntShim = tslib_1.__importStar(require("./_dnt.shims.js"));
const deps_js_1 = require("./deps.js");
const etag_js_1 = require("./etag.js");
const util_js_1 = require("./util.js");
const ETAG_RE = /(?:W\/)?"[ !#-\x7E\x80-\xFF]+"/;
/** Determine, by the value of an `If-Range` header, if a `Range` header should
 * be applied to a request, returning `true` if it should or otherwise
 * `false`. */
async function ifRange(value, mtime, entity) {
    if (value) {
        const matches = value.match(ETAG_RE);
        if (matches) {
            const [match] = matches;
            if (await (0, etag_js_1.calculate)(entity) === match) {
                return true;
            }
        }
        else {
            return new Date(value).getTime() >= mtime;
        }
    }
    return false;
}
exports.ifRange = ifRange;
function parseRange(value, size) {
    const ranges = [];
    const [unit, rangesStr] = value.split("=");
    if (unit !== "bytes") {
        throw (0, deps_js_1.createHttpError)(deps_js_1.Status.RequestedRangeNotSatisfiable);
    }
    for (const range of rangesStr.split(/\s*,\s+/)) {
        const item = range.split("-");
        if (item.length !== 2) {
            throw (0, deps_js_1.createHttpError)(deps_js_1.Status.RequestedRangeNotSatisfiable);
        }
        const [startStr, endStr] = item;
        let start;
        let end;
        try {
            if (startStr === "") {
                start = size - parseInt(endStr, 10) - 1;
                end = size - 1;
            }
            else if (endStr === "") {
                start = parseInt(startStr, 10);
                end = size - 1;
            }
            else {
                start = parseInt(startStr, 10);
                end = parseInt(endStr, 10);
            }
        }
        catch {
            throw (0, deps_js_1.createHttpError)();
        }
        if (start < 0 || start >= size || end < 0 || end >= size || start > end) {
            throw (0, deps_js_1.createHttpError)(deps_js_1.Status.RequestedRangeNotSatisfiable);
        }
        ranges.push({ start, end });
    }
    return ranges;
}
exports.parseRange = parseRange;
/** A reader  */
async function readRange(file, range) {
    let length = range.end - range.start + 1;
    (0, util_js_1.assert)(length);
    await file.seek(range.start, dntShim.Deno.SeekMode.Start);
    const result = new Uint8Array(length);
    let off = 0;
    while (length) {
        const p = new Uint8Array(Math.min(length, util_js_1.DEFAULT_CHUNK_SIZE));
        const nread = await file.read(p);
        (0, util_js_1.assert)(nread !== null, "Unexpected EOF encountered when reading a range.");
        (0, util_js_1.assert)(nread > 0, "Unexpected read of 0 bytes while reading a range.");
        (0, deps_js_1.copyBytes)(p, result, off);
        off += nread;
        length -= nread;
        (0, util_js_1.assert)(length >= 0, "Unexpected length remaining.");
    }
    return result;
}
const encoder = new TextEncoder();
/** A class that takes a file (either a Deno.FsFile or Uint8Array) and bytes
 * and streams the ranges as a multi-part encoded HTTP body.
 *
 * This is specifically used by the `.send()` functionality to fulfill range
 * requests it receives, and could be used by others when trying to deal with
 * range requests, but is generally a low level API that most users of oak
 * would not need to worry about. */
class MultiPartStream extends dntShim.ReadableStream {
    constructor(file, type, ranges, size, boundary) {
        super({
            pull: async (controller) => {
                const range = ranges.shift();
                if (!range) {
                    controller.enqueue(tslib_1.__classPrivateFieldGet(this, _MultiPartStream_postscript, "f"));
                    controller.close();
                    if (!(file instanceof Uint8Array)) {
                        file.close();
                    }
                    return;
                }
                let bytes;
                if (file instanceof Uint8Array) {
                    bytes = file.subarray(range.start, range.end + 1);
                }
                else {
                    bytes = await readRange(file, range);
                }
                const rangeHeader = encoder.encode(`Content-Range: ${range.start}-${range.end}/${size}\n\n`);
                controller.enqueue((0, deps_js_1.concat)([tslib_1.__classPrivateFieldGet(this, _MultiPartStream_preamble, "f"), rangeHeader, bytes]));
            },
        });
        _MultiPartStream_contentLength.set(this, void 0);
        _MultiPartStream_postscript.set(this, void 0);
        _MultiPartStream_preamble.set(this, void 0);
        const resolvedType = (0, deps_js_1.contentType)(type);
        if (!resolvedType) {
            throw new TypeError(`Could not resolve media type for "${type}"`);
        }
        tslib_1.__classPrivateFieldSet(this, _MultiPartStream_preamble, encoder.encode(`\n--${boundary}\nContent-Type: ${resolvedType}\n`), "f");
        tslib_1.__classPrivateFieldSet(this, _MultiPartStream_postscript, encoder.encode(`\n--${boundary}--\n`), "f");
        tslib_1.__classPrivateFieldSet(this, _MultiPartStream_contentLength, ranges.reduce((prev, { start, end }) => {
            return prev + tslib_1.__classPrivateFieldGet(this, _MultiPartStream_preamble, "f").length + String(start).length +
                String(end).length + String(size).length + 20 + (end - start);
        }, tslib_1.__classPrivateFieldGet(this, _MultiPartStream_postscript, "f").length), "f");
    }
    /** The content length of the entire streamed body. */
    contentLength() {
        return tslib_1.__classPrivateFieldGet(this, _MultiPartStream_contentLength, "f");
    }
}
exports.MultiPartStream = MultiPartStream;
_MultiPartStream_contentLength = new WeakMap(), _MultiPartStream_postscript = new WeakMap(), _MultiPartStream_preamble = new WeakMap();
