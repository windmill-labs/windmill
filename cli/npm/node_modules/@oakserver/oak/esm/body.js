var _RequestBody_instances, _RequestBody_body, _RequestBody_formDataReader, _RequestBody_headers, _RequestBody_jsonBodyReviver, _RequestBody_stream, _RequestBody_readAllBody, _RequestBody_readBody, _RequestBody_type, _RequestBody_exceedsLimit, _RequestBody_parse, _RequestBody_validateGetArgs, _RequestBody_valuePromise;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
// Copyright 2018-2023 the oak authors. All rights reserved. MIT license.
import * as dntShim from "./_dnt.shims.js";
import { createHttpError, errors, readerFromStreamReader, Status, } from "./deps.js";
import { isMediaType } from "./isMediaType.js";
import { FormDataReader } from "./multipart.js";
import { assert } from "./util.js";
const DEFAULT_LIMIT = 10485760; // 10mb
const defaultBodyContentTypes = {
    json: ["json", "application/*+json", "application/csp-report"],
    form: ["urlencoded"],
    formData: ["multipart"],
    text: ["text"],
};
function resolveType(contentType, contentTypes) {
    const contentTypesJson = [
        ...defaultBodyContentTypes.json,
        ...(contentTypes.json ?? []),
    ];
    const contentTypesForm = [
        ...defaultBodyContentTypes.form,
        ...(contentTypes.form ?? []),
    ];
    const contentTypesFormData = [
        ...defaultBodyContentTypes.formData,
        ...(contentTypes.formData ?? []),
    ];
    const contentTypesText = [
        ...defaultBodyContentTypes.text,
        ...(contentTypes.text ?? []),
    ];
    if (contentTypes.bytes && isMediaType(contentType, contentTypes.bytes)) {
        return "bytes";
    }
    else if (isMediaType(contentType, contentTypesJson)) {
        return "json";
    }
    else if (isMediaType(contentType, contentTypesForm)) {
        return "form";
    }
    else if (isMediaType(contentType, contentTypesFormData)) {
        return "form-data";
    }
    else if (isMediaType(contentType, contentTypesText)) {
        return "text";
    }
    return "bytes";
}
const decoder = new TextDecoder(undefined, { fatal: true });
export class RequestBody {
    constructor({ body, readBody }, headers, jsonBodyReviver) {
        _RequestBody_instances.add(this);
        _RequestBody_body.set(this, void 0);
        _RequestBody_formDataReader.set(this, void 0);
        _RequestBody_headers.set(this, void 0);
        _RequestBody_jsonBodyReviver.set(this, void 0);
        _RequestBody_stream.set(this, void 0);
        _RequestBody_readAllBody.set(this, void 0);
        _RequestBody_readBody.set(this, void 0);
        _RequestBody_type.set(this, void 0);
        __classPrivateFieldSet(this, _RequestBody_body, body, "f");
        __classPrivateFieldSet(this, _RequestBody_headers, headers, "f");
        __classPrivateFieldSet(this, _RequestBody_jsonBodyReviver, jsonBodyReviver, "f");
        __classPrivateFieldSet(this, _RequestBody_readBody, readBody, "f");
    }
    get({ limit = DEFAULT_LIMIT, type, contentTypes = {} } = {}) {
        __classPrivateFieldGet(this, _RequestBody_instances, "m", _RequestBody_validateGetArgs).call(this, type, contentTypes);
        if (type === "reader") {
            if (!__classPrivateFieldGet(this, _RequestBody_body, "f")) {
                __classPrivateFieldSet(this, _RequestBody_type, "undefined", "f");
                throw new TypeError(`Body is undefined and cannot be returned as "reader".`);
            }
            __classPrivateFieldSet(this, _RequestBody_type, "reader", "f");
            return {
                type,
                value: readerFromStreamReader(__classPrivateFieldGet(this, _RequestBody_body, "f").getReader()),
            };
        }
        if (type === "stream") {
            if (!__classPrivateFieldGet(this, _RequestBody_body, "f")) {
                __classPrivateFieldSet(this, _RequestBody_type, "undefined", "f");
                throw new TypeError(`Body is undefined and cannot be returned as "stream".`);
            }
            __classPrivateFieldSet(this, _RequestBody_type, "stream", "f");
            const streams = (__classPrivateFieldGet(this, _RequestBody_stream, "f") ?? __classPrivateFieldGet(this, _RequestBody_body, "f"))
                .tee();
            __classPrivateFieldSet(this, _RequestBody_stream, streams[1], "f");
            return { type, value: streams[0] };
        }
        if (!this.has()) {
            __classPrivateFieldSet(this, _RequestBody_type, "undefined", "f");
        }
        else if (!__classPrivateFieldGet(this, _RequestBody_type, "f")) {
            const encoding = __classPrivateFieldGet(this, _RequestBody_headers, "f").get("content-encoding") ??
                "identity";
            if (encoding !== "identity") {
                throw new errors.UnsupportedMediaType(`Unsupported content-encoding: ${encoding}`);
            }
        }
        if (__classPrivateFieldGet(this, _RequestBody_type, "f") === "undefined" && (!type || type === "undefined")) {
            return { type: "undefined", value: undefined };
        }
        if (!type) {
            const contentType = __classPrivateFieldGet(this, _RequestBody_headers, "f").get("content-type");
            if (!contentType) {
                throw createHttpError(Status.BadRequest, "The Content-Type header is missing from the request");
            }
            type = resolveType(contentType, contentTypes);
        }
        assert(type);
        const body = Object.create(null);
        Object.defineProperties(body, {
            type: {
                value: type,
                configurable: true,
                enumerable: true,
            },
            value: {
                get: __classPrivateFieldGet(this, _RequestBody_instances, "m", _RequestBody_parse).call(this, type, limit),
                configurable: true,
                enumerable: true,
            },
        });
        return body;
    }
    /** Returns if the request might have a body or not, without attempting to
     * consume it.
     *
     * **WARNING** This is an unreliable API. In HTTP/2 it is not possible to
     * determine if certain HTTP methods have a body or not without attempting to
     * read the body. As of Deno 1.16.1 and later, for HTTP/1.1 aligns to the
     * HTTP/2 behaviour.
     */
    has() {
        return __classPrivateFieldGet(this, _RequestBody_body, "f") != null;
    }
}
_RequestBody_body = new WeakMap(), _RequestBody_formDataReader = new WeakMap(), _RequestBody_headers = new WeakMap(), _RequestBody_jsonBodyReviver = new WeakMap(), _RequestBody_stream = new WeakMap(), _RequestBody_readAllBody = new WeakMap(), _RequestBody_readBody = new WeakMap(), _RequestBody_type = new WeakMap(), _RequestBody_instances = new WeakSet(), _RequestBody_exceedsLimit = function _RequestBody_exceedsLimit(limit) {
    if (!limit || limit === Infinity) {
        return false;
    }
    if (!__classPrivateFieldGet(this, _RequestBody_body, "f")) {
        return false;
    }
    const contentLength = __classPrivateFieldGet(this, _RequestBody_headers, "f").get("content-length") ?? "0";
    const parsed = parseInt(contentLength, 10);
    if (isNaN(parsed)) {
        return true;
    }
    return parsed > limit;
}, _RequestBody_parse = function _RequestBody_parse(type, limit) {
    switch (type) {
        case "form":
            __classPrivateFieldSet(this, _RequestBody_type, "bytes", "f");
            if (__classPrivateFieldGet(this, _RequestBody_instances, "m", _RequestBody_exceedsLimit).call(this, limit)) {
                return () => Promise.reject(createHttpError(Status.BadRequest, `Body exceeds a limit of ${limit}.`, { expose: false }));
            }
            return async () => new URLSearchParams(decoder.decode(await __classPrivateFieldGet(this, _RequestBody_instances, "m", _RequestBody_valuePromise).call(this)).replace(/\+/g, " "));
        case "form-data":
            __classPrivateFieldSet(this, _RequestBody_type, "form-data", "f");
            return () => {
                const contentType = __classPrivateFieldGet(this, _RequestBody_headers, "f").get("content-type");
                assert(contentType);
                const readableStream = __classPrivateFieldGet(this, _RequestBody_body, "f") ?? new dntShim.ReadableStream();
                try {
                    return __classPrivateFieldGet(this, _RequestBody_formDataReader, "f") ??
                        (__classPrivateFieldSet(this, _RequestBody_formDataReader, new FormDataReader(contentType, readerFromStreamReader(readableStream.getReader())), "f"));
                }
                catch (err) {
                    const message = err instanceof Error
                        ? err.message
                        : "Malformed request body.";
                    throw createHttpError(Status.BadRequest, message, { expose: false });
                }
            };
        case "json":
            __classPrivateFieldSet(this, _RequestBody_type, "bytes", "f");
            if (__classPrivateFieldGet(this, _RequestBody_instances, "m", _RequestBody_exceedsLimit).call(this, limit)) {
                return () => Promise.reject(createHttpError(Status.BadRequest, `Body exceeds a limit of ${limit}.`, { expose: false }));
            }
            return async () => {
                const value = await __classPrivateFieldGet(this, _RequestBody_instances, "m", _RequestBody_valuePromise).call(this);
                try {
                    return value.length
                        ? JSON.parse(decoder.decode(await __classPrivateFieldGet(this, _RequestBody_instances, "m", _RequestBody_valuePromise).call(this)), __classPrivateFieldGet(this, _RequestBody_jsonBodyReviver, "f"))
                        : null;
                }
                catch (err) {
                    const message = err instanceof Error
                        ? err.message
                        : "Malformed request body.";
                    throw createHttpError(Status.BadRequest, message, { expose: false });
                }
            };
        case "bytes":
            __classPrivateFieldSet(this, _RequestBody_type, "bytes", "f");
            if (__classPrivateFieldGet(this, _RequestBody_instances, "m", _RequestBody_exceedsLimit).call(this, limit)) {
                return () => Promise.reject(createHttpError(Status.BadRequest, `Body exceeds a limit of ${limit}.`, { expose: false }));
            }
            return () => __classPrivateFieldGet(this, _RequestBody_instances, "m", _RequestBody_valuePromise).call(this);
        case "text":
            __classPrivateFieldSet(this, _RequestBody_type, "bytes", "f");
            if (__classPrivateFieldGet(this, _RequestBody_instances, "m", _RequestBody_exceedsLimit).call(this, limit)) {
                return () => Promise.reject(createHttpError(Status.BadRequest, `Body exceeds a limit of ${limit}.`, { expose: false }));
            }
            return async () => {
                try {
                    return decoder.decode(await __classPrivateFieldGet(this, _RequestBody_instances, "m", _RequestBody_valuePromise).call(this));
                }
                catch (err) {
                    const message = err instanceof Error
                        ? err.message
                        : "Malformed request body.";
                    throw createHttpError(Status.BadRequest, message, { expose: false });
                }
            };
        default:
            throw createHttpError(Status.InternalServerError, `Invalid body type: "${type}"`, { expose: true });
    }
}, _RequestBody_validateGetArgs = function _RequestBody_validateGetArgs(type, contentTypes) {
    if (type === "reader" && __classPrivateFieldGet(this, _RequestBody_type, "f") && __classPrivateFieldGet(this, _RequestBody_type, "f") !== "reader") {
        throw new TypeError(`Body already consumed as "${__classPrivateFieldGet(this, _RequestBody_type, "f")}" and cannot be returned as a reader.`);
    }
    if (type === "stream" && __classPrivateFieldGet(this, _RequestBody_type, "f") && __classPrivateFieldGet(this, _RequestBody_type, "f") !== "stream") {
        throw new TypeError(`Body already consumed as "${__classPrivateFieldGet(this, _RequestBody_type, "f")}" and cannot be returned as a stream.`);
    }
    if (type === "form-data" && __classPrivateFieldGet(this, _RequestBody_type, "f") && __classPrivateFieldGet(this, _RequestBody_type, "f") !== "form-data") {
        throw new TypeError(`Body already consumed as "${__classPrivateFieldGet(this, _RequestBody_type, "f")}" and cannot be returned as a stream.`);
    }
    if (__classPrivateFieldGet(this, _RequestBody_type, "f") === "reader" && type !== "reader") {
        throw new TypeError("Body already consumed as a reader and can only be returned as a reader.");
    }
    if (__classPrivateFieldGet(this, _RequestBody_type, "f") === "stream" && type !== "stream") {
        throw new TypeError("Body already consumed as a stream and can only be returned as a stream.");
    }
    if (__classPrivateFieldGet(this, _RequestBody_type, "f") === "form-data" && type !== "form-data") {
        throw new TypeError("Body already consumed as form data and can only be returned as form data.");
    }
    if (type && Object.keys(contentTypes).length) {
        throw new TypeError(`"type" and "contentTypes" cannot be specified at the same time`);
    }
}, _RequestBody_valuePromise = function _RequestBody_valuePromise() {
    return __classPrivateFieldGet(this, _RequestBody_readAllBody, "f") ?? (__classPrivateFieldSet(this, _RequestBody_readAllBody, __classPrivateFieldGet(this, _RequestBody_readBody, "f").call(this), "f"));
};
