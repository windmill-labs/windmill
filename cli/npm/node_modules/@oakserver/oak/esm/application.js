var _Application_instances, _Application_composedMiddleware, _Application_contextOptions, _Application_contextState, _Application_keys, _Application_middleware, _Application_serverConstructor, _Application_getComposed, _Application_getContextState, _Application_handleError, _Application_handleRequest;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
// Copyright 2018-2023 the oak authors. All rights reserved. MIT license.
import * as dntShim from "./_dnt.shims.js";
import { Context } from "./context.js";
import { KeyStack, STATUS_TEXT } from "./deps.js";
import { HttpServer } from "./http_server_node.js";
import { NativeRequest } from "./http_server_native_request.js";
import { compose, isMiddlewareObject, } from "./middleware.js";
import { cloneState } from "./structured_clone.js";
import { assert, isConn } from "./util.js";
const ADDR_REGEXP = /^\[?([^\]]*)\]?:([0-9]{1,5})$/;
const DEFAULT_SERVER = HttpServer;
export class ApplicationCloseEvent extends Event {
    constructor(eventInitDict) {
        super("close", eventInitDict);
    }
}
export class ApplicationErrorEvent extends dntShim.ErrorEvent {
    constructor(eventInitDict) {
        super("error", eventInitDict);
        Object.defineProperty(this, "context", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.context = eventInitDict.context;
    }
}
function logErrorListener({ error, context }) {
    if (error instanceof Error) {
        console.error(`[uncaught application error]: ${error.name} - ${error.message}`);
    }
    else {
        console.error(`[uncaught application error]\n`, error);
    }
    if (context) {
        let url;
        try {
            url = context.request.url.toString();
        }
        catch {
            url = "[malformed url]";
        }
        console.error(`\nrequest:`, {
            url,
            method: context.request.method,
            hasBody: context.request.hasBody,
        });
        console.error(`response:`, {
            status: context.response.status,
            type: context.response.type,
            hasBody: !!context.response.body,
            writable: context.response.writable,
        });
    }
    if (error instanceof Error && error.stack) {
        console.error(`\n${error.stack.split("\n").slice(1).join("\n")}`);
    }
}
export class ApplicationListenEvent extends Event {
    constructor(eventInitDict) {
        super("listen", eventInitDict);
        Object.defineProperty(this, "hostname", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "listener", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "port", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "secure", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "serverType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.hostname = eventInitDict.hostname;
        this.listener = eventInitDict.listener;
        this.port = eventInitDict.port;
        this.secure = eventInitDict.secure;
        this.serverType = eventInitDict.serverType;
    }
}
/** A class which registers middleware (via `.use()`) and then processes
 * inbound requests against that middleware (via `.listen()`).
 *
 * The `context.state` can be typed via passing a generic argument when
 * constructing an instance of `Application`. It can also be inferred by setting
 * the {@linkcode ApplicationOptions.state} option when constructing the
 * application.
 *
 * ### Basic example
 *
 * ```ts
 * import { Application } from "https://deno.land/x/oak/mod.ts";
 *
 * const app = new Application();
 *
 * app.use((ctx, next) => {
 *   // called on each request with the context (`ctx`) of the request,
 *   // response, and other data.
 *   // `next()` is use to modify the flow control of the middleware stack.
 * });
 *
 * app.listen({ port: 8080 });
 * ```
 *
 * @template AS the type of the application state which extends
 *              {@linkcode State} and defaults to a simple string record.
 */
// deno-lint-ignore no-explicit-any
export class Application extends EventTarget {
    /** A set of keys, or an instance of `KeyStack` which will be used to sign
     * cookies read and set by the application to avoid tampering with the
     * cookies. */
    get keys() {
        return __classPrivateFieldGet(this, _Application_keys, "f");
    }
    set keys(keys) {
        if (!keys) {
            __classPrivateFieldSet(this, _Application_keys, undefined, "f");
            return;
        }
        else if (Array.isArray(keys)) {
            __classPrivateFieldSet(this, _Application_keys, new KeyStack(keys), "f");
        }
        else {
            __classPrivateFieldSet(this, _Application_keys, keys, "f");
        }
    }
    constructor(options = {}) {
        super();
        _Application_instances.add(this);
        _Application_composedMiddleware.set(this, void 0);
        _Application_contextOptions.set(this, void 0);
        _Application_contextState.set(this, void 0);
        _Application_keys.set(this, void 0);
        _Application_middleware.set(this, []);
        _Application_serverConstructor.set(this, void 0);
        /** If `true`, proxy headers will be trusted when processing requests.  This
         * defaults to `false`. */
        Object.defineProperty(this, "proxy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** Generic state of the application, which can be specified by passing the
         * generic argument when constructing:
         *
         *       const app = new Application<{ foo: string }>();
         *
         * Or can be contextually inferred based on setting an initial state object:
         *
         *       const app = new Application({ state: { foo: "bar" } });
         *
         * When a new context is created, the application's state is cloned and the
         * state is unique to that request/response.  Changes can be made to the
         * application state that will be shared with all contexts.
         */
        Object.defineProperty(this, "state", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** Handle an individual server request, returning the server response.  This
         * is similar to `.listen()`, but opening the connection and retrieving
         * requests are not the responsibility of the application.  If the generated
         * context gets set to not to respond, then the method resolves with
         * `undefined`, otherwise it resolves with a request that is compatible with
         * `std/http/server`. */
        Object.defineProperty(this, "handle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (async (request, secureOrConn, secure = false) => {
                if (!__classPrivateFieldGet(this, _Application_middleware, "f").length) {
                    throw new TypeError("There is no middleware to process requests.");
                }
                assert(isConn(secureOrConn) || typeof secureOrConn === "undefined");
                const contextRequest = new NativeRequest({
                    request,
                    respondWith() {
                        return Promise.resolve(undefined);
                    },
                }, { conn: secureOrConn });
                const context = new Context(this, contextRequest, __classPrivateFieldGet(this, _Application_instances, "m", _Application_getContextState).call(this), { secure, ...__classPrivateFieldGet(this, _Application_contextOptions, "f") });
                try {
                    await __classPrivateFieldGet(this, _Application_instances, "m", _Application_getComposed).call(this)(context);
                }
                catch (err) {
                    __classPrivateFieldGet(this, _Application_instances, "m", _Application_handleError).call(this, context, err);
                }
                if (context.respond === false) {
                    context.response.destroy();
                    return;
                }
                try {
                    const response = await context.response.toDomResponse();
                    context.response.destroy(false);
                    return response;
                }
                catch (err) {
                    __classPrivateFieldGet(this, _Application_instances, "m", _Application_handleError).call(this, context, err);
                    throw err;
                }
            })
        });
        const { state, keys, proxy, serverConstructor = DEFAULT_SERVER, contextState = "clone", logErrors = true, ...contextOptions } = options;
        this.proxy = proxy ?? false;
        this.keys = keys;
        this.state = state ?? {};
        __classPrivateFieldSet(this, _Application_serverConstructor, serverConstructor, "f");
        __classPrivateFieldSet(this, _Application_contextOptions, contextOptions, "f");
        __classPrivateFieldSet(this, _Application_contextState, contextState, "f");
        if (logErrors) {
            this.addEventListener("error", logErrorListener);
        }
    }
    /** Add an event listener for an event.  Currently valid event types are
     * `"error"` and `"listen"`. */
    addEventListener(type, listener, options) {
        super.addEventListener(type, listener, options);
    }
    async listen(options = { port: 0 }) {
        if (!__classPrivateFieldGet(this, _Application_middleware, "f").length) {
            throw new TypeError("There is no middleware to process requests.");
        }
        for (const middleware of __classPrivateFieldGet(this, _Application_middleware, "f")) {
            if (isMiddlewareObject(middleware) && middleware.init) {
                await middleware.init();
            }
        }
        if (typeof options === "string") {
            const match = ADDR_REGEXP.exec(options);
            if (!match) {
                throw TypeError(`Invalid address passed: "${options}"`);
            }
            const [, hostname, portStr] = match;
            options = { hostname, port: parseInt(portStr, 10) };
        }
        options = Object.assign({ port: 0 }, options);
        const server = new (__classPrivateFieldGet(this, _Application_serverConstructor, "f"))(this, options);
        const { signal } = options;
        const state = {
            closed: false,
            closing: false,
            handling: new Set(),
            server,
        };
        if (signal) {
            signal.addEventListener("abort", () => {
                if (!state.handling.size) {
                    server.close();
                    state.closed = true;
                    this.dispatchEvent(new ApplicationCloseEvent({}));
                }
                state.closing = true;
            });
        }
        const { secure = false } = options;
        const serverType = server instanceof HttpServer ? "native" : "custom";
        const listener = await server.listen();
        const { hostname, port } = listener.addr;
        this.dispatchEvent(new ApplicationListenEvent({
            hostname,
            listener,
            port,
            secure,
            serverType,
        }));
        try {
            for await (const request of server) {
                __classPrivateFieldGet(this, _Application_instances, "m", _Application_handleRequest).call(this, request, secure, state);
            }
            await Promise.all(state.handling);
        }
        catch (error) {
            const message = error instanceof Error
                ? error.message
                : "Application Error";
            this.dispatchEvent(new ApplicationErrorEvent({ message, error }));
        }
    }
    use(...middleware) {
        __classPrivateFieldGet(this, _Application_middleware, "f").push(...middleware);
        __classPrivateFieldSet(this, _Application_composedMiddleware, undefined, "f");
        // deno-lint-ignore no-explicit-any
        return this;
    }
    [(_Application_composedMiddleware = new WeakMap(), _Application_contextOptions = new WeakMap(), _Application_contextState = new WeakMap(), _Application_keys = new WeakMap(), _Application_middleware = new WeakMap(), _Application_serverConstructor = new WeakMap(), _Application_instances = new WeakSet(), _Application_getComposed = function _Application_getComposed() {
        if (!__classPrivateFieldGet(this, _Application_composedMiddleware, "f")) {
            __classPrivateFieldSet(this, _Application_composedMiddleware, compose(__classPrivateFieldGet(this, _Application_middleware, "f")), "f");
        }
        return __classPrivateFieldGet(this, _Application_composedMiddleware, "f");
    }, _Application_getContextState = function _Application_getContextState() {
        switch (__classPrivateFieldGet(this, _Application_contextState, "f")) {
            case "alias":
                return this.state;
            case "clone":
                return cloneState(this.state);
            case "empty":
                return {};
            case "prototype":
                return Object.create(this.state);
        }
    }, _Application_handleError = function _Application_handleError(context, error) {
        if (!(error instanceof Error)) {
            error = new Error(`non-error thrown: ${JSON.stringify(error)}`);
        }
        const { message } = error;
        this.dispatchEvent(new ApplicationErrorEvent({ context, message, error }));
        if (!context.response.writable) {
            return;
        }
        for (const key of [...context.response.headers.keys()]) {
            context.response.headers.delete(key);
        }
        if (error.headers && error.headers instanceof dntShim.Headers) {
            for (const [key, value] of error.headers) {
                context.response.headers.set(key, value);
            }
        }
        context.response.type = "text";
        const status = context.response.status =
            dntShim.Deno.errors && error instanceof dntShim.Deno.errors.NotFound
                ? 404
                : error.status && typeof error.status === "number"
                    ? error.status
                    : 500;
        context.response.body = error.expose ? error.message : STATUS_TEXT[status];
    }, _Application_handleRequest = 
    /** Processing registered middleware on each request. */
    async function _Application_handleRequest(request, secure, state) {
        let context;
        try {
            context = new Context(this, request, __classPrivateFieldGet(this, _Application_instances, "m", _Application_getContextState).call(this), { secure, ...__classPrivateFieldGet(this, _Application_contextOptions, "f") });
        }
        catch (e) {
            const error = e instanceof Error
                ? e
                : new Error(`non-error thrown: ${JSON.stringify(e)}`);
            const { message } = error;
            this.dispatchEvent(new ApplicationErrorEvent({ message, error }));
            return;
        }
        assert(context, "Context was not created.");
        let resolve;
        const handlingPromise = new Promise((res) => resolve = res);
        state.handling.add(handlingPromise);
        if (!state.closing && !state.closed) {
            try {
                await __classPrivateFieldGet(this, _Application_instances, "m", _Application_getComposed).call(this)(context);
            }
            catch (err) {
                __classPrivateFieldGet(this, _Application_instances, "m", _Application_handleError).call(this, context, err);
            }
        }
        if (context.respond === false) {
            context.response.destroy();
            resolve();
            state.handling.delete(handlingPromise);
            return;
        }
        let closeResources = true;
        let response;
        try {
            closeResources = false;
            response = await context.response.toDomResponse();
        }
        catch (err) {
            __classPrivateFieldGet(this, _Application_instances, "m", _Application_handleError).call(this, context, err);
            response = await context.response.toDomResponse();
        }
        assert(response);
        try {
            await request.respond(response);
        }
        catch (err) {
            __classPrivateFieldGet(this, _Application_instances, "m", _Application_handleError).call(this, context, err);
        }
        finally {
            context.response.destroy(closeResources);
            resolve();
            state.handling.delete(handlingPromise);
            if (state.closing) {
                await state.server.close();
                if (!state.closed) {
                    this.dispatchEvent(new ApplicationCloseEvent({}));
                }
                state.closed = true;
            }
        }
    }, Symbol.for("Deno.customInspect"))](inspect) {
        const { keys, proxy, state } = this;
        return `${this.constructor.name} ${inspect({ "#middleware": __classPrivateFieldGet(this, _Application_middleware, "f"), keys, proxy, state })}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, 
    // deno-lint-ignore no-explicit-any
    options, inspect) {
        if (depth < 0) {
            return options.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options, {
            depth: options.depth === null ? null : options.depth - 1,
        });
        const { keys, proxy, state } = this;
        return `${options.stylize(this.constructor.name, "special")} ${inspect({ "#middleware": __classPrivateFieldGet(this, _Application_middleware, "f"), keys, proxy, state }, newOptions)}`;
    }
}
