/**
 * Adapted directly from @koa/router at
 * https://github.com/koajs/router/ which is licensed as:
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Alexander C. Mingoia
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var _Layer_opts, _Layer_paramNames, _Layer_regexp, _Router_instances, _a, _Router_opts, _Router_methods, _Router_params, _Router_stack, _Router_match, _Router_register, _Router_addLayer, _Router_route, _Router_useVerb, _Router_clone;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { compile, errors, pathParse, pathToRegexp, Status, } from "./deps.js";
import { compose } from "./middleware.js";
import { assert, decodeComponent } from "./util.js";
/** Generate a URL from a string, potentially replace route params with
 * values. */
function toUrl(url, params = {}, options) {
    const tokens = pathParse(url);
    let replace = {};
    if (tokens.some((token) => typeof token === "object")) {
        replace = params;
    }
    else {
        options = params;
    }
    const toPath = compile(url, options);
    const replaced = toPath(replace);
    if (options && options.query) {
        const url = new URL(replaced, "http://oak");
        if (typeof options.query === "string") {
            url.search = options.query;
        }
        else {
            url.search = String(options.query instanceof URLSearchParams
                ? options.query
                : new URLSearchParams(options.query));
        }
        return `${url.pathname}${url.search}${url.hash}`;
    }
    return replaced;
}
class Layer {
    constructor(path, methods, middleware, { name, ...opts } = {}) {
        _Layer_opts.set(this, void 0);
        _Layer_paramNames.set(this, []);
        _Layer_regexp.set(this, void 0);
        Object.defineProperty(this, "methods", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "path", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "stack", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        __classPrivateFieldSet(this, _Layer_opts, opts, "f");
        this.name = name;
        this.methods = [...methods];
        if (this.methods.includes("GET")) {
            this.methods.unshift("HEAD");
        }
        this.stack = Array.isArray(middleware) ? middleware.slice() : [middleware];
        this.path = path;
        __classPrivateFieldSet(this, _Layer_regexp, pathToRegexp(path, __classPrivateFieldGet(this, _Layer_paramNames, "f"), __classPrivateFieldGet(this, _Layer_opts, "f")), "f");
    }
    clone() {
        return new Layer(this.path, this.methods, this.stack, { name: this.name, ...__classPrivateFieldGet(this, _Layer_opts, "f") });
    }
    match(path) {
        return __classPrivateFieldGet(this, _Layer_regexp, "f").test(path);
    }
    params(captures, existingParams = {}) {
        const params = existingParams;
        for (let i = 0; i < captures.length; i++) {
            if (__classPrivateFieldGet(this, _Layer_paramNames, "f")[i]) {
                const c = captures[i];
                params[__classPrivateFieldGet(this, _Layer_paramNames, "f")[i].name] = c ? decodeComponent(c) : c;
            }
        }
        return params;
    }
    captures(path) {
        if (__classPrivateFieldGet(this, _Layer_opts, "f").ignoreCaptures) {
            return [];
        }
        return path.match(__classPrivateFieldGet(this, _Layer_regexp, "f"))?.slice(1) ?? [];
    }
    url(params = {}, options) {
        const url = this.path.replace(/\(\.\*\)/g, "");
        return toUrl(url, params, options);
    }
    param(param, 
    // deno-lint-ignore no-explicit-any
    fn) {
        const stack = this.stack;
        const params = __classPrivateFieldGet(this, _Layer_paramNames, "f");
        const middleware = function (ctx, next) {
            const p = ctx.params[param];
            assert(p);
            return fn.call(this, p, ctx, next);
        };
        middleware.param = param;
        const names = params.map((p) => p.name);
        const x = names.indexOf(param);
        if (x >= 0) {
            for (let i = 0; i < stack.length; i++) {
                const fn = stack[i];
                if (!fn.param || names.indexOf(fn.param) > x) {
                    stack.splice(i, 0, middleware);
                    break;
                }
            }
        }
        return this;
    }
    setPrefix(prefix) {
        if (this.path) {
            this.path = this.path !== "/" || __classPrivateFieldGet(this, _Layer_opts, "f").strict === true
                ? `${prefix}${this.path}`
                : prefix;
            __classPrivateFieldSet(this, _Layer_paramNames, [], "f");
            __classPrivateFieldSet(this, _Layer_regexp, pathToRegexp(this.path, __classPrivateFieldGet(this, _Layer_paramNames, "f"), __classPrivateFieldGet(this, _Layer_opts, "f")), "f");
        }
        return this;
    }
    // deno-lint-ignore no-explicit-any
    toJSON() {
        return {
            methods: [...this.methods],
            middleware: [...this.stack],
            paramNames: __classPrivateFieldGet(this, _Layer_paramNames, "f").map((key) => key.name),
            path: this.path,
            regexp: __classPrivateFieldGet(this, _Layer_regexp, "f"),
            options: { ...__classPrivateFieldGet(this, _Layer_opts, "f") },
        };
    }
    [(_Layer_opts = new WeakMap(), _Layer_paramNames = new WeakMap(), _Layer_regexp = new WeakMap(), Symbol.for("Deno.customInspect"))](inspect) {
        return `${this.constructor.name} ${inspect({
            methods: this.methods,
            middleware: this.stack,
            options: __classPrivateFieldGet(this, _Layer_opts, "f"),
            paramNames: __classPrivateFieldGet(this, _Layer_paramNames, "f").map((key) => key.name),
            path: this.path,
            regexp: __classPrivateFieldGet(this, _Layer_regexp, "f"),
        })}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, 
    // deno-lint-ignore no-explicit-any
    options, inspect) {
        if (depth < 0) {
            return options.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options, {
            depth: options.depth === null ? null : options.depth - 1,
        });
        return `${options.stylize(this.constructor.name, "special")} ${inspect({
            methods: this.methods,
            middleware: this.stack,
            options: __classPrivateFieldGet(this, _Layer_opts, "f"),
            paramNames: __classPrivateFieldGet(this, _Layer_paramNames, "f").map((key) => key.name),
            path: this.path,
            regexp: __classPrivateFieldGet(this, _Layer_regexp, "f"),
        }, newOptions)}`;
    }
}
/** An interface for registering middleware that will run when certain HTTP
 * methods and paths are requested, as well as provides a way to parameterize
 * parts of the requested path.
 *
 * ### Basic example
 *
 * ```ts
 * import { Application, Router } from "https://deno.land/x/oak/mod.ts";
 *
 * const router = new Router();
 * router.get("/", (ctx, next) => {
 *   // handle the GET endpoint here
 * });
 * router.all("/item/:item", (ctx, next) => {
 *   // called for all HTTP verbs/requests
 *   ctx.params.item; // contains the value of `:item` from the parsed URL
 * });
 *
 * const app = new Application();
 * app.use(router.routes());
 * app.use(router.allowedMethods());
 *
 * app.listen({ port: 8080 });
 * ```
 */
export class Router {
    constructor(opts = {}) {
        _Router_instances.add(this);
        _Router_opts.set(this, void 0);
        _Router_methods.set(this, void 0);
        // deno-lint-ignore no-explicit-any
        _Router_params.set(this, {});
        _Router_stack.set(this, []);
        __classPrivateFieldSet(this, _Router_opts, opts, "f");
        __classPrivateFieldSet(this, _Router_methods, opts.methods ?? [
            "DELETE",
            "GET",
            "HEAD",
            "OPTIONS",
            "PATCH",
            "POST",
            "PUT",
        ], "f");
    }
    add(methods, nameOrPath, pathOrMiddleware, ...middleware) {
        __classPrivateFieldGet(this, _Router_instances, "m", _Router_useVerb).call(this, nameOrPath, pathOrMiddleware, middleware, typeof methods === "string" ? [methods] : methods);
        return this;
    }
    all(nameOrPath, pathOrMiddleware, ...middleware) {
        __classPrivateFieldGet(this, _Router_instances, "m", _Router_useVerb).call(this, nameOrPath, pathOrMiddleware, middleware, __classPrivateFieldGet(this, _Router_methods, "f").filter((method) => method !== "OPTIONS"));
        return this;
    }
    /** Middleware that handles requests for HTTP methods registered with the
     * router.  If none of the routes handle a method, then "not allowed" logic
     * will be used.  If a method is supported by some routes, but not the
     * particular matched router, then "not implemented" will be returned.
     *
     * The middleware will also automatically handle the `OPTIONS` method,
     * responding with a `200 OK` when the `Allowed` header sent to the allowed
     * methods for a given route.
     *
     * By default, a "not allowed" request will respond with a `405 Not Allowed`
     * and a "not implemented" will respond with a `501 Not Implemented`. Setting
     * the option `.throw` to `true` will cause the middleware to throw an
     * `HTTPError` instead of setting the response status.  The error can be
     * overridden by providing a `.notImplemented` or `.notAllowed` method in the
     * options, of which the value will be returned will be thrown instead of the
     * HTTP error. */
    allowedMethods(options = {}) {
        const implemented = __classPrivateFieldGet(this, _Router_methods, "f");
        const allowedMethods = async (context, next) => {
            const ctx = context;
            await next();
            if (!ctx.response.status || ctx.response.status === Status.NotFound) {
                assert(ctx.matched);
                const allowed = new Set();
                for (const route of ctx.matched) {
                    for (const method of route.methods) {
                        allowed.add(method);
                    }
                }
                const allowedStr = [...allowed].join(", ");
                if (!implemented.includes(ctx.request.method)) {
                    if (options.throw) {
                        throw options.notImplemented
                            ? options.notImplemented()
                            : new errors.NotImplemented();
                    }
                    else {
                        ctx.response.status = Status.NotImplemented;
                        ctx.response.headers.set("Allow", allowedStr);
                    }
                }
                else if (allowed.size) {
                    if (ctx.request.method === "OPTIONS") {
                        ctx.response.status = Status.OK;
                        ctx.response.headers.set("Allow", allowedStr);
                    }
                    else if (!allowed.has(ctx.request.method)) {
                        if (options.throw) {
                            throw options.methodNotAllowed
                                ? options.methodNotAllowed()
                                : new errors.MethodNotAllowed();
                        }
                        else {
                            ctx.response.status = Status.MethodNotAllowed;
                            ctx.response.headers.set("Allow", allowedStr);
                        }
                    }
                }
            }
        };
        return allowedMethods;
    }
    delete(nameOrPath, pathOrMiddleware, ...middleware) {
        __classPrivateFieldGet(this, _Router_instances, "m", _Router_useVerb).call(this, nameOrPath, pathOrMiddleware, middleware, ["DELETE"]);
        return this;
    }
    /** Iterate over the routes currently added to the router.  To be compatible
     * with the iterable interfaces, both the key and value are set to the value
     * of the route. */
    *entries() {
        for (const route of __classPrivateFieldGet(this, _Router_stack, "f")) {
            const value = route.toJSON();
            yield [value, value];
        }
    }
    /** Iterate over the routes currently added to the router, calling the
     * `callback` function for each value. */
    forEach(callback, 
    // deno-lint-ignore no-explicit-any
    thisArg = null) {
        for (const route of __classPrivateFieldGet(this, _Router_stack, "f")) {
            const value = route.toJSON();
            callback.call(thisArg, value, value, this);
        }
    }
    get(nameOrPath, pathOrMiddleware, ...middleware) {
        __classPrivateFieldGet(this, _Router_instances, "m", _Router_useVerb).call(this, nameOrPath, pathOrMiddleware, middleware, ["GET"]);
        return this;
    }
    head(nameOrPath, pathOrMiddleware, ...middleware) {
        __classPrivateFieldGet(this, _Router_instances, "m", _Router_useVerb).call(this, nameOrPath, pathOrMiddleware, middleware, ["HEAD"]);
        return this;
    }
    /** Iterate over the routes currently added to the router.  To be compatible
     * with the iterable interfaces, the key is set to the value of the route. */
    *keys() {
        for (const route of __classPrivateFieldGet(this, _Router_stack, "f")) {
            yield route.toJSON();
        }
    }
    options(nameOrPath, pathOrMiddleware, ...middleware) {
        __classPrivateFieldGet(this, _Router_instances, "m", _Router_useVerb).call(this, nameOrPath, pathOrMiddleware, middleware, ["OPTIONS"]);
        return this;
    }
    /** Register param middleware, which will be called when the particular param
     * is parsed from the route. */
    param(param, middleware) {
        __classPrivateFieldGet(this, _Router_params, "f")[param] = middleware;
        for (const route of __classPrivateFieldGet(this, _Router_stack, "f")) {
            route.param(param, middleware);
        }
        return this;
    }
    patch(nameOrPath, pathOrMiddleware, ...middleware) {
        __classPrivateFieldGet(this, _Router_instances, "m", _Router_useVerb).call(this, nameOrPath, pathOrMiddleware, middleware, ["PATCH"]);
        return this;
    }
    post(nameOrPath, pathOrMiddleware, ...middleware) {
        __classPrivateFieldGet(this, _Router_instances, "m", _Router_useVerb).call(this, nameOrPath, pathOrMiddleware, middleware, ["POST"]);
        return this;
    }
    /** Set the router prefix for this router. */
    prefix(prefix) {
        prefix = prefix.replace(/\/$/, "");
        __classPrivateFieldGet(this, _Router_opts, "f").prefix = prefix;
        for (const route of __classPrivateFieldGet(this, _Router_stack, "f")) {
            route.setPrefix(prefix);
        }
        return this;
    }
    put(nameOrPath, pathOrMiddleware, ...middleware) {
        __classPrivateFieldGet(this, _Router_instances, "m", _Router_useVerb).call(this, nameOrPath, pathOrMiddleware, middleware, ["PUT"]);
        return this;
    }
    /** Register a direction middleware, where when the `source` path is matched
     * the router will redirect the request to the `destination` path.  A `status`
     * of `302 Found` will be set by default.
     *
     * The `source` and `destination` can be named routes. */
    redirect(source, destination, status = Status.Found) {
        if (source[0] !== "/") {
            const s = this.url(source);
            if (!s) {
                throw new RangeError(`Could not resolve named route: "${source}"`);
            }
            source = s;
        }
        if (typeof destination === "string") {
            if (destination[0] !== "/") {
                const d = this.url(destination);
                if (!d) {
                    try {
                        const url = new URL(destination);
                        destination = url;
                    }
                    catch {
                        throw new RangeError(`Could not resolve named route: "${source}"`);
                    }
                }
                else {
                    destination = d;
                }
            }
        }
        this.all(source, async (ctx, next) => {
            await next();
            ctx.response.redirect(destination);
            ctx.response.status = status;
        });
        return this;
    }
    /** Return middleware that will do all the route processing that the router
     * has been configured to handle.  Typical usage would be something like this:
     *
     * ```ts
     * import { Application, Router } from "https://deno.land/x/oak/mod.ts";
     *
     * const app = new Application();
     * const router = new Router();
     *
     * // register routes
     *
     * app.use(router.routes());
     * app.use(router.allowedMethods());
     * await app.listen({ port: 80 });
     * ```
     */
    routes() {
        const dispatch = (context, next) => {
            const ctx = context;
            let pathname;
            let method;
            try {
                const { url: { pathname: p }, method: m } = ctx.request;
                pathname = p;
                method = m;
            }
            catch (e) {
                return Promise.reject(e);
            }
            const path = __classPrivateFieldGet(this, _Router_opts, "f").routerPath ?? ctx.routerPath ??
                decodeURI(pathname);
            const matches = __classPrivateFieldGet(this, _Router_instances, "m", _Router_match).call(this, path, method);
            if (ctx.matched) {
                ctx.matched.push(...matches.path);
            }
            else {
                ctx.matched = [...matches.path];
            }
            // deno-lint-ignore no-explicit-any
            ctx.router = this;
            if (!matches.route)
                return next();
            ctx.routeName = matches.name;
            const { pathAndMethod: matchedRoutes } = matches;
            const chain = matchedRoutes.reduce((prev, route) => [
                ...prev,
                (ctx, next) => {
                    ctx.captures = route.captures(path);
                    ctx.params = route.params(ctx.captures, ctx.params);
                    return next();
                },
                ...route.stack,
            ], []);
            return compose(chain)(ctx, next);
        };
        dispatch.router = this;
        return dispatch;
    }
    /** Generate a URL pathname for a named route, interpolating the optional
     * params provided.  Also accepts an optional set of options. */
    url(name, params, options) {
        const route = __classPrivateFieldGet(this, _Router_instances, "m", _Router_route).call(this, name);
        if (route) {
            return route.url(params, options);
        }
    }
    use(pathOrMiddleware, ...middleware) {
        let path;
        if (typeof pathOrMiddleware === "string" || Array.isArray(pathOrMiddleware)) {
            path = pathOrMiddleware;
        }
        else {
            middleware.unshift(pathOrMiddleware);
        }
        __classPrivateFieldGet(this, _Router_instances, "m", _Router_register).call(this, path ?? "(.*)", middleware, [], { end: false, ignoreCaptures: !path, ignorePrefix: !path });
        return this;
    }
    /** Iterate over the routes currently added to the router. */
    *values() {
        for (const route of __classPrivateFieldGet(this, _Router_stack, "f")) {
            yield route.toJSON();
        }
    }
    /** Provide an iterator interface that iterates over the routes registered
     * with the router. */
    *[(_Router_opts = new WeakMap(), _Router_methods = new WeakMap(), _Router_params = new WeakMap(), _Router_stack = new WeakMap(), _Router_instances = new WeakSet(), _Router_match = function _Router_match(path, method) {
        const matches = {
            path: [],
            pathAndMethod: [],
            route: false,
        };
        for (const route of __classPrivateFieldGet(this, _Router_stack, "f")) {
            if (route.match(path)) {
                matches.path.push(route);
                if (route.methods.length === 0 || route.methods.includes(method)) {
                    matches.pathAndMethod.push(route);
                    if (route.methods.length) {
                        matches.route = true;
                        matches.name = route.name;
                    }
                }
            }
        }
        return matches;
    }, _Router_register = function _Router_register(path, middlewares, methods, options = {}) {
        var _b;
        if (Array.isArray(path)) {
            for (const p of path) {
                __classPrivateFieldGet(this, _Router_instances, "m", _Router_register).call(this, p, middlewares, methods, options);
            }
            return;
        }
        let layerMiddlewares = [];
        for (const middleware of middlewares) {
            if (!middleware.router) {
                layerMiddlewares.push(middleware);
                continue;
            }
            if (layerMiddlewares.length) {
                __classPrivateFieldGet(this, _Router_instances, "m", _Router_addLayer).call(this, path, layerMiddlewares, methods, options);
                layerMiddlewares = [];
            }
            const router = __classPrivateFieldGet((_b = middleware.router), _Router_instances, "m", _Router_clone).call(_b);
            for (const layer of __classPrivateFieldGet(router, _Router_stack, "f")) {
                if (!options.ignorePrefix) {
                    layer.setPrefix(path);
                }
                if (__classPrivateFieldGet(this, _Router_opts, "f").prefix) {
                    layer.setPrefix(__classPrivateFieldGet(this, _Router_opts, "f").prefix);
                }
                __classPrivateFieldGet(this, _Router_stack, "f").push(layer);
            }
            for (const [param, mw] of Object.entries(__classPrivateFieldGet(this, _Router_params, "f"))) {
                router.param(param, mw);
            }
        }
        if (layerMiddlewares.length) {
            __classPrivateFieldGet(this, _Router_instances, "m", _Router_addLayer).call(this, path, layerMiddlewares, methods, options);
        }
    }, _Router_addLayer = function _Router_addLayer(path, middlewares, methods, options = {}) {
        const { end, name, sensitive = __classPrivateFieldGet(this, _Router_opts, "f").sensitive, strict = __classPrivateFieldGet(this, _Router_opts, "f").strict, ignoreCaptures, } = options;
        const route = new Layer(path, methods, middlewares, {
            end,
            name,
            sensitive,
            strict,
            ignoreCaptures,
        });
        if (__classPrivateFieldGet(this, _Router_opts, "f").prefix) {
            route.setPrefix(__classPrivateFieldGet(this, _Router_opts, "f").prefix);
        }
        for (const [param, mw] of Object.entries(__classPrivateFieldGet(this, _Router_params, "f"))) {
            route.param(param, mw);
        }
        __classPrivateFieldGet(this, _Router_stack, "f").push(route);
    }, _Router_route = function _Router_route(name) {
        for (const route of __classPrivateFieldGet(this, _Router_stack, "f")) {
            if (route.name === name) {
                return route;
            }
        }
    }, _Router_useVerb = function _Router_useVerb(nameOrPath, pathOrMiddleware, middleware, methods) {
        let name = undefined;
        let path;
        if (typeof pathOrMiddleware === "string") {
            name = nameOrPath;
            path = pathOrMiddleware;
        }
        else {
            path = nameOrPath;
            middleware.unshift(pathOrMiddleware);
        }
        __classPrivateFieldGet(this, _Router_instances, "m", _Router_register).call(this, path, middleware, methods, { name });
    }, _Router_clone = function _Router_clone() {
        const router = new _a(__classPrivateFieldGet(this, _Router_opts, "f"));
        __classPrivateFieldSet(router, _Router_methods, __classPrivateFieldGet(router, _Router_methods, "f").slice(), "f");
        __classPrivateFieldSet(router, _Router_params, { ...__classPrivateFieldGet(this, _Router_params, "f") }, "f");
        __classPrivateFieldSet(router, _Router_stack, __classPrivateFieldGet(this, _Router_stack, "f").map((layer) => layer.clone()), "f");
        return router;
    }, Symbol.iterator)]() {
        for (const route of __classPrivateFieldGet(this, _Router_stack, "f")) {
            yield route.toJSON();
        }
    }
    /** Generate a URL pathname based on the provided path, interpolating the
     * optional params provided.  Also accepts an optional set of options. */
    static url(path, params, options) {
        return toUrl(path, params, options);
    }
    [Symbol.for("Deno.customInspect")](inspect) {
        return `${this.constructor.name} ${inspect({ "#params": __classPrivateFieldGet(this, _Router_params, "f"), "#stack": __classPrivateFieldGet(this, _Router_stack, "f") })}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, 
    // deno-lint-ignore no-explicit-any
    options, inspect) {
        if (depth < 0) {
            return options.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options, {
            depth: options.depth === null ? null : options.depth - 1,
        });
        return `${options.stylize(this.constructor.name, "special")} ${inspect({ "#params": __classPrivateFieldGet(this, _Router_params, "f"), "#stack": __classPrivateFieldGet(this, _Router_stack, "f") }, newOptions)}`;
    }
}
_a = Router;
