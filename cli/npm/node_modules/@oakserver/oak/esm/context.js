var _Context_instances, _Context_socket, _Context_sse, _Context_wrapReviverReplacer;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
// Copyright 2018-2023 the oak authors. All rights reserved. MIT license.
import * as dntShim from "./_dnt.shims.js";
import { createHttpError, SecureCookieMap, ServerSentEventStreamTarget, } from "./deps.js";
import { Request } from "./request.js";
import { Response } from "./response.js";
import { send } from "./send.js";
import { assert } from "./util.js";
/** Provides context about the current request and response to middleware
 * functions, and the current instance being processed is the first argument
 * provided a {@linkcode Middleware} function.
 *
 * _Typically this is only used as a type annotation and shouldn't be
 * constructed directly._
 *
 * ### Example
 *
 * ```ts
 * import { Application, Context } from "https://deno.land/x/oak/mod.ts";
 *
 * const app = new Application();
 *
 * app.use((ctx) => {
 *   // information about the request is here:
 *   ctx.request;
 *   // information about the response is here:
 *   ctx.response;
 *   // the cookie store is here:
 *   ctx.cookies;
 * });
 *
 * // Needs a type annotation because it cannot be inferred.
 * function mw(ctx: Context) {
 *   // process here...
 * }
 *
 * app.use(mw);
 * ```
 *
 * @template S the state which extends the application state (`AS`)
 * @template AS the type of the state derived from the application
 */
export class Context {
    /** Is `true` if the current connection is upgradeable to a web socket.
     * Otherwise the value is `false`.  Use `.upgrade()` to upgrade the connection
     * and return the web socket. */
    get isUpgradable() {
        const upgrade = this.request.headers.get("upgrade");
        if (!upgrade || upgrade.toLowerCase() !== "websocket") {
            return false;
        }
        const secKey = this.request.headers.get("sec-websocket-key");
        return typeof secKey === "string" && secKey != "";
    }
    /** If the the current context has been upgraded, then this will be set to
     * with the current web socket, otherwise it is `undefined`. */
    get socket() {
        return __classPrivateFieldGet(this, _Context_socket, "f");
    }
    constructor(app, serverRequest, state, { secure = false, jsonBodyReplacer, jsonBodyReviver, } = {}) {
        _Context_instances.add(this);
        _Context_socket.set(this, void 0);
        _Context_sse.set(this, void 0);
        /** A reference to the current application. */
        Object.defineProperty(this, "app", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** An object which allows access to cookies, mediating both the request and
         * response. */
        Object.defineProperty(this, "cookies", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** Determines if the request should be responded to.  If `false` when the
         * middleware completes processing, the response will not be sent back to the
         * requestor.  Typically this is used if the middleware will take over low
         * level processing of requests and responses, for example if using web
         * sockets.  This automatically gets set to `false` when the context is
         * upgraded to a web socket via the `.upgrade()` method.
         *
         * The default is `true`. */
        Object.defineProperty(this, "respond", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** An object which contains information about the current request. */
        Object.defineProperty(this, "request", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** An object which contains information about the response that will be sent
         * when the middleware finishes processing. */
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** The object to pass state to front-end views.  This can be typed by
         * supplying the generic state argument when creating a new app.  For
         * example:
         *
         * ```ts
         * const app = new Application<{ foo: string }>();
         * ```
         *
         * Or can be contextually inferred based on setting an initial state object:
         *
         * ```ts
         * const app = new Application({ state: { foo: "bar" } });
         * ```
         *
         * On each request/response cycle, the context's state is cloned from the
         * application state. This means changes to the context's `.state` will be
         * dropped when the request drops, but "defaults" can be applied to the
         * application's state.  Changes to the application's state though won't be
         * reflected until the next request in the context's state.
         */
        Object.defineProperty(this, "state", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.app = app;
        this.state = state;
        const { proxy } = app;
        this.request = new Request(serverRequest, {
            proxy,
            secure,
            jsonBodyReviver: __classPrivateFieldGet(this, _Context_instances, "m", _Context_wrapReviverReplacer).call(this, jsonBodyReviver),
        });
        this.respond = true;
        this.response = new Response(this.request, __classPrivateFieldGet(this, _Context_instances, "m", _Context_wrapReviverReplacer).call(this, jsonBodyReplacer));
        this.cookies = new SecureCookieMap(serverRequest, {
            keys: this.app.keys,
            response: this.response,
            secure: this.request.secure,
        });
    }
    /** Asserts the condition and if the condition fails, creates an HTTP error
     * with the provided status (which defaults to `500`).  The error status by
     * default will be set on the `.response.status`.
     *
     * Because of limitation of TypeScript, any assertion type function requires
     * specific type annotations, so the {@linkcode Context} type should be used
     * even if it can be inferred from the context.
     *
     * ### Example
     *
     * ```ts
     * import { Context, Status } from "https://deno.land/x/oak/mod.ts";
     *
     * export function mw(ctx: Context) {
     *   const body = ctx.request.body();
     *   ctx.assert(body.type === "json", Status.NotAcceptable);
     *   // process the body and send a response...
     * }
     * ```
     */
    assert(
    // deno-lint-ignore no-explicit-any
    condition, errorStatus = 500, message, props) {
        if (condition) {
            return;
        }
        const httpErrorOptions = {};
        if (typeof props === "object") {
            if ("headers" in props) {
                httpErrorOptions.headers = props.headers;
                delete props.headers;
            }
            if ("expose" in props) {
                httpErrorOptions.expose = props.expose;
                delete props.expose;
            }
        }
        const err = createHttpError(errorStatus, message, httpErrorOptions);
        if (props) {
            Object.assign(err, props);
        }
        throw err;
    }
    /** Asynchronously fulfill a response with a file from the local file
     * system.
     *
     * If the `options.path` is not supplied, the file to be sent will default
     * to this `.request.url.pathname`.
     *
     * Requires Deno read permission. */
    send(options) {
        const { path = this.request.url.pathname, ...sendOptions } = options;
        return send(this, path, sendOptions);
    }
    /** Convert the connection to stream events, returning an event target for
     * sending server sent events.  Events dispatched on the returned target will
     * be sent to the client and be available in the client's `EventSource` that
     * initiated the connection.
     *
     * **Note** the body needs to be returned to the client to be able to
     * dispatch events, so dispatching events within the middleware will delay
     * sending the body back to the client.
     *
     * This will set the response body and update response headers to support
     * sending SSE events. Additional middleware should not modify the body.
     */
    sendEvents(options) {
        if (!__classPrivateFieldGet(this, _Context_sse, "f")) {
            assert(this.response.writable, "The response is not writable.");
            const sse = __classPrivateFieldSet(this, _Context_sse, new ServerSentEventStreamTarget(options), "f");
            this.app.addEventListener("close", () => sse.close());
            const [bodyInit, { headers }] = sse.asResponseInit({
                headers: this.response.headers,
            });
            this.response.body = bodyInit;
            if (headers instanceof dntShim.Headers) {
                this.response.headers = headers;
            }
        }
        return __classPrivateFieldGet(this, _Context_sse, "f");
    }
    /** Create and throw an HTTP Error, which can be used to pass status
     * information which can be caught by other middleware to send more
     * meaningful error messages back to the client.  The passed error status will
     * be set on the `.response.status` by default as well.
     */
    throw(errorStatus, message, props) {
        const err = createHttpError(errorStatus, message);
        if (props) {
            Object.assign(err, props);
        }
        throw err;
    }
    /** Take the current request and upgrade it to a web socket, resolving with
     * the a web standard `WebSocket` object. This will set `.respond` to
     * `false`.  If the socket cannot be upgraded, this method will throw. */
    upgrade(options) {
        if (__classPrivateFieldGet(this, _Context_socket, "f")) {
            return __classPrivateFieldGet(this, _Context_socket, "f");
        }
        if (!this.request.originalRequest.upgrade) {
            throw new TypeError("Web socket upgrades not currently supported for this type of server.");
        }
        __classPrivateFieldSet(this, _Context_socket, this.request.originalRequest.upgrade(options), "f");
        this.app.addEventListener("close", () => __classPrivateFieldGet(this, _Context_socket, "f")?.close());
        this.respond = false;
        return __classPrivateFieldGet(this, _Context_socket, "f");
    }
    [(_Context_socket = new WeakMap(), _Context_sse = new WeakMap(), _Context_instances = new WeakSet(), _Context_wrapReviverReplacer = function _Context_wrapReviverReplacer(reviver) {
        return reviver
            ? (key, value) => reviver(key, value, this)
            : undefined;
    }, Symbol.for("Deno.customInspect"))](inspect) {
        const { app, cookies, isUpgradable, respond, request, response, socket, state, } = this;
        return `${this.constructor.name} ${inspect({
            app,
            cookies,
            isUpgradable,
            respond,
            request,
            response,
            socket,
            state,
        })}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, 
    // deno-lint-ignore no-explicit-any
    options, inspect) {
        if (depth < 0) {
            return options.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options, {
            depth: options.depth === null ? null : options.depth - 1,
        });
        const { app, cookies, isUpgradable, respond, request, response, socket, state, } = this;
        return `${options.stylize(this.constructor.name, "special")} ${inspect({
            app,
            cookies,
            isUpgradable,
            respond,
            request,
            response,
            socket,
            state,
        }, newOptions)}`;
    }
}
