var _ByteSliceStream_offsetStart, _ByteSliceStream_offsetEnd;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import * as dntShim from "../../../../_dnt.shims.js";
import { assert } from "../assert/assert.js";
/**
 * A transform stream that only transforms from the zero-indexed `start` and
 * `end` bytes (both inclusive).
 *
 * @example
 * ```ts
 * import { ByteSliceStream } from "https://deno.land/std@$STD_VERSION/streams/byte_slice_stream.ts";
 *
 * const response = await fetch("https://example.com");
 * const rangedStream = response.body!
 *   .pipeThrough(new ByteSliceStream(3, 8));
 * ```
 */
export class ByteSliceStream extends dntShim.TransformStream {
    /** Constructs a new instance. */
    constructor(start = 0, end = Infinity) {
        super({
            start: () => {
                assert(start >= 0, "`start` must be greater than 0");
                end += 1;
            },
            transform: (chunk, controller) => {
                __classPrivateFieldSet(this, _ByteSliceStream_offsetStart, __classPrivateFieldGet(this, _ByteSliceStream_offsetEnd, "f"), "f");
                __classPrivateFieldSet(this, _ByteSliceStream_offsetEnd, __classPrivateFieldGet(this, _ByteSliceStream_offsetEnd, "f") + chunk.byteLength, "f");
                if (__classPrivateFieldGet(this, _ByteSliceStream_offsetEnd, "f") > start) {
                    if (__classPrivateFieldGet(this, _ByteSliceStream_offsetStart, "f") < start) {
                        chunk = chunk.slice(start - __classPrivateFieldGet(this, _ByteSliceStream_offsetStart, "f"));
                    }
                    if (__classPrivateFieldGet(this, _ByteSliceStream_offsetEnd, "f") >= end) {
                        chunk = chunk.slice(0, chunk.byteLength - __classPrivateFieldGet(this, _ByteSliceStream_offsetEnd, "f") + end);
                        controller.enqueue(chunk);
                        controller.terminate();
                    }
                    else {
                        controller.enqueue(chunk);
                    }
                }
            },
        });
        _ByteSliceStream_offsetStart.set(this, 0);
        _ByteSliceStream_offsetEnd.set(this, 0);
    }
}
_ByteSliceStream_offsetStart = new WeakMap(), _ByteSliceStream_offsetEnd = new WeakMap();
