// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
var _KeyStack_instances, _KeyStack_cryptoKeys, _KeyStack_keys, _KeyStack_toCryptoKey;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
/**
 * Provides the {@linkcode KeyStack} class which implements the
 * {@linkcode KeyRing} interface for managing rotatable keys.
 *
 * @module
 */
import * as dntShim from "../../../../_dnt.shims.js";
import { timingSafeEqual } from "./timing_safe_equal.js";
import { encodeBase64Url } from "../encoding/base64url.js";
const encoder = new TextEncoder();
function importKey(key) {
    if (typeof key === "string") {
        key = encoder.encode(key);
    }
    else if (Array.isArray(key)) {
        key = new Uint8Array(key);
    }
    return dntShim.crypto.subtle.importKey("raw", key, {
        name: "HMAC",
        hash: { name: "SHA-256" },
    }, true, ["sign", "verify"]);
}
function sign(data, key) {
    if (typeof data === "string") {
        data = encoder.encode(data);
    }
    else if (Array.isArray(data)) {
        data = Uint8Array.from(data);
    }
    return dntShim.crypto.subtle.sign("HMAC", key, data);
}
/** Compare two strings, Uint8Arrays, ArrayBuffers, or arrays of numbers in a
 * way that avoids timing based attacks on the comparisons on the values.
 *
 * The function will return `true` if the values match, or `false`, if they
 * do not match.
 *
 * This was inspired by https://github.com/suryagh/tsscmp which provides a
 * timing safe string comparison to avoid timing attacks as described in
 * https://codahale.com/a-lesson-in-timing-attacks/.
 */
async function compare(a, b) {
    const key = new Uint8Array(32);
    dntShim.dntGlobalThis.crypto.getRandomValues(key);
    const cryptoKey = await importKey(key);
    const [ah, bh] = await Promise.all([
        sign(a, cryptoKey),
        sign(b, cryptoKey),
    ]);
    return timingSafeEqual(ah, bh);
}
/** A cryptographic key chain which allows signing of data to prevent tampering,
 * but also allows for easy key rotation without needing to re-sign the data.
 *
 * Data is signed as SHA256 HMAC.
 *
 * This was inspired by [keygrip](https://github.com/crypto-utils/keygrip/).
 *
 * @example
 * ```ts
 * import { KeyStack } from "https://deno.land/std@$STD_VERSION/crypto/unstable_keystack.ts";
 *
 * const keyStack = new KeyStack(["hello", "world"]);
 * const digest = await keyStack.sign("some data");
 *
 * const rotatedStack = new KeyStack(["deno", "says", "hello", "world"]);
 * await rotatedStack.verify("some data", digest); // true
 * ```
 */
export class KeyStack {
    /** Number of keys */
    get length() {
        return __classPrivateFieldGet(this, _KeyStack_keys, "f").length;
    }
    /** A class which accepts an array of keys that are used to sign and verify
     * data and allows easy key rotation without invalidation of previously signed
     * data.
     *
     * @param keys An iterable of keys, of which the index 0 will be used to sign
     *             data, but verification can happen against any key.
     */
    constructor(keys) {
        _KeyStack_instances.add(this);
        _KeyStack_cryptoKeys.set(this, new Map());
        _KeyStack_keys.set(this, void 0);
        const values = Array.isArray(keys) ? keys : [...keys];
        if (!(values.length)) {
            throw new TypeError("keys must contain at least one value");
        }
        __classPrivateFieldSet(this, _KeyStack_keys, values, "f");
    }
    /** Take `data` and return a SHA256 HMAC digest that uses the current 0 index
     * of the `keys` passed to the constructor.  This digest is in the form of a
     * URL safe base64 encoded string. */
    async sign(data) {
        const key = await __classPrivateFieldGet(this, _KeyStack_instances, "m", _KeyStack_toCryptoKey).call(this, __classPrivateFieldGet(this, _KeyStack_keys, "f")[0]);
        return encodeBase64Url(await sign(data, key));
    }
    /** Given `data` and a `digest`, verify that one of the `keys` provided the
     * constructor was used to generate the `digest`.  Returns `true` if one of
     * the keys was used, otherwise `false`. */
    async verify(data, digest) {
        return (await this.indexOf(data, digest)) > -1;
    }
    /** Given `data` and a `digest`, return the current index of the key in the
     * `keys` passed the constructor that was used to generate the digest.  If no
     * key can be found, the method returns `-1`. */
    async indexOf(data, digest) {
        for (let i = 0; i < __classPrivateFieldGet(this, _KeyStack_keys, "f").length; i++) {
            const cryptoKey = await __classPrivateFieldGet(this, _KeyStack_instances, "m", _KeyStack_toCryptoKey).call(this, __classPrivateFieldGet(this, _KeyStack_keys, "f")[i]);
            if (await compare(digest, encodeBase64Url(await sign(data, cryptoKey)))) {
                return i;
            }
        }
        return -1;
    }
    /** Custom output for {@linkcode Deno.inspect}. */
    [(_KeyStack_cryptoKeys = new WeakMap(), _KeyStack_keys = new WeakMap(), _KeyStack_instances = new WeakSet(), _KeyStack_toCryptoKey = async function _KeyStack_toCryptoKey(key) {
        if (!__classPrivateFieldGet(this, _KeyStack_cryptoKeys, "f").has(key)) {
            __classPrivateFieldGet(this, _KeyStack_cryptoKeys, "f").set(key, await importKey(key));
        }
        return __classPrivateFieldGet(this, _KeyStack_cryptoKeys, "f").get(key);
    }, Symbol.for("Deno.customInspect"))](inspect) {
        const { length } = this;
        return `${this.constructor.name} ${inspect({ length })}`;
    }
    /** Custom output for Node's {@linkcode https://nodejs.org/api/util.html#utilinspectobject-options|util.inspect}. */
    [Symbol.for("nodejs.util.inspect.custom")](depth, 
    // deno-lint-ignore no-explicit-any
    options, inspect) {
        if (depth < 0) {
            return options.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options, {
            depth: options.depth === null ? null : options.depth - 1,
        });
        const { length } = this;
        return `${options.stylize(this.constructor.name, "special")} ${inspect({ length }, newOptions)}`;
    }
}
