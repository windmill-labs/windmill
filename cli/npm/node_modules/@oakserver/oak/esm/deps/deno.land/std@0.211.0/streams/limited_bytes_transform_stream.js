// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
var _LimitedBytesTransformStream_read;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
/**
 * A {@linkcode TransformStream} that will only read & enqueue `size` amount of
 * bytes. This operation is chunk based and not BYOB based, and as such will
 * read more than needed.
 *
 * If `options.error` is set, then instead of terminating the stream,
 * an error will be thrown.
 *
 * @example
 * ```ts
 * import { LimitedBytesTransformStream } from "https://deno.land/std@$STD_VERSION/streams/limited_bytes_transform_stream.ts";
 *
 * const res = await fetch("https://example.com");
 * const parts = res.body!
 *   .pipeThrough(new LimitedBytesTransformStream(512 * 1024));
 * ```
 */
import * as dntShim from "../../../../_dnt.shims.js";
export class LimitedBytesTransformStream extends dntShim.TransformStream {
    /** Constructs a new instance. */
    constructor(size, options = {}) {
        super({
            transform: (chunk, controller) => {
                if ((__classPrivateFieldGet(this, _LimitedBytesTransformStream_read, "f") + chunk.byteLength) > size) {
                    if (options.error) {
                        throw new RangeError(`Exceeded byte size limit of '${size}'`);
                    }
                    else {
                        controller.terminate();
                    }
                }
                else {
                    __classPrivateFieldSet(this, _LimitedBytesTransformStream_read, __classPrivateFieldGet(this, _LimitedBytesTransformStream_read, "f") + chunk.byteLength, "f");
                    controller.enqueue(chunk);
                }
            },
        });
        _LimitedBytesTransformStream_read.set(this, 0);
    }
}
_LimitedBytesTransformStream_read = new WeakMap();
