/**
 * Provides {@linkcode ServerSentEvent} and
 * {@linkcode ServerSentEventStreamTarget} which provides an interface to send
 * server sent events to a browser using the DOM event model.
 *
 * The {@linkcode ServerSentEventStreamTarget} provides the `.asResponse()` or
 * `.asResponseInit()` to provide a body and headers to the client to establish
 * the event connection. This is accomplished by keeping a connection open to
 * the client by not closing the body, which allows events to be sent down the
 * connection and processed by the client browser.
 *
 * See more about Server-sent events on [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events)
 *
 * ## Example
 *
 * ```ts
 * import {
 *   ServerSentEvent,
 *   ServerSentEventStreamTarget,
 * } from "https://deno.land/std@$STD_VERSION/http/unstable_server_sent_event.ts";
 *
 * Deno.serve({ port: 8000 }, (request) => {
 *   const target = new ServerSentEventStreamTarget();
 *   let counter = 0;
 *
 *   // Sends an event every 2 seconds, incrementing the ID
 *   const id = setInterval(() => {
 *     const evt = new ServerSentEvent(
 *       "message",
 *       { data: { hello: "world" }, id: counter++ },
 *     );
 *     target.dispatchEvent(evt);
 *   }, 2000);
 *
 *   target.addEventListener("close", () => clearInterval(id));
 *   return target.asResponse();
 * });
 * ```
 *
 * @module
 */
import * as dntShim from "../../../../_dnt.shims.js";
export interface ServerSentEventInit extends EventInit {
    /** Optional arbitrary data to send to the client, data this is a string will
     * be sent unmodified, otherwise `JSON.parse()` will be used to serialize the
     * value. */
    data?: unknown;
    /** An optional `id` which will be sent with the event and exposed in the
     * client `EventSource`. */
    id?: number;
    /** The replacer is passed to `JSON.stringify` when converting the `data`
     * property to a JSON string. */
    replacer?: (string | number)[] | ((this: any, key: string, value: any) => any);
    /** Space is passed to `JSON.stringify` when converting the `data` property
     * to a JSON string. */
    space?: string | number;
}
export interface ServerSentEventTargetOptions {
    /** Keep client connections alive by sending a comment event to the client
     * at a specified interval.  If `true`, then it polls every 30000 milliseconds
     * (30 seconds). If set to a number, then it polls that number of
     * milliseconds.  The feature is disabled if set to `false`.  It defaults to
     * `false`. */
    keepAlive?: boolean | number;
}
declare class CloseEvent extends Event {
    constructor(eventInit: EventInit);
}
/**
 * An event which contains information which will be sent to the remote
 * connection and be made available in an `EventSource` as an event. A server
 * creates new events and dispatches them on the target which will then be
 * sent to a client.
 *
 * See more about Server-sent events on [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events)
 *
 * ### Example
 *
 * ```ts
 * import {
 *   ServerSentEvent,
 *   ServerSentEventStreamTarget,
 * } from "https://deno.land/std@$STD_VERSION/http/server_sent_event.ts";
 *
 * Deno.serve({ port: 8000 }, (request) => {
 *   const target = new ServerSentEventStreamTarget();
 *   const evt = new ServerSentEvent("message", {
 *     data: { hello: "world" },
 *     id: 1
 *   });
 *   target.dispatchEvent(evt);
 *   return target.asResponse();
 * });
 * ```
 */
export declare class ServerSentEvent extends Event {
    #private;
    /**
     * @param type the event type that will be available on the client. The type
     *             of `"message"` will be handled specifically as a message
     *             server-side event.
     * @param eventInit initialization options for the event
     */
    constructor(type: string, eventInit?: ServerSentEventInit);
    /** The data associated with the event, which will be sent to the client and
     * be made available in the `EventSource`. */
    get data(): string;
    /** The optional ID associated with the event that will be sent to the client
     * and be made available in the `EventSource`. */
    get id(): number | undefined;
    toString(): string;
}
export interface ServerSentEventTarget extends EventTarget {
    /** Is set to `true` if events cannot be sent to the remote connection.
     * Otherwise it is set to `false`.
     *
     * *Note*: This flag is lazily set, and might not reflect a closed state until
     * another event, comment or message is attempted to be processed. */
    readonly closed: boolean;
    /** Close the target, refusing to accept any more events. */
    close(): Promise<void>;
    /** Send a comment to the remote connection.  Comments are not exposed to the
     * client `EventSource` but are used for diagnostics and helping ensure a
     * connection is kept alive.
     *
     * ```ts
     * import { ServerSentEventStreamTarget } from "https://deno.land/std@$STD_VERSION/http/server_sent_event.ts";
     *
     * Deno.serve({ port: 8000 }, (request) => {
     *   const target = new ServerSentEventStreamTarget();
     *   target.dispatchComment("this is a comment");
     *   return target.asResponse();
     * });
     * ```
     */
    dispatchComment(comment: string): boolean;
    /** Dispatch a message to the client.  This message will contain `data: ` only
     * and be available on the client `EventSource` on the `onmessage` or an event
     * listener of type `"message"`. */
    dispatchMessage(data: unknown): boolean;
    /** Dispatch a server sent event to the client.  The event `type` will be
     * sent as `event: ` to the client which will be raised as a `MessageEvent`
     * on the `EventSource` in the client.
     *
     * Any local event handlers will be dispatched to first, and if the event
     * is cancelled, it will not be sent to the client.
     *
     * ```ts
     * import {
     *   ServerSentEvent,
     *   ServerSentEventStreamTarget,
     * } from "https://deno.land/std@$STD_VERSION/http/server_sent_event.ts";
     *
     * Deno.serve({ port: 8000 }, (request) => {
     *   const target = new ServerSentEventStreamTarget();
     *   const evt = new ServerSentEvent("ping", { data: "hello" });
     *   target.dispatchEvent(evt);
     *   return target.asResponse();
     * });
     * ```
     */
    dispatchEvent(event: ServerSentEvent): boolean;
    /** Dispatch a server sent event to the client.  The event `type` will be
     * sent as `event: ` to the client which will be raised as a `MessageEvent`
     * on the `EventSource` in the client.
     *
     * Any local event handlers will be dispatched to first, and if the event
     * is cancelled, it will not be sent to the client.
     *
     * ```ts
     * import {
     *   ServerSentEvent,
     *   ServerSentEventStreamTarget,
     * } from "https://deno.land/std@$STD_VERSION/http/server_sent_event.ts";
     *
     * Deno.serve({ port: 8000 }, (request) => {
     *   const target = new ServerSentEventStreamTarget();
     *   const evt = new ServerSentEvent("ping", { data: "hello" });
     *   target.dispatchEvent(evt);
     *   return target.asResponse();
     * });
     * ```
     */
    dispatchEvent(event: CloseEvent | dntShim.ErrorEvent): boolean;
}
/**
 * An implementation of {@linkcode ServerSentEventTarget} that provides a
 * readable stream as a body of a response to establish a connection to a
 * client.
 */
export declare class ServerSentEventStreamTarget extends EventTarget implements ServerSentEventTarget {
    #private;
    get closed(): boolean;
    constructor({ keepAlive }?: ServerSentEventTargetOptions);
    /** Returns a {@linkcode Response} which contains the body and headers needed
     * to initiate a SSE connection with the client. */
    asResponse(responseInit?: dntShim.ResponseInit): dntShim.Response;
    /** Returns a tuple which contains the {@linkcode BodyInit} and
     * {@linkcode ResponseInit} needed to create a response that will establish
     * a SSE connection with the client. */
    asResponseInit(responseInit?: dntShim.ResponseInit): [dntShim.BodyInit, dntShim.ResponseInit];
    close(): Promise<void>;
    dispatchComment(comment: string): boolean;
    dispatchMessage(data: any): boolean;
    dispatchEvent(event: ServerSentEvent): boolean;
    dispatchEvent(event: CloseEvent | dntShim.ErrorEvent): boolean;
}
export {};
