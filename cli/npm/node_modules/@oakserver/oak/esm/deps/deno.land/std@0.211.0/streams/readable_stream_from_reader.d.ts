/// <reference types="node" />
import * as dntShim from "../../../../_dnt.shims.js";
import type { Closer, Reader } from "../io/types";
export type { Closer };
/**
 * Options for {@linkcode readableStreamFromReader}.
 *
 * @deprecated (will be removed after 1.0.0) Use {@linkcode ReadableStream}
 * directly instead.
 */
export interface ReadableStreamFromReaderOptions {
    /** If the `reader` is also a `Closer`, automatically close the `reader`
     * when `EOF` is encountered, or a read error occurs.
     *
     * @default {true}
     */
    autoClose?: boolean;
    /** The size of chunks to allocate to read, the default is ~16KiB, which is
     * the maximum size that Deno operations can currently support. */
    chunkSize?: number;
    /** The queuing strategy to create the `ReadableStream` with. */
    strategy?: {
        highWaterMark?: number | undefined;
        size?: undefined;
    };
}
/**
 * Create a {@linkcode ReadableStream} of {@linkcode Uint8Array}s from a
 * {@linkcode Reader}.
 *
 * When the pull algorithm is called on the stream, a chunk from the reader
 * will be read.  When `null` is returned from the reader, the stream will be
 * closed along with the reader (if it is also a `Closer`).
 *
 * An example converting a `Deno.FsFile` into a readable stream:
 *
 * ```ts
 * import { readableStreamFromReader } from "https://deno.land/std@$STD_VERSION/streams/readable_stream_from_reader.ts";
 *
 * const file = await Deno.open("./file.txt", { read: true });
 * const fileStream = readableStreamFromReader(file);
 * ```
 *
 * @deprecated (will be removed after 1.0.0) Use {@linkcode ReadableStream} directly instead.
 */
export declare function readableStreamFromReader(reader: Reader | (Reader & Closer), options?: ReadableStreamFromReaderOptions): dntShim.ReadableStream<Uint8Array>;
