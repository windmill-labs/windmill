var _Response_instances, _Response_body, _Response_bodySet, _Response_domResponse, _Response_headers, _Response_jsonBodyReplacer, _Response_request, _Response_resources, _Response_status, _Response_type, _Response_writable, _Response_getBodyInit, _Response_setContentType;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
// Copyright 2018-2023 the oak authors. All rights reserved. MIT license.
import * as dntShim from "./_dnt.shims.js";
import { contentType, isRedirectStatus, Status, STATUS_TEXT } from "./deps.js";
import { DomResponse } from "./http_server_native_request.js";
import { BODY_TYPES, encodeUrl, isAsyncIterable, isHtml, isReader, readableStreamFromAsyncIterable, readableStreamFromReader, Uint8ArrayTransformStream, } from "./util.js";
/** A symbol that indicates to `response.redirect()` to attempt to redirect
 * back to the request referrer.  For example:
 *
 * ```ts
 * import { Application, REDIRECT_BACK } from "https://deno.land/x/oak/mod.ts";
 *
 * const app = new Application();
 *
 * app.use((ctx) => {
 *   if (ctx.request.url.pathName === "/back") {
 *     ctx.response.redirect(REDIRECT_BACK, "/");
 *   }
 * });
 *
 * await app.listen({ port: 80 });
 * ```
 */
export const REDIRECT_BACK = Symbol("redirect backwards");
export async function convertBodyToBodyInit(body, type, jsonBodyReplacer) {
    let result;
    if (BODY_TYPES.includes(typeof body)) {
        result = String(body);
        type = type ?? (isHtml(result) ? "html" : "text/plain");
    }
    else if (isReader(body)) {
        result = readableStreamFromReader(body);
    }
    else if (ArrayBuffer.isView(body) || body instanceof ArrayBuffer ||
        body instanceof dntShim.Blob || body instanceof URLSearchParams) {
        // deno-lint-ignore no-explicit-any
        result = body;
    }
    else if (body instanceof dntShim.ReadableStream) {
        result = body.pipeThrough(new Uint8ArrayTransformStream());
    }
    else if (body instanceof dntShim.FormData) {
        result = body;
        type = "multipart/form-data";
    }
    else if (isAsyncIterable(body)) {
        result = readableStreamFromAsyncIterable(body);
    }
    else if (body && typeof body === "object") {
        result = JSON.stringify(body, jsonBodyReplacer);
        type = type ?? "json";
    }
    else if (typeof body === "function") {
        const result = body.call(null);
        return convertBodyToBodyInit(await result, type, jsonBodyReplacer);
    }
    else if (body) {
        throw new TypeError("Response body was set but could not be converted.");
    }
    return [result, type];
}
/** An interface to control what response will be sent when the middleware
 * finishes processing the request.
 *
 * The response is usually accessed via the context's `.response` property.
 *
 * ### Example
 *
 * ```ts
 * import { Application, Status } from "https://deno.land/x/oak/mod.ts";
 *
 * const app = new Application();
 *
 * app.use((ctx) => {
 *   ctx.response.body = { hello: "oak" };
 *   ctx.response.type = "json";
 *   ctx.response.status = Status.OK;
 * });
 * ```
 */
export class Response {
    /** The body of the response.  The body will be automatically processed when
     * the response is being sent and converted to a `Uint8Array` or a
     * `Deno.Reader`.
     *
     * Automatic conversion to a `Deno.Reader` occurs for async iterables. */
    get body() {
        return __classPrivateFieldGet(this, _Response_body, "f");
    }
    /** The body of the response.  The body will be automatically processed when
     * the response is being sent and converted to a `Uint8Array` or a
     * `Deno.Reader`.
     *
     * Automatic conversion to a `Deno.Reader` occurs for async iterables. */
    set body(value) {
        if (!__classPrivateFieldGet(this, _Response_writable, "f")) {
            throw new Error("The response is not writable.");
        }
        __classPrivateFieldSet(this, _Response_bodySet, true, "f");
        __classPrivateFieldSet(this, _Response_body, value, "f");
    }
    /** Headers that will be returned in the response. */
    get headers() {
        return __classPrivateFieldGet(this, _Response_headers, "f");
    }
    /** Headers that will be returned in the response. */
    set headers(value) {
        if (!__classPrivateFieldGet(this, _Response_writable, "f")) {
            throw new Error("The response is not writable.");
        }
        __classPrivateFieldSet(this, _Response_headers, value, "f");
    }
    /** The HTTP status of the response.  If this has not been explicitly set,
     * reading the value will return what would be the value of status if the
     * response were sent at this point in processing the middleware.  If the body
     * has been set, the status will be `200 OK`.  If a value for the body has
     * not been set yet, the status will be `404 Not Found`. */
    get status() {
        if (__classPrivateFieldGet(this, _Response_status, "f")) {
            return __classPrivateFieldGet(this, _Response_status, "f");
        }
        return this.body != null
            ? Status.OK
            : __classPrivateFieldGet(this, _Response_bodySet, "f")
                ? Status.NoContent
                : Status.NotFound;
    }
    /** The HTTP status of the response.  If this has not been explicitly set,
     * reading the value will return what would be the value of status if the
     * response were sent at this point in processing the middleware.  If the body
     * has been set, the status will be `200 OK`.  If a value for the body has
     * not been set yet, the status will be `404 Not Found`. */
    set status(value) {
        if (!__classPrivateFieldGet(this, _Response_writable, "f")) {
            throw new Error("The response is not writable.");
        }
        __classPrivateFieldSet(this, _Response_status, value, "f");
    }
    /** The media type, or extension of the response.  Setting this value will
     * ensure an appropriate `Content-Type` header is added to the response. */
    get type() {
        return __classPrivateFieldGet(this, _Response_type, "f");
    }
    /** The media type, or extension of the response.  Setting this value will
     * ensure an appropriate `Content-Type` header is added to the response. */
    set type(value) {
        if (!__classPrivateFieldGet(this, _Response_writable, "f")) {
            throw new Error("The response is not writable.");
        }
        __classPrivateFieldSet(this, _Response_type, value, "f");
    }
    /** A read-only property which determines if the response is writable or not.
     * Once the response has been processed, this value is set to `false`. */
    get writable() {
        return __classPrivateFieldGet(this, _Response_writable, "f");
    }
    constructor(request, jsonBodyReplacer) {
        _Response_instances.add(this);
        _Response_body.set(this, void 0);
        _Response_bodySet.set(this, false);
        _Response_domResponse.set(this, void 0);
        _Response_headers.set(this, new dntShim.Headers());
        _Response_jsonBodyReplacer.set(this, void 0);
        _Response_request.set(this, void 0);
        _Response_resources.set(this, []);
        _Response_status.set(this, void 0);
        _Response_type.set(this, void 0);
        _Response_writable.set(this, true);
        __classPrivateFieldSet(this, _Response_request, request, "f");
        __classPrivateFieldSet(this, _Response_jsonBodyReplacer, jsonBodyReplacer, "f");
    }
    /** Add a resource to the list of resources that will be closed when the
     * request is destroyed. */
    addResource(rid) {
        __classPrivateFieldGet(this, _Response_resources, "f").push(rid);
    }
    /** Release any resources that are being tracked by the response.
     *
     * @param closeResources close any resource IDs registered with the response
     */
    destroy(closeResources = true) {
        __classPrivateFieldSet(this, _Response_writable, false, "f");
        __classPrivateFieldSet(this, _Response_body, undefined, "f");
        __classPrivateFieldSet(this, _Response_domResponse, undefined, "f");
        if (closeResources) {
            for (const rid of __classPrivateFieldGet(this, _Response_resources, "f")) {
                try {
                    dntShim.Deno.close(rid);
                }
                catch {
                    // we don't care about errors here
                }
            }
        }
    }
    redirect(url, alt = "/") {
        if (url === REDIRECT_BACK) {
            url = __classPrivateFieldGet(this, _Response_request, "f").headers.get("Referer") ?? String(alt);
        }
        else if (typeof url === "object") {
            url = String(url);
        }
        this.headers.set("Location", encodeUrl(url));
        if (!this.status || !isRedirectStatus(this.status)) {
            this.status = Status.Found;
        }
        if (__classPrivateFieldGet(this, _Response_request, "f").accepts("html")) {
            url = encodeURI(url);
            this.type = "text/html; charset=UTF-8";
            this.body = `Redirecting to <a href="${url}">${url}</a>.`;
            return;
        }
        this.type = "text/plain; charset=UTF-8";
        this.body = `Redirecting to ${url}.`;
    }
    async toDomResponse() {
        if (__classPrivateFieldGet(this, _Response_domResponse, "f")) {
            return __classPrivateFieldGet(this, _Response_domResponse, "f");
        }
        const bodyInit = await __classPrivateFieldGet(this, _Response_instances, "m", _Response_getBodyInit).call(this);
        __classPrivateFieldGet(this, _Response_instances, "m", _Response_setContentType).call(this);
        const { headers } = this;
        // If there is no body and no content type and no set length, then set the
        // content length to 0
        if (!(bodyInit ||
            headers.has("Content-Type") ||
            headers.has("Content-Length"))) {
            headers.append("Content-Length", "0");
        }
        __classPrivateFieldSet(this, _Response_writable, false, "f");
        const status = this.status;
        const responseInit = {
            headers,
            status,
            statusText: STATUS_TEXT[status],
        };
        return __classPrivateFieldSet(this, _Response_domResponse, new DomResponse(bodyInit, responseInit), "f");
    }
    [(_Response_body = new WeakMap(), _Response_bodySet = new WeakMap(), _Response_domResponse = new WeakMap(), _Response_headers = new WeakMap(), _Response_jsonBodyReplacer = new WeakMap(), _Response_request = new WeakMap(), _Response_resources = new WeakMap(), _Response_status = new WeakMap(), _Response_type = new WeakMap(), _Response_writable = new WeakMap(), _Response_instances = new WeakSet(), _Response_getBodyInit = async function _Response_getBodyInit() {
        const [body, type] = await convertBodyToBodyInit(this.body, this.type, __classPrivateFieldGet(this, _Response_jsonBodyReplacer, "f"));
        this.type = type;
        return body;
    }, _Response_setContentType = function _Response_setContentType() {
        if (this.type) {
            const contentTypeString = contentType(this.type);
            if (contentTypeString && !this.headers.has("Content-Type")) {
                this.headers.append("Content-Type", contentTypeString);
            }
        }
    }, Symbol.for("Deno.customInspect"))](inspect) {
        const { body, headers, status, type, writable } = this;
        return `${this.constructor.name} ${inspect({ body, headers, status, type, writable })}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, 
    // deno-lint-ignore no-explicit-any
    options, inspect) {
        if (depth < 0) {
            return options.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options, {
            depth: options.depth === null ? null : options.depth - 1,
        });
        const { body, headers, status, type, writable } = this;
        return `${options.stylize(this.constructor.name, "special")} ${inspect({ body, headers, status, type, writable }, newOptions)}`;
    }
}
