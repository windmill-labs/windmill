import * as dntShim from "../_dnt.shims.js";
import type { State } from "../application.js";
import type { Context } from "../context.js";
import type { Middleware } from "../middleware.js";
import type { RouteParams, RouterContext } from "../router.js";
export type Fetch = (input: dntShim.Request, init: {
    context: Context;
}) => Promise<dntShim.Response>;
export type ProxyMatchFunction<R extends string, P extends RouteParams<R> = RouteParams<R>, S extends State = Record<string, any>> = (ctx: Context<S> | RouterContext<R, P, S>) => boolean;
export type ProxyMapFunction<R extends string, P extends RouteParams<R>> = (path: R, params?: P) => R;
export type ProxyHeadersFunction<S extends State> = (ctx: Context<S>) => dntShim.HeadersInit | Promise<dntShim.HeadersInit>;
export type ProxyRouterHeadersFunction<R extends string, P extends RouteParams<R>, S extends State> = (ctx: RouterContext<R, P, S>) => dntShim.HeadersInit | Promise<dntShim.HeadersInit>;
export interface ProxyOptions<R extends string, P extends RouteParams<R> = RouteParams<R>, S extends State = Record<string, any>> {
    /** A callback hook that is called after the response is received which allows
     * the response content type to be adjusted. This is for situations where the
     * content type provided by the proxy server might not be suitable for
     * responding with. */
    contentType?(url: string, contentType?: string): Promise<string | undefined> | string | undefined;
    /** The fetch function to use to proxy the request. This defaults to the
     * global {@linkcode fetch} function. It will always be called with a
     * second argument which contains an object of `{ context }` which the
     * `context` property will be an instance of {@linkcode RouterContext}.
     *
     * This is designed for mocking purposes or implementing a `fetch()`
     * callback that needs access the current context when it is called. */
    fetch?: Fetch;
    /** Additional headers that should be set in the response. The value can
     * be a headers init value or a function that returns or resolves with a
     * headers init value. */
    headers?: dntShim.HeadersInit | ProxyHeadersFunction<S> | ProxyRouterHeadersFunction<R, P, S>;
    /** Either a record or a proxy map function that will allow proxied requests
     * being handled by the middleware to be remapped to a different remote
     * path. */
    map?: Record<string, R> | ProxyMapFunction<R, P>;
    /** A string, regular expression or proxy match function what determines if
     * the proxy middleware should proxy the request.
     *
     * If the value is a string the match will be true if the requests pathname
     * starts with the string. In the case of a regular expression, if the
     * pathname
     */
    match?: string | RegExp | ProxyMatchFunction<R, P, S>;
    /** A flag that indicates if traditional proxy headers should be set in the
     * response. This defaults to `true`.
     */
    proxyHeaders?: boolean;
    /** A callback hook which will be called before each proxied fetch request
     * to allow the native `Request` to be modified or replaced. */
    request?(req: dntShim.Request): dntShim.Request | Promise<dntShim.Request>;
    /** A callback hook which will be called after each proxied fetch response
     * is received to allow the native `Response` to be modified or replaced. */
    response?(res: dntShim.Response): dntShim.Response | Promise<dntShim.Response>;
}
/**
 * Middleware that provides a back-to-back proxy for requests.
 *
 * @param target
 * @param options
 */
export declare function proxy<S extends State>(target: string | URL, options?: ProxyOptions<string, RouteParams<string>, S>): Middleware<S>;
