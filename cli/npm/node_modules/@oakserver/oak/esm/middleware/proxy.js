// Copyright 2018-2023 the oak authors. All rights reserved. MIT license.
import * as dntShim from "../_dnt.shims.js";
import { parse } from "../forwarded.js";
import { isRouterContext } from "../util.js";
function createMatcher({ match }) {
    return function matches(ctx) {
        if (!match) {
            return true;
        }
        if (typeof match === "string") {
            return ctx.request.url.pathname.startsWith(match);
        }
        if (match instanceof RegExp) {
            return match.test(ctx.request.url.pathname);
        }
        return match(ctx);
    };
}
async function createRequest(target, ctx, { headers: optHeaders, map, proxyHeaders = true, request: reqFn }) {
    let path = ctx.request.url.pathname;
    let params;
    if (isRouterContext(ctx)) {
        params = ctx.params;
    }
    if (map && typeof map === "function") {
        path = map(path, params);
    }
    else if (map) {
        path = map[path] ?? path;
    }
    const url = new URL(String(target));
    if (url.pathname.endsWith("/") && path.startsWith("/")) {
        url.pathname = `${url.pathname}${path.slice(1)}`;
    }
    else if (!url.pathname.endsWith("/") && !path.startsWith("/")) {
        url.pathname = `${url.pathname}/${path}`;
    }
    else {
        url.pathname = `${url.pathname}${path}`;
    }
    url.search = ctx.request.url.search;
    const body = getBodyInit(ctx);
    const headers = new dntShim.Headers(ctx.request.headers);
    if (optHeaders) {
        if (typeof optHeaders === "function") {
            optHeaders = await optHeaders(ctx);
        }
        for (const [key, value] of iterableHeaders(optHeaders)) {
            headers.set(key, value);
        }
    }
    if (proxyHeaders) {
        const maybeForwarded = headers.get("forwarded");
        const ip = ctx.request.ip.startsWith("[")
            ? `"${ctx.request.ip}"`
            : ctx.request.ip;
        const host = headers.get("host");
        if (maybeForwarded && parse(maybeForwarded)) {
            let value = `for=${ip}`;
            if (host) {
                value += `;host=${host}`;
            }
            headers.append("forwarded", value);
        }
        else {
            headers.append("x-forwarded-for", ip);
            if (host) {
                headers.append("x-forwarded-host", host);
            }
        }
    }
    const init = {
        body,
        headers,
        method: ctx.request.method,
        redirect: "follow",
    };
    let request = new dntShim.Request(url.toString(), init);
    if (reqFn) {
        request = await reqFn(request);
    }
    return request;
}
function getBodyInit(ctx) {
    if (!ctx.request.hasBody) {
        return null;
    }
    return ctx.request.body({ type: "stream" }).value;
}
function iterableHeaders(headers) {
    if (headers instanceof dntShim.Headers) {
        return headers.entries();
    }
    else if (Array.isArray(headers)) {
        return headers.values();
    }
    else {
        return Object.entries(headers).values();
    }
}
async function processResponse(response, ctx, { contentType: contentTypeFn, response: resFn }) {
    if (resFn) {
        response = await resFn(response);
    }
    if (response.body) {
        ctx.response.body = response.body;
    }
    else {
        ctx.response.body = null;
    }
    ctx.response.status = response.status;
    for (const [key, value] of response.headers) {
        ctx.response.headers.append(key, value);
    }
    if (contentTypeFn) {
        const value = await contentTypeFn(response.url, ctx.response.headers.get("content-type") ?? undefined);
        if (value != null) {
            ctx.response.headers.set("content-type", value);
        }
    }
}
export function proxy(target, options = {}) {
    const matches = createMatcher(options);
    return async function proxy(context, next) {
        if (!matches(context)) {
            return next();
        }
        const request = await createRequest(target, context, options);
        const { fetch = dntShim.dntGlobalThis.fetch } = options;
        const response = await fetch(request, { context });
        await processResponse(response, context, options);
        return next();
    };
}
