var _BufReader_instances, _BufReader_buffer, _BufReader_reader, _BufReader_posRead, _BufReader_posWrite, _BufReader_eof, _BufReader_fill, _BufReader_reset;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { assert, stripEol } from "./util.js";
const DEFAULT_BUF_SIZE = 4096;
const MIN_BUF_SIZE = 16;
const MAX_CONSECUTIVE_EMPTY_READS = 100;
const CR = "\r".charCodeAt(0);
const LF = "\n".charCodeAt(0);
export class BufferFullError extends Error {
    constructor(partial) {
        super("Buffer full");
        Object.defineProperty(this, "partial", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: partial
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "BufferFullError"
        });
    }
}
/** BufReader implements buffering for a Reader object. */
export class BufReader {
    constructor(rd, size = DEFAULT_BUF_SIZE) {
        _BufReader_instances.add(this);
        _BufReader_buffer.set(this, void 0);
        _BufReader_reader.set(this, void 0);
        _BufReader_posRead.set(this, 0);
        _BufReader_posWrite.set(this, 0);
        _BufReader_eof.set(this, false);
        if (size < MIN_BUF_SIZE) {
            size = MIN_BUF_SIZE;
        }
        __classPrivateFieldGet(this, _BufReader_instances, "m", _BufReader_reset).call(this, new Uint8Array(size), rd);
    }
    buffered() {
        return __classPrivateFieldGet(this, _BufReader_posWrite, "f") - __classPrivateFieldGet(this, _BufReader_posRead, "f");
    }
    async readLine(strip = true) {
        var _a;
        let line;
        try {
            line = await this.readSlice(LF);
        }
        catch (err) {
            assert(err instanceof Error);
            let { partial } = err;
            assert(partial instanceof Uint8Array, "Caught error from `readSlice()` without `partial` property");
            // Don't throw if `readSlice()` failed with `BufferFullError`, instead we
            // just return whatever is available and set the `more` flag.
            if (!(err instanceof BufferFullError)) {
                throw err;
            }
            // Handle the case where "\r\n" straddles the buffer.
            if (!__classPrivateFieldGet(this, _BufReader_eof, "f") &&
                partial.byteLength > 0 &&
                partial[partial.byteLength - 1] === CR) {
                // Put the '\r' back on buf and drop it from line.
                // Let the next call to ReadLine check for "\r\n".
                assert(__classPrivateFieldGet(this, _BufReader_posRead, "f") > 0, "Tried to rewind past start of buffer");
                __classPrivateFieldSet(this, _BufReader_posRead, (_a = __classPrivateFieldGet(this, _BufReader_posRead, "f"), _a--, _a), "f");
                partial = partial.subarray(0, partial.byteLength - 1);
            }
            return { bytes: partial, eol: __classPrivateFieldGet(this, _BufReader_eof, "f") };
        }
        if (line === null) {
            return null;
        }
        if (line.byteLength === 0) {
            return { bytes: line, eol: true };
        }
        if (strip) {
            line = stripEol(line);
        }
        return { bytes: line, eol: true };
    }
    async readSlice(delim) {
        let s = 0; // search start index
        let slice;
        while (true) {
            // Search buffer.
            let i = __classPrivateFieldGet(this, _BufReader_buffer, "f").subarray(__classPrivateFieldGet(this, _BufReader_posRead, "f") + s, __classPrivateFieldGet(this, _BufReader_posWrite, "f")).indexOf(delim);
            if (i >= 0) {
                i += s;
                slice = __classPrivateFieldGet(this, _BufReader_buffer, "f").subarray(__classPrivateFieldGet(this, _BufReader_posRead, "f"), __classPrivateFieldGet(this, _BufReader_posRead, "f") + i + 1);
                __classPrivateFieldSet(this, _BufReader_posRead, __classPrivateFieldGet(this, _BufReader_posRead, "f") + (i + 1), "f");
                break;
            }
            // EOF?
            if (__classPrivateFieldGet(this, _BufReader_eof, "f")) {
                if (__classPrivateFieldGet(this, _BufReader_posRead, "f") === __classPrivateFieldGet(this, _BufReader_posWrite, "f")) {
                    return null;
                }
                slice = __classPrivateFieldGet(this, _BufReader_buffer, "f").subarray(__classPrivateFieldGet(this, _BufReader_posRead, "f"), __classPrivateFieldGet(this, _BufReader_posWrite, "f"));
                __classPrivateFieldSet(this, _BufReader_posRead, __classPrivateFieldGet(this, _BufReader_posWrite, "f"), "f");
                break;
            }
            // Buffer full?
            if (this.buffered() >= __classPrivateFieldGet(this, _BufReader_buffer, "f").byteLength) {
                __classPrivateFieldSet(this, _BufReader_posRead, __classPrivateFieldGet(this, _BufReader_posWrite, "f"), "f");
                // #4521 The internal buffer should not be reused across reads because it causes corruption of data.
                const oldbuf = __classPrivateFieldGet(this, _BufReader_buffer, "f");
                const newbuf = __classPrivateFieldGet(this, _BufReader_buffer, "f").slice(0);
                __classPrivateFieldSet(this, _BufReader_buffer, newbuf, "f");
                throw new BufferFullError(oldbuf);
            }
            s = __classPrivateFieldGet(this, _BufReader_posWrite, "f") - __classPrivateFieldGet(this, _BufReader_posRead, "f"); // do not rescan area we scanned before
            // Buffer is not full.
            try {
                await __classPrivateFieldGet(this, _BufReader_instances, "m", _BufReader_fill).call(this);
            }
            catch (err) {
                const e = err instanceof Error ? err : new Error("[non-object thrown]");
                e.partial = slice;
                throw err;
            }
        }
        return slice;
    }
}
_BufReader_buffer = new WeakMap(), _BufReader_reader = new WeakMap(), _BufReader_posRead = new WeakMap(), _BufReader_posWrite = new WeakMap(), _BufReader_eof = new WeakMap(), _BufReader_instances = new WeakSet(), _BufReader_fill = 
// Reads a new chunk into the buffer.
async function _BufReader_fill() {
    // Slide existing data to beginning.
    if (__classPrivateFieldGet(this, _BufReader_posRead, "f") > 0) {
        __classPrivateFieldGet(this, _BufReader_buffer, "f").copyWithin(0, __classPrivateFieldGet(this, _BufReader_posRead, "f"), __classPrivateFieldGet(this, _BufReader_posWrite, "f"));
        __classPrivateFieldSet(this, _BufReader_posWrite, __classPrivateFieldGet(this, _BufReader_posWrite, "f") - __classPrivateFieldGet(this, _BufReader_posRead, "f"), "f");
        __classPrivateFieldSet(this, _BufReader_posRead, 0, "f");
    }
    if (__classPrivateFieldGet(this, _BufReader_posWrite, "f") >= __classPrivateFieldGet(this, _BufReader_buffer, "f").byteLength) {
        throw Error("bufio: tried to fill full buffer");
    }
    // Read new data: try a limited number of times.
    for (let i = MAX_CONSECUTIVE_EMPTY_READS; i > 0; i--) {
        const rr = await __classPrivateFieldGet(this, _BufReader_reader, "f").read(__classPrivateFieldGet(this, _BufReader_buffer, "f").subarray(__classPrivateFieldGet(this, _BufReader_posWrite, "f")));
        if (rr === null) {
            __classPrivateFieldSet(this, _BufReader_eof, true, "f");
            return;
        }
        assert(rr >= 0, "negative read");
        __classPrivateFieldSet(this, _BufReader_posWrite, __classPrivateFieldGet(this, _BufReader_posWrite, "f") + rr, "f");
        if (rr > 0) {
            return;
        }
    }
    throw new Error(`No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`);
}, _BufReader_reset = function _BufReader_reset(buffer, reader) {
    __classPrivateFieldSet(this, _BufReader_buffer, buffer, "f");
    __classPrivateFieldSet(this, _BufReader_reader, reader, "f");
    __classPrivateFieldSet(this, _BufReader_eof, false, "f");
};
