// This file is auto-generated by @hey-api/openapi-ts

export type Script = {
    workspace_id?: string;
    hash: string;
    path: string;
    /**
     * The first element is the direct parent of the script, the second is the parent of the first, etc
     *
     */
    parent_hashes?: Array<(string)>;
    summary: string;
    description: string;
    content: string;
    created_by: string;
    created_at: string;
    archived: boolean;
    schema?: {
        [key: string]: unknown;
    };
    deleted: boolean;
    is_template: boolean;
    extra_perms: {
        [key: string]: (boolean);
    };
    lock?: string;
    lock_error_logs?: string;
    language: 'python3' | 'deno' | 'go' | 'bash' | 'powershell' | 'postgresql' | 'mysql' | 'bigquery' | 'snowflake' | 'mssql' | 'graphql' | 'nativets' | 'bun' | 'php' | 'rust' | 'ansible';
    kind: 'script' | 'failure' | 'trigger' | 'command' | 'approval';
    starred: boolean;
    tag?: string;
    has_draft?: boolean;
    draft_only?: boolean;
    envs?: Array<(string)>;
    concurrent_limit?: number;
    concurrency_time_window_s?: number;
    concurrency_key?: string;
    cache_ttl?: number;
    dedicated_worker?: boolean;
    ws_error_handler_muted?: boolean;
    priority?: number;
    restart_unless_cancelled?: boolean;
    timeout?: number;
    delete_after_use?: boolean;
    visible_to_runner_only?: boolean;
    no_main_func: boolean;
    codebase?: string;
    has_preprocessor: boolean;
};

export type language = 'python3' | 'deno' | 'go' | 'bash' | 'powershell' | 'postgresql' | 'mysql' | 'bigquery' | 'snowflake' | 'mssql' | 'graphql' | 'nativets' | 'bun' | 'php' | 'rust' | 'ansible';

export type kind = 'script' | 'failure' | 'trigger' | 'command' | 'approval';

export type NewScript = {
    path: string;
    parent_hash?: string;
    summary: string;
    description: string;
    content: string;
    schema?: {
        [key: string]: unknown;
    };
    is_template?: boolean;
    lock?: string;
    language: 'python3' | 'deno' | 'go' | 'bash' | 'powershell' | 'postgresql' | 'mysql' | 'bigquery' | 'snowflake' | 'mssql' | 'graphql' | 'nativets' | 'bun' | 'php' | 'rust' | 'ansible';
    kind?: 'script' | 'failure' | 'trigger' | 'command' | 'approval';
    tag?: string;
    draft_only?: boolean;
    envs?: Array<(string)>;
    concurrent_limit?: number;
    concurrency_time_window_s?: number;
    cache_ttl?: number;
    dedicated_worker?: boolean;
    ws_error_handler_muted?: boolean;
    priority?: number;
    restart_unless_cancelled?: boolean;
    timeout?: number;
    delete_after_use?: boolean;
    deployment_message?: string;
    concurrency_key?: string;
    visible_to_runner_only?: boolean;
    no_main_func?: boolean;
    codebase?: string;
    has_preprocessor?: boolean;
};

export type NewScriptWithDraft = NewScript & {
    draft?: NewScript;
    hash: string;
};

export type ScriptHistory = {
    script_hash: string;
    deployment_msg?: string;
};

export type ScriptArgs = {
    [key: string]: unknown;
};

export type Input = {
    id: string;
    name: string;
    created_by: string;
    created_at: string;
    is_public: boolean;
    success?: boolean;
};

export type CreateInput = {
    name: string;
    args: {
        [key: string]: unknown;
    };
};

export type UpdateInput = {
    id: string;
    name: string;
    is_public: boolean;
};

export type RunnableType = 'ScriptHash' | 'ScriptPath' | 'FlowPath';

export type QueuedJob = {
    workspace_id?: string;
    id: string;
    parent_job?: string;
    created_by?: string;
    created_at?: string;
    started_at?: string;
    scheduled_for?: string;
    running: boolean;
    script_path?: string;
    script_hash?: string;
    args?: ScriptArgs;
    logs?: string;
    raw_code?: string;
    canceled: boolean;
    canceled_by?: string;
    canceled_reason?: string;
    last_ping?: string;
    job_kind: 'script' | 'preview' | 'dependencies' | 'flowdependencies' | 'appdependencies' | 'flow' | 'flowpreview' | 'script_hub' | 'identity' | 'deploymentcallback' | 'singlescriptflow';
    schedule_path?: string;
    /**
     * The user (u/userfoo) or group (g/groupfoo) whom
     * the execution of this script will be permissioned_as and by extension its DT_TOKEN.
     *
     */
    permissioned_as: string;
    flow_status?: FlowStatus;
    raw_flow?: FlowValue;
    is_flow_step: boolean;
    language?: 'python3' | 'deno' | 'go' | 'bash' | 'powershell' | 'postgresql' | 'mysql' | 'bigquery' | 'snowflake' | 'mssql' | 'graphql' | 'nativets' | 'bun' | 'php' | 'rust' | 'ansible';
    email: string;
    visible_to_owner: boolean;
    mem_peak?: number;
    tag: string;
    priority?: number;
    self_wait_time_ms?: number;
    aggregate_wait_time_ms?: number;
    suspend?: number;
};

export type job_kind = 'script' | 'preview' | 'dependencies' | 'flowdependencies' | 'appdependencies' | 'flow' | 'flowpreview' | 'script_hub' | 'identity' | 'deploymentcallback' | 'singlescriptflow';

export type CompletedJob = {
    workspace_id?: string;
    id: string;
    parent_job?: string;
    created_by: string;
    created_at: string;
    started_at: string;
    duration_ms: number;
    success: boolean;
    script_path?: string;
    script_hash?: string;
    args?: ScriptArgs;
    result?: unknown;
    logs?: string;
    deleted?: boolean;
    raw_code?: string;
    canceled: boolean;
    canceled_by?: string;
    canceled_reason?: string;
    job_kind: 'script' | 'preview' | 'dependencies' | 'flow' | 'flowdependencies' | 'appdependencies' | 'flowpreview' | 'script_hub' | 'identity' | 'deploymentcallback' | 'singlescriptflow';
    schedule_path?: string;
    /**
     * The user (u/userfoo) or group (g/groupfoo) whom
     * the execution of this script will be permissioned_as and by extension its DT_TOKEN.
     *
     */
    permissioned_as: string;
    flow_status?: FlowStatus;
    raw_flow?: FlowValue;
    is_flow_step: boolean;
    language?: 'python3' | 'deno' | 'go' | 'bash' | 'powershell' | 'postgresql' | 'mysql' | 'bigquery' | 'snowflake' | 'mssql' | 'graphql' | 'nativets' | 'bun' | 'php' | 'rust' | 'ansible';
    is_skipped: boolean;
    email: string;
    visible_to_owner: boolean;
    mem_peak?: number;
    tag: string;
    priority?: number;
    labels?: Array<(string)>;
    self_wait_time_ms?: number;
    aggregate_wait_time_ms?: number;
};

export type ObscuredJob = {
    typ?: string;
    started_at?: string;
    duration_ms?: number;
};

export type Job = (CompletedJob & {
    type?: 'CompletedJob';
}) | (QueuedJob & {
    type?: 'QueuedJob';
});

export type type = 'CompletedJob';

export type User = {
    email: string;
    username: string;
    is_admin: boolean;
    is_super_admin: boolean;
    created_at: string;
    operator: boolean;
    disabled: boolean;
    groups?: Array<(string)>;
    folders: Array<(string)>;
    folders_owners: Array<(string)>;
};

export type UserUsage = {
    email?: string;
    executions?: number;
};

export type Login = {
    email: string;
    password: string;
};

export type EditWorkspaceUser = {
    is_admin?: boolean;
    operator?: boolean;
    disabled?: boolean;
};

export type TruncatedToken = {
    label?: string;
    expiration?: string;
    token_prefix: string;
    created_at: string;
    last_used_at: string;
    scopes?: Array<(string)>;
};

export type NewToken = {
    label?: string;
    expiration?: string;
    scopes?: Array<(string)>;
};

export type NewTokenImpersonate = {
    label?: string;
    expiration?: string;
    impersonate_email: string;
};

export type ListableVariable = {
    workspace_id: string;
    path: string;
    value?: string;
    is_secret: boolean;
    description?: string;
    account?: number;
    is_oauth?: boolean;
    extra_perms: {
        [key: string]: (boolean);
    };
    is_expired?: boolean;
    refresh_error?: string;
    is_linked?: boolean;
    is_refreshed?: boolean;
    expires_at?: string;
};

export type ContextualVariable = {
    name: string;
    value: string;
    description: string;
    is_custom: boolean;
};

export type CreateVariable = {
    path: string;
    value: string;
    is_secret: boolean;
    description: string;
    account?: number;
    is_oauth?: boolean;
    expires_at?: string;
};

export type EditVariable = {
    path?: string;
    value?: string;
    is_secret?: boolean;
    description?: string;
};

export type AuditLog = {
    id: number;
    timestamp: string;
    username: string;
    operation: 'jobs.run' | 'jobs.run.script' | 'jobs.run.preview' | 'jobs.run.flow' | 'jobs.run.flow_preview' | 'jobs.run.script_hub' | 'jobs.run.dependencies' | 'jobs.run.identity' | 'jobs.run.noop' | 'jobs.flow_dependencies' | 'jobs' | 'jobs.cancel' | 'jobs.force_cancel' | 'jobs.disapproval' | 'jobs.delete' | 'account.delete' | 'openai.request' | 'resources.create' | 'resources.update' | 'resources.delete' | 'resource_types.create' | 'resource_types.update' | 'resource_types.delete' | 'schedule.create' | 'schedule.setenabled' | 'schedule.edit' | 'schedule.delete' | 'scripts.create' | 'scripts.update' | 'scripts.archive' | 'scripts.delete' | 'users.create' | 'users.delete' | 'users.update' | 'users.login' | 'users.logout' | 'users.accept_invite' | 'users.decline_invite' | 'users.token.create' | 'users.token.delete' | 'users.add_to_workspace' | 'users.add_global' | 'users.setpassword' | 'users.impersonate' | 'users.leave_workspace' | 'oauth.login' | 'oauth.signup' | 'variables.create' | 'variables.delete' | 'variables.update' | 'flows.create' | 'flows.update' | 'flows.delete' | 'flows.archive' | 'apps.create' | 'apps.update' | 'apps.delete' | 'folder.create' | 'folder.update' | 'folder.delete' | 'folder.add_owner' | 'folder.remove_owner' | 'group.create' | 'group.delete' | 'group.edit' | 'group.adduser' | 'group.removeuser' | 'igroup.create' | 'igroup.delete' | 'igroup.adduser' | 'igroup.removeuser' | 'variables.decrypt_secret' | 'workspaces.edit_command_script' | 'workspaces.edit_deploy_to' | 'workspaces.edit_auto_invite_domain' | 'workspaces.edit_webhook' | 'workspaces.edit_copilot_config' | 'workspaces.edit_error_handler' | 'workspaces.create' | 'workspaces.update' | 'workspaces.archive' | 'workspaces.unarchive' | 'workspaces.delete';
    action_kind: 'Created' | 'Updated' | 'Delete' | 'Execute';
    resource?: string;
    parameters?: {
        [key: string]: unknown;
    };
};

export type operation = 'jobs.run' | 'jobs.run.script' | 'jobs.run.preview' | 'jobs.run.flow' | 'jobs.run.flow_preview' | 'jobs.run.script_hub' | 'jobs.run.dependencies' | 'jobs.run.identity' | 'jobs.run.noop' | 'jobs.flow_dependencies' | 'jobs' | 'jobs.cancel' | 'jobs.force_cancel' | 'jobs.disapproval' | 'jobs.delete' | 'account.delete' | 'openai.request' | 'resources.create' | 'resources.update' | 'resources.delete' | 'resource_types.create' | 'resource_types.update' | 'resource_types.delete' | 'schedule.create' | 'schedule.setenabled' | 'schedule.edit' | 'schedule.delete' | 'scripts.create' | 'scripts.update' | 'scripts.archive' | 'scripts.delete' | 'users.create' | 'users.delete' | 'users.update' | 'users.login' | 'users.logout' | 'users.accept_invite' | 'users.decline_invite' | 'users.token.create' | 'users.token.delete' | 'users.add_to_workspace' | 'users.add_global' | 'users.setpassword' | 'users.impersonate' | 'users.leave_workspace' | 'oauth.login' | 'oauth.signup' | 'variables.create' | 'variables.delete' | 'variables.update' | 'flows.create' | 'flows.update' | 'flows.delete' | 'flows.archive' | 'apps.create' | 'apps.update' | 'apps.delete' | 'folder.create' | 'folder.update' | 'folder.delete' | 'folder.add_owner' | 'folder.remove_owner' | 'group.create' | 'group.delete' | 'group.edit' | 'group.adduser' | 'group.removeuser' | 'igroup.create' | 'igroup.delete' | 'igroup.adduser' | 'igroup.removeuser' | 'variables.decrypt_secret' | 'workspaces.edit_command_script' | 'workspaces.edit_deploy_to' | 'workspaces.edit_auto_invite_domain' | 'workspaces.edit_webhook' | 'workspaces.edit_copilot_config' | 'workspaces.edit_error_handler' | 'workspaces.create' | 'workspaces.update' | 'workspaces.archive' | 'workspaces.unarchive' | 'workspaces.delete';

export type action_kind = 'Created' | 'Updated' | 'Delete' | 'Execute';

export type MainArgSignature = {
    type: 'Valid' | 'Invalid';
    error: string;
    star_args: boolean;
    star_kwargs?: boolean;
    args: Array<{
        name: string;
        typ: ('float' | 'int' | 'bool' | 'email' | 'unknown' | 'bytes' | 'dict' | 'datetime' | 'sql' | {
    resource: (string) | null;
} | {
    str: Array<(string)> | null;
} | {
    object: Array<{
        key: string;
        typ: ('float' | 'int' | 'bool' | 'email' | 'unknown' | 'bytes' | 'dict' | 'datetime' | 'sql' | {
    str: unknown;
});
    }>;
} | {
    list: (('float' | 'int' | 'bool' | 'email' | 'unknown' | 'bytes' | 'dict' | 'datetime' | 'sql' | {
    str: unknown;
}) | null);
});
        has_default?: boolean;
        default?: unknown;
    }>;
    no_main_func: (boolean) | null;
    has_preprocessor: (boolean) | null;
};

export type type2 = 'Valid' | 'Invalid';

export type Preview = {
    content?: string;
    path?: string;
    args: ScriptArgs;
    language?: 'python3' | 'deno' | 'go' | 'bash' | 'powershell' | 'postgresql' | 'mysql' | 'bigquery' | 'snowflake' | 'mssql' | 'graphql' | 'nativets' | 'bun' | 'php' | 'rust' | 'ansible';
    tag?: string;
    kind?: 'code' | 'identity' | 'http';
    dedicated_worker?: boolean;
    lock?: string;
};

export type kind2 = 'code' | 'identity' | 'http';

export type WorkflowTask = {
    args: ScriptArgs;
};

export type WorkflowStatusRecord = {
    [key: string]: WorkflowStatus;
};

export type WorkflowStatus = {
    scheduled_for?: string;
    started_at?: string;
    duration_ms?: number;
    name?: string;
};

export type CreateResource = {
    path: string;
    value: unknown;
    description?: string;
    resource_type: string;
};

export type EditResource = {
    path?: string;
    description?: string;
    value?: unknown;
};

export type Resource = {
    workspace_id?: string;
    path: string;
    description?: string;
    resource_type: string;
    value?: unknown;
    is_oauth: boolean;
    extra_perms?: {
        [key: string]: (boolean);
    };
    created_by?: string;
    edited_at?: string;
};

export type ListableResource = {
    workspace_id?: string;
    path: string;
    description?: string;
    resource_type: string;
    value?: unknown;
    is_oauth: boolean;
    extra_perms?: {
        [key: string]: (boolean);
    };
    is_expired?: boolean;
    refresh_error?: string;
    is_linked: boolean;
    is_refreshed: boolean;
    account?: number;
    created_by?: string;
    edited_at?: string;
};

export type ResourceType = {
    workspace_id?: string;
    name: string;
    schema?: unknown;
    description?: string;
    created_by?: string;
    edited_at?: string;
    format_extension?: string;
};

export type EditResourceType = {
    schema?: unknown;
    description?: string;
};

export type Schedule = {
    path: string;
    edited_by: string;
    edited_at: string;
    schedule: string;
    timezone: string;
    enabled: boolean;
    script_path: string;
    is_flow: boolean;
    args?: ScriptArgs;
    extra_perms: {
        [key: string]: (boolean);
    };
    email: string;
    error?: string;
    on_failure?: string;
    on_failure_times?: number;
    on_failure_exact?: boolean;
    on_failure_extra_args?: ScriptArgs;
    on_recovery?: string;
    on_recovery_times?: number;
    on_recovery_extra_args?: ScriptArgs;
    on_success?: string;
    on_success_extra_args?: ScriptArgs;
    ws_error_handler_muted?: boolean;
    retry?: Retry;
    summary?: string;
    no_flow_overlap?: boolean;
    tag?: string;
    paused_until?: string;
};

export type ScheduleWJobs = Schedule & {
    jobs?: Array<{
        id: string;
        success: boolean;
        duration_ms: number;
    }>;
};

export type NewSchedule = {
    path: string;
    schedule: string;
    timezone: string;
    script_path: string;
    is_flow: boolean;
    args: ScriptArgs;
    enabled?: boolean;
    on_failure?: string;
    on_failure_times?: number;
    on_failure_exact?: boolean;
    on_failure_extra_args?: ScriptArgs;
    on_recovery?: string;
    on_recovery_times?: number;
    on_recovery_extra_args?: ScriptArgs;
    on_success?: string;
    on_success_extra_args?: ScriptArgs;
    ws_error_handler_muted?: boolean;
    retry?: Retry;
    no_flow_overlap?: boolean;
    summary?: string;
    tag?: string;
    paused_until?: string;
};

export type EditSchedule = {
    schedule: string;
    timezone: string;
    args: ScriptArgs;
    on_failure?: string;
    on_failure_times?: number;
    on_failure_exact?: boolean;
    on_failure_extra_args?: ScriptArgs;
    on_recovery?: string;
    on_recovery_times?: number;
    on_recovery_extra_args?: ScriptArgs;
    on_success?: string;
    on_success_extra_args?: ScriptArgs;
    ws_error_handler_muted?: boolean;
    retry?: Retry;
    no_flow_overlap?: boolean;
    summary?: string;
    tag?: string;
    paused_until?: string;
};

export type HttpTrigger = {
    path: string;
    edited_by: string;
    edited_at: string;
    script_path: string;
    route_path: string;
    is_flow: boolean;
    extra_perms: {
        [key: string]: (boolean);
    };
    email: string;
    workspace_id: string;
    http_method: 'get' | 'post' | 'put' | 'delete' | 'patch';
    is_async: boolean;
    requires_auth: boolean;
};

export type http_method = 'get' | 'post' | 'put' | 'delete' | 'patch';

export type NewHttpTrigger = {
    path: string;
    script_path: string;
    route_path: string;
    is_flow: boolean;
    http_method: 'get' | 'post' | 'put' | 'delete' | 'patch';
    is_async: boolean;
    requires_auth: boolean;
};

export type EditHttpTrigger = {
    path: string;
    script_path: string;
    route_path?: string;
    is_flow: boolean;
    http_method: 'get' | 'post' | 'put' | 'delete' | 'patch';
    is_async: boolean;
    requires_auth: boolean;
};

export type Group = {
    name: string;
    summary?: string;
    members?: Array<(string)>;
    extra_perms?: {
        [key: string]: (boolean);
    };
};

export type InstanceGroup = {
    name: string;
    summary?: string;
    emails?: Array<(string)>;
};

export type Folder = {
    name: string;
    owners: Array<(string)>;
    extra_perms: {
        [key: string]: (boolean);
    };
    summary?: string;
    created_by?: string;
    edited_at?: string;
};

export type WorkerPing = {
    worker: string;
    worker_instance: string;
    last_ping?: number;
    started_at: string;
    ip: string;
    jobs_executed: number;
    custom_tags?: Array<(string)>;
    worker_group: string;
    wm_version: string;
    last_job_id?: string;
    last_job_workspace_id?: string;
    occupancy_rate?: number;
    occupancy_rate_15s?: number;
    occupancy_rate_5m?: number;
    occupancy_rate_30m?: number;
    memory?: number;
    vcpus?: number;
    memory_usage?: number;
    wm_memory_usage?: number;
};

export type UserWorkspaceList = {
    email: string;
    workspaces: Array<{
        id: string;
        name: string;
        username: string;
    }>;
};

export type CreateWorkspace = {
    id: string;
    name: string;
    username?: string;
};

export type Workspace = {
    id: string;
    name: string;
    owner: string;
    domain?: string;
};

export type WorkspaceInvite = {
    workspace_id: string;
    email: string;
    is_admin: boolean;
    operator: boolean;
};

export type GlobalUserInfo = {
    email: string;
    login_type: 'password' | 'github';
    super_admin: boolean;
    verified: boolean;
    name?: string;
    company?: string;
    username?: string;
};

export type login_type = 'password' | 'github';

export type Flow = OpenFlow & FlowMetadata;

export type ExtraPerms = {
    [key: string]: (boolean);
};

export type FlowMetadata = {
    workspace_id?: string;
    path: string;
    edited_by: string;
    edited_at: string;
    archived: boolean;
    extra_perms: ExtraPerms;
    starred?: boolean;
    draft_only?: boolean;
    tag?: string;
    ws_error_handler_muted?: boolean;
    priority?: number;
    dedicated_worker?: boolean;
    timeout?: number;
    visible_to_runner_only?: boolean;
};

export type OpenFlowWPath = OpenFlow & {
    path: string;
    tag?: string;
    ws_error_handler_muted?: boolean;
    priority?: number;
    dedicated_worker?: boolean;
    timeout?: number;
    visible_to_runner_only?: boolean;
};

export type FlowPreview = {
    value: FlowValue;
    path?: string;
    args: ScriptArgs;
    tag?: string;
    restarted_from?: RestartedFrom;
};

export type RestartedFrom = {
    flow_job_id?: string;
    step_id?: string;
    branch_or_iteration_n?: number;
};

export type Policy = {
    triggerables?: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    triggerables_v2?: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    execution_mode?: 'viewer' | 'publisher' | 'anonymous';
    on_behalf_of?: string;
    on_behalf_of_email?: string;
};

export type execution_mode = 'viewer' | 'publisher' | 'anonymous';

export type ListableApp = {
    id: number;
    workspace_id: string;
    path: string;
    summary: string;
    version: number;
    extra_perms: {
        [key: string]: (boolean);
    };
    starred?: boolean;
    edited_at: string;
    execution_mode: 'viewer' | 'publisher' | 'anonymous';
};

export type ListableRawApp = {
    workspace_id: string;
    path: string;
    summary: string;
    extra_perms: {
        [key: string]: (boolean);
    };
    starred?: boolean;
    version: number;
    edited_at: string;
};

export type AppWithLastVersion = {
    id: number;
    workspace_id: string;
    path: string;
    summary: string;
    versions: Array<(number)>;
    created_by: string;
    created_at: string;
    value: {
        [key: string]: unknown;
    };
    policy: Policy;
    execution_mode: 'viewer' | 'publisher' | 'anonymous';
    extra_perms: {
        [key: string]: (boolean);
    };
};

export type AppWithLastVersionWDraft = AppWithLastVersion & {
    draft_only?: boolean;
    draft?: unknown;
};

export type AppHistory = {
    version: number;
    deployment_msg?: string;
};

export type FlowVersion = {
    id: number;
    created_at: string;
    deployment_msg?: string;
};

export type SlackToken = {
    access_token: string;
    team_id: string;
    team_name: string;
    bot: {
        bot_access_token?: string;
    };
};

export type TokenResponse = {
    access_token: string;
    expires_in?: number;
    refresh_token?: string;
    scope?: Array<(string)>;
};

export type HubScriptKind = unknown;

export type PolarsClientKwargs = {
    region_name: string;
};

export type LargeFileStorage = {
    type?: 'S3Storage' | 'AzureBlobStorage' | 'AzureWorkloadIdentity' | 'S3AwsOidc';
    s3_resource_path?: string;
    azure_blob_resource_path?: string;
    public_resource?: boolean;
    secondary_storage?: {
        [key: string]: {
            type?: 'S3Storage' | 'AzureBlobStorage' | 'AzureWorkloadIdentity' | 'S3AwsOidc';
            s3_resource_path?: string;
            azure_blob_resource_path?: string;
            public_resource?: boolean;
        };
    };
};

export type type3 = 'S3Storage' | 'AzureBlobStorage' | 'AzureWorkloadIdentity' | 'S3AwsOidc';

export type WindmillLargeFile = {
    s3: string;
};

export type WindmillFileMetadata = {
    mime_type?: string;
    size_in_bytes?: number;
    last_modified?: string;
    expires?: string;
    version_id?: string;
};

export type WindmillFilePreview = {
    msg?: string;
    content?: string;
    content_type: 'RawText' | 'Csv' | 'Parquet' | 'Unknown';
};

export type content_type = 'RawText' | 'Csv' | 'Parquet' | 'Unknown';

export type S3Resource = {
    bucket: string;
    region: string;
    endPoint: string;
    useSSL: boolean;
    accessKey?: string;
    secretKey?: string;
    pathStyle: boolean;
};

export type WorkspaceGitSyncSettings = {
    include_path?: Array<(string)>;
    include_type?: Array<('script' | 'flow' | 'app' | 'folder' | 'resource' | 'variable' | 'secret' | 'resourcetype' | 'schedule' | 'user' | 'group')>;
    repositories?: Array<GitRepositorySettings>;
};

export type WorkspaceDeployUISettings = {
    include_path?: Array<(string)>;
    include_type?: Array<('script' | 'flow' | 'app' | 'resource' | 'variable' | 'secret')>;
};

export type WorkspaceDefaultScripts = {
    order?: Array<(string)>;
    hidden?: Array<(string)>;
    default_script_content?: {
        [key: string]: (string);
    };
};

export type GitRepositorySettings = {
    script_path: string;
    git_repo_resource_path: string;
    use_individual_branch?: boolean;
    group_by_folder?: boolean;
    exclude_types_override?: Array<('script' | 'flow' | 'app' | 'folder' | 'resource' | 'variable' | 'secret' | 'resourcetype' | 'schedule' | 'user' | 'group')>;
};

export type UploadFilePart = {
    part_number: number;
    tag: string;
};

export type MetricMetadata = {
    id: string;
    name?: string;
};

export type ScalarMetric = {
    metric_id?: string;
    value: number;
};

export type TimeseriesMetric = {
    metric_id?: string;
    values: Array<MetricDataPoint>;
};

export type MetricDataPoint = {
    timestamp: string;
    value: number;
};

export type RawScriptForDependencies = {
    raw_code: string;
    path: string;
    language: 'python3' | 'deno' | 'go' | 'bash' | 'powershell' | 'postgresql' | 'mysql' | 'bigquery' | 'snowflake' | 'mssql' | 'graphql' | 'nativets' | 'bun' | 'php' | 'rust' | 'ansible';
};

export type ConcurrencyGroup = {
    concurrency_key: string;
    total_running: number;
};

export type ExtendedJobs = {
    jobs: Array<Job>;
    obscured_jobs: Array<ObscuredJob>;
    /**
     * Obscured jobs omitted for security because of too specific filtering
     */
    omitted_obscured_jobs?: boolean;
};

export type ExportedUser = {
    email: string;
    password_hash?: string;
    super_admin: boolean;
    verified: boolean;
    name?: string;
    company?: string;
    first_time_user: boolean;
    username?: string;
};

export type GlobalSetting = {
    name: string;
    value: {
        [key: string]: unknown;
    };
};

export type Config = {
    name: string;
    config?: {
        [key: string]: unknown;
    };
};

export type ExportedInstanceGroup = {
    name: string;
    summary?: string;
    emails?: Array<(string)>;
    id?: string;
    scim_display_name?: string;
    external_id?: string;
};

export type JobSearchHit = {
    dancer?: string;
};

export type OpenFlow = {
    summary: string;
    description?: string;
    value: FlowValue;
    schema?: {
        [key: string]: unknown;
    };
};

export type FlowValue = {
    modules: Array<FlowModule>;
    failure_module?: FlowModule;
    preprocessor_module?: FlowModule;
    same_worker?: boolean;
    concurrent_limit?: number;
    concurrency_key?: string;
    concurrency_time_window_s?: number;
    skip_expr?: string;
    cache_ttl?: number;
    priority?: number;
    early_return?: string;
};

export type Retry = {
    constant?: {
        attempts?: number;
        seconds?: number;
    };
    exponential?: {
        attempts?: number;
        multiplier?: number;
        seconds?: number;
        random_factor?: number;
    };
};

export type FlowModule = {
    id: string;
    value: FlowModuleValue;
    stop_after_if?: {
        skip_if_stopped?: boolean;
        expr: string;
    };
    stop_after_all_iters_if?: {
        skip_if_stopped?: boolean;
        expr: string;
    };
    skip_if?: {
        expr: string;
    };
    sleep?: InputTransform;
    cache_ttl?: number;
    timeout?: number;
    delete_after_use?: boolean;
    summary?: string;
    mock?: {
        enabled?: boolean;
        return_value?: unknown;
    };
    suspend?: {
        required_events?: number;
        timeout?: number;
        resume_form?: {
            schema?: {
                [key: string]: unknown;
            };
        };
        user_auth_required?: boolean;
        user_groups_required?: InputTransform;
        self_approval_disabled?: boolean;
        hide_cancel?: boolean;
        continue_on_disapprove_timeout?: boolean;
    };
    priority?: number;
    continue_on_error?: boolean;
    retry?: Retry;
};

export type InputTransform = StaticTransform | JavascriptTransform;

export type StaticTransform = {
    value?: unknown;
    type: 'static';
};

export type JavascriptTransform = {
    expr: string;
    type: 'javascript';
};

export type FlowModuleValue = RawScript | PathScript | PathFlow | ForloopFlow | WhileloopFlow | BranchOne | BranchAll | Identity;

export type RawScript = {
    input_transforms: {
        [key: string]: InputTransform;
    };
    content: string;
    language: 'deno' | 'bun' | 'python3' | 'go' | 'bash' | 'powershell' | 'postgresql' | 'mysql' | 'bigquery' | 'snowflake' | 'mssql' | 'graphql' | 'nativets' | 'php';
    path?: string;
    lock?: string;
    type: 'rawscript';
    tag?: string;
    concurrent_limit?: number;
    concurrency_time_window_s?: number;
    custom_concurrency_key?: string;
};

export type language2 = 'deno' | 'bun' | 'python3' | 'go' | 'bash' | 'powershell' | 'postgresql' | 'mysql' | 'bigquery' | 'snowflake' | 'mssql' | 'graphql' | 'nativets' | 'php';

export type PathScript = {
    input_transforms: {
        [key: string]: InputTransform;
    };
    path: string;
    hash?: string;
    type: 'script';
    tag_override?: string;
};

export type PathFlow = {
    input_transforms: {
        [key: string]: InputTransform;
    };
    path: string;
    type: 'flow';
};

export type ForloopFlow = {
    modules: Array<FlowModule>;
    iterator: InputTransform;
    skip_failures: boolean;
    type: 'forloopflow';
    parallel?: boolean;
    parallelism?: number;
};

export type WhileloopFlow = {
    modules: Array<FlowModule>;
    skip_failures: boolean;
    type: 'whileloopflow';
    parallel?: boolean;
    parallelism?: number;
};

export type BranchOne = {
    branches: Array<{
        summary?: string;
        expr: string;
        modules: Array<FlowModule>;
    }>;
    default: Array<FlowModule>;
    type: 'branchone';
};

export type BranchAll = {
    branches: Array<{
        summary?: string;
        skip_failure?: boolean;
        modules: Array<FlowModule>;
    }>;
    type: 'branchall';
    parallel?: boolean;
};

export type Identity = {
    type: 'identity';
    flow?: boolean;
};

export type FlowStatus = {
    step: number;
    modules: Array<FlowStatusModule>;
    user_states?: {
        [key: string]: unknown;
    };
    preprocessor_module?: (FlowStatusModule);
    failure_module: (FlowStatusModule & {
    parent_module?: string;
});
    retry?: {
        fail_count?: number;
        failed_jobs?: Array<(string)>;
    };
};

export type FlowStatusModule = {
    type: 'WaitingForPriorSteps' | 'WaitingForEvents' | 'WaitingForExecutor' | 'InProgress' | 'Success' | 'Failure';
    id?: string;
    job?: string;
    count?: number;
    progress?: number;
    iterator?: {
        index?: number;
        itered?: Array<unknown>;
        args?: unknown;
    };
    flow_jobs?: Array<(string)>;
    flow_jobs_success?: Array<(boolean)>;
    branch_chosen?: {
        type: 'branch' | 'default';
        branch?: number;
    };
    branchall?: {
        branch: number;
        len: number;
    };
    approvers?: Array<{
        resume_id: number;
        approver: string;
    }>;
    failed_retries?: Array<(string)>;
    skipped?: boolean;
};

export type type4 = 'WaitingForPriorSteps' | 'WaitingForEvents' | 'WaitingForExecutor' | 'InProgress' | 'Success' | 'Failure';

export type ParameterKey = string;

export type ParameterWorkspaceId = string;

export type ParameterVersionId = number;

export type ParameterToken = string;

export type ParameterAccountId = number;

export type ParameterClientName = string;

export type ParameterScriptPath = string;

export type ParameterScriptHash = string;

export type ParameterJobId = string;

export type ParameterPath = string;

export type ParameterPathId = number;

export type ParameterPathVersion = number;

export type ParameterName = string;

/**
 * which page to return (start at 1, default 1)
 */
export type ParameterPage = number;

/**
 * number of items to return for a given page (default 30, max 100)
 */
export type ParameterPerPage = number;

/**
 * order by desc order (default true)
 */
export type ParameterOrderDesc = boolean;

/**
 * mask to filter exact matching user creator
 */
export type ParameterCreatedBy = string;

/**
 * mask to filter exact matching job's label (job labels are completed jobs with as a result an object containing a string in the array at key 'wm_labels')
 */
export type ParameterLabel = string;

/**
 * The parent job that is at the origin and responsible for the execution of this script if any
 */
export type ParameterParentJob = string;

/**
 * Override the tag to use
 */
export type ParameterWorkerTag = string;

/**
 * Override the cache time to live (in seconds). Can not be used to disable caching, only override with a new cache ttl
 */
export type ParameterCacheTtl = string;

/**
 * The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
 */
export type ParameterNewJobId = string;

/**
 * List of headers's keys (separated with ',') whove value are added to the args
 * Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
 *
 */
export type ParameterIncludeHeader = string;

/**
 * The maximum size of the queue for which the request would get rejected if that job would push it above that limit
 *
 */
export type ParameterQueueLimit = string;

/**
 * The base64 encoded payload that has been encoded as a JSON. e.g how to encode such payload encodeURIComponent
 * `encodeURIComponent(btoa(JSON.stringify({a: 2})))`
 *
 */
export type ParameterPayload = string;

/**
 * mask to filter matching starting path
 */
export type ParameterScriptStartPath = string;

/**
 * mask to filter by schedule path
 */
export type ParameterSchedulePath = string;

/**
 * mask to filter exact matching path
 */
export type ParameterScriptExactPath = string;

/**
 * mask to filter exact matching path
 */
export type ParameterScriptExactHash = string;

/**
 * filter on created before (inclusive) timestamp
 */
export type ParameterCreatedBefore = string;

/**
 * filter on created after (exclusive) timestamp
 */
export type ParameterCreatedAfter = string;

/**
 * filter on started before (inclusive) timestamp
 */
export type ParameterStartedBefore = string;

/**
 * filter on started after (exclusive) timestamp
 */
export type ParameterStartedAfter = string;

/**
 * filter on started before (inclusive) timestamp
 */
export type ParameterBefore = string;

/**
 * filter on created_at for non non started job and started_at otherwise after (exclusive) timestamp
 */
export type ParameterCreatedOrStartedAfter = string;

/**
 * filter on created_at for non non started job and started_at otherwise after (exclusive) timestamp but only for the completed jobs
 */
export type ParameterCreatedOrStartedAfterCompletedJob = string;

/**
 * filter on created_at for non non started job and started_at otherwise before (inclusive) timestamp
 */
export type ParameterCreatedOrStartedBefore = string;

/**
 * filter on successful jobs
 */
export type ParameterSuccess = boolean;

/**
 * filter on jobs scheduled_for before now (hence waitinf for a worker)
 */
export type ParameterScheduledForBeforeNow = boolean;

/**
 * filter on suspended jobs
 */
export type ParameterSuspended = boolean;

/**
 * filter on running jobs
 */
export type ParameterRunning = boolean;

/**
 * filter on jobs containing those args as a json subset (@> in postgres)
 */
export type ParameterArgsFilter = string;

/**
 * filter on jobs with a given tag/worker group
 */
export type ParameterTag = string;

/**
 * filter on jobs containing those result as a json subset (@> in postgres)
 */
export type ParameterResultFilter = string;

/**
 * filter on created after (exclusive) timestamp
 */
export type ParameterAfter = string;

/**
 * filter on exact username of user
 */
export type ParameterUsername = string;

/**
 * filter on exact or prefix name of operation
 */
export type ParameterOperation = string;

/**
 * filter on exact or prefix name of resource
 */
export type ParameterResourceName = string;

/**
 * filter on type of operation
 */
export type ParameterActionKind = 'Create' | 'Update' | 'Delete' | 'Execute';

/**
 * filter on job kind (values 'preview', 'script', 'dependencies', 'flow') separated by,
 */
export type ParameterJobKinds = string;

export type ParameterRunnableId = string;

export type ParameterRunnableTypeQuery = RunnableType;

export type ParameterInputId = string;

export type ParameterGetStarted = boolean;

export type ParameterConcurrencyId = string;

export type BackendVersionResponse = (string);

export type BackendUptodateResponse = (string);

export type GetLicenseIdResponse = (string);

export type GetOpenApiYamlResponse = (string);

export type GetAuditLogData = {
    id: number;
    workspace: string;
};

export type GetAuditLogResponse = (AuditLog);

export type ListAuditLogsData = {
    /**
     * filter on type of operation
     */
    actionKind?: 'Create' | 'Update' | 'Delete' | 'Execute';
    /**
     * filter on created after (exclusive) timestamp
     */
    after?: string;
    /**
     * filter on started before (inclusive) timestamp
     */
    before?: string;
    /**
     * comma separated list of operations to exclude
     */
    excludeOperations?: string;
    /**
     * filter on exact or prefix name of operation
     */
    operation?: string;
    /**
     * comma separated list of exact operations to include
     */
    operations?: string;
    /**
     * which page to return (start at 1, default 1)
     */
    page?: number;
    /**
     * number of items to return for a given page (default 30, max 100)
     */
    perPage?: number;
    /**
     * filter on exact or prefix name of resource
     */
    resource?: string;
    /**
     * filter on exact username of user
     */
    username?: string;
    workspace: string;
};

export type ListAuditLogsResponse = (Array<AuditLog>);

export type LoginData = {
    /**
     * credentials
     */
    requestBody: Login;
};

export type LoginResponse = (string);

export type LogoutResponse = (string);

export type GetUserData = {
    username: string;
    workspace: string;
};

export type GetUserResponse = (User);

export type UpdateUserData = {
    /**
     * new user
     */
    requestBody: EditWorkspaceUser;
    username: string;
    workspace: string;
};

export type UpdateUserResponse = (string);

export type IsOwnerOfPathData = {
    path: string;
    workspace: string;
};

export type IsOwnerOfPathResponse = (boolean);

export type SetPasswordData = {
    /**
     * set password
     */
    requestBody: {
        password: string;
    };
};

export type SetPasswordResponse = (string);

export type CreateUserGloballyData = {
    /**
     * user info
     */
    requestBody: {
        email: string;
        password: string;
        super_admin: boolean;
        name?: string;
        company?: string;
    };
};

export type CreateUserGloballyResponse = (string);

export type GlobalUserUpdateData = {
    email: string;
    /**
     * new user info
     */
    requestBody: {
        is_super_admin?: boolean;
        name?: string;
    };
};

export type GlobalUserUpdateResponse = (string);

export type GlobalUsernameInfoData = {
    email: string;
};

export type GlobalUsernameInfoResponse = ({
    username: string;
    workspace_usernames: Array<{
        workspace_id: string;
        username: string;
    }>;
});

export type GlobalUserRenameData = {
    email: string;
    /**
     * new username
     */
    requestBody: {
        new_username: string;
    };
};

export type GlobalUserRenameResponse = (string);

export type GlobalUserDeleteData = {
    email: string;
};

export type GlobalUserDeleteResponse = (string);

export type GlobalUsersOverwriteData = {
    /**
     * List of users
     */
    requestBody: Array<ExportedUser>;
};

export type GlobalUsersOverwriteResponse = (string);

export type GlobalUsersExportResponse = (Array<ExportedUser>);

export type DeleteUserData = {
    username: string;
    workspace: string;
};

export type DeleteUserResponse = (string);

export type ListWorkspacesResponse = (Array<Workspace>);

export type IsDomainAllowedResponse = (boolean);

export type ListUserWorkspacesResponse = (UserWorkspaceList);

export type ListWorkspacesAsSuperAdminData = {
    /**
     * which page to return (start at 1, default 1)
     */
    page?: number;
    /**
     * number of items to return for a given page (default 30, max 100)
     */
    perPage?: number;
};

export type ListWorkspacesAsSuperAdminResponse = (Array<Workspace>);

export type CreateWorkspaceData = {
    /**
     * new token
     */
    requestBody: CreateWorkspace;
};

export type CreateWorkspaceResponse = (string);

export type ExistsWorkspaceData = {
    /**
     * id of workspace
     */
    requestBody: {
        id: string;
    };
};

export type ExistsWorkspaceResponse = (boolean);

export type ExistsUsernameData = {
    requestBody: {
        id: string;
        username: string;
    };
};

export type ExistsUsernameResponse = (boolean);

export type GetGlobalData = {
    key: string;
};

export type GetGlobalResponse = (unknown);

export type SetGlobalData = {
    key: string;
    /**
     * value set
     */
    requestBody: {
        value?: unknown;
    };
};

export type SetGlobalResponse = (string);

export type GetLocalResponse = (unknown);

export type TestSmtpData = {
    /**
     * test smtp payload
     */
    requestBody: {
        to: string;
        smtp: {
            host: string;
            username: string;
            password: string;
            port: number;
            from: string;
            tls_implicit: boolean;
        };
    };
};

export type TestSmtpResponse = (string);

export type TestCriticalChannelsData = {
    /**
     * test critical channel payload
     */
    requestBody: Array<{
        email?: string;
        slack_channel?: string;
    }>;
};

export type TestCriticalChannelsResponse = (string);

export type TestLicenseKeyData = {
    /**
     * test license key
     */
    requestBody: {
        license_key: string;
    };
};

export type TestLicenseKeyResponse = (string);

export type TestObjectStorageConfigData = {
    /**
     * test object storage config
     */
    requestBody: {
        [key: string]: unknown;
    };
};

export type TestObjectStorageConfigResponse = (string);

export type SendStatsResponse = (string);

export type GetLatestKeyRenewalAttemptResponse = ({
    result: string;
    attempted_at: string;
} | null);

export type RenewLicenseKeyData = {
    licenseKey?: string;
};

export type RenewLicenseKeyResponse = (string);

export type CreateCustomerPortalSessionData = {
    licenseKey?: string;
};

export type CreateCustomerPortalSessionResponse = (string);

export type TestMetadataData = {
    /**
     * test metadata
     */
    requestBody: string;
};

export type TestMetadataResponse = (string);

export type ListGlobalSettingsResponse = (Array<GlobalSetting>);

export type GetCurrentEmailResponse = (string);

export type RefreshUserTokenResponse = (string);

export type GetTutorialProgressResponse = ({
    progress?: number;
});

export type UpdateTutorialProgressData = {
    /**
     * progress update
     */
    requestBody: {
        progress?: number;
    };
};

export type UpdateTutorialProgressResponse = (string);

export type LeaveInstanceResponse = (string);

export type GetUsageResponse = (number);

export type GetRunnableResponse = ({
    workspace: string;
    endpoint_async: string;
    endpoint_sync: string;
    endpoint_openai_sync: string;
    summary: string;
    description?: string;
    kind: string;
});

export type GlobalWhoamiResponse = (GlobalUserInfo);

export type ListWorkspaceInvitesResponse = (Array<WorkspaceInvite>);

export type WhoamiData = {
    workspace: string;
};

export type WhoamiResponse = (User);

export type AcceptInviteData = {
    /**
     * accept invite
     */
    requestBody: {
        workspace_id: string;
        username?: string;
    };
};

export type AcceptInviteResponse = (string);

export type DeclineInviteData = {
    /**
     * decline invite
     */
    requestBody: {
        workspace_id: string;
    };
};

export type DeclineInviteResponse = (string);

export type InviteUserData = {
    /**
     * WorkspaceInvite
     */
    requestBody: {
        email: string;
        is_admin: boolean;
        operator: boolean;
    };
    workspace: string;
};

export type InviteUserResponse = (string);

export type AddUserData = {
    /**
     * WorkspaceInvite
     */
    requestBody: {
        email: string;
        is_admin: boolean;
        username?: string;
        operator: boolean;
    };
    workspace: string;
};

export type AddUserResponse = (string);

export type DeleteInviteData = {
    /**
     * WorkspaceInvite
     */
    requestBody: {
        email: string;
        is_admin: boolean;
        operator: boolean;
    };
    workspace: string;
};

export type DeleteInviteResponse = (string);

export type ArchiveWorkspaceData = {
    workspace: string;
};

export type ArchiveWorkspaceResponse = (string);

export type UnarchiveWorkspaceData = {
    workspace: string;
};

export type UnarchiveWorkspaceResponse = (string);

export type DeleteWorkspaceData = {
    workspace: string;
};

export type DeleteWorkspaceResponse = (string);

export type LeaveWorkspaceData = {
    workspace: string;
};

export type LeaveWorkspaceResponse = (string);

export type GetWorkspaceNameData = {
    workspace: string;
};

export type GetWorkspaceNameResponse = (string);

export type ChangeWorkspaceNameData = {
    requestBody?: {
        new_name?: string;
    };
    workspace: string;
};

export type ChangeWorkspaceNameResponse = (string);

export type ChangeWorkspaceIdData = {
    requestBody?: {
        new_id?: string;
        new_name?: string;
    };
    workspace: string;
};

export type ChangeWorkspaceIdResponse = (string);

export type WhoisData = {
    username: string;
    workspace: string;
};

export type WhoisResponse = (User);

export type ExistsEmailData = {
    email: string;
};

export type ExistsEmailResponse = (boolean);

export type ListUsersAsSuperAdminData = {
    /**
     * which page to return (start at 1, default 1)
     */
    page?: number;
    /**
     * number of items to return for a given page (default 30, max 100)
     */
    perPage?: number;
};

export type ListUsersAsSuperAdminResponse = (Array<GlobalUserInfo>);

export type ListPendingInvitesData = {
    workspace: string;
};

export type ListPendingInvitesResponse = (Array<WorkspaceInvite>);

export type GetSettingsData = {
    workspace: string;
};

export type GetSettingsResponse = ({
    workspace_id?: string;
    slack_name?: string;
    slack_team_id?: string;
    slack_command_script?: string;
    auto_invite_domain?: string;
    auto_invite_operator?: boolean;
    auto_add?: boolean;
    plan?: string;
    automatic_billing: boolean;
    customer_id?: string;
    webhook?: string;
    deploy_to?: string;
    openai_resource_path?: string;
    code_completion_enabled: boolean;
    error_handler?: string;
    error_handler_extra_args?: ScriptArgs;
    error_handler_muted_on_cancel: boolean;
    large_file_storage?: LargeFileStorage;
    git_sync?: WorkspaceGitSyncSettings;
    deploy_ui?: WorkspaceDeployUISettings;
    default_app?: string;
    default_scripts?: WorkspaceDefaultScripts;
});

export type GetDeployToData = {
    workspace: string;
};

export type GetDeployToResponse = ({
    deploy_to?: string;
});

export type GetIsPremiumData = {
    workspace: string;
};

export type GetIsPremiumResponse = (boolean);

export type GetPremiumInfoData = {
    workspace: string;
};

export type GetPremiumInfoResponse = ({
    premium: boolean;
    usage?: number;
    seats?: number;
    automatic_billing: boolean;
});

export type SetAutomaticBillingData = {
    /**
     * automatic billing
     */
    requestBody: {
        automatic_billing: boolean;
        seats?: number;
    };
    workspace: string;
};

export type SetAutomaticBillingResponse = (string);

export type EditSlackCommandData = {
    /**
     * WorkspaceInvite
     */
    requestBody: {
        slack_command_script?: string;
    };
    workspace: string;
};

export type EditSlackCommandResponse = (string);

export type RunSlackMessageTestJobData = {
    /**
     * path to hub script to run and its corresponding args
     */
    requestBody: {
        hub_script_path?: string;
        channel?: string;
        test_msg?: string;
    };
    workspace: string;
};

export type RunSlackMessageTestJobResponse = ({
    job_uuid?: string;
});

export type EditDeployToData = {
    requestBody: {
        deploy_to?: string;
    };
    workspace: string;
};

export type EditDeployToResponse = (string);

export type EditAutoInviteData = {
    /**
     * WorkspaceInvite
     */
    requestBody: {
        operator?: boolean;
        invite_all?: boolean;
        auto_add?: boolean;
    };
    workspace: string;
};

export type EditAutoInviteResponse = (string);

export type EditWebhookData = {
    /**
     * WorkspaceWebhook
     */
    requestBody: {
        webhook?: string;
    };
    workspace: string;
};

export type EditWebhookResponse = (string);

export type EditCopilotConfigData = {
    /**
     * WorkspaceCopilotConfig
     */
    requestBody: {
        openai_resource_path?: string;
        code_completion_enabled: boolean;
    };
    workspace: string;
};

export type EditCopilotConfigResponse = (string);

export type GetCopilotInfoData = {
    workspace: string;
};

export type GetCopilotInfoResponse = ({
    exists_openai_resource_path: boolean;
    code_completion_enabled: boolean;
});

export type EditErrorHandlerData = {
    /**
     * WorkspaceErrorHandler
     */
    requestBody: {
        error_handler?: string;
        error_handler_extra_args?: ScriptArgs;
        error_handler_muted_on_cancel?: boolean;
    };
    workspace: string;
};

export type EditErrorHandlerResponse = (string);

export type EditLargeFileStorageConfigData = {
    /**
     * LargeFileStorage info
     */
    requestBody: {
        large_file_storage?: LargeFileStorage;
    };
    workspace: string;
};

export type EditLargeFileStorageConfigResponse = (unknown);

export type EditWorkspaceGitSyncConfigData = {
    /**
     * Workspace Git sync settings
     */
    requestBody: {
        git_sync_settings?: WorkspaceGitSyncSettings;
    };
    workspace: string;
};

export type EditWorkspaceGitSyncConfigResponse = (unknown);

export type EditWorkspaceDeployUiSettingsData = {
    /**
     * Workspace deploy UI settings
     */
    requestBody: {
        deploy_ui_settings?: WorkspaceDeployUISettings;
    };
    workspace: string;
};

export type EditWorkspaceDeployUiSettingsResponse = (unknown);

export type EditWorkspaceDefaultAppData = {
    /**
     * Workspace default app
     */
    requestBody: {
        default_app_path?: string;
    };
    workspace: string;
};

export type EditWorkspaceDefaultAppResponse = (string);

export type EditDefaultScriptsData = {
    /**
     * Workspace default app
     */
    requestBody?: WorkspaceDefaultScripts;
    workspace: string;
};

export type EditDefaultScriptsResponse = (string);

export type GetDefaultScriptsData = {
    workspace: string;
};

export type GetDefaultScriptsResponse = (WorkspaceDefaultScripts);

export type SetEnvironmentVariableData = {
    /**
     * Workspace default app
     */
    requestBody: {
        name: string;
        value?: string;
    };
    workspace: string;
};

export type SetEnvironmentVariableResponse = (string);

export type GetWorkspaceEncryptionKeyData = {
    workspace: string;
};

export type GetWorkspaceEncryptionKeyResponse = ({
    key: string;
});

export type SetWorkspaceEncryptionKeyData = {
    /**
     * New encryption key
     */
    requestBody: {
        new_key: string;
        skip_reencrypt?: boolean;
    };
    workspace: string;
};

export type SetWorkspaceEncryptionKeyResponse = (string);

export type GetWorkspaceDefaultAppData = {
    workspace: string;
};

export type GetWorkspaceDefaultAppResponse = ({
    default_app_path?: string;
});

export type GetLargeFileStorageConfigData = {
    workspace: string;
};

export type GetLargeFileStorageConfigResponse = (LargeFileStorage);

export type GetWorkspaceUsageData = {
    workspace: string;
};

export type GetWorkspaceUsageResponse = (number);

export type ListUsersData = {
    workspace: string;
};

export type ListUsersResponse = (Array<User>);

export type ListUsersUsageData = {
    workspace: string;
};

export type ListUsersUsageResponse = (Array<UserUsage>);

export type ListUsernamesData = {
    workspace: string;
};

export type ListUsernamesResponse = (Array<(string)>);

export type UsernameToEmailData = {
    username: string;
    workspace: string;
};

export type UsernameToEmailResponse = (string);

export type CreateTokenData = {
    /**
     * new token
     */
    requestBody: NewToken;
};

export type CreateTokenResponse = (string);

export type CreateTokenImpersonateData = {
    /**
     * new token
     */
    requestBody: NewTokenImpersonate;
};

export type CreateTokenImpersonateResponse = (string);

export type DeleteTokenData = {
    tokenPrefix: string;
};

export type DeleteTokenResponse = (string);

export type ListTokensData = {
    excludeEphemeral?: boolean;
    /**
     * which page to return (start at 1, default 1)
     */
    page?: number;
    /**
     * number of items to return for a given page (default 30, max 100)
     */
    perPage?: number;
};

export type ListTokensResponse = (Array<TruncatedToken>);

export type GetOidcTokenData = {
    audience: string;
    workspace: string;
};

export type GetOidcTokenResponse = (string);

export type CreateVariableData = {
    alreadyEncrypted?: boolean;
    /**
     * new variable
     */
    requestBody: CreateVariable;
    workspace: string;
};

export type CreateVariableResponse = (string);

export type EncryptValueData = {
    /**
     * new variable
     */
    requestBody: string;
    workspace: string;
};

export type EncryptValueResponse = (string);

export type DeleteVariableData = {
    path: string;
    workspace: string;
};

export type DeleteVariableResponse = (string);

export type UpdateVariableData = {
    alreadyEncrypted?: boolean;
    path: string;
    /**
     * updated variable
     */
    requestBody: EditVariable;
    workspace: string;
};

export type UpdateVariableResponse = (string);

export type GetVariableData = {
    /**
     * ask to decrypt secret if this variable is secret
     * (if not secret no effect, default: true)
     *
     */
    decryptSecret?: boolean;
    /**
     * ask to include the encrypted value if secret and decrypt secret is not true (default: false)
     *
     */
    includeEncrypted?: boolean;
    path: string;
    workspace: string;
};

export type GetVariableResponse = (ListableVariable);

export type GetVariableValueData = {
    path: string;
    workspace: string;
};

export type GetVariableValueResponse = (string);

export type ExistsVariableData = {
    path: string;
    workspace: string;
};

export type ExistsVariableResponse = (boolean);

export type ListVariableData = {
    /**
     * which page to return (start at 1, default 1)
     */
    page?: number;
    pathStart?: string;
    /**
     * number of items to return for a given page (default 30, max 100)
     */
    perPage?: number;
    workspace: string;
};

export type ListVariableResponse = (Array<ListableVariable>);

export type ListContextualVariablesData = {
    workspace: string;
};

export type ListContextualVariablesResponse = (Array<ContextualVariable>);

export type LoginWithOauthData = {
    clientName: string;
    /**
     * Partially filled script
     */
    requestBody: {
        code?: string;
        state?: string;
    };
};

export type LoginWithOauthResponse = (string);

export type ConnectSlackCallbackData = {
    /**
     * code endpoint
     */
    requestBody: {
        code: string;
        state: string;
    };
    workspace: string;
};

export type ConnectSlackCallbackResponse = (string);

export type ConnectSlackCallbackInstanceData = {
    /**
     * code endpoint
     */
    requestBody: {
        code: string;
        state: string;
    };
};

export type ConnectSlackCallbackInstanceResponse = (string);

export type ConnectCallbackData = {
    clientName: string;
    /**
     * code endpoint
     */
    requestBody: {
        code: string;
        state: string;
    };
};

export type ConnectCallbackResponse = (TokenResponse);

export type CreateAccountData = {
    /**
     * code endpoint
     */
    requestBody: {
        refresh_token?: string;
        expires_in: number;
        client: string;
    };
    workspace: string;
};

export type CreateAccountResponse = (string);

export type RefreshTokenData = {
    id: number;
    /**
     * variable path
     */
    requestBody: {
        path: string;
    };
    workspace: string;
};

export type RefreshTokenResponse = (string);

export type DisconnectAccountData = {
    id: number;
    workspace: string;
};

export type DisconnectAccountResponse = (string);

export type DisconnectSlackData = {
    workspace: string;
};

export type DisconnectSlackResponse = (string);

export type ListOauthLoginsResponse = ({
    oauth: Array<(string)>;
    saml?: string;
});

export type ListOauthConnectsResponse = (Array<(string)>);

export type GetOauthConnectData = {
    /**
     * client name
     */
    client: string;
};

export type GetOauthConnectResponse = ({
    extra_params?: {
        [key: string]: unknown;
    };
    scopes?: Array<(string)>;
});

export type CreateResourceData = {
    /**
     * new resource
     */
    requestBody: CreateResource;
    updateIfExists?: boolean;
    workspace: string;
};

export type CreateResourceResponse = (string);

export type DeleteResourceData = {
    path: string;
    workspace: string;
};

export type DeleteResourceResponse = (string);

export type UpdateResourceData = {
    path: string;
    /**
     * updated resource
     */
    requestBody: EditResource;
    workspace: string;
};

export type UpdateResourceResponse = (string);

export type UpdateResourceValueData = {
    path: string;
    /**
     * updated resource
     */
    requestBody: {
        value?: unknown;
    };
    workspace: string;
};

export type UpdateResourceValueResponse = (string);

export type GetResourceData = {
    path: string;
    workspace: string;
};

export type GetResourceResponse = (Resource);

export type GetResourceValueInterpolatedData = {
    /**
     * job id
     */
    jobId?: string;
    path: string;
    workspace: string;
};

export type GetResourceValueInterpolatedResponse = (unknown);

export type GetResourceValueData = {
    path: string;
    workspace: string;
};

export type GetResourceValueResponse = (unknown);

export type ExistsResourceData = {
    path: string;
    workspace: string;
};

export type ExistsResourceResponse = (boolean);

export type ListResourceData = {
    /**
     * which page to return (start at 1, default 1)
     */
    page?: number;
    pathStart?: string;
    /**
     * number of items to return for a given page (default 30, max 100)
     */
    perPage?: number;
    /**
     * resource_types to list from, separated by ',',
     */
    resourceType?: string;
    /**
     * resource_types to not list from, separated by ',',
     */
    resourceTypeExclude?: string;
    workspace: string;
};

export type ListResourceResponse = (Array<ListableResource>);

export type ListSearchResourceData = {
    workspace: string;
};

export type ListSearchResourceResponse = (Array<{
    path: string;
    value: unknown;
}>);

export type ListResourceNamesData = {
    name: string;
    workspace: string;
};

export type ListResourceNamesResponse = (Array<{
    name: string;
    path: string;
}>);

export type CreateResourceTypeData = {
    /**
     * new resource_type
     */
    requestBody: ResourceType;
    workspace: string;
};

export type CreateResourceTypeResponse = (string);

export type FileResourceTypeToFileExtMapData = {
    workspace: string;
};

export type FileResourceTypeToFileExtMapResponse = (unknown);

export type DeleteResourceTypeData = {
    path: string;
    workspace: string;
};

export type DeleteResourceTypeResponse = (string);

export type UpdateResourceTypeData = {
    path: string;
    /**
     * updated resource_type
     */
    requestBody: EditResourceType;
    workspace: string;
};

export type UpdateResourceTypeResponse = (string);

export type GetResourceTypeData = {
    path: string;
    workspace: string;
};

export type GetResourceTypeResponse = (ResourceType);

export type ExistsResourceTypeData = {
    path: string;
    workspace: string;
};

export type ExistsResourceTypeResponse = (boolean);

export type ListResourceTypeData = {
    workspace: string;
};

export type ListResourceTypeResponse = (Array<ResourceType>);

export type ListResourceTypeNamesData = {
    workspace: string;
};

export type ListResourceTypeNamesResponse = (Array<(string)>);

export type QueryResourceTypesData = {
    /**
     * query limit
     */
    limit?: number;
    /**
     * query text
     */
    text: string;
    workspace: string;
};

export type QueryResourceTypesResponse = (Array<{
    name: string;
    score: number;
    schema?: unknown;
}>);

export type ListHubIntegrationsData = {
    /**
     * query integrations kind
     */
    kind?: string;
};

export type ListHubIntegrationsResponse = (Array<{
    name: string;
}>);

export type ListHubFlowsResponse = ({
    flows?: Array<{
        id: number;
        flow_id: number;
        summary: string;
        apps: Array<(string)>;
        approved: boolean;
        votes: number;
    }>;
});

export type GetHubFlowByIdData = {
    id: number;
};

export type GetHubFlowByIdResponse = ({
    flow?: OpenFlow;
});

export type ListHubAppsResponse = ({
    apps?: Array<{
        id: number;
        app_id: number;
        summary: string;
        apps: Array<(string)>;
        approved: boolean;
        votes: number;
    }>;
});

export type GetHubAppByIdData = {
    id: number;
};

export type GetHubAppByIdResponse = ({
    app: {
        summary: string;
        value: unknown;
    };
});

export type GetHubScriptContentByPathData = {
    path: string;
};

export type GetHubScriptContentByPathResponse = (string);

export type GetHubScriptByPathData = {
    path: string;
};

export type GetHubScriptByPathResponse = ({
    content: string;
    lockfile?: string;
    schema?: unknown;
    language: string;
    summary?: string;
});

export type GetTopHubScriptsData = {
    /**
     * query scripts app
     */
    app?: string;
    /**
     * query scripts kind
     */
    kind?: string;
    /**
     * query limit
     */
    limit?: number;
};

export type GetTopHubScriptsResponse = ({
    asks?: Array<{
        id: number;
        ask_id: number;
        summary: string;
        app: string;
        version_id: number;
        kind: HubScriptKind;
        votes: number;
        views: number;
    }>;
});

export type QueryHubScriptsData = {
    /**
     * query scripts app
     */
    app?: string;
    /**
     * query scripts kind
     */
    kind?: string;
    /**
     * query limit
     */
    limit?: number;
    /**
     * query text
     */
    text: string;
};

export type QueryHubScriptsResponse = (Array<{
    ask_id: number;
    id: number;
    version_id: number;
    summary: string;
    app: string;
    kind: HubScriptKind;
    score: number;
}>);

export type ListSearchScriptData = {
    workspace: string;
};

export type ListSearchScriptResponse = (Array<{
    path: string;
    content: string;
}>);

export type ListScriptsData = {
    /**
     * mask to filter exact matching user creator
     */
    createdBy?: string;
    /**
     * mask to filter scripts whom first direct parent has exact hash
     */
    firstParentHash?: string;
    /**
     * (default false)
     * include scripts that have no deployed version
     *
     */
    includeDraftOnly?: boolean;
    /**
     * (default false)
     * include scripts without an exported main function
     *
     */
    includeWithoutMain?: boolean;
    /**
     * (default regardless)
     * if true show only the templates
     * if false show only the non templates
     * if not defined, show all regardless of if the script is a template
     *
     */
    isTemplate?: boolean;
    /**
     * (default regardless)
     * script kinds to filter, split by comma
     *
     */
    kinds?: string;
    /**
     * mask to filter scripts whom last parent in the chain has exact hash.
     * Beware that each script stores only a limited number of parents. Hence
     * the last parent hash for a script is not necessarily its top-most parent.
     * To find the top-most parent you will have to jump from last to last hash
     * until finding the parent
     *
     */
    lastParentHash?: string;
    /**
     * order by desc order (default true)
     */
    orderDesc?: boolean;
    /**
     * which page to return (start at 1, default 1)
     */
    page?: number;
    /**
     * is the hash present in the array of stored parent hashes for this script.
     * The same warning applies than for last_parent_hash. A script only store a
     * limited number of direct parent
     *
     */
    parentHash?: string;
    /**
     * mask to filter exact matching path
     */
    pathExact?: string;
    /**
     * mask to filter matching starting path
     */
    pathStart?: string;
    /**
     * number of items to return for a given page (default 30, max 100)
     */
    perPage?: number;
    /**
     * (default false)
     * show only the archived files.
     * when multiple archived hash share the same path, only the ones with the latest create_at
     * are
     * ed.
     *
     */
    showArchived?: boolean;
    /**
     * (default false)
     * show only the starred items
     *
     */
    starredOnly?: boolean;
    /**
     * (default false)
     * include deployment message
     *
     */
    withDeploymentMsg?: boolean;
    workspace: string;
};

export type ListScriptsResponse = (Array<Script>);

export type ListScriptPathsData = {
    workspace: string;
};

export type ListScriptPathsResponse = (Array<(string)>);

export type CreateDraftData = {
    requestBody: {
        path: string;
        typ: 'flow' | 'script' | 'app';
        value?: unknown;
    };
    workspace: string;
};

export type CreateDraftResponse = (string);

export type DeleteDraftData = {
    kind: 'script' | 'flow' | 'app';
    path: string;
    workspace: string;
};

export type DeleteDraftResponse = (string);

export type CreateScriptData = {
    /**
     * Partially filled script
     */
    requestBody: NewScript;
    workspace: string;
};

export type CreateScriptResponse = (string);

export type ToggleWorkspaceErrorHandlerForScriptData = {
    path: string;
    /**
     * Workspace error handler enabled
     */
    requestBody: {
        muted?: boolean;
    };
    workspace: string;
};

export type ToggleWorkspaceErrorHandlerForScriptResponse = (string);

export type GetCustomTagsResponse = (Array<(string)>);

export type GeDefaultTagsResponse = (Array<(string)>);

export type IsDefaultTagsPerWorkspaceResponse = (boolean);

export type ArchiveScriptByPathData = {
    path: string;
    workspace: string;
};

export type ArchiveScriptByPathResponse = (string);

export type ArchiveScriptByHashData = {
    hash: string;
    workspace: string;
};

export type ArchiveScriptByHashResponse = (Script);

export type DeleteScriptByHashData = {
    hash: string;
    workspace: string;
};

export type DeleteScriptByHashResponse = (Script);

export type DeleteScriptByPathData = {
    path: string;
    workspace: string;
};

export type DeleteScriptByPathResponse = (string);

export type GetScriptByPathData = {
    path: string;
    withStarredInfo?: boolean;
    workspace: string;
};

export type GetScriptByPathResponse = (Script);

export type GetScriptByPathWithDraftData = {
    path: string;
    workspace: string;
};

export type GetScriptByPathWithDraftResponse = (NewScriptWithDraft);

export type GetScriptHistoryByPathData = {
    path: string;
    workspace: string;
};

export type GetScriptHistoryByPathResponse = (Array<ScriptHistory>);

export type UpdateScriptHistoryData = {
    hash: string;
    path: string;
    /**
     * Script deployment message
     */
    requestBody: {
        deployment_msg?: string;
    };
    workspace: string;
};

export type UpdateScriptHistoryResponse = (string);

export type RawScriptByPathData = {
    path: string;
    workspace: string;
};

export type RawScriptByPathResponse = (string);

export type RawScriptByPathTokenedData = {
    path: string;
    token: string;
    workspace: string;
};

export type RawScriptByPathTokenedResponse = (string);

export type ExistsScriptByPathData = {
    path: string;
    workspace: string;
};

export type ExistsScriptByPathResponse = (boolean);

export type GetScriptByHashData = {
    hash: string;
    withStarredInfo?: boolean;
    workspace: string;
};

export type GetScriptByHashResponse = (Script);

export type RawScriptByHashData = {
    path: string;
    workspace: string;
};

export type RawScriptByHashResponse = (string);

export type GetScriptDeploymentStatusData = {
    hash: string;
    workspace: string;
};

export type GetScriptDeploymentStatusResponse = ({
    lock?: string;
    lock_error_logs?: string;
});

export type RunScriptByPathData = {
    /**
     * Override the cache time to live (in seconds). Can not be used to disable caching, only override with a new cache ttl
     */
    cacheTtl?: string;
    /**
     * make the run invisible to the the script owner (default false)
     */
    invisibleToOwner?: boolean;
    /**
     * The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
     */
    jobId?: string;
    /**
     * The parent job that is at the origin and responsible for the execution of this script if any
     */
    parentJob?: string;
    path: string;
    /**
     * script args
     */
    requestBody: ScriptArgs;
    /**
     * when to schedule this job (leave empty for immediate run)
     */
    scheduledFor?: string;
    /**
     * schedule the script to execute in the number of seconds starting now
     */
    scheduledInSecs?: number;
    /**
     * skip the preprocessor
     */
    skipPreprocessor?: boolean;
    /**
     * Override the tag to use
     */
    tag?: string;
    workspace: string;
};

export type RunScriptByPathResponse = (string);

export type OpenaiSyncScriptByPathData = {
    /**
     * List of headers's keys (separated with ',') whove value are added to the args
     * Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
     *
     */
    includeHeader?: string;
    /**
     * The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
     */
    jobId?: string;
    /**
     * The parent job that is at the origin and responsible for the execution of this script if any
     */
    parentJob?: string;
    path: string;
    /**
     * The maximum size of the queue for which the request would get rejected if that job would push it above that limit
     *
     */
    queueLimit?: string;
    /**
     * script args
     */
    requestBody: ScriptArgs;
    workspace: string;
};

export type OpenaiSyncScriptByPathResponse = (unknown);

export type RunWaitResultScriptByPathData = {
    /**
     * Override the cache time to live (in seconds). Can not be used to disable caching, only override with a new cache ttl
     */
    cacheTtl?: string;
    /**
     * List of headers's keys (separated with ',') whove value are added to the args
     * Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
     *
     */
    includeHeader?: string;
    /**
     * The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
     */
    jobId?: string;
    /**
     * The parent job that is at the origin and responsible for the execution of this script if any
     */
    parentJob?: string;
    path: string;
    /**
     * The maximum size of the queue for which the request would get rejected if that job would push it above that limit
     *
     */
    queueLimit?: string;
    /**
     * script args
     */
    requestBody: ScriptArgs;
    /**
     * Override the tag to use
     */
    tag?: string;
    workspace: string;
};

export type RunWaitResultScriptByPathResponse = (unknown);

export type RunWaitResultScriptByPathGetData = {
    /**
     * Override the cache time to live (in seconds). Can not be used to disable caching, only override with a new cache ttl
     */
    cacheTtl?: string;
    /**
     * List of headers's keys (separated with ',') whove value are added to the args
     * Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
     *
     */
    includeHeader?: string;
    /**
     * The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
     */
    jobId?: string;
    /**
     * The parent job that is at the origin and responsible for the execution of this script if any
     */
    parentJob?: string;
    path: string;
    /**
     * The base64 encoded payload that has been encoded as a JSON. e.g how to encode such payload encodeURIComponent
     * `encodeURIComponent(btoa(JSON.stringify({a: 2})))`
     *
     */
    payload?: string;
    /**
     * The maximum size of the queue for which the request would get rejected if that job would push it above that limit
     *
     */
    queueLimit?: string;
    /**
     * Override the tag to use
     */
    tag?: string;
    workspace: string;
};

export type RunWaitResultScriptByPathGetResponse = (unknown);

export type OpenaiSyncFlowByPathData = {
    /**
     * List of headers's keys (separated with ',') whove value are added to the args
     * Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
     *
     */
    includeHeader?: string;
    /**
     * The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
     */
    jobId?: string;
    path: string;
    /**
     * The maximum size of the queue for which the request would get rejected if that job would push it above that limit
     *
     */
    queueLimit?: string;
    /**
     * script args
     */
    requestBody: ScriptArgs;
    workspace: string;
};

export type OpenaiSyncFlowByPathResponse = (unknown);

export type RunWaitResultFlowByPathData = {
    /**
     * List of headers's keys (separated with ',') whove value are added to the args
     * Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
     *
     */
    includeHeader?: string;
    /**
     * The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
     */
    jobId?: string;
    path: string;
    /**
     * The maximum size of the queue for which the request would get rejected if that job would push it above that limit
     *
     */
    queueLimit?: string;
    /**
     * script args
     */
    requestBody: ScriptArgs;
    workspace: string;
};

export type RunWaitResultFlowByPathResponse = (unknown);

export type ResultByIdData = {
    flowJobId: string;
    nodeId: string;
    workspace: string;
};

export type ResultByIdResponse = (unknown);

export type ListFlowPathsData = {
    workspace: string;
};

export type ListFlowPathsResponse = (Array<(string)>);

export type ListSearchFlowData = {
    workspace: string;
};

export type ListSearchFlowResponse = (Array<{
    path: string;
    value: unknown;
}>);

export type ListFlowsData = {
    /**
     * mask to filter exact matching user creator
     */
    createdBy?: string;
    /**
     * (default false)
     * include items that have no deployed version
     *
     */
    includeDraftOnly?: boolean;
    /**
     * order by desc order (default true)
     */
    orderDesc?: boolean;
    /**
     * which page to return (start at 1, default 1)
     */
    page?: number;
    /**
     * mask to filter exact matching path
     */
    pathExact?: string;
    /**
     * mask to filter matching starting path
     */
    pathStart?: string;
    /**
     * number of items to return for a given page (default 30, max 100)
     */
    perPage?: number;
    /**
     * (default false)
     * show only the archived files.
     * when multiple archived hash share the same path, only the ones with the latest create_at
     * are displayed.
     *
     */
    showArchived?: boolean;
    /**
     * (default false)
     * show only the starred items
     *
     */
    starredOnly?: boolean;
    /**
     * (default false)
     * include deployment message
     *
     */
    withDeploymentMsg?: boolean;
    workspace: string;
};

export type ListFlowsResponse = (Array<(Flow & {
    has_draft?: boolean;
    draft_only?: boolean;
})>);

export type GetFlowHistoryData = {
    path: string;
    workspace: string;
};

export type GetFlowHistoryResponse = (Array<FlowVersion>);

export type GetFlowVersionData = {
    path: string;
    version: number;
    workspace: string;
};

export type GetFlowVersionResponse = (Flow);

export type UpdateFlowHistoryData = {
    path: string;
    /**
     * Flow deployment message
     */
    requestBody: {
        deployment_msg: string;
    };
    version: number;
    workspace: string;
};

export type UpdateFlowHistoryResponse = (string);

export type GetFlowByPathData = {
    path: string;
    withStarredInfo?: boolean;
    workspace: string;
};

export type GetFlowByPathResponse = (Flow);

export type ToggleWorkspaceErrorHandlerForFlowData = {
    path: string;
    /**
     * Workspace error handler enabled
     */
    requestBody: {
        muted?: boolean;
    };
    workspace: string;
};

export type ToggleWorkspaceErrorHandlerForFlowResponse = (string);

export type GetFlowByPathWithDraftData = {
    path: string;
    workspace: string;
};

export type GetFlowByPathWithDraftResponse = ((Flow & {
    draft?: Flow;
}));

export type ExistsFlowByPathData = {
    path: string;
    workspace: string;
};

export type ExistsFlowByPathResponse = (boolean);

export type CreateFlowData = {
    /**
     * Partially filled flow
     */
    requestBody: (OpenFlowWPath & {
    draft_only?: boolean;
    deployment_message?: string;
});
    workspace: string;
};

export type CreateFlowResponse = (string);

export type UpdateFlowData = {
    path: string;
    /**
     * Partially filled flow
     */
    requestBody: (OpenFlowWPath & {
    deployment_message?: string;
});
    workspace: string;
};

export type UpdateFlowResponse = (string);

export type ArchiveFlowByPathData = {
    path: string;
    /**
     * archiveFlow
     */
    requestBody: {
        archived?: boolean;
    };
    workspace: string;
};

export type ArchiveFlowByPathResponse = (string);

export type DeleteFlowByPathData = {
    path: string;
    workspace: string;
};

export type DeleteFlowByPathResponse = (string);

export type ListRawAppsData = {
    /**
     * mask to filter exact matching user creator
     */
    createdBy?: string;
    /**
     * order by desc order (default true)
     */
    orderDesc?: boolean;
    /**
     * which page to return (start at 1, default 1)
     */
    page?: number;
    /**
     * mask to filter exact matching path
     */
    pathExact?: string;
    /**
     * mask to filter matching starting path
     */
    pathStart?: string;
    /**
     * number of items to return for a given page (default 30, max 100)
     */
    perPage?: number;
    /**
     * (default false)
     * show only the starred items
     *
     */
    starredOnly?: boolean;
    workspace: string;
};

export type ListRawAppsResponse = (Array<ListableRawApp>);

export type ExistsRawAppData = {
    path: string;
    workspace: string;
};

export type ExistsRawAppResponse = (boolean);

export type GetRawAppDataData = {
    path: string;
    version: number;
    workspace: string;
};

export type GetRawAppDataResponse = (string);

export type ListSearchAppData = {
    workspace: string;
};

export type ListSearchAppResponse = (Array<{
    path: string;
    value: unknown;
}>);

export type ListAppsData = {
    /**
     * mask to filter exact matching user creator
     */
    createdBy?: string;
    /**
     * (default false)
     * include items that have no deployed version
     *
     */
    includeDraftOnly?: boolean;
    /**
     * order by desc order (default true)
     */
    orderDesc?: boolean;
    /**
     * which page to return (start at 1, default 1)
     */
    page?: number;
    /**
     * mask to filter exact matching path
     */
    pathExact?: string;
    /**
     * mask to filter matching starting path
     */
    pathStart?: string;
    /**
     * number of items to return for a given page (default 30, max 100)
     */
    perPage?: number;
    /**
     * (default false)
     * show only the starred items
     *
     */
    starredOnly?: boolean;
    /**
     * (default false)
     * include deployment message
     *
     */
    withDeploymentMsg?: boolean;
    workspace: string;
};

export type ListAppsResponse = (Array<ListableApp>);

export type CreateAppData = {
    /**
     * new app
     */
    requestBody: {
        path: string;
        value: unknown;
        summary: string;
        policy: Policy;
        draft_only?: boolean;
        deployment_message?: string;
    };
    workspace: string;
};

export type CreateAppResponse = (string);

export type ExistsAppData = {
    path: string;
    workspace: string;
};

export type ExistsAppResponse = (boolean);

export type GetAppByPathData = {
    path: string;
    withStarredInfo?: boolean;
    workspace: string;
};

export type GetAppByPathResponse = (AppWithLastVersion);

export type GetAppByPathWithDraftData = {
    path: string;
    workspace: string;
};

export type GetAppByPathWithDraftResponse = (AppWithLastVersionWDraft);

export type GetAppHistoryByPathData = {
    path: string;
    workspace: string;
};

export type GetAppHistoryByPathResponse = (Array<AppHistory>);

export type UpdateAppHistoryData = {
    id: number;
    /**
     * App deployment message
     */
    requestBody: {
        deployment_msg?: string;
    };
    version: number;
    workspace: string;
};

export type UpdateAppHistoryResponse = (string);

export type GetPublicAppBySecretData = {
    path: string;
    workspace: string;
};

export type GetPublicAppBySecretResponse = (AppWithLastVersion);

export type GetPublicResourceData = {
    path: string;
    workspace: string;
};

export type GetPublicResourceResponse = (unknown);

export type GetPublicSecretOfAppData = {
    path: string;
    workspace: string;
};

export type GetPublicSecretOfAppResponse = (string);

export type GetAppByVersionData = {
    id: number;
    workspace: string;
};

export type GetAppByVersionResponse = (AppWithLastVersion);

export type CreateRawAppData = {
    /**
     * new raw app
     */
    requestBody: {
        path: string;
        value: string;
        summary: string;
    };
    workspace: string;
};

export type CreateRawAppResponse = (string);

export type UpdateRawAppData = {
    path: string;
    /**
     * updateraw  app
     */
    requestBody: {
        path?: string;
        summary?: string;
        value?: string;
    };
    workspace: string;
};

export type UpdateRawAppResponse = (string);

export type DeleteRawAppData = {
    path: string;
    workspace: string;
};

export type DeleteRawAppResponse = (string);

export type DeleteAppData = {
    path: string;
    workspace: string;
};

export type DeleteAppResponse = (string);

export type UpdateAppData = {
    path: string;
    /**
     * update app
     */
    requestBody: {
        path?: string;
        summary?: string;
        value?: unknown;
        policy?: Policy;
        deployment_message?: string;
    };
    workspace: string;
};

export type UpdateAppResponse = (string);

export type ExecuteComponentData = {
    path: string;
    /**
     * update app
     */
    requestBody: {
        component: string;
        path?: string;
        args: unknown;
        raw_code?: {
            content: string;
            language: string;
            path?: string;
            lock?: string;
            cache_ttl?: number;
        };
        force_viewer_static_fields?: {
            [key: string]: unknown;
        };
        force_viewer_one_of_fields?: {
            [key: string]: unknown;
        };
        force_viewer_allow_user_resources?: Array<(string)>;
    };
    workspace: string;
};

export type ExecuteComponentResponse = (string);

export type RunFlowByPathData = {
    /**
     * List of headers's keys (separated with ',') whove value are added to the args
     * Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
     *
     */
    includeHeader?: string;
    /**
     * make the run invisible to the the flow owner (default false)
     */
    invisibleToOwner?: boolean;
    /**
     * The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
     */
    jobId?: string;
    /**
     * The parent job that is at the origin and responsible for the execution of this script if any
     */
    parentJob?: string;
    path: string;
    /**
     * flow args
     */
    requestBody: ScriptArgs;
    /**
     * when to schedule this job (leave empty for immediate run)
     */
    scheduledFor?: string;
    /**
     * schedule the script to execute in the number of seconds starting now
     */
    scheduledInSecs?: number;
    /**
     * skip the preprocessor
     */
    skipPreprocessor?: boolean;
    /**
     * Override the tag to use
     */
    tag?: string;
    workspace: string;
};

export type RunFlowByPathResponse = (string);

export type RestartFlowAtStepData = {
    /**
     * for branchall or loop, the iteration at which the flow should restart
     */
    branchOrIterationN: number;
    id: string;
    /**
     * List of headers's keys (separated with ',') whove value are added to the args
     * Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
     *
     */
    includeHeader?: string;
    /**
     * make the run invisible to the the flow owner (default false)
     */
    invisibleToOwner?: boolean;
    /**
     * The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
     */
    jobId?: string;
    /**
     * The parent job that is at the origin and responsible for the execution of this script if any
     */
    parentJob?: string;
    /**
     * flow args
     */
    requestBody: ScriptArgs;
    /**
     * when to schedule this job (leave empty for immediate run)
     */
    scheduledFor?: string;
    /**
     * schedule the script to execute in the number of seconds starting now
     */
    scheduledInSecs?: number;
    /**
     * step id to restart the flow from
     */
    stepId: string;
    /**
     * Override the tag to use
     */
    tag?: string;
    workspace: string;
};

export type RestartFlowAtStepResponse = (string);

export type RunScriptByHashData = {
    /**
     * Override the cache time to live (in seconds). Can not be used to disable caching, only override with a new cache ttl
     */
    cacheTtl?: string;
    hash: string;
    /**
     * List of headers's keys (separated with ',') whove value are added to the args
     * Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
     *
     */
    includeHeader?: string;
    /**
     * make the run invisible to the the script owner (default false)
     */
    invisibleToOwner?: boolean;
    /**
     * The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
     */
    jobId?: string;
    /**
     * The parent job that is at the origin and responsible for the execution of this script if any
     */
    parentJob?: string;
    /**
     * Partially filled args
     */
    requestBody: {
        [key: string]: unknown;
    };
    /**
     * when to schedule this job (leave empty for immediate run)
     */
    scheduledFor?: string;
    /**
     * schedule the script to execute in the number of seconds starting now
     */
    scheduledInSecs?: number;
    /**
     * skip the preprocessor
     */
    skipPreprocessor?: boolean;
    /**
     * Override the tag to use
     */
    tag?: string;
    workspace: string;
};

export type RunScriptByHashResponse = (string);

export type RunScriptPreviewData = {
    /**
     * List of headers's keys (separated with ',') whove value are added to the args
     * Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
     *
     */
    includeHeader?: string;
    /**
     * make the run invisible to the the script owner (default false)
     */
    invisibleToOwner?: boolean;
    /**
     * The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
     */
    jobId?: string;
    /**
     * preview
     */
    requestBody: Preview;
    workspace: string;
};

export type RunScriptPreviewResponse = (string);

export type RunCodeWorkflowTaskData = {
    entrypoint: string;
    jobId: string;
    /**
     * preview
     */
    requestBody: WorkflowTask;
    workspace: string;
};

export type RunCodeWorkflowTaskResponse = (string);

export type RunRawScriptDependenciesData = {
    /**
     * raw script content
     */
    requestBody: {
        raw_scripts: Array<RawScriptForDependencies>;
        entrypoint: string;
    };
    workspace: string;
};

export type RunRawScriptDependenciesResponse = ({
    lock: string;
});

export type RunFlowPreviewData = {
    /**
     * List of headers's keys (separated with ',') whove value are added to the args
     * Header's key lowercased and '-'' replaced to '_' such that 'Content-Type' becomes the 'content_type' arg key
     *
     */
    includeHeader?: string;
    /**
     * make the run invisible to the the script owner (default false)
     */
    invisibleToOwner?: boolean;
    /**
     * The job id to assign to the created job. if missing, job is chosen randomly using the ULID scheme. If a job id already exists in the queue or as a completed job, the request to create one will fail (Bad Request)
     */
    jobId?: string;
    /**
     * preview
     */
    requestBody: FlowPreview;
    workspace: string;
};

export type RunFlowPreviewResponse = (string);

export type ListQueueData = {
    /**
     * get jobs from all workspaces (only valid if request come from the `admins` workspace)
     */
    allWorkspaces?: boolean;
    /**
     * filter on jobs containing those args as a json subset (@> in postgres)
     */
    args?: string;
    /**
     * mask to filter exact matching user creator
     */
    createdBy?: string;
    /**
     * is not a scheduled job
     */
    isNotSchedule?: boolean;
    /**
     * filter on job kind (values 'preview', 'script', 'dependencies', 'flow') separated by,
     */
    jobKinds?: string;
    /**
     * order by desc order (default true)
     */
    orderDesc?: boolean;
    /**
     * which page to return (start at 1, default 1)
     */
    page?: number;
    /**
     * The parent job that is at the origin and responsible for the execution of this script if any
     */
    parentJob?: string;
    /**
     * number of items to return for a given page (default 30, max 100)
     */
    perPage?: number;
    /**
     * filter on jobs containing those result as a json subset (@> in postgres)
     */
    result?: string;
    /**
     * filter on running jobs
     */
    running?: boolean;
    /**
     * filter on jobs scheduled_for before now (hence waitinf for a worker)
     */
    scheduledForBeforeNow?: boolean;
    /**
     * mask to filter by schedule path
     */
    schedulePath?: string;
    /**
     * mask to filter exact matching path
     */
    scriptHash?: string;
    /**
     * mask to filter exact matching path
     */
    scriptPathExact?: string;
    /**
     * mask to filter matching starting path
     */
    scriptPathStart?: string;
    /**
     * filter on started after (exclusive) timestamp
     */
    startedAfter?: string;
    /**
     * filter on started before (inclusive) timestamp
     */
    startedBefore?: string;
    /**
     * filter on successful jobs
     */
    success?: boolean;
    /**
     * filter on suspended jobs
     */
    suspended?: boolean;
    /**
     * filter on jobs with a given tag/worker group
     */
    tag?: string;
    workspace: string;
};

export type ListQueueResponse = (Array<QueuedJob>);

export type GetQueueCountData = {
    /**
     * get jobs from all workspaces (only valid if request come from the `admins` workspace)
     */
    allWorkspaces?: boolean;
    workspace: string;
};

export type GetQueueCountResponse = ({
    database_length: number;
    suspended?: number;
});

export type GetCompletedCountData = {
    workspace: string;
};

export type GetCompletedCountResponse = ({
    database_length: number;
});

export type ListFilteredUuidsData = {
    /**
     * get jobs from all workspaces (only valid if request come from the `admins` workspace)
     */
    allWorkspaces?: boolean;
    /**
     * filter on jobs containing those args as a json subset (@> in postgres)
     */
    args?: string;
    concurrencyKey?: string;
    /**
     * mask to filter exact matching user creator
     */
    createdBy?: string;
    /**
     * is not a scheduled job
     */
    isNotSchedule?: boolean;
    /**
     * filter on job kind (values 'preview', 'script', 'dependencies', 'flow') separated by,
     */
    jobKinds?: string;
    /**
     * order by desc order (default true)
     */
    orderDesc?: boolean;
    /**
     * which page to return (start at 1, default 1)
     */
    page?: number;
    /**
     * The parent job that is at the origin and responsible for the execution of this script if any
     */
    parentJob?: string;
    /**
     * number of items to return for a given page (default 30, max 100)
     */
    perPage?: number;
    /**
     * filter on jobs containing those result as a json subset (@> in postgres)
     */
    result?: string;
    /**
     * filter on running jobs
     */
    running?: boolean;
    /**
     * filter on jobs scheduled_for before now (hence waitinf for a worker)
     */
    scheduledForBeforeNow?: boolean;
    /**
     * mask to filter by schedule path
     */
    schedulePath?: string;
    /**
     * mask to filter exact matching path
     */
    scriptHash?: string;
    /**
     * mask to filter exact matching path
     */
    scriptPathExact?: string;
    /**
     * mask to filter matching starting path
     */
    scriptPathStart?: string;
    /**
     * filter on started after (exclusive) timestamp
     */
    startedAfter?: string;
    /**
     * filter on started before (inclusive) timestamp
     */
    startedBefore?: string;
    /**
     * filter on successful jobs
     */
    success?: boolean;
    /**
     * filter on suspended jobs
     */
    suspended?: boolean;
    /**
     * filter on jobs with a given tag/worker group
     */
    tag?: string;
    workspace: string;
};

export type ListFilteredUuidsResponse = (Array<(string)>);

export type CancelSelectionData = {
    /**
     * uuids of the jobs to cancel
     */
    requestBody: Array<(string)>;
    workspace: string;
};

export type CancelSelectionResponse = (Array<(string)>);

export type ListCompletedJobsData = {
    /**
     * filter on jobs containing those args as a json subset (@> in postgres)
     */
    args?: string;
    /**
     * mask to filter exact matching user creator
     */
    createdBy?: string;
    /**
     * has null parent
     */
    hasNullParent?: boolean;
    /**
     * is the job a flow step
     */
    isFlowStep?: boolean;
    /**
     * is not a scheduled job
     */
    isNotSchedule?: boolean;
    /**
     * is the job skipped
     */
    isSkipped?: boolean;
    /**
     * filter on job kind (values 'preview', 'script', 'dependencies', 'flow') separated by,
     */
    jobKinds?: string;
    /**
     * mask to filter exact matching job's label (job labels are completed jobs with as a result an object containing a string in the array at key 'wm_labels')
     */
    label?: string;
    /**
     * order by desc order (default true)
     */
    orderDesc?: boolean;
    /**
     * which page to return (start at 1, default 1)
     */
    page?: number;
    /**
     * The parent job that is at the origin and responsible for the execution of this script if any
     */
    parentJob?: string;
    /**
     * number of items to return for a given page (default 30, max 100)
     */
    perPage?: number;
    /**
     * filter on jobs containing those result as a json subset (@> in postgres)
     */
    result?: string;
    /**
     * mask to filter by schedule path
     */
    schedulePath?: string;
    /**
     * mask to filter exact matching path
     */
    scriptHash?: string;
    /**
     * mask to filter exact matching path
     */
    scriptPathExact?: string;
    /**
     * mask to filter matching starting path
     */
    scriptPathStart?: string;
    /**
     * filter on started after (exclusive) timestamp
     */
    startedAfter?: string;
    /**
     * filter on started before (inclusive) timestamp
     */
    startedBefore?: string;
    /**
     * filter on successful jobs
     */
    success?: boolean;
    /**
     * filter on jobs with a given tag/worker group
     */
    tag?: string;
    workspace: string;
};

export type ListCompletedJobsResponse = (Array<CompletedJob>);

export type ListJobsData = {
    /**
     * get jobs from all workspaces (only valid if request come from the `admins` workspace)
     */
    allWorkspaces?: boolean;
    /**
     * filter on jobs containing those args as a json subset (@> in postgres)
     */
    args?: string;
    /**
     * filter on created after (exclusive) timestamp
     */
    createdAfter?: string;
    /**
     * filter on created before (inclusive) timestamp
     */
    createdBefore?: string;
    /**
     * mask to filter exact matching user creator
     */
    createdBy?: string;
    /**
     * filter on created_at for non non started job and started_at otherwise after (exclusive) timestamp
     */
    createdOrStartedAfter?: string;
    /**
     * filter on created_at for non non started job and started_at otherwise after (exclusive) timestamp but only for the completed jobs
     */
    createdOrStartedAfterCompletedJobs?: string;
    /**
     * filter on created_at for non non started job and started_at otherwise before (inclusive) timestamp
     */
    createdOrStartedBefore?: string;
    /**
     * has null parent
     */
    hasNullParent?: boolean;
    /**
     * is the job a flow step
     */
    isFlowStep?: boolean;
    /**
     * is not a scheduled job
     */
    isNotSchedule?: boolean;
    /**
     * is the job skipped
     */
    isSkipped?: boolean;
    /**
     * filter on job kind (values 'preview', 'script', 'dependencies', 'flow') separated by,
     */
    jobKinds?: string;
    /**
     * mask to filter exact matching job's label (job labels are completed jobs with as a result an object containing a string in the array at key 'wm_labels')
     */
    label?: string;
    /**
     * which page to return (start at 1, default 1)
     */
    page?: number;
    /**
     * The parent job that is at the origin and responsible for the execution of this script if any
     */
    parentJob?: string;
    /**
     * number of items to return for a given page (default 30, max 100)
     */
    perPage?: number;
    /**
     * filter on jobs containing those result as a json subset (@> in postgres)
     */
    result?: string;
    /**
     * filter on running jobs
     */
    running?: boolean;
    /**
     * filter on jobs scheduled_for before now (hence waitinf for a worker)
     */
    scheduledForBeforeNow?: boolean;
    /**
     * mask to filter by schedule path
     */
    schedulePath?: string;
    /**
     * mask to filter exact matching path
     */
    scriptHash?: string;
    /**
     * mask to filter exact matching path
     */
    scriptPathExact?: string;
    /**
     * mask to filter matching starting path
     */
    scriptPathStart?: string;
    /**
     * filter on started after (exclusive) timestamp
     */
    startedAfter?: string;
    /**
     * filter on started before (inclusive) timestamp
     */
    startedBefore?: string;
    /**
     * filter on successful jobs
     */
    success?: boolean;
    /**
     * filter on suspended jobs
     */
    suspended?: boolean;
    /**
     * filter on jobs with a given tag/worker group
     */
    tag?: string;
    workspace: string;
};

export type ListJobsResponse = (Array<Job>);

export type GetDbClockResponse = (number);

export type CountJobsByTagData = {
    /**
     * Past Time horizon in seconds (when to start the count = now - horizon) (default is 3600)
     */
    horizonSecs?: number;
    /**
     * Specific workspace ID to filter results (optional)
     */
    workspaceId?: string;
};

export type CountJobsByTagResponse = (Array<{
    tag: string;
    count: number;
}>);

export type GetJobData = {
    id: string;
    noLogs?: boolean;
    workspace: string;
};

export type GetJobResponse = (Job);

export type GetRootJobIdData = {
    id: string;
    workspace: string;
};

export type GetRootJobIdResponse = (string);

export type GetJobLogsData = {
    id: string;
    workspace: string;
};

export type GetJobLogsResponse = (string);

export type GetJobArgsData = {
    id: string;
    workspace: string;
};

export type GetJobArgsResponse = (unknown);

export type GetJobUpdatesData = {
    getProgress?: boolean;
    id: string;
    logOffset?: number;
    running?: boolean;
    workspace: string;
};

export type GetJobUpdatesResponse = ({
    running?: boolean;
    completed?: boolean;
    new_logs?: string;
    log_offset?: number;
    mem_peak?: number;
    progress?: number;
    flow_status?: WorkflowStatusRecord;
});

export type GetLogFileFromStoreData = {
    path: string;
    workspace: string;
};

export type GetLogFileFromStoreResponse = (unknown);

export type GetFlowDebugInfoData = {
    id: string;
    workspace: string;
};

export type GetFlowDebugInfoResponse = (unknown);

export type GetCompletedJobData = {
    id: string;
    workspace: string;
};

export type GetCompletedJobResponse = (CompletedJob);

export type GetCompletedJobResultData = {
    approver?: string;
    id: string;
    resumeId?: number;
    secret?: string;
    suspendedJob?: string;
    workspace: string;
};

export type GetCompletedJobResultResponse = (unknown);

export type GetCompletedJobResultMaybeData = {
    getStarted?: boolean;
    id: string;
    workspace: string;
};

export type GetCompletedJobResultMaybeResponse = ({
    completed: boolean;
    result: unknown;
    success?: boolean;
    started?: boolean;
});

export type DeleteCompletedJobData = {
    id: string;
    workspace: string;
};

export type DeleteCompletedJobResponse = (CompletedJob);

export type CancelQueuedJobData = {
    id: string;
    /**
     * reason
     */
    requestBody: {
        reason?: string;
    };
    workspace: string;
};

export type CancelQueuedJobResponse = (string);

export type CancelPersistentQueuedJobsData = {
    path: string;
    /**
     * reason
     */
    requestBody: {
        reason?: string;
    };
    workspace: string;
};

export type CancelPersistentQueuedJobsResponse = (string);

export type ForceCancelQueuedJobData = {
    id: string;
    /**
     * reason
     */
    requestBody: {
        reason?: string;
    };
    workspace: string;
};

export type ForceCancelQueuedJobResponse = (string);

export type CreateJobSignatureData = {
    approver?: string;
    id: string;
    resumeId: number;
    workspace: string;
};

export type CreateJobSignatureResponse = (string);

export type GetResumeUrlsData = {
    approver?: string;
    id: string;
    resumeId: number;
    workspace: string;
};

export type GetResumeUrlsResponse = ({
    approvalPage: string;
    resume: string;
    cancel: string;
});

export type ResumeSuspendedJobGetData = {
    approver?: string;
    id: string;
    /**
     * The base64 encoded payload that has been encoded as a JSON. e.g how to encode such payload encodeURIComponent
     * `encodeURIComponent(btoa(JSON.stringify({a: 2})))`
     *
     */
    payload?: string;
    resumeId: number;
    signature: string;
    workspace: string;
};

export type ResumeSuspendedJobGetResponse = (string);

export type ResumeSuspendedJobPostData = {
    approver?: string;
    id: string;
    requestBody: {
        [key: string]: unknown;
    };
    resumeId: number;
    signature: string;
    workspace: string;
};

export type ResumeSuspendedJobPostResponse = (string);

export type SetFlowUserStateData = {
    id: string;
    key: string;
    /**
     * new value
     */
    requestBody: unknown;
    workspace: string;
};

export type SetFlowUserStateResponse = (string);

export type GetFlowUserStateData = {
    id: string;
    key: string;
    workspace: string;
};

export type GetFlowUserStateResponse = (unknown);

export type ResumeSuspendedFlowAsOwnerData = {
    id: string;
    requestBody: {
        [key: string]: unknown;
    };
    workspace: string;
};

export type ResumeSuspendedFlowAsOwnerResponse = (string);

export type CancelSuspendedJobGetData = {
    approver?: string;
    id: string;
    resumeId: number;
    signature: string;
    workspace: string;
};

export type CancelSuspendedJobGetResponse = (string);

export type CancelSuspendedJobPostData = {
    approver?: string;
    id: string;
    requestBody: {
        [key: string]: unknown;
    };
    resumeId: number;
    signature: string;
    workspace: string;
};

export type CancelSuspendedJobPostResponse = (string);

export type GetSuspendedJobFlowData = {
    approver?: string;
    id: string;
    resumeId: number;
    signature: string;
    workspace: string;
};

export type GetSuspendedJobFlowResponse = ({
    job: Job;
    approvers: Array<{
        resume_id: number;
        approver: string;
    }>;
});

export type PreviewScheduleData = {
    /**
     * schedule
     */
    requestBody: {
        schedule: string;
        timezone: string;
    };
};

export type PreviewScheduleResponse = (Array<(string)>);

export type CreateScheduleData = {
    /**
     * new schedule
     */
    requestBody: NewSchedule;
    workspace: string;
};

export type CreateScheduleResponse = (string);

export type UpdateScheduleData = {
    path: string;
    /**
     * updated schedule
     */
    requestBody: EditSchedule;
    workspace: string;
};

export type UpdateScheduleResponse = (string);

export type SetScheduleEnabledData = {
    path: string;
    /**
     * updated schedule enable
     */
    requestBody: {
        enabled: boolean;
    };
    workspace: string;
};

export type SetScheduleEnabledResponse = (string);

export type DeleteScheduleData = {
    path: string;
    workspace: string;
};

export type DeleteScheduleResponse = (string);

export type GetScheduleData = {
    path: string;
    workspace: string;
};

export type GetScheduleResponse = (Schedule);

export type ExistsScheduleData = {
    path: string;
    workspace: string;
};

export type ExistsScheduleResponse = (boolean);

export type ListSchedulesData = {
    /**
     * filter on jobs containing those args as a json subset (@> in postgres)
     */
    args?: string;
    isFlow?: boolean;
    /**
     * which page to return (start at 1, default 1)
     */
    page?: number;
    /**
     * filter by path
     */
    path?: string;
    pathStart?: string;
    /**
     * number of items to return for a given page (default 30, max 100)
     */
    perPage?: number;
    workspace: string;
};

export type ListSchedulesResponse = (Array<Schedule>);

export type ListSchedulesWithJobsData = {
    /**
     * which page to return (start at 1, default 1)
     */
    page?: number;
    /**
     * number of items to return for a given page (default 30, max 100)
     */
    perPage?: number;
    workspace: string;
};

export type ListSchedulesWithJobsResponse = (Array<ScheduleWJobs>);

export type SetDefaultErrorOrRecoveryHandlerData = {
    /**
     * Handler description
     */
    requestBody: {
        handler_type: 'error' | 'recovery' | 'success';
        override_existing: boolean;
        path?: string;
        extra_args?: {
            [key: string]: unknown;
        };
        number_of_occurence?: number;
        number_of_occurence_exact?: boolean;
        workspace_handler_muted?: boolean;
    };
    workspace: string;
};

export type SetDefaultErrorOrRecoveryHandlerResponse = (unknown);

export type CreateHttpTriggerData = {
    /**
     * new http trigger
     */
    requestBody: NewHttpTrigger;
    workspace: string;
};

export type CreateHttpTriggerResponse = (string);

export type UpdateHttpTriggerData = {
    path: string;
    /**
     * updated trigger
     */
    requestBody: EditHttpTrigger;
    workspace: string;
};

export type UpdateHttpTriggerResponse = (string);

export type DeleteHttpTriggerData = {
    path: string;
    workspace: string;
};

export type DeleteHttpTriggerResponse = (string);

export type GetHttpTriggerData = {
    path: string;
    workspace: string;
};

export type GetHttpTriggerResponse = (HttpTrigger);

export type ListHttpTriggersData = {
    isFlow?: boolean;
    /**
     * which page to return (start at 1, default 1)
     */
    page?: number;
    /**
     * filter by path
     */
    path?: string;
    pathStart?: string;
    /**
     * number of items to return for a given page (default 30, max 100)
     */
    perPage?: number;
    workspace: string;
};

export type ListHttpTriggersResponse = (Array<HttpTrigger>);

export type ExistsHttpTriggerData = {
    path: string;
    workspace: string;
};

export type ExistsHttpTriggerResponse = (boolean);

export type ExistsRouteData = {
    /**
     * route exists request
     */
    requestBody: {
        route_path: string;
        http_method: 'get' | 'post' | 'put' | 'delete' | 'patch';
    };
    workspace: string;
};

export type ExistsRouteResponse = (boolean);

export type UsedData = {
    workspace: string;
};

export type UsedResponse = (boolean);

export type ListInstanceGroupsResponse = (Array<InstanceGroup>);

export type GetInstanceGroupData = {
    name: string;
};

export type GetInstanceGroupResponse = (InstanceGroup);

export type CreateInstanceGroupData = {
    /**
     * create instance group
     */
    requestBody: {
        name: string;
        summary?: string;
    };
};

export type CreateInstanceGroupResponse = (string);

export type UpdateInstanceGroupData = {
    name: string;
    /**
     * update instance group
     */
    requestBody: {
        new_summary: string;
    };
};

export type UpdateInstanceGroupResponse = (string);

export type DeleteInstanceGroupData = {
    name: string;
};

export type DeleteInstanceGroupResponse = (string);

export type AddUserToInstanceGroupData = {
    name: string;
    /**
     * user to add to instance group
     */
    requestBody: {
        email: string;
    };
};

export type AddUserToInstanceGroupResponse = (string);

export type RemoveUserFromInstanceGroupData = {
    name: string;
    /**
     * user to remove from instance group
     */
    requestBody: {
        email: string;
    };
};

export type RemoveUserFromInstanceGroupResponse = (string);

export type ExportInstanceGroupsResponse = (Array<ExportedInstanceGroup>);

export type OverwriteInstanceGroupsData = {
    /**
     * overwrite instance groups
     */
    requestBody: Array<ExportedInstanceGroup>;
};

export type OverwriteInstanceGroupsResponse = (string);

export type ListGroupsData = {
    /**
     * which page to return (start at 1, default 1)
     */
    page?: number;
    /**
     * number of items to return for a given page (default 30, max 100)
     */
    perPage?: number;
    workspace: string;
};

export type ListGroupsResponse = (Array<Group>);

export type ListGroupNamesData = {
    /**
     * only list the groups the user is member of (default false)
     */
    onlyMemberOf?: boolean;
    workspace: string;
};

export type ListGroupNamesResponse = (Array<(string)>);

export type CreateGroupData = {
    /**
     * create group
     */
    requestBody: {
        name: string;
        summary?: string;
    };
    workspace: string;
};

export type CreateGroupResponse = (string);

export type UpdateGroupData = {
    name: string;
    /**
     * updated group
     */
    requestBody: {
        summary?: string;
    };
    workspace: string;
};

export type UpdateGroupResponse = (string);

export type DeleteGroupData = {
    name: string;
    workspace: string;
};

export type DeleteGroupResponse = (string);

export type GetGroupData = {
    name: string;
    workspace: string;
};

export type GetGroupResponse = (Group);

export type AddUserToGroupData = {
    name: string;
    /**
     * added user to group
     */
    requestBody: {
        username?: string;
    };
    workspace: string;
};

export type AddUserToGroupResponse = (string);

export type RemoveUserToGroupData = {
    name: string;
    /**
     * added user to group
     */
    requestBody: {
        username?: string;
    };
    workspace: string;
};

export type RemoveUserToGroupResponse = (string);

export type ListFoldersData = {
    /**
     * which page to return (start at 1, default 1)
     */
    page?: number;
    /**
     * number of items to return for a given page (default 30, max 100)
     */
    perPage?: number;
    workspace: string;
};

export type ListFoldersResponse = (Array<Folder>);

export type ListFolderNamesData = {
    /**
     * only list the folders the user is member of (default false)
     */
    onlyMemberOf?: boolean;
    workspace: string;
};

export type ListFolderNamesResponse = (Array<(string)>);

export type CreateFolderData = {
    /**
     * create folder
     */
    requestBody: {
        name: string;
        summary?: string;
        owners?: Array<(string)>;
        extra_perms?: {
            [key: string]: (boolean);
        };
    };
    workspace: string;
};

export type CreateFolderResponse = (string);

export type UpdateFolderData = {
    name: string;
    /**
     * update folder
     */
    requestBody: {
        summary?: string;
        owners?: Array<(string)>;
        extra_perms?: {
            [key: string]: (boolean);
        };
    };
    workspace: string;
};

export type UpdateFolderResponse = (string);

export type DeleteFolderData = {
    name: string;
    workspace: string;
};

export type DeleteFolderResponse = (string);

export type GetFolderData = {
    name: string;
    workspace: string;
};

export type GetFolderResponse = (Folder);

export type GetFolderUsageData = {
    name: string;
    workspace: string;
};

export type GetFolderUsageResponse = ({
    scripts: number;
    flows: number;
    apps: number;
    resources: number;
    variables: number;
    schedules: number;
});

export type AddOwnerToFolderData = {
    name: string;
    /**
     * owner user to folder
     */
    requestBody: {
        owner: string;
    };
    workspace: string;
};

export type AddOwnerToFolderResponse = (string);

export type RemoveOwnerToFolderData = {
    name: string;
    /**
     * added owner to folder
     */
    requestBody: {
        owner: string;
        write?: boolean;
    };
    workspace: string;
};

export type RemoveOwnerToFolderResponse = (string);

export type ListWorkersData = {
    /**
     * which page to return (start at 1, default 1)
     */
    page?: number;
    /**
     * number of items to return for a given page (default 30, max 100)
     */
    perPage?: number;
    /**
     * number of seconds the worker must have had a last ping more recent of (default to 300)
     */
    pingSince?: number;
};

export type ListWorkersResponse = (Array<WorkerPing>);

export type ExistsWorkerWithTagData = {
    tag: string;
};

export type ExistsWorkerWithTagResponse = (boolean);

export type GetQueueMetricsResponse = (Array<{
    id: string;
    values: Array<{
        created_at: string;
        value: number;
    }>;
}>);

export type ListWorkerGroupsResponse = (Array<{
    name: string;
    config: unknown;
}>);

export type GetConfigData = {
    name: string;
};

export type GetConfigResponse = (unknown);

export type UpdateConfigData = {
    name: string;
    /**
     * worker group
     */
    requestBody: unknown;
};

export type UpdateConfigResponse = (string);

export type DeleteConfigData = {
    name: string;
};

export type DeleteConfigResponse = (string);

export type ListConfigsResponse = (Array<Config>);

export type GetGranularAclsData = {
    kind: 'script' | 'group_' | 'resource' | 'schedule' | 'variable' | 'flow' | 'folder' | 'app' | 'raw_app' | 'http_trigger';
    path: string;
    workspace: string;
};

export type GetGranularAclsResponse = ({
    [key: string]: (boolean);
});

export type AddGranularAclsData = {
    kind: 'script' | 'group_' | 'resource' | 'schedule' | 'variable' | 'flow' | 'folder' | 'app' | 'raw_app' | 'http_trigger';
    path: string;
    /**
     * acl to add
     */
    requestBody: {
        owner: string;
        write?: boolean;
    };
    workspace: string;
};

export type AddGranularAclsResponse = (string);

export type RemoveGranularAclsData = {
    kind: 'script' | 'group_' | 'resource' | 'schedule' | 'variable' | 'flow' | 'folder' | 'app' | 'raw_app' | 'http_trigger';
    path: string;
    /**
     * acl to add
     */
    requestBody: {
        owner: string;
    };
    workspace: string;
};

export type RemoveGranularAclsResponse = (string);

export type UpdateCaptureData = {
    path: string;
    workspace: string;
};

export type UpdateCaptureResponse = (void);

export type CreateCaptureData = {
    path: string;
    workspace: string;
};

export type CreateCaptureResponse = (unknown);

export type GetCaptureData = {
    path: string;
    workspace: string;
};

export type GetCaptureResponse = (unknown);

export type StarData = {
    requestBody?: {
        path?: string;
        favorite_kind?: 'flow' | 'app' | 'script' | 'raw_app';
    };
    workspace: string;
};

export type StarResponse = (unknown);

export type UnstarData = {
    requestBody?: {
        path?: string;
        favorite_kind?: 'flow' | 'app' | 'script' | 'raw_app';
    };
    workspace: string;
};

export type UnstarResponse = (unknown);

export type GetInputHistoryData = {
    /**
     * which page to return (start at 1, default 1)
     */
    page?: number;
    /**
     * number of items to return for a given page (default 30, max 100)
     */
    perPage?: number;
    runnableId?: string;
    runnableType?: RunnableType;
    workspace: string;
};

export type GetInputHistoryResponse = (Array<Input>);

export type GetArgsFromHistoryOrSavedInputData = {
    allowLarge?: boolean;
    input?: boolean;
    jobOrInputId: string;
    workspace: string;
};

export type GetArgsFromHistoryOrSavedInputResponse = (unknown);

export type ListInputsData = {
    /**
     * which page to return (start at 1, default 1)
     */
    page?: number;
    /**
     * number of items to return for a given page (default 30, max 100)
     */
    perPage?: number;
    runnableId?: string;
    runnableType?: RunnableType;
    workspace: string;
};

export type ListInputsResponse = (Array<Input>);

export type CreateInputData = {
    /**
     * Input
     */
    requestBody: CreateInput;
    runnableId?: string;
    runnableType?: RunnableType;
    workspace: string;
};

export type CreateInputResponse = (string);

export type UpdateInputData = {
    /**
     * UpdateInput
     */
    requestBody: UpdateInput;
    workspace: string;
};

export type UpdateInputResponse = (string);

export type DeleteInputData = {
    input: string;
    workspace: string;
};

export type DeleteInputResponse = (string);

export type DuckdbConnectionSettingsData = {
    /**
     * S3 resource to connect to
     */
    requestBody: {
        s3_resource?: S3Resource;
    };
    workspace: string;
};

export type DuckdbConnectionSettingsResponse = ({
    connection_settings_str?: string;
});

export type DuckdbConnectionSettingsV2Data = {
    /**
     * S3 resource path to use to generate the connection settings. If empty, the S3 resource defined in the workspace settings will be used
     */
    requestBody: {
        s3_resource_path?: string;
    };
    workspace: string;
};

export type DuckdbConnectionSettingsV2Response = ({
    connection_settings_str: string;
});

export type PolarsConnectionSettingsData = {
    /**
     * S3 resource to connect to
     */
    requestBody: {
        s3_resource?: S3Resource;
    };
    workspace: string;
};

export type PolarsConnectionSettingsResponse = ({
    endpoint_url: string;
    key?: string;
    secret?: string;
    use_ssl: boolean;
    cache_regions: boolean;
    client_kwargs: PolarsClientKwargs;
});

export type PolarsConnectionSettingsV2Data = {
    /**
     * S3 resource path to use to generate the connection settings. If empty, the S3 resource defined in the workspace settings will be used
     */
    requestBody: {
        s3_resource_path?: string;
    };
    workspace: string;
};

export type PolarsConnectionSettingsV2Response = ({
    s3fs_args: {
        endpoint_url: string;
        key?: string;
        secret?: string;
        use_ssl: boolean;
        cache_regions: boolean;
        client_kwargs: PolarsClientKwargs;
    };
    storage_options: {
        aws_endpoint_url: string;
        aws_access_key_id?: string;
        aws_secret_access_key?: string;
        aws_region: string;
        aws_allow_http: string;
    };
});

export type S3ResourceInfoData = {
    /**
     * S3 resource path to use. If empty, the S3 resource defined in the workspace settings will be used
     */
    requestBody: {
        s3_resource_path?: string;
    };
    workspace: string;
};

export type S3ResourceInfoResponse = (S3Resource);

export type DatasetStorageTestConnectionData = {
    storage?: string;
    workspace: string;
};

export type DatasetStorageTestConnectionResponse = (unknown);

export type ListStoredFilesData = {
    marker?: string;
    maxKeys: number;
    prefix?: string;
    storage?: string;
    workspace: string;
};

export type ListStoredFilesResponse = ({
    next_marker?: string;
    windmill_large_files: Array<WindmillLargeFile>;
    restricted_access?: boolean;
});

export type LoadFileMetadataData = {
    fileKey: string;
    storage?: string;
    workspace: string;
};

export type LoadFileMetadataResponse = (WindmillFileMetadata);

export type LoadFilePreviewData = {
    csvHasHeader?: boolean;
    csvSeparator?: string;
    fileKey: string;
    fileMimeType?: string;
    fileSizeInBytes?: number;
    readBytesFrom?: number;
    readBytesLength?: number;
    storage?: string;
    workspace: string;
};

export type LoadFilePreviewResponse = (WindmillFilePreview);

export type LoadParquetPreviewData = {
    limit?: number;
    offset?: number;
    path: string;
    searchCol?: string;
    searchTerm?: string;
    sortCol?: string;
    sortDesc?: boolean;
    storage?: string;
    workspace: string;
};

export type LoadParquetPreviewResponse = (unknown);

export type LoadTableRowCountData = {
    path: string;
    searchCol?: string;
    searchTerm?: string;
    storage?: string;
    workspace: string;
};

export type LoadTableRowCountResponse = ({
    count?: number;
});

export type LoadCsvPreviewData = {
    csvSeparator?: string;
    limit?: number;
    offset?: number;
    path: string;
    searchCol?: string;
    searchTerm?: string;
    sortCol?: string;
    sortDesc?: boolean;
    storage?: string;
    workspace: string;
};

export type LoadCsvPreviewResponse = (unknown);

export type DeleteS3FileData = {
    fileKey: string;
    storage?: string;
    workspace: string;
};

export type DeleteS3FileResponse = (unknown);

export type MoveS3FileData = {
    destFileKey: string;
    srcFileKey: string;
    storage?: string;
    workspace: string;
};

export type MoveS3FileResponse = (unknown);

export type FileUploadData = {
    fileExtension?: string;
    fileKey?: string;
    /**
     * File content
     */
    requestBody: (Blob | File);
    resourceType?: string;
    s3ResourcePath?: string;
    storage?: string;
    workspace: string;
};

export type FileUploadResponse = ({
    file_key: string;
});

export type FileDownloadData = {
    fileKey: string;
    resourceType?: string;
    s3ResourcePath?: string;
    storage?: string;
    workspace: string;
};

export type FileDownloadResponse = ((Blob | File));

export type FileDownloadParquetAsCsvData = {
    fileKey: string;
    resourceType?: string;
    s3ResourcePath?: string;
    workspace: string;
};

export type FileDownloadParquetAsCsvResponse = (string);

export type GetJobMetricsData = {
    id: string;
    /**
     * parameters for statistics retrieval
     */
    requestBody: {
        timeseries_max_datapoints?: number;
        from_timestamp?: string;
        to_timestamp?: string;
    };
    workspace: string;
};

export type GetJobMetricsResponse = ({
    metrics_metadata?: Array<MetricMetadata>;
    scalar_metrics?: Array<ScalarMetric>;
    timeseries_metrics?: Array<TimeseriesMetric>;
});

export type SetJobProgressData = {
    id: string;
    /**
     * parameters for statistics retrieval
     */
    requestBody: {
        percent?: number;
        flow_job_id?: string;
    };
    workspace: string;
};

export type SetJobProgressResponse = (unknown);

export type GetJobProgressData = {
    id: string;
    workspace: string;
};

export type GetJobProgressResponse = (number);

export type ListLogFilesData = {
    /**
     * filter on created after (exclusive) timestamp
     */
    after?: string;
    /**
     * filter on started before (inclusive) timestamp
     */
    before?: string;
    withError?: boolean;
};

export type ListLogFilesResponse = (Array<{
    hostname: string;
    mode: string;
    worker_group?: string;
    log_ts: string;
    file_path: string;
    ok_lines?: number;
    err_lines?: number;
    json_fmt: boolean;
}>);

export type GetLogFileData = {
    path: string;
};

export type GetLogFileResponse = (string);

export type ListConcurrencyGroupsResponse = (Array<ConcurrencyGroup>);

export type DeleteConcurrencyGroupData = {
    concurrencyId: string;
};

export type DeleteConcurrencyGroupResponse = ({
    [key: string]: unknown;
});

export type GetConcurrencyKeyData = {
    id: string;
};

export type GetConcurrencyKeyResponse = (string);

export type ListExtendedJobsData = {
    /**
     * get jobs from all workspaces (only valid if request come from the `admins` workspace)
     */
    allWorkspaces?: boolean;
    /**
     * filter on jobs containing those args as a json subset (@> in postgres)
     */
    args?: string;
    concurrencyKey?: string;
    /**
     * mask to filter exact matching user creator
     */
    createdBy?: string;
    /**
     * filter on created_at for non non started job and started_at otherwise after (exclusive) timestamp
     */
    createdOrStartedAfter?: string;
    /**
     * filter on created_at for non non started job and started_at otherwise after (exclusive) timestamp but only for the completed jobs
     */
    createdOrStartedAfterCompletedJobs?: string;
    /**
     * filter on created_at for non non started job and started_at otherwise before (inclusive) timestamp
     */
    createdOrStartedBefore?: string;
    /**
     * has null parent
     */
    hasNullParent?: boolean;
    /**
     * is the job a flow step
     */
    isFlowStep?: boolean;
    /**
     * is not a scheduled job
     */
    isNotSchedule?: boolean;
    /**
     * is the job skipped
     */
    isSkipped?: boolean;
    /**
     * filter on job kind (values 'preview', 'script', 'dependencies', 'flow') separated by,
     */
    jobKinds?: string;
    /**
     * mask to filter exact matching job's label (job labels are completed jobs with as a result an object containing a string in the array at key 'wm_labels')
     */
    label?: string;
    /**
     * which page to return (start at 1, default 1)
     */
    page?: number;
    /**
     * The parent job that is at the origin and responsible for the execution of this script if any
     */
    parentJob?: string;
    /**
     * number of items to return for a given page (default 30, max 100)
     */
    perPage?: number;
    /**
     * filter on jobs containing those result as a json subset (@> in postgres)
     */
    result?: string;
    rowLimit?: number;
    /**
     * filter on running jobs
     */
    running?: boolean;
    /**
     * filter on jobs scheduled_for before now (hence waitinf for a worker)
     */
    scheduledForBeforeNow?: boolean;
    /**
     * mask to filter by schedule path
     */
    schedulePath?: string;
    /**
     * mask to filter exact matching path
     */
    scriptHash?: string;
    /**
     * mask to filter exact matching path
     */
    scriptPathExact?: string;
    /**
     * mask to filter matching starting path
     */
    scriptPathStart?: string;
    /**
     * filter on started after (exclusive) timestamp
     */
    startedAfter?: string;
    /**
     * filter on started before (inclusive) timestamp
     */
    startedBefore?: string;
    /**
     * filter on successful jobs
     */
    success?: boolean;
    /**
     * filter on jobs with a given tag/worker group
     */
    tag?: string;
    workspace: string;
};

export type ListExtendedJobsResponse = (ExtendedJobs);

export type SearchJobsIndexData = {
    searchQuery: string;
    workspace: string;
};

export type SearchJobsIndexResponse = ({
    /**
     * a list of the terms that couldn't be parsed (and thus ignored)
     */
    query_parse_errors?: Array<{
        dancer?: string;
    }>;
    /**
     * the jobs that matched the query
     */
    hits?: Array<JobSearchHit>;
});